{"task_id": "P5349", "title": "幂", "difficulty": "advanced", "nl": "$$\\text{Find}\\ \\sum_{n=0}^{\\infty}f(n)\\ r^n\\ ,\\ f(n)\\text{ is a polynomial},\\ r\\text{ is a rational number within }(0,1)$$\n\nIf the answer can be expressed as a fraction $\\frac{p}{q}$ in its simplest form, output the value of $p\\times q^{-1}\\  \\mathrm{mod} \\ 998244353\\ $.", "code": "#include<cstdio>\nconst int N=262150;\nconst int mod=998244353;\nint n,Ans,r,r_,A[N],fac[N],inv[N];\nint f[N],g[N],c[N],rnk[N];\nint ksm(int u,int v){\n    int res=1;\n    for(;v;v>>=1,u=1ll*u*u%mod)\n    if(v&1)res=1ll*res*u%mod;\n    return res;\n}\ninline void swap(int &u,int &v){int o=u;u=v;v=o;}\ninline int _(int u){return u<mod?u:u-mod;}\ninline int __(int u){return u<0?u+mod:u;}\nvoid ntt(int *t,int opt,int len){\n    int g=3,g_=ksm(g,mod-2);\n    for(int i=0;i<len;i++)if(i<rnk[i])swap(t[i],t[rnk[i]]);\n    for(int i=1;i<len;i<<=1){\n        int wn=ksm(~opt?g:g_,(mod-1)/(i<<1));\n        for(int j=0,J=i<<1;j<len;j+=J){\n            int w=1;\n            for(int k=j;k<i+j;k++,w=1ll*w*wn%mod){\n                int r=1ll*w*t[i+k]%mod;\n                t[i+k]=__(t[k]-r);\n                t[k]=_(t[k]+r);\n            }\n        }\n    }\n    if(~opt)return;\n    int ny=ksm(len,mod-2);\n    for(int i=0;i<len;i++)t[i]=1ll*t[i]*ny%mod;\n}\nvoid Inv(int Len,int *a,int *b){\n    if(Len==1){b[0]=ksm(a[0],mod-2);return;}\n    Inv((Len+1)>>1,a,b);\n    int len=1,_2=-1;\n    while(len<Len+Len)len<<=1,_2++;\n    for(int i=0;i<len;i++)rnk[i]=(rnk[i>>1]>>1)|((i&1)<<_2);\n    for(int i=0;i<Len;i++)c[i]=a[i];\n    for(int i=Len;i<len;i++)c[i]=0;\n    ntt(c,1,len);ntt(b,1,len);\n    for(int i=0;i<len;i++)\n    b[i]=1ll*(2-1ll*c[i]*b[i]%mod+mod)*b[i]%mod;\n    ntt(b,-1,len);\n    for(int i=Len;i<len;i++)b[i]=0;\n}\nint main(){\n    scanf(\"%d%d\",&n,&r);r_=1ll*r*ksm(1-r+mod,mod-2)%mod;\n    for(int i=0;i<=n;i++)scanf(\"%d\",&A[i]);\n    fac[0]=inv[0]=1;\n    for(int i=1;i<=n;i++)fac[i]=1ll*fac[i-1]*i%mod;\n    inv[n]=ksm(fac[n],mod-2)%mod;\n    for(int i=n-1;i>=1;i--)inv[i]=1ll*inv[i+1]*(i+1)%mod;\n    for(int i=1;i<=n;i++)g[i]=mod-1ll*inv[i]*r_%mod;\n    g[0]=1;\n    Inv(n+1,g,f);\n    for(int i=0;i<=n;i++)f[i]=1ll*f[i]*fac[i]%mod*ksm(1-r+mod,mod-2)%mod;\n    for(int i=0;i<=n;i++)Ans=_(Ans+1ll*f[i]*A[i]%mod);\n    printf(\"%d\\n\",Ans);\n}", "step": ["Read in the inputs (n, r, f)", "Calculate g and s", "Perform polynomial multiplication using a divide and conquer approach", "Calculate the coefficients of the solved polynomial equation", "Calculate the values of the solved polynomial equation", "Calculate and print the final answer"], "nl_cn": "$$\\text{求}\\ \\sum_{n=0}^{\\infty}f(n)\\ r^n\\ ,\\ f(n)\\text{为一个多项式},\\ r\\text{是一个}(0,1)\\text{内的有理数}$$\n\n若答案的最简分数为$\\frac{p}{q}$，你只需要输出$p\\times q^{-1}\\  \\mathrm{mod} \\ 998244353\\ $的值即可。", "test_cases": [{"input": "1 499122177\n0 1", "output": "2"}, {"input": "2 748683265\n0 0 1", "output": "628524223"}, {"input": "3 713031681\n7 5 23 2", "output": "257147786"}], "test": "#undef NDEBUG\n#include<assert.h>\nint main(){\n    assert(solution(\"1 499122177\\n0 1\") == \"2\");\n    assert(solution(\"2 748683265\\n0 0 1\") == \"628524223\");\n    assert(solution(\"3 713031681\\n7 5 23 2\") == \"257147786\");\n    return 0; \n}", "prompt": "/*$$\\text{Find}\\ \\sum_{n=0}^{\\infty}f(n)\\ r^n\\ ,\\ f(n)\\text{ is a polynomial},\\ r\\text{ is a rational number within }(0,1)$$\n\nIf the answer can be expressed as a fraction $\\frac{p}{q}$ in its simplest form, output the value of $p\\times q^{-1}\\  \\mathrm{mod} \\ 998244353\\ $.\n\ninput_format:\nThe first row has two integers $m,r$. $m$is the degree of the polynomial.\n\nThe second row has $m+1$integers, and the first $is $x^{i-1}$coefficient $a_{i-1}$.\n\noutput_format:\nJust one line, one number, for the answer.\n*/\n\n#include<sstream>\n#include<stdlib.h>\n#include<algorithm>\n#include<math.h>\n#include<stdio.h>\n#include<vector>\n#include<string>\n#include<climits>\n#include<cstring>\n#include<iostream>\nusing namespace std;\n\n             \nstring solution(string std_in){\n    istringstream iss(std_in);\n             ", "constraints": "对于$10\\%$的数据，$m\\le 5$。\n\n对于$40\\%$的数据，$m\\le 2000$。\n\n对于$100\\%$的数据，$m\\le 10^5\\ ,\\ a_i\\in [0,998244353)$，保证$\\ a_{m}\\neq 0$\n\n**捆绑测试**\n\n----\n\n**样例1解释：**\n\n$499122177\\equiv \\frac{1}{2}\\ (\\mathrm{mod}\\ 998244353)$\n\n$\\sum_{n=0}^{\\infty}n\\ (\\frac{1}{2})^n=2$\n\n-----\n\n**样例2解释：**\n\n$748683265\\equiv \\frac{1}{4}\\ (\\mathrm{mod}\\ 998244353)$\n\n$\\sum_{n=0}^{\\infty}n^2\\ (\\frac{1}{4})^n=\\frac{20}{27}$\n\n-----\n\n**样例3解释：**\n\n$713031681\\equiv \\frac{2}{7}\\ (\\mathrm{mod}\\ 998244353)$\n\n$\\sum_{n=0}^{\\infty}(2n^3+23n^2+5n+7)\\ (\\frac{2}{7})^n=\\frac{25417}{625}$\n\n", "samples": [["1 499122177\n0 1", "2"], ["2 748683265\n0 0 1", "628524223"], ["3 713031681\n7 5 23 2", "257147786"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}}
{"task_id": "P5810", "title": "[SCOI2004]文本的输入", "difficulty": "advanced", "nl": "People can input text by either typing one character at a time or using the clipboard to copy and paste. Typing one character takes 1 unit of time, copying the already-typed part to the clipboard takes 5 units of time (Ctrl+A, Ctrl+C, then unselect), and pasting from the clipboard takes 2 units of time (Ctrl+V).\n\nIf we only care about the length of the input text, and not the content, what is the minimum time required to input a text of length at least n?\n\nPlease note that the data range is slightly different from the original problem.", "code": "#include <cstdio>\nusing namespace std;\n\nconst int max_n = 120;\nint dp[max_n] = {};\n\nint main()\n{\n\tint n, ans;\n\n\tscanf(\"%d\", &n);\n\n\tif (n == 0)\n\t{\n\t\tputs(\"0\");\n\t\treturn 0;\n\t}\n\n\tfor (ans = 1; dp[ans-1] < n; ans++)\n\t{\n\t\tdp[ans] = dp[ans-1] + 1;\n\n\t\tfor (int i = ans - 7, j = 2; i > 0; i -= 2, j++)\n\t\t\tif (dp[ans] < dp[i] * j)\n\t\t\t\tdp[ans] = dp[i] * j;\n\t}\n\n\tprintf(\"%d\\n\", ans-1);\n\n\treturn 0;\n}", "step": ["Read integer n as input.", "If n is zero, return 0.", "Initialize an integer array called dp with the maximum value 120, and initialize the first value to 0.", "Loop through the array, starting with ans=1, until dp[ans-1] is greater than or equal to n.", "Within the loop, calculate a new value for dp[ans] by adding 1 to the previous value, and checking if any smaller values in the array, up to 7 steps back and multiplied by a factor of 2, are larger than the current value. If so, update the current value.", "Once the loop finishes, print the value ans-1."], "nl_cn": "人们在输入文本时，除了逐个输入这种方式外，还可以利用剪贴板进行复制，如果打入一个字母需要 $1$ 的时间，将已输入的部分复制进剪贴板需要 $5$ 的时间（`Ctrl`+`A`，`Ctrl`+`C`，再取消全选状态），将剪贴板的内容粘贴出来需要 $2$ 的时间（`Ctrl`+`V`）。\n\n如果我们不关心输入文本的内容，而只关心输入文本的长度，要输入一个长度**不低于** $n$ 的文本最少需要多少时间？\n\n**请注意，数据范围与原题略有不同。**\n　　", "test_cases": [{"input": "20", "output": "16"}, {"input": "0\n", "output": "0"}, {"input": "1\n", "output": "1"}, {"input": "5\n", "output": "5"}, {"input": "2\n", "output": "2"}, {"input": "50\n", "output": "23"}], "test": "#undef NDEBUG\n#include<assert.h>\nint main(){\n    assert(solution(\"20\") == \"16\");\n    assert(solution(\"0\\n\") == \"0\");\n    assert(solution(\"1\\n\") == \"1\");\n    assert(solution(\"5\\n\") == \"5\");\n    assert(solution(\"2\\n\") == \"2\");\n    assert(solution(\"50\\n\") == \"23\");\n    return 0; \n}", "prompt": "/*People can input text by either typing one character at a time or using the clipboard to copy and paste. Typing one character takes 1 unit of time, copying the already-typed part to the clipboard takes 5 units of time (Ctrl+A, Ctrl+C, then unselect), and pasting from the clipboard takes 2 units of time (Ctrl+V).\n\nIf we only care about the length of the input text, and not the content, what is the minimum time required to input a text of length at least n?\n\nPlease note that the data range is slightly different from the original problem.\n\ninput_format:\nA positive integer $n$, representing the length of the text.\n\noutput_format:\nA positive integer $t$, representing the shortest time required.\n*/\n\n#include<sstream>\n#include<stdlib.h>\n#include<algorithm>\n#include<math.h>\n#include<stdio.h>\n#include<vector>\n#include<string>\n#include<climits>\n#include<cstring>\n#include<iostream>\nusing namespace std;\n\n             \nstring solution(string std_in){\n    istringstream iss(std_in);\n             ", "constraints": "样例解释：先用 $7$ 时间打出 $7$ 个字符，再复制（用去 $5$ 时间），粘贴两次（用去 $4$ 时间），即可用 $16$ 时间打出 $21$ 个字符。\n\n对于 $20\\%$ 的数据，$n\\le 10$；\n\n对于 $60\\%$ 的数据，$n\\le 10^4$；\n\n对于 $100\\%$ 的数据，$n\\le 4\\times 10^4$。", "samples": [["20", "16"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}}
{"task_id": "P1640", "title": "[SCOI2010] 连续攻击游戏", "difficulty": "advanced", "nl": "Lxhgww has recently become obsessed with a game in which he has many equipment, with each equipment having 2 attributes represented by values between $1$ and $10000$. When he uses a certain equipment, he can only use one of its attributes and each type of equipment can only be used once. When the game reaches its final boss, lxhgww encounters a strange requirement, which is that the attribute values used to attack the boss must increase from $1$ in a continuous sequence, meaning that at the beginning, lxhgww can only use equipment with an attribute value of $1$ to attack the boss, then only equipment with an attribute value of $2$, and so on. Now, lxhgww wants to know the maximum number of times he can continuously attack the boss.", "code": "// luogu-judger-enable-o2\n#include<cstdio>\n#include<vector>\n#define Maxn 1010000\nusing namespace std;\nint n,m,sink,em,ans;\nstruct Line\n{int g,l,b;}\nl[Maxn*6];\nint s[Maxn+100];\nint cnt,e[Maxn+100];\nint dfs(int num,int val)\n{\n  if (num==sink)return val;\n  e[num]=cnt;\n  int flow,v;\n  for (int i=s[num-1];i<s[num];i++)\n   if (l[i].l&&e[v=l[i].g]!=cnt){\n    flow=dfs(v,min(val,l[i].l));\n    if (flow){\n      l[i].l-=flow;\n      l[l[i].b].l+=flow;\n      return flow;\n    }\n  }return 0;\n}\nvoid addLine(int f,int t,int c)\n{\n  l[s[f]].b=s[t];\n  l[s[t]].b=s[f];\n  l[s[f]].g=t;\n  l[s[f]].l=c;\n  l[s[t]].g=f;\n  l[s[t]].l=0;\n  s[t]++;s[f]++;\n}\nstruct Data\n{int a,b;}\na[1000500];\nint main()\n{\n  scanf(\"%d\",&n);\n  sink=n+10010+1;\n  //点1~n是物品，点n+1~n+10000是属性值\n  //sink是汇，没有源\n  for (int i=1;i<=n;i++){\n    scanf(\"%d%d\",&a[i].a,&a[i].b);\n    s[sink]++;s[i]=3;\n    s[n+a[i].a]++;\n    s[n+a[i].b]++;\n  }for (int i=2;i<=sink;i++)s[i]+=s[i-1];\n  for (int i=sink;i>=0;i--)s[i+1]=s[i];\n  for (int i=1;i<=n;i++)addLine(i,sink,1);\n  for (int i=1;i<=n;i++){\n    addLine(n+a[i].a,i,1);\n    addLine(n+a[i].b,i,1);\n  }cnt=1;\n  for (int i=1;i<=10010;i++,cnt=i)\n   if (!dfs(n+i,1))\n    {printf(\"%d\",i-1);break;}\n  return 0;\n}", "step": ["Create a struct for Edge and declare global variables.", "Implement Add() function to connect each node with its corresponding neighbor.", "Implement DFS() function to find augmenting paths in the bipartite graph.", "Implement Hungary() function to find the maximum matching using DFS().", "In the main function, initialize first[] to -1, read the input, build the graph using Add(), and output the size of the maximum matching."], "nl_cn": "lxhgww 最近迷上了一款游戏，在游戏里，他拥有很多的装备，每种装备都有 $2$ 个属性，这些属性的值用 $[1,10000]$ 之间的数表示。当他使用某种装备时，他只能使用该装备的某一个属性。并且每种装备最多只能使用一次。游戏进行到最后，lxhgww 遇到了终极 boss，这个终极 boss 很奇怪，攻击他的装备所使用的属性值必须从 $1$ 开始连续递增地攻击，才能对 boss 产生伤害。也就是说一开始的时候，lxhgww 只能使用某个属性值为 $1$ 的装备攻击 boss，然后只能使用某个属性值为 $2$ 的装备攻击 boss，然后只能使用某个属性值为 $3$ 的装备攻击 boss……以此类推。现在 lxhgww 想知道他最多能连续攻击 boss 多少次？", "test_cases": [{"input": "3\n1 2\n3 2\n4 5\n", "output": "2"}, {"input": "1\n1 1\n", "output": "1"}, {"input": "5\n1 2\n2 3\n3 4\n4 5\n5 6\n", "output": "5"}, {"input": "2\n1 10000\n1 2\n", "output": "2"}, {"input": "4\n1 2\n1 3\n2 1\n3 1\n", "output": "3"}, {"input": "5\n1 1\n2 2\n3 3\n4 4\n5 5\n", "output": "5"}, {"input": "2\n10000 10000\n1 1\n", "output": "1"}, {"input": "5\n1 1\n1 2\n2 2\n2 3\n3 3\n", "output": "3"}, {"input": "4\n2 2\n3 3\n1 1\n4 4\n", "output": "4"}, {"input": "3\n10000 5000\n1 1\n2 2\n", "output": "2"}, {"input": "2\n4 4\n1 1\n", "output": "1"}, {"input": "3\n3 2\n2 1\n1 3\n", "output": "3"}, {"input": "5\n1 7\n2 9\n3 4\n5 6\n8 10\n", "output": "3"}, {"input": "4\n1 2\n2 3\n3 4\n4 5\n", "output": "4"}, {"input": "5\n1 10\n2 1000\n3 100\n4 1\n5 10000\n", "output": "5"}, {"input": "2\n1 2\n2 3\n", "output": "2"}], "test": "#undef NDEBUG\n#include<assert.h>\nint main(){\n    assert(solution(\"3\\n1 2\\n3 2\\n4 5\\n\") == \"2\");\n    assert(solution(\"1\\n1 1\\n\") == \"1\");\n    assert(solution(\"5\\n1 2\\n2 3\\n3 4\\n4 5\\n5 6\\n\") == \"5\");\n    assert(solution(\"2\\n1 10000\\n1 2\\n\") == \"2\");\n    assert(solution(\"4\\n1 2\\n1 3\\n2 1\\n3 1\\n\") == \"3\");\n    assert(solution(\"5\\n1 1\\n2 2\\n3 3\\n4 4\\n5 5\\n\") == \"5\");\n    assert(solution(\"2\\n10000 10000\\n1 1\\n\") == \"1\");\n    assert(solution(\"5\\n1 1\\n1 2\\n2 2\\n2 3\\n3 3\\n\") == \"3\");\n    assert(solution(\"4\\n2 2\\n3 3\\n1 1\\n4 4\\n\") == \"4\");\n    assert(solution(\"3\\n10000 5000\\n1 1\\n2 2\\n\") == \"2\");\n    assert(solution(\"2\\n4 4\\n1 1\\n\") == \"1\");\n    assert(solution(\"3\\n3 2\\n2 1\\n1 3\\n\") == \"3\");\n    assert(solution(\"5\\n1 7\\n2 9\\n3 4\\n5 6\\n8 10\\n\") == \"3\");\n    assert(solution(\"4\\n1 2\\n2 3\\n3 4\\n4 5\\n\") == \"4\");\n    assert(solution(\"5\\n1 10\\n2 1000\\n3 100\\n4 1\\n5 10000\\n\") == \"5\");\n    assert(solution(\"2\\n1 2\\n2 3\\n\") == \"2\");\n    return 0; \n}", "prompt": "/*Lxhgww has recently become obsessed with a game in which he has many equipment, with each equipment having 2 attributes represented by values between $1$ and $10000$. When he uses a certain equipment, he can only use one of its attributes and each type of equipment can only be used once. When the game reaches its final boss, lxhgww encounters a strange requirement, which is that the attribute values used to attack the boss must increase from $1$ in a continuous sequence, meaning that at the beginning, lxhgww can only use equipment with an attribute value of $1$ to attack the boss, then only equipment with an attribute value of $2$, and so on. Now, lxhgww wants to know the maximum number of times he can continuously attack the boss.\n\ninput_format:\nThe first line of input is an integer $N$, indicating that lxhgww has $N$equipment. The next $N$line is a description of this $N$equipment. The $2 numbers in each line represent the $2 attribute value of the $i$equipment.\n\noutput_format:\nOutput a line containing a number of $1, indicating the maximum number of consecutive lxhgww attacks.\n*/\n\n#include<sstream>\n#include<stdlib.h>\n#include<algorithm>\n#include<math.h>\n#include<stdio.h>\n#include<vector>\n#include<string>\n#include<climits>\n#include<cstring>\n#include<iostream>\nusing namespace std;\n\n             \nstring solution(string std_in){\n    istringstream iss(std_in);\n             ", "constraints": "对于 $30\\%$ 的数据，保证 $N \\le 10^3$。\n\n对于 $100\\%$ 的数据，保证 $N \\le 10^6$。", "samples": [["3\n1 2\n3 2\n4 5\n", "2"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072]}}
{"task_id": "P7934", "title": "[COCI2007-2008#5] JABUKE", "difficulty": "challenge", "nl": "Given the coordinates of three vertices of a triangle and the coordinates of $N$ points, please calculate the area of the triangle and the number of points (including boundary points) inside the triangle among these $N$ points.", "code": "#include<cstdio>\nstruct pt{\n    int x,y; //定义点的坐标结构体\n};\nint area(pt a,pt b,pt c){ //计算面积\n   int t=a.x*(b.y-c.y)+b.x*(c.y-a.y)+c.x*(a.y-b.y);\n   if(t<0) return -t; //面积非负\n   else return t;\n}\nint main(){\n   pt a,b,c;\n   scanf(\"%d%d%d%d%d%d\",&a.x,&a.y,&b.x,&b.y,&c.x,&c.y);\n   int n,ans=0;\n   scanf(\"%d\",&n);\n   for(int i=0;i<n;i++){\n      pt p;\n      scanf(\"%d%d\",&p.x,&p.y);\n      if(area(a,b,p)+area(a,c,p)+area(b,c,p)==area(a,b,c)) ans++; //判断面积是否相等\n   }\n   printf(\"%.1lf\\n%d\\n\",area(a,b,c)/2.0,ans); //代入公式\n}", "step": ["Define a struct to represent a point, with an x and y coordinate.", "Define a function to compute the area of the triangle formed by three points.", "In the main function, read input for three points and the number of additional points.", "For each additional point, compute the sum of the areas of the triangles formed by the additional point and each edge of the original triangle; if the sum equals the area of the original triangle, the point lies inside the triangle.", "Count how many additional points lie inside the triangle.", "Print the area of the original triangle and the number of additional points that lie inside it."], "nl_cn": "给出一个三角形三个顶点的坐标以及 $N$ 个点的坐标，请您计算出这个三角形的面积和在这 $N$ 个点中，有多少个点在这个三角形内部（包含边界）。", "test_cases": [{"input": "1 1\n5 1\n3 3\n4\n3 1\n3 2\n3 3\n3 4 ", "output": "4.0\n3"}, {"input": "3 2\n5 4\n1 6\n3\n2 4\n3 5\n4 3 ", "output": "6.0\n3"}, {"input": "2 6\n5 1\n7 8\n5\n1 4\n3 5\n6 4\n6 5\n4 7 ", "output": "15.5\n2"}, {"input": "0 0\n5 0\n0 10\n5\n2 2\n3 3\n4 4\n5 5\n", "output": "25.0\n2"}, {"input": "1 1\n6 1\n3 5\n4\n2 2\n3 3\n4 4\n5 5\n", "output": "10.0\n2"}, {"input": "1 1\n1 4\n5 1\n3\n2 2\n3 2\n4 2", "output": "6.0\n2"}, {"input": "0 0\n0 10\n10 0\n3\n5 5\n7 6\n3 4", "output": "50.0\n2"}, {"input": "0 0\n0 0\n0 0\n1\n0 0\n", "output": "0.0\n1"}, {"input": "1 1\n1 1\n1 1\n4\n1 1\n1 1\n1 1\n1 1\n", "output": "0.0\n4"}, {"input": "1 1\n3 1\n2 2\n3\n1 1\n1 2\n1 3\n", "output": "1.0\n1"}, {"input": "1 2\n3 4\n5 6\n3\n2 2\n4 4\n6 6\n", "output": "0.0\n0"}, {"input": "1 1\n2 2\n3 3\n2\n1 1\n2 2\n", "output": "0.0\n2"}, {"input": "0 0\n0 0\n0 0\n4\n0 0\n0 0\n0 0\n0 0\n", "output": "0.0\n4"}, {"input": "1 1\n1 1\n1 1\n3\n1 1\n1 1\n1 1\n", "output": "0.0\n3"}, {"input": "1 1\n2 2\n3 3\n2\n2 2\n3 3\n", "output": "0.0\n2"}], "test": "#undef NDEBUG\n#include<assert.h>\nint main(){\n    assert(solution(\"1 1\\n5 1\\n3 3\\n4\\n3 1\\n3 2\\n3 3\\n3 4 \") == \"4.0\\n3\");\n    assert(solution(\"3 2\\n5 4\\n1 6\\n3\\n2 4\\n3 5\\n4 3 \") == \"6.0\\n3\");\n    assert(solution(\"2 6\\n5 1\\n7 8\\n5\\n1 4\\n3 5\\n6 4\\n6 5\\n4 7 \") == \"15.5\\n2\");\n    assert(solution(\"0 0\\n5 0\\n0 10\\n5\\n2 2\\n3 3\\n4 4\\n5 5\\n\") == \"25.0\\n2\");\n    assert(solution(\"1 1\\n6 1\\n3 5\\n4\\n2 2\\n3 3\\n4 4\\n5 5\\n\") == \"10.0\\n2\");\n    assert(solution(\"1 1\\n1 4\\n5 1\\n3\\n2 2\\n3 2\\n4 2\") == \"6.0\\n2\");\n    assert(solution(\"0 0\\n0 10\\n10 0\\n3\\n5 5\\n7 6\\n3 4\") == \"50.0\\n2\");\n    assert(solution(\"0 0\\n0 0\\n0 0\\n1\\n0 0\\n\") == \"0.0\\n1\");\n    assert(solution(\"1 1\\n1 1\\n1 1\\n4\\n1 1\\n1 1\\n1 1\\n1 1\\n\") == \"0.0\\n4\");\n    assert(solution(\"1 1\\n3 1\\n2 2\\n3\\n1 1\\n1 2\\n1 3\\n\") == \"1.0\\n1\");\n    assert(solution(\"1 2\\n3 4\\n5 6\\n3\\n2 2\\n4 4\\n6 6\\n\") == \"0.0\\n0\");\n    assert(solution(\"1 1\\n2 2\\n3 3\\n2\\n1 1\\n2 2\\n\") == \"0.0\\n2\");\n    assert(solution(\"0 0\\n0 0\\n0 0\\n4\\n0 0\\n0 0\\n0 0\\n0 0\\n\") == \"0.0\\n4\");\n    assert(solution(\"1 1\\n1 1\\n1 1\\n3\\n1 1\\n1 1\\n1 1\\n\") == \"0.0\\n3\");\n    assert(solution(\"1 1\\n2 2\\n3 3\\n2\\n2 2\\n3 3\\n\") == \"0.0\\n2\");\n    return 0; \n}", "prompt": "/*Given the coordinates of three vertices of a triangle and the coordinates of $N$ points, please calculate the area of the triangle and the number of points (including boundary points) inside the triangle among these $N$ points.\n\ninput_format:\nThe first three lines, with two integers each, represent the coordinates of one vertex of the triangle.\n\nOn the next line, an integer $N$.\n\nThe next $N$line, each with two integers $x_i,y_i$, represents the coordinates of the $i$point.\n\noutput_format:\nThe first line, a real number, represents the area of the triangle, retaining one decimal place.\n\nThe second line, an integer, represents the number of points inside and on the boundary of the triangle.\n*/\n\n#include<sstream>\n#include<stdlib.h>\n#include<algorithm>\n#include<math.h>\n#include<stdio.h>\n#include<vector>\n#include<string>\n#include<climits>\n#include<cstring>\n#include<iostream>\nusing namespace std;\n\n             \nstring solution(string std_in){\n    istringstream iss(std_in);\n             ", "constraints": "对于 $100\\%$ 的数据，$1\\le N\\le100$，所有坐标的 $x,y$ 均为小于 $10^3$ 的正整数。\n\n**提示：以坐标 $(x_A,y_A)$，$(x_B,y_B)$ 与 $(x_C,y_C)$ 为顶点的三角形面积公式如下：**\n\n$\\dfrac{|x_A(y_B-y_C)+x_B(y_C-y_A)+x_C(y_A-y_B)|}{2}$\n\n本题分值按照原比赛设置，满分 $30$ 分。", "samples": [["1 1\n5 1\n3 3\n4\n3 1\n3 2\n3 3\n3 4 ", "4.0\n3"], ["3 2\n5 4\n1 6\n3\n2 4\n3 5\n4 3 ", "6.0\n3"], ["2 6\n5 1\n7 8\n5\n1 4\n3 5\n6 4\n6 5\n4 7 ", "15.5\n2"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000], "memory": [32768, 32768, 32768, 32768, 32768]}}
{"task_id": "P2476", "title": "[SCOI2008]着色方案", "difficulty": "advanced", "nl": "There are n blocks arranged in a row, numbered from 1 to n from left to right.\n\nYou have k colors of paint, where the i-th color of paint is enough to paint ci blocks.\n\nAll paints are just enough to paint all the blocks, i.e. ∑ci=n.\n\nSince it looks bad to paint adjacent blocks with the same color, you want to count the number of coloring schemes where any two adjacent blocks have different colors.\n\nOutput the result modulo 109+7 due to the possibility of a large answer.", "code": "#include <iostream>\n#include <cstdio>\n#include <cstring>\n\nusing namespace std;\ntypedef long long ll;\nconst int Maxn = 0x3f3f3f3f, N = 16;\nconst ll Mod = 1000000007;\nll f[N][N][N][N][N][6], res;\nint n, m, x, num[6];\n\ninline int get()\n{\n    char ch; bool f = false; int res = 0;\n    while (((ch = getchar()) < '0' || ch > '9') && ch != '-');\n    if (ch == '-') f = true;\n     else res = ch - '0';\n    while ((ch = getchar()) >='0' && ch <= '9')\n        res = (res << 3) + (res << 1) + ch - '0';\n    return f? ~res + 1 : res;\n}\n\ninline void put(ll x)\n{\n    if (x < 0)\n      x = ~x + 1, putchar('-');\n    if (x > 9) put(x / 10);\n    putchar(x % 10 + 48);\n}\n\ninline ll Dfs(const int c1, const int c2, const int c3, const int c4, const int c5, const int lst)\n{\n    if (f[c1][c2][c3][c4][c5][lst]) return f[c1][c2][c3][c4][c5][lst];\n    ll res = 0;\n    if (c1) res = (res + (c1 - (lst == 2)) * Dfs(c1 - 1, c2, c3, c4, c5, 1)) % Mod;\n    if (c2) res = (res + (c2 - (lst == 3)) * Dfs(c1 + 1, c2 - 1, c3, c4, c5, 2)) % Mod;\n    if (c3) res = (res + (c3 - (lst == 4)) * Dfs(c1, c2 + 1, c3 - 1, c4, c5, 3)) % Mod;\n    if (c4) res = (res + (c4 - (lst == 5)) * Dfs(c1, c2, c3 + 1, c4 - 1, c5, 4)) % Mod;\n    if (c5) res = (res + c5 * Dfs(c1, c2, c3, c4 + 1, c5 - 1, 5)) % Mod;\n    return f[c1][c2][c3][c4][c5][lst]=res; \n} \n\nint main()\n{\n    for (int i = 1; i <= 5; ++i) f[0][0][0][0][0][i] = 1;\n    n = get(); for (int i = 1; i <= n; ++i) num[x = get()]++;\n    return put(Dfs(num[1], num[2], num[3], num[4], num[5], 0)), 0;\n}", "step": ["Initialize variables and input values.", "Prepare the combination array.", "Loop through each value of k.", "Loop through each combination of the previous values and the current value.", "Calculate the current combination and store it in the f array.", "Output the final result from the f array."], "nl_cn": "有 $n$ 个木块排成一行，从左到右依次编号为 $1$ 至 $n$。\n\n你有 $k$ 种颜色的油漆，第 $i$ 种颜色的油漆足够涂 $c_i$ 个木块。\n\n所有油漆刚好足够涂满所有木块，即 $\\sum_{i=1}^kc_i=n$。\n\n由于相邻两个木块涂相同色显得很难看，所以你希望统计任意两个相邻木块颜色不同的着色方案。\n\n由于答案可能很大，请输出对 $10^9+7$ 取模的结果。", "test_cases": [{"input": "3\n1 2 3", "output": "10"}, {"input": "5\n2 2 2 2 2", "output": "39480"}, {"input": "10\n1 1 2 2 3 3 4 4 5 5\n", "output": "85937576"}, {"input": "1\n1\n", "output": "1"}, {"input": "2\n1 2\n", "output": "1"}], "test": "#undef NDEBUG\n#include<assert.h>\nint main(){\n    assert(solution(\"3\\n1 2 3\") == \"10\");\n    assert(solution(\"5\\n2 2 2 2 2\") == \"39480\");\n    assert(solution(\"10\\n1 1 2 2 3 3 4 4 5 5\\n\") == \"85937576\");\n    assert(solution(\"1\\n1\\n\") == \"1\");\n    assert(solution(\"2\\n1 2\\n\") == \"1\");\n    return 0; \n}", "prompt": "/*There are n blocks arranged in a row, numbered from 1 to n from left to right.\n\nYou have k colors of paint, where the i-th color of paint is enough to paint ci blocks.\n\nAll paints are just enough to paint all the blocks, i.e. ∑ci=n.\n\nSince it looks bad to paint adjacent blocks with the same color, you want to count the number of coloring schemes where any two adjacent blocks have different colors.\n\nOutput the result modulo 109+7 due to the possibility of a large answer.\n\ninput_format:\n`````\nThe first line contains an integer $k$, representing the number of colors.\n\nThe second line contains $k$ integers $c_1,c_2,\\dots,c_k$, representing the number of blocks that can be painted with each color.\n`````\n\noutput_format:\nA row of integers represents the result of the answer modulo $10^9+7.\n*/\n\n#include<sstream>\n#include<stdlib.h>\n#include<algorithm>\n#include<math.h>\n#include<stdio.h>\n#include<vector>\n#include<string>\n#include<climits>\n#include<cstring>\n#include<iostream>\nusing namespace std;\n\n             \nstring solution(string std_in){\n    istringstream iss(std_in);\n             ", "constraints": "- 对于 $50\\%$ 的数据，$1 \\leq k \\leq 5$，$1 \\leq c_i \\leq 3$；\n- 对于 $100\\%$ 的数据，$1 \\leq k \\leq 15$，$1 \\leq c_i \\leq 5$。", "samples": [["3\n1 2 3", "10"], ["5\n2 2 2 2 2", "39480"], ["10\n1 1 2 2 3 3 4 4 5 5\n", "85937576"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}}
{"task_id": "P6909", "title": "[ICPC2015 WF]Keyboarding", "difficulty": "advanced", "nl": "How many keystrokes are required to input a text message? You might think it's equal to the number of characters in the text, but that's only true when one key generates one character. For pocket devices, the possibilities for inputting text are often limited. Some devices provide only a few buttons, far fewer than the number of letters in the alphabet. Therefore, multiple keystrokes are required to input a single character. One mechanism used to address these limitations is a virtual keyboard displayed on a screen, with a movable cursor to select characters. Four arrow buttons control the movement of the cursor, and when the cursor is positioned over the appropriate key, pressing the fifth button selects the corresponding character and appends it to the end of the text. To terminate the text, the user must navigate and select the Enter key. This provides users with an arbitrary set of characters and allows them to type text of any length using only five hardware buttons.\n\nIn this problem, given a virtual keyboard layout and the task of determining the minimum number of keystrokes required to type a given text, where pressing any five hardware buttons constitutes a keystroke. The keys are arranged in a rectangular grid, with each virtual key occupying one or more adjacent cells. The cursor starts moving from the top-left corner of the keyboard, moving in one of the four cardinal directions, so that it always jumps to the next cell belonging to a different key in that direction. If there is no such cell, the cursor does not move.\n\nFigure 1 (showing example input 1) depicts one possibility for inputting the word \"CONTEST\" using the example virtual keyboard, requiring 30 keystrokes. The red dot indicates the virtual key selected by pressing the selection button.", "code": "#include<cstdio>\n#include<cmath>\n#include<iostream>\n#include<cstring>\n#include<queue>\n#include<algorithm>\n#include<stdlib.h>\n#include<time.h>\n#include<map>\n#include<vector>\n#include<set>\n#define ull unsigned long long\n#define ll long long\n#define M 1000010\n#define N 1010\n#define qaq cout<<\"可行QAQ\"<<endl\n#define INF 0x3f3f3f3f\nusing namespace std;\nconst int mod1 = 19260817;\nconst int mod2 = 19660813;\n/*================================================*/\n\nint n,m,len;\nchar mp[55][55];//键盘\nchar yuan[10010];//要求的字符串\nint dx[5] = {0, 1, -1, 0, 0};\nint dy[5] = {0, 0, 0, 1, -1};//方向\nint disx[5][55][55],disy[5][55][55];//能到达的位置的坐标\nstruct node {\n\tint x , y , cnt , len ;\n} now , cur ;//从左到右依次为 ： 横坐标，纵坐标，按键次数，字符串长度\nint length[10010][55][55];//储存按键次数\nqueue<node> qp;\n\n/*================================================*/\n\nbool check(int x,int y) //判断是否出边界\n{\n\tif(x < 1 || x > n) return false;\n\tif(y < 1 || y > m) return false;\n\treturn true;\n}\n\nvoid init()\n{\n\tfor(int i = 1; i <= n; ++i) {//枚举行；\n\t\tfor(int j = 1; j <= m; ++j) {//枚举列；\n\t\t\tfor(int k = 1; k <= 4; ++k) {//枚举每个方向；\n\t\t\t\tint sx = i, sy = j;\n\t\t\t\twhile(mp[sx][sy] == mp[i][j]){\n\t\t\t\t//当寻找到的字符和原来的字符相同时，就继续枚举；\n\t\t\t\t\tsx += dx[k];\n\t\t\t\t\tsy += dy[k];\n\t\t\t\t}\n\t\t\t\tif(check(sx,sy)) {\n\t\t\t\t\tdisx[k][i][j] = sx;\n\t\t\t\t\tdisy[k][i][j] = sy;\n\t\t\t\t//如果没出边界，就附上从这个字符能到的下个字符的坐标；\n\t\t\t\t} else {\n\t\t\t\t\tdisx[k][i][j] = INF;\n\t\t\t\t\tdisy[k][i][j] = INF;//否则 附为 0x3f3f3f3f；\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\treturn;\n}\n\nint bfs() \n{\n\t\n\tmemset(length,INF,sizeof(length));\n\tnow.x = 1; now.y = 1; now.len = 0; now.cnt = 0;\n\t//初始化一开始的位置，按键次数，找到的字符串长度。\n\tlength[0][now.x][now.y] = 0;//当找到的字符串长度为 0 是按键次数为 0\n\tqp.push((node){ now.x, now.y, now.cnt, now.len});//压入队列\n\twhile(qp.size()) {\n\t\tcur = qp.front();//cur 是 光标的意思\n\t\tqp.pop();\n\t\twhile(yuan[cur.len + 1] == mp[cur.x][cur.y]) {//寻找匹配的字符\n\t\t\tcur.len++;\n\t\t\tcur.cnt++;\n\t\t}\n\t\tif(cur.len == len) return cur.cnt;\n\t\t//退出条件 ：把要求的字符串打完了\n\t\tfor(int i=1;i<=4;i++) {//向 4 个方向枚举\n\t\t\tnow.x = cur.x; now.y = cur.y;\n\t\t\tnow.len = cur.len; now.cnt = cur.cnt;\n\t\t\t//因为 下面 now.x 和 now.y 被附为了新值。\n\t\t\t//所以这里每一遍都要把 now = cur.\n\t\t\tif(disx[i][now.x][now.y] != INF ||\n\t\t\t    disy[i][now.x][now.y] != INF) {//如果有可到达的字符\n\t\t\t\tnow.x = disx[i][cur.x][cur.y];\n\t\t\t\tnow.y = disy[i][cur.x][cur.y];\n\t\t\t\tnow.len = cur.len;\n\t\t\t\tnow.cnt = cur.cnt + 1;//赋值\n\t\t\t\tif(now.cnt < length[now.len][now.x][now.y]) {//如果小于\n\t\t\t\t\tlength[now.len][now.x][now.y] = now.cnt;\n\t\t\t\t\t//更新到现在长度的最小值。\n\t\t\t\t\tqp.push((node){now.x , now.y , now.cnt , now.len});\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}\n\n/*=================================================*/\n\nsigned main()\n{\n//\tfreopen(\".in\",\"r\",stdin);\n//\tfreopen(\".out\",\"w\",stdout);\n\tscanf(\"%d%d\",&n,&m);\n\tfor(int i = 1 ;i <= n; ++i){\n\t\tscanf(\"%s\",mp[i] + 1);\n\t}\n\tscanf(\"%s\",yuan + 1);//读入\n\tyuan[strlen(yuan + 1)+ 1] = '*';//最后一定要加 * ； ！！！！\n\tlen = strlen(yuan + 1);//计算要求的字符串长度\n\tinit();\n\tint ans = bfs();\n\tprintf(\"%d\",ans);//输出\n\treturn 0;\n}", "step": ["Initialize variables n, m, ans, len, vis and mi.", "Create a struct point and a struct node.", "Implement the BFS algorithm using the queue.", "Read input values for variables n and m.", "Read a string as input, initialize the struct point attributes with 4 values and loop through them with init() function.", "Read another string as input and execute the bfs() function."], "nl_cn": "How many keystrokes are necessary to type a text message? You may think that it is equal to the number of characters in the text, but this is correct only if one keystroke generates one character. With pocket-size devices, the possibilities for typing text are often limited. Some devices provide only a few buttons, significantly fewer than the number of letters in the alphabet. For such devices, several strokes may be needed to type a single character. One mechanism to deal with these limitations is a virtual keyboard displayed on a screen, with a cursor that can be moved from key to key to select characters. Four arrow buttons control the movement of the cursor, and when the cursor is positioned over an appropriate key, pressing the fifth button selects the corresponding character and appends it to the end of the text. To terminate the text, the user must navigate to and select the Enter key. This provides users with an arbitrary set of characters and enables them to type text of any length with only five hardware buttons.\n\nIn this problem, you are given a virtual keyboard layout and your task is to determine the minimal number of strokes needed to type a given text, where pressing any of the five hardware buttons constitutes a stroke. The keys are arranged in a rectangular grid, such that each virtual key occupies one or more connected unit squares of the grid. The cursor starts in the upper left corner of the keyboard and moves in the four cardinal directions, in such a way that it always skips to the next unit square in that direction that belongs to a different key. If there is no such unit square, the cursor does not move.\n\n   \n\n   Figure 1: Sample Input 1. An example virtual keyboard and hardware buttons. \n\nFigure 1, illustrating Sample Input 1, shows a possible way to type CONTEST using 30 strokes on an example virtual keyboard. The red dots represent the virtual keys where the select button was pressed.", "test_cases": [{"input": "4 7\nABCDEFG\nHIJKLMN\nOPQRSTU\nVWXYZ**\nCONTEST\n", "output": "30"}, {"input": "5 20\n12233445566778899000\nQQWWEERRTTYYUUIIOOPP\n-AASSDDFFGGHHJJKKLL*\n--ZZXXCCVVBBNNMM--**\n--------------------\nACM-ICPC-WORLD-FINALS-2015\n", "output": "160"}, {"input": "2 19\nABCDEFGHIJKLMNOPQZY\nX*****************Y\nAZAZ\n", "output": "19"}, {"input": "6 4\nAXYB\nBBBB\nKLMB\nOPQB\nDEFB\nGHI*\nAB\n", "output": "7"}], "test": "#undef NDEBUG\n#include<assert.h>\nint main(){\n    assert(solution(\"4 7\\nABCDEFG\\nHIJKLMN\\nOPQRSTU\\nVWXYZ**\\nCONTEST\\n\") == \"30\");\n    assert(solution(\"5 20\\n12233445566778899000\\nQQWWEERRTTYYUUIIOOPP\\n-AASSDDFFGGHHJJKKLL*\\n--ZZXXCCVVBBNNMM--**\\n--------------------\\nACM-ICPC-WORLD-FINALS-2015\\n\") == \"160\");\n    assert(solution(\"2 19\\nABCDEFGHIJKLMNOPQZY\\nX*****************Y\\nAZAZ\\n\") == \"19\");\n    assert(solution(\"6 4\\nAXYB\\nBBBB\\nKLMB\\nOPQB\\nDEFB\\nGHI*\\nAB\\n\") == \"7\");\n    return 0; \n}", "prompt": "/*How many keystrokes are required to input a text message? You might think it's equal to the number of characters in the text, but that's only true when one key generates one character. For pocket devices, the possibilities for inputting text are often limited. Some devices provide only a few buttons, far fewer than the number of letters in the alphabet. Therefore, multiple keystrokes are required to input a single character. One mechanism used to address these limitations is a virtual keyboard displayed on a screen, with a movable cursor to select characters. Four arrow buttons control the movement of the cursor, and when the cursor is positioned over the appropriate key, pressing the fifth button selects the corresponding character and appends it to the end of the text. To terminate the text, the user must navigate and select the Enter key. This provides users with an arbitrary set of characters and allows them to type text of any length using only five hardware buttons.\n\nIn this problem, given a virtual keyboard layout and the task of determining the minimum number of keystrokes required to type a given text, where pressing any five hardware buttons constitutes a keystroke. The keys are arranged in a rectangular grid, with each virtual key occupying one or more adjacent cells. The cursor starts moving from the top-left corner of the keyboard, moving in one of the four cardinal directions, so that it always jumps to the next cell belonging to a different key in that direction. If there is no such cell, the cursor does not move.\n\nFigure 1 (showing example input 1) depicts one possibility for inputting the word \"CONTEST\" using the example virtual keyboard, requiring 30 keystrokes. The red dot indicates the virtual key selected by pressing the selection button.\n\ninput_format:\nThe first line of the input contains two integers $r$ and $c$ ($1 \\leq r, c \\leq 50$), giving the number of rows and columns of the virtual keyboard grid. The virtual keyboard is specified in the next $r$ lines, each of which contains $c$ characters. The possible values of these characters are uppercase letters, digits, a dash, and an asterisk (representing Enter). There is only one key corresponding to any given character. Each key is made up of  one or more grid squares, which will always form a connected region. The last line of the input contains the text to be typed. This text is a non-empty string of at most $10\\, 000$ of the available characters other than the asterisk.\n\noutput_format:\nDisplay the minimal number of strokes necessary to type the whole text, including the Enter key at the end. It is guaranteed that the text can be typed.\n*/\n\n#include<sstream>\n#include<stdlib.h>\n#include<algorithm>\n#include<math.h>\n#include<stdio.h>\n#include<vector>\n#include<string>\n#include<climits>\n#include<cstring>\n#include<iostream>\nusing namespace std;\n\n             \nstring solution(string std_in){\n    istringstream iss(std_in);\n             ", "constraints": "Time limit: 3000 ms, Memory limit: 1048576 kB. \n\n International Collegiate Programming Contest (ACM-ICPC) World Finals 2015", "samples": [["4 7\nABCDEFG\nHIJKLMN\nOPQRSTU\nVWXYZ**\nCONTEST\n", "30\n"], ["5 20\n12233445566778899000\nQQWWEERRTTYYUUIIOOPP\n-AASSDDFFGGHHJJKKLL*\n--ZZXXCCVVBBNNMM--**\n--------------------\nACM-ICPC-WORLD-FINALS-2015\n", "160\n"], ["2 19\nABCDEFGHIJKLMNOPQZY\nX*****************Y\nAZAZ\n", "19\n"], ["6 4\nAXYB\nBBBB\nKLMB\nOPQB\nDEFB\nGHI*\nAB\n", "7\n"]], "limits": {"time": [3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000], "memory": [512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000]}}
{"task_id": "P8296", "title": "[COCI2012-2013#2] KRIZALJKA", "difficulty": "challenge", "nl": "Do you like to play word puzzles? If so, you might know the traditional beginner game, as shown below:\n\n***\n\n\n\n- Horizontal:\n\n  1. Device used to cool a computer\n\n  2. Solid water\n\n  3. Used to obtain\n\n- Vertical:\n\n  1. Small, soft, and sweet fruit\n  \n  2. Strong playing card\n  \n  3. Fisher's tool\n***\n\nGiven six three-letter words, you need to place them in a 3x3 grid so that each word appears both horizontally and vertically.", "code": "#include<bits/stdc++.h>\nusing namespace std;\nint n=6;//这里n均为6\nstring a[10];\nint main()\n{\n\tfor(int i=1;i<=n;i++)\n\t{\n\t\tcin>>a[i];\n\t}\n\tfor(int i=1;i<=n;i++)\n\t{\n\t\tfor(int j=1;j<=n;j++)\n\t\t{\n\t\t\tfor(int k=1;k<=n;k++)//枚举三个数\n\t\t\t{\n\t\t\t\tif(i==j||j==k||k==i)//判重\n\t\t\t\t{\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tstring x;\n\t\t\t\tx=x+a[i][0]+a[j][0]+a[k][0];\n\t\t\t\tstring y;\n\t\t\t\ty=y+a[i][1]+a[j][1]+a[k][1];\n\t\t\t\tstring z;\n\t\t\t\tz=z+a[i][2]+a[j][2]+a[k][2];\n\t\t\t\t//分别令 x,y,z 为第一列，第二列，第三列\n\t\t\t\tbool f1=0,f2=0,f3=0;\n\t\t\t\t//成功的就可以标记\n\t\t\t\tfor(int l=1;l<=n;l++)\n\t\t\t\t{\n\t\t\t\t\tif(l==i||l==j||l==k)\n\t\t\t\t\t{\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t\tif(a[l]==x&&!f1)//会有重复的记得判重\n\t\t\t\t\t{\n\t\t\t\t\t\tf1=1;\n\t\t\t\t\t}\n\t\t\t\t\telse if(a[l]==y&&!f2)//同上\n\t\t\t\t\t{\n\t\t\t\t\t\tf2=1;\n\t\t\t\t\t}\n\t\t\t\t\telse if(a[l]==z)\n\t\t\t\t\t{\n\t\t\t\t\t\tf3=1;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif(f1&&f2&&f3)//成功了直接输出，并结束\n\t\t\t\t{\n\t\t\t\t\tcout<<a[i]<<endl;\n\t\t\t\t\tcout<<a[j]<<endl;\n\t\t\t\t\tcout<<a[k]<<endl;\n\t\t\t\t\treturn 0;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tcout<<0<<endl;//未成功的输出0\n\treturn 0;\n}", "step": ["Take input of 6 strings.", "Create new strings by combining the 1st three characters of each of the input strings in all possible combinations.", "Check each of the newly created strings against the input strings.", "If all three newly created strings are present in the input, output them.", "If no such combination of strings exists, output 0."], "nl_cn": "你喜欢玩填字游戏吗？如果是，你可能会知道传统的初学游戏，如下所示：\n\n***\n\n\n\n- 水平方向上：\n\n  1. 用于冷却电脑的设备\n\n  2. 固态水\n\n  3. 用来获得\n\n- 垂直方向上：\n\n  1. 又小又软又甜的水果\n  \n  2. 强力纸牌\n  \n  3. 渔夫的工具\n***\n\n给定六个有三个字母的单词，你需要把它们放在 $3\\times 3$ 的方格上，使得水平与垂直均出现这几个单词。\n", "test_cases": [{"input": "ANA\nANA\nDAR\nDAR\nRAD\nRAD", "output": "DAR\nANA\nRAD"}, {"input": "EVO\nHEP\nHIR\nIVA\nPAD\nROD", "output": "HEP\nIVA\nROD"}, {"input": "AKO\nCES\nDOC\nDON\nESI\nKES", "output": "0"}], "test": "#undef NDEBUG\n#include<assert.h>\nint main(){\n    assert(solution(\"ANA\\nANA\\nDAR\\nDAR\\nRAD\\nRAD\") == \"DAR\\nANA\\nRAD\");\n    assert(solution(\"EVO\\nHEP\\nHIR\\nIVA\\nPAD\\nROD\") == \"HEP\\nIVA\\nROD\");\n    assert(solution(\"AKO\\nCES\\nDOC\\nDON\\nESI\\nKES\") == \"0\");\n    return 0; \n}", "prompt": "/*Do you like to play word puzzles? If so, you might know the traditional beginner game, as shown below:\n\n***\n\n\n\n- Horizontal:\n\n  1. Device used to cool a computer\n\n  2. Solid water\n\n  3. Used to obtain\n\n- Vertical:\n\n  1. Small, soft, and sweet fruit\n  \n  2. Strong playing card\n  \n  3. Fisher's tool\n***\n\nGiven six three-letter words, you need to place them in a 3x3 grid so that each word appears both horizontally and vertically.\n\ninput_format:\nEnter a total of $6$lines, one word with three capital letters per line. Ensure that it is given in lexicographical order.\n\noutput_format:\nIf no solution exists, output $0$. Otherwise output a matrix of three rows and three columns.\n\nIf there are multiple solutions, output the minimum lexicographic order of nine characters formed from the end of each line.\n*/\n\n#include<sstream>\n#include<stdlib.h>\n#include<algorithm>\n#include<math.h>\n#include<stdio.h>\n#include<vector>\n#include<string>\n#include<climits>\n#include<cstring>\n#include<iostream>\nusing namespace std;\n\n             \nstring solution(string std_in){\n    istringstream iss(std_in);\n             ", "constraints": "", "samples": [["ANA\nANA\nDAR\nDAR\nRAD\nRAD", "DAR\nANA\nRAD"], ["EVO\nHEP\nHIR\nIVA\nPAD\nROD", "HEP\nIVA\nROD"], ["AKO\nCES\nDOC\nDON\nESI\nKES", "0"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [32768, 32768, 32768, 32768, 32768, 32768, 32768, 32768, 32768, 32768, 32768, 32768, 32768, 32768, 32768, 32768]}}
{"task_id": "P1317", "title": "低洼地", "difficulty": "basic", "nl": "A set of numbers, representing the changes in height of a horizon. The height values are integers and adjacent heights are connected with straight lines. Find and count how many possible depressions can hold water.\n\nFor example: the heights are 0 1 0 2 1 2 0 0 2 0. \n\n", "code": "#include <bits/stdc++.h>\nusing namespace std;\nint n,m,a[100001],ans,k;\nint main()\n{\n\tscanf(\"%d\",&n);\n\tfor(int i=1;i<=n;i++)scanf(\"%d\",&a[i]);\n\tint i=1;\n\twhile(i<=n){\n\t\twhile(a[i]<=a[i-1]&&i<=n) i++;//1\n\t\twhile(a[i]>=a[i-1]&&i<=n) i++;//2\n\t\tans++;//一段完了多一个答案\n\t}\n\tprintf(\"%d\",ans-2);//最开始与最后都算了所以减掉\n    return 0;\n}", "step": ["Reads input size", "Reads array data", "Initializes i to 1", "Counts number of peaks", "Prints the final answer"], "nl_cn": "一组数，分别表示地平线的高度变化。高度值为整数，相邻高度用直线连接。找出并统计有多少个可能积水的低洼地？\n\n如图：地高变化为 0 1 0 2 1 2 0 0 2 0\n\n\n\n\n\n  \n\n", "test_cases": [{"input": "10\n0 1 0 2 1 2 0 0 2 0\n", "output": "3"}, {"input": "5\n3 2 1 2 3\n", "output": "0"}, {"input": "8\n5 4 3 2 1 0 1 2\n", "output": "0"}, {"input": "9\n3 1 4 1 2 3 2 1 4\n", "output": "2"}, {"input": "6\n2 1 2 2 1 2\n", "output": "1"}, {"input": "4\n4 3 2 1\n", "output": "0"}, {"input": "7\n0 1 2 1 2 1 2\n", "output": "1"}, {"input": "8\n0 1 0 2 0 1 0 2\n", "output": "2"}, {"input": "9\n0 1 2 3 2 1 0 1 0\n", "output": "1"}, {"input": "11\n0 1 0 2 0 3 0 4 0 5 0\n", "output": "4"}, {"input": "7\n0 1 2 3 1 2 0\n", "output": "1"}, {"input": "6\n0 1 2 1 1 0\n", "output": "0"}, {"input": "10\n0 1 0 2 1 1 2 2 0 0\n", "output": "2"}, {"input": "5\n2 1 2 1 1\n", "output": "1"}, {"input": "6\n1 2 1 1 2 1\n", "output": "1"}, {"input": "5\n5 4 3 2 1\n", "output": "0"}, {"input": "3\n2 1 2\n", "output": "0"}, {"input": "5\n3 2 1 5 4\n", "output": "1"}, {"input": "3\n2 1 3\n", "output": "0"}, {"input": "4\n1 2 2 1\n", "output": "0"}, {"input": "6\n1 2 3 2 3 1\n", "output": "1"}, {"input": "10\n2 4 6 8 10 8 6 4 2 0\n", "output": "0"}, {"input": "5\n1 2 3 2 1\n", "output": "0"}, {"input": "6\n0 1 0 1 0 1\n", "output": "1"}, {"input": "8\n1 2 3 4 5 4 3 2\n", "output": "0"}, {"input": "6\n1 2 3 0 3 2\n", "output": "1"}], "test": "#undef NDEBUG\n#include<assert.h>\nint main(){\n    assert(solution(\"10\\n0 1 0 2 1 2 0 0 2 0\\n\") == \"3\");\n    assert(solution(\"5\\n3 2 1 2 3\\n\") == \"0\");\n    assert(solution(\"8\\n5 4 3 2 1 0 1 2\\n\") == \"0\");\n    assert(solution(\"9\\n3 1 4 1 2 3 2 1 4\\n\") == \"2\");\n    assert(solution(\"6\\n2 1 2 2 1 2\\n\") == \"1\");\n    assert(solution(\"4\\n4 3 2 1\\n\") == \"0\");\n    assert(solution(\"7\\n0 1 2 1 2 1 2\\n\") == \"1\");\n    assert(solution(\"8\\n0 1 0 2 0 1 0 2\\n\") == \"2\");\n    assert(solution(\"9\\n0 1 2 3 2 1 0 1 0\\n\") == \"1\");\n    assert(solution(\"11\\n0 1 0 2 0 3 0 4 0 5 0\\n\") == \"4\");\n    assert(solution(\"7\\n0 1 2 3 1 2 0\\n\") == \"1\");\n    assert(solution(\"6\\n0 1 2 1 1 0\\n\") == \"0\");\n    assert(solution(\"10\\n0 1 0 2 1 1 2 2 0 0\\n\") == \"2\");\n    assert(solution(\"5\\n2 1 2 1 1\\n\") == \"1\");\n    assert(solution(\"6\\n1 2 1 1 2 1\\n\") == \"1\");\n    assert(solution(\"5\\n5 4 3 2 1\\n\") == \"0\");\n    assert(solution(\"3\\n2 1 2\\n\") == \"0\");\n    assert(solution(\"5\\n3 2 1 5 4\\n\") == \"1\");\n    assert(solution(\"3\\n2 1 3\\n\") == \"0\");\n    assert(solution(\"4\\n1 2 2 1\\n\") == \"0\");\n    assert(solution(\"6\\n1 2 3 2 3 1\\n\") == \"1\");\n    assert(solution(\"10\\n2 4 6 8 10 8 6 4 2 0\\n\") == \"0\");\n    assert(solution(\"5\\n1 2 3 2 1\\n\") == \"0\");\n    assert(solution(\"6\\n0 1 0 1 0 1\\n\") == \"1\");\n    assert(solution(\"8\\n1 2 3 4 5 4 3 2\\n\") == \"0\");\n    assert(solution(\"6\\n1 2 3 0 3 2\\n\") == \"1\");\n    return 0; \n}", "prompt": "/*A set of numbers, representing the changes in height of a horizon. The height values are integers and adjacent heights are connected with straight lines. Find and count how many possible depressions can hold water.\n\nFor example: the heights are 0 1 0 2 1 2 0 0 2 0. \n\n\n\ninput_format:\nTwo lines, the first line $n,$indicates the number of $n$. The number of consecutive $n$in row $2 indicates the data of the horizon height change, guaranteed to start and end with $0$. $(3 \\le n \\le 10,000,0 \\le $Height $\\le 1000)$.\n\noutput_format:\nA number, the number of possible waterlogged depressions.\n*/\n\n#include<sstream>\n#include<stdlib.h>\n#include<algorithm>\n#include<math.h>\n#include<stdio.h>\n#include<vector>\n#include<string>\n#include<climits>\n#include<cstring>\n#include<iostream>\nusing namespace std;\n\n             \nstring solution(string std_in){\n    istringstream iss(std_in);\n             ", "constraints": "", "samples": [["10\n0 1 0 2 1 2 0 0 2 0\n", "3"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}}
{"task_id": "P2796", "title": "Facer的程序", "difficulty": "advanced", "nl": "Facer is a cute coder who has written N programs. There are organic connections between the programs, and any two programs are connected by exactly one chain of contacts. Specifically, for programs a and b, there exists a unique sequence a,x1,x2,...,xn,b such that a and x1 have contacts, x1 and x2 have contacts, and so on. A set of programs that meet these requirements is called a program block. Now the contacts between programs in a program block are known. The task is to determine how many sub-program blocks there are, i.e. to extract a program subset S that also satisfies the above conditions.", "code": "#include<bits/stdc++.h>\n#define ll long long\nconst int mod=1000000007;\nusing namespace std;\nint n;\nint cnt,head[100010],ne[200010],to[200010];\nll f[100010];\nll ans;\nvoid add(int a,int b){\n    cnt++;\n    ne[cnt]=head[a];\n    to[cnt]=b;\n    head[a]=cnt;\n    return ;\n}\nvoid update(ll &a,ll b){\n    a=a*(b+1)%mod;\n}\nvoid dfs(int u,int fa){\n    f[u]=1;\n    for(int i=head[u];i;i=ne[i]){\n        if(to[i]==fa)continue;\n        dfs(to[i],u);\n        update(f[u],f[to[i]]);\n    }\n    ans=(ans+f[u])%mod;\n    return ;\n}\nint main(){\n    cin>>n;\n    for(int i=1;i<n;++i){\n        int a,b;\n        scanf(\"%d%d\",&a,&b);\n        add(a,b);\n        add(b,a);\n    }\n    dfs(1,0);\n    cout<<ans;\n}", "step": ["Initialize an array h and a counter tot.", "Define an edge structure, add a node in the graph, and initialize an array f and a variable ans.", "Define the dfs function to calculate the subgraph sizes and update the counter.", "In the main function, create a graph using add function, call the dfs function, and print the ans variable.", "End the program by returning 0."], "nl_cn": "Facer是一个萌萌哒的码农\n\n他写了N个程序\n\n程序之间是有 有机的联系的\n\n任意两个程序恰好由1条联系链连在一起\n\n具体来说，对于程序a,b ， 存在且仅存在一个序列a,x1,x2....xn,b\n\n使得a,x1有联系,x1,x2有联系.....\n\n符合这样的一组程序称为程序块\n\n\n现在已知一个程序块的程序之间的联系\n\n询问它有多少个子程序块\n\n即取出一个程序子集S，使得S也满足上述条件\n", "test_cases": [{"input": "3\n1 2\n2 3", "output": "6"}, {"input": "1\n", "output": "1"}, {"input": "2\n1 2\n", "output": "3"}, {"input": "3\n1 2\n1 3\n", "output": "6"}], "test": "#undef NDEBUG\n#include<assert.h>\nint main(){\n    assert(solution(\"3\\n1 2\\n2 3\") == \"6\");\n    assert(solution(\"1\\n\") == \"1\");\n    assert(solution(\"2\\n1 2\\n\") == \"3\");\n    assert(solution(\"3\\n1 2\\n1 3\\n\") == \"6\");\n    return 0; \n}", "prompt": "/*Facer is a cute coder who has written N programs. There are organic connections between the programs, and any two programs are connected by exactly one chain of contacts. Specifically, for programs a and b, there exists a unique sequence a,x1,x2,...,xn,b such that a and x1 have contacts, x1 and x2 have contacts, and so on. A set of programs that meet these requirements is called a program block. Now the contacts between programs in a program block are known. The task is to determine how many sub-program blocks there are, i.e. to extract a program subset S that also satisfies the above conditions.\n\ninput_format:\nThe first line is N.\n\nThe next N-1 lines, each line contains two numbers, representing two connected programs.\n\noutput_format:\nOutput how many subroutines there are\n\nTake the mode of 1000000007\n*/\n\n#include<sstream>\n#include<stdlib.h>\n#include<algorithm>\n#include<math.h>\n#include<stdio.h>\n#include<vector>\n#include<string>\n#include<climits>\n#include<cstring>\n#include<iostream>\nusing namespace std;\n\n             \nstring solution(string std_in){\n    istringstream iss(std_in);\n             ", "constraints": "样例解释：\n\n子集(1),(2),(3),(1,2),(2,3),(1,2,3)满足\n\n对于 10%的数据 1 <= N <= 20\n\n对于 40%的数据  1 <= N <= 500\n\n对于 100%的数据 1 <= N <= 100000\n", "samples": [["3\n1 2\n2 3", "6"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}}
{"task_id": "P3056", "title": "[USACO12NOV]Clumsy Cows S", "difficulty": "challenge", "nl": "Bessie the cow is trying to input a balanced parentheses string on her new laptop, but she is clumsy due to her big hooves and often types the wrong characters. Help her calculate the minimum number of characters that need to be flipped (e.g. change a left parenthesis to a right parenthesis or vice versa) to make the string balanced.\n\nThere are several ways to define a set of parentheses as \"balanced\". Perhaps the simplest definition is that the total number of left and right parentheses must be equal, and for any prefix of the string, the number of left parentheses must not be less than the number of right parentheses. For example, the following strings are all balanced:\n\n()\n(())\n()(()())\n\nWhile the following strings are unbalanced:\n\n)(\n())(\n((())))\n\nGiven a parentheses sequence of even length, what is the minimum number of modifications needed to make it balanced?", "code": "#include<cstdio>\n#include<cstring>//便于使用strlen();\nusing namespace std;\nconst int maxn=100010;\nchar str[maxn];//我也不知道用const开数组的习惯从何而来，先这样吧\nint ans,ls,num;//ans即answer,ls即str字符串的长度,num就是个假栈顶,说明现在已经有num个括号未匹配成功\nint main(){\n\tscanf(\"%s\",&str);\n\tls=strlen(str);//记录str的长度，不要问我为什么不用STL\n\tfor(int i=0;i<ls;i++){\n\t\tif(str[i]=='(')  num++;//等待匹配右括号\n\t\telse if(str[i]==')'&&num==0){//num==0即为现在str[i]之前所有括号都能匹配，凭空出现个右括号,ans自加,并将该括号转为左括号等待匹配\n\t\t\tans++;num++;\n\t\t}else num--;//匹配成功后要减少一个待匹配的数量\n\t}\n\tans+=num/2;//还有num个左括号没有匹配,便将其中的一半转为右括号\n\tif(num%2!=0)  ans++;//如果num是单数,则有一个括号必须进行一次删除修改\n    //值得一提的是，楼上的dalao用的ans+=(num+1)/2;和此思路一致，也更加巧妙，我太弱所以没想到\n\tprintf(\"%d\",ans);\n\treturn 0;\n}", "step": ["Initialize a stack and a character array.", "Read a string as input and get its length.", "Traverse through the length of the string and push onto the stack if the character is an opening bracket and pop the stack if it is a closing bracket. If the stack is empty or the top element is not the corresponding opening bracket, push a closing bracket.", "Count the number of closing brackets and opening brackets left in the stack.", "If the count of both types of brackets in the stack is even, output their sum divided by 2. Otherwise, output their sum divided by 2 plus 2."], "nl_cn": "Bessie the cow is trying to type a balanced string of parentheses into her new laptop, but she is sufficiently clumsy (due to her large hooves) that she keeps mis-typing characters.  Please help her by computing the minimum number of characters in the string that one must reverse (e.g., changing a left parenthesis to a right parenthesis, or vice versa) so that the string would become balanced.\n\nThere are several ways to define what it means for a string of parentheses to be \"balanced\".  Perhaps the simplest definition is that there must be the same total number of ('s and )'s, and for any prefix of the string, there must be at least as many ('s as )'s.  For example, the following strings are all balanced:\n\n() \n(()) \n()(()()) \n\nwhile these are not:\n\n)( \n())( \n((()))) \n\n给出一个偶数长度的括号序列，问最少修改多少个括号可以使其平衡。\n", "test_cases": [{"input": "())( \n", "output": "2"}, {"input": "()(()()) \n", "output": "0"}, {"input": "(())() \n", "output": "0"}, {"input": "(()()) \n", "output": "0"}, {"input": "((())) \n", "output": "0"}, {"input": "((()(()))) \n", "output": "0"}, {"input": "()() \n", "output": "0"}, {"input": ")( \n", "output": "2"}, {"input": "() \n", "output": "0"}, {"input": ")(())( \n", "output": "2"}, {"input": "()()()\n", "output": "0"}, {"input": "((()())())\n", "output": "0"}, {"input": "()(()))(\n", "output": "2"}, {"input": "(())((()))\n", "output": "0"}, {"input": "()(((()))())\n", "output": "0"}, {"input": "()(())()(())\n", "output": "0"}, {"input": "())((()()))\n", "output": "2"}, {"input": "(())()((()))\n", "output": "0"}, {"input": "())(())(())(\n", "output": "2"}, {"input": "((()))(()())\n", "output": "0"}, {"input": "((())(()()))\n", "output": "0"}, {"input": "()(())\n", "output": "0"}, {"input": "(((()))) \n", "output": "0"}, {"input": "()((())) \n", "output": "0"}, {"input": "((() \n", "output": "1"}, {"input": "))(( \n", "output": "2"}, {"input": ")(() \n", "output": "2"}, {"input": ")))(( \n", "output": "4"}, {"input": "((()))()() \n", "output": "0"}, {"input": "((()(()))()) \n", "output": "0"}, {"input": "(()) \n", "output": "0"}, {"input": "()((())()()) \n", "output": "0"}, {"input": "((())()) \n", "output": "0"}, {"input": "((()()()() \n", "output": "1"}, {"input": "()()()() \n", "output": "0"}, {"input": "())()((()(() \n", "output": "3"}, {"input": "()()()()()() \n", "output": "0"}, {"input": "((((((())))))) \n", "output": "0"}, {"input": "())())(())) \n", "output": "3"}], "test": "#undef NDEBUG\n#include<assert.h>\nint main(){\n    assert(solution(\"())( \\n\") == \"2\");\n    assert(solution(\"()(()()) \\n\") == \"0\");\n    assert(solution(\"(())() \\n\") == \"0\");\n    assert(solution(\"(()()) \\n\") == \"0\");\n    assert(solution(\"((())) \\n\") == \"0\");\n    assert(solution(\"((()(()))) \\n\") == \"0\");\n    assert(solution(\"()() \\n\") == \"0\");\n    assert(solution(\")( \\n\") == \"2\");\n    assert(solution(\"() \\n\") == \"0\");\n    assert(solution(\")(())( \\n\") == \"2\");\n    assert(solution(\"()()()\\n\") == \"0\");\n    assert(solution(\"((()())())\\n\") == \"0\");\n    assert(solution(\"()(()))(\\n\") == \"2\");\n    assert(solution(\"(())((()))\\n\") == \"0\");\n    assert(solution(\"()(((()))())\\n\") == \"0\");\n    assert(solution(\"()(())()(())\\n\") == \"0\");\n    assert(solution(\"())((()()))\\n\") == \"2\");\n    assert(solution(\"(())()((()))\\n\") == \"0\");\n    assert(solution(\"())(())(())(\\n\") == \"2\");\n    assert(solution(\"((()))(()())\\n\") == \"0\");\n    assert(solution(\"((())(()()))\\n\") == \"0\");\n    assert(solution(\"()(())\\n\") == \"0\");\n    assert(solution(\"(((()))) \\n\") == \"0\");\n    assert(solution(\"()((())) \\n\") == \"0\");\n    assert(solution(\"((() \\n\") == \"1\");\n    assert(solution(\"))(( \\n\") == \"2\");\n    assert(solution(\")(() \\n\") == \"2\");\n    assert(solution(\")))(( \\n\") == \"4\");\n    assert(solution(\"((()))()() \\n\") == \"0\");\n    assert(solution(\"((()(()))()) \\n\") == \"0\");\n    assert(solution(\"(()) \\n\") == \"0\");\n    assert(solution(\"()((())()()) \\n\") == \"0\");\n    assert(solution(\"((())()) \\n\") == \"0\");\n    assert(solution(\"((()()()() \\n\") == \"1\");\n    assert(solution(\"()()()() \\n\") == \"0\");\n    assert(solution(\"())()((()(() \\n\") == \"3\");\n    assert(solution(\"()()()()()() \\n\") == \"0\");\n    assert(solution(\"((((((())))))) \\n\") == \"0\");\n    assert(solution(\"())())(())) \\n\") == \"3\");\n    return 0; \n}", "prompt": "/*Bessie the cow is trying to input a balanced parentheses string on her new laptop, but she is clumsy due to her big hooves and often types the wrong characters. Help her calculate the minimum number of characters that need to be flipped (e.g. change a left parenthesis to a right parenthesis or vice versa) to make the string balanced.\n\nThere are several ways to define a set of parentheses as \"balanced\". Perhaps the simplest definition is that the total number of left and right parentheses must be equal, and for any prefix of the string, the number of left parentheses must not be less than the number of right parentheses. For example, the following strings are all balanced:\n\n()\n(())\n()(()())\n\nWhile the following strings are unbalanced:\n\n)(\n())(\n((())))\n\nGiven a parentheses sequence of even length, what is the minimum number of modifications needed to make it balanced?\n\ninput_format:\n\\* Line 1: A string of parentheses with a length that is at most 100,000 characters and is always an even number.\n\noutput_format:\n\\* Line 1: A single integer giving the minimum number of parentheses that must be toggled to convert the string into a balanced string.\n*/\n\n#include<sstream>\n#include<stdlib.h>\n#include<algorithm>\n#include<math.h>\n#include<stdio.h>\n#include<vector>\n#include<string>\n#include<climits>\n#include<cstring>\n#include<iostream>\nusing namespace std;\n\n             \nstring solution(string std_in){\n    istringstream iss(std_in);\n             ", "constraints": "The last parenthesis must be toggled, and so must one of the two middle right parentheses.\n\n", "samples": [["())( \n", "2 \n"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}}
{"task_id": "P2036", "title": "[COCI2008-2009#2] PERKET", "difficulty": "challenge", "nl": "Perket is a popular delicacy. To make a good Perket, the chef must carefully choose ingredients to obtain the most comprehensive flavor while maintaining the traditional taste. There are $n$ ingredients available, and for each one, we know their respective acidity $s$ and bitterness $b$. When we add ingredients, the total acidity is the product of the acidity of each ingredient, and the total bitterness is the sum of the bitterness of each ingredient.\n\nAs we all know, delicacies should have a moderate taste. Therefore, we hope to select ingredients to minimize the absolute difference between acidity and bitterness.\n\nIn addition, we must add at least one ingredient because there is no food that uses water as an ingredient.", "code": "#include<iostream>\n#include<algorithm>\n#include<cstdio>\n#include<cstring>\n#include<cmath>\n#define ll long long\nusing namespace std;\nint N,s[12],b[12],mi=2000000001;\nint main()\n{\n\tscanf(\"%d\",&N);\n\tfor(int i=0;i<N;i++)\n\t\tscanf(\"%d %d\",&s[i],&b[i]);\n\tfor(int i=1;i<(1<<N);i++)//因为至少有一种配料，所以从1开始\n\t{\n\t\tint S=1,B=0;//注意总酸度初始值为1！\n\t\tfor(int j=0;j<N;j++)\n\t\t\tif((i>>j)&1)//判断是否为1\n\t\t\t{\n\t\t\t\tS*=s[j];\n\t\t\t\tB+=b[j];\n\t\t\t}\n\t\tmi=min(mi,abs(S-B));//别忘了绝对值\n\t}\n\tprintf(\"%d\",mi);\n\treturn 0;\n}", "step": ["Initialize variables and arrays.", "Define a function that recursively calculates the minimum difference.", "If the recursion ends, compare the current difference with the minimum difference found so far and update it if the current difference is smaller.", "Call the function initially with parameters 1, 1, and 0.", "Read input values for the arrays a and b.", "Print the minimum difference found."], "nl_cn": "Perket 是一种流行的美食。为了做好 Perket，厨师必须谨慎选择食材，以在保持传统风味的同时尽可能获得最全面的味道。你有 $n$ 种可支配的配料。对于每一种配料，我们知道它们各自的酸度 $s$ 和苦度 $b$。当我们添加配料时，总的酸度为每一种配料的酸度总乘积；总的苦度为每一种配料的苦度的总和。\n\n众所周知，美食应该做到口感适中，所以我们希望选取配料，以使得酸度和苦度的绝对差最小。\n\n另外，我们必须添加至少一种配料，因为没有任何食物以水为配料的。", "test_cases": [{"input": "1\n3 10", "output": "7"}, {"input": "2\n3 8\n5 8", "output": "1"}, {"input": "4\n1 7\n2 6\n3 8\n4 9", "output": "1"}, {"input": "2\n5 3\n4 7\n", "output": "2"}, {"input": "2\n1 4\n5 6\n", "output": "1"}, {"input": "3\n3 5\n2 7\n6 8\n", "output": "2"}, {"input": "5\n8 2\n6 5\n3 4\n9 7\n2 1\n", "output": "1"}, {"input": "4\n1 2\n7 4\n3 6\n5 8\n", "output": "1"}, {"input": "4\n5 7\n2 4\n6 9\n3 1\n", "output": "1"}, {"input": "1\n1 1", "output": "0"}, {"input": "2\n1 1\n2 2", "output": "0"}, {"input": "1\n0 0\n", "output": "0"}, {"input": "3\n2 4\n3 6\n4 8\n", "output": "2"}, {"input": "5\n5 1\n6 2\n7 3\n8 4\n9 5\n", "output": "4"}, {"input": "2\n3 2\n4 5\n", "output": "1"}, {"input": "4\n1 1\n2 2\n3 3\n4 4\n", "output": "0"}, {"input": "3\n4 5\n5 5\n6 4\n", "output": "0"}, {"input": "5\n2 3\n4 5\n6 1\n8 6\n10 2\n", "output": "0"}, {"input": "4\n3 3\n6 6\n9 1\n12 4\n", "output": "0"}, {"input": "5\n1 1\n2 2\n3 3\n4 4\n5 5\n", "output": "0"}, {"input": "4\n2 2\n3 3\n4 4\n5 5\n", "output": "0"}, {"input": "4\n5 5\n4 4\n3 3\n2 2\n", "output": "0"}, {"input": "7\n1 1\n2 2\n3 3\n4 4\n5 5\n6 6\n7 7\n", "output": "0"}, {"input": "7\n7 7\n6 6\n5 5\n4 4\n3 3\n2 2\n1 1\n", "output": "0"}, {"input": "10\n2 1\n4 3\n6 5\n8 7\n10 9\n12 11\n14 13\n16 15\n18 17\n20 19\n", "output": "1"}, {"input": "2\n100 100\n100 200\n", "output": "0"}, {"input": "1\n10 10\n", "output": "0"}, {"input": "2\n1 1\n100 100\n", "output": "0"}], "test": "#undef NDEBUG\n#include<assert.h>\nint main(){\n    assert(solution(\"1\\n3 10\") == \"7\");\n    assert(solution(\"2\\n3 8\\n5 8\") == \"1\");\n    assert(solution(\"4\\n1 7\\n2 6\\n3 8\\n4 9\") == \"1\");\n    assert(solution(\"2\\n5 3\\n4 7\\n\") == \"2\");\n    assert(solution(\"2\\n1 4\\n5 6\\n\") == \"1\");\n    assert(solution(\"3\\n3 5\\n2 7\\n6 8\\n\") == \"2\");\n    assert(solution(\"5\\n8 2\\n6 5\\n3 4\\n9 7\\n2 1\\n\") == \"1\");\n    assert(solution(\"4\\n1 2\\n7 4\\n3 6\\n5 8\\n\") == \"1\");\n    assert(solution(\"4\\n5 7\\n2 4\\n6 9\\n3 1\\n\") == \"1\");\n    assert(solution(\"1\\n1 1\") == \"0\");\n    assert(solution(\"2\\n1 1\\n2 2\") == \"0\");\n    assert(solution(\"1\\n0 0\\n\") == \"0\");\n    assert(solution(\"3\\n2 4\\n3 6\\n4 8\\n\") == \"2\");\n    assert(solution(\"5\\n5 1\\n6 2\\n7 3\\n8 4\\n9 5\\n\") == \"4\");\n    assert(solution(\"2\\n3 2\\n4 5\\n\") == \"1\");\n    assert(solution(\"4\\n1 1\\n2 2\\n3 3\\n4 4\\n\") == \"0\");\n    assert(solution(\"3\\n4 5\\n5 5\\n6 4\\n\") == \"0\");\n    assert(solution(\"5\\n2 3\\n4 5\\n6 1\\n8 6\\n10 2\\n\") == \"0\");\n    assert(solution(\"4\\n3 3\\n6 6\\n9 1\\n12 4\\n\") == \"0\");\n    assert(solution(\"5\\n1 1\\n2 2\\n3 3\\n4 4\\n5 5\\n\") == \"0\");\n    assert(solution(\"4\\n2 2\\n3 3\\n4 4\\n5 5\\n\") == \"0\");\n    assert(solution(\"4\\n5 5\\n4 4\\n3 3\\n2 2\\n\") == \"0\");\n    assert(solution(\"7\\n1 1\\n2 2\\n3 3\\n4 4\\n5 5\\n6 6\\n7 7\\n\") == \"0\");\n    assert(solution(\"7\\n7 7\\n6 6\\n5 5\\n4 4\\n3 3\\n2 2\\n1 1\\n\") == \"0\");\n    assert(solution(\"10\\n2 1\\n4 3\\n6 5\\n8 7\\n10 9\\n12 11\\n14 13\\n16 15\\n18 17\\n20 19\\n\") == \"1\");\n    assert(solution(\"2\\n100 100\\n100 200\\n\") == \"0\");\n    assert(solution(\"1\\n10 10\\n\") == \"0\");\n    assert(solution(\"2\\n1 1\\n100 100\\n\") == \"0\");\n    return 0; \n}", "prompt": "/*Perket is a popular delicacy. To make a good Perket, the chef must carefully choose ingredients to obtain the most comprehensive flavor while maintaining the traditional taste. There are $n$ ingredients available, and for each one, we know their respective acidity $s$ and bitterness $b$. When we add ingredients, the total acidity is the product of the acidity of each ingredient, and the total bitterness is the sum of the bitterness of each ingredient.\n\nAs we all know, delicacies should have a moderate taste. Therefore, we hope to select ingredients to minimize the absolute difference between acidity and bitterness.\n\nIn addition, we must add at least one ingredient because there is no food that uses water as an ingredient.\n\ninput_format:\nThe first line is an integer $n$, indicating the number of ingredients available.\n\nThe next $n$line, each $2$integer $s_i$and $b_i$, indicates the acidity and bitterness of the $i$ingredient.\n\noutput_format:\nOne line, an integer, represents the smallest absolute difference between the possible total acidity and total bitterness.\n*/\n\n#include<sstream>\n#include<stdlib.h>\n#include<algorithm>\n#include<math.h>\n#include<stdio.h>\n#include<vector>\n#include<string>\n#include<climits>\n#include<cstring>\n#include<iostream>\nusing namespace std;\n\n             \nstring solution(string std_in){\n    istringstream iss(std_in);\n             ", "constraints": "#### 数据规模与约定\n对于 $100\\%$ 的数据，有 $1 \\leq n \\leq 10$，且将所有可用食材全部使用产生的总酸度和总苦度小于 $1 \\times 10^9$，酸度和苦度不同时为 $1$ 和 $0$。\n#### 说明\n- 本题满分 $70$ 分。\n- 题目译自 [COCI2008-2009](https://hsin.hr/coci/archive/2008_2009/) [CONTEST #2](https://hsin.hr/coci/archive/2008_2009/contest2_tasks.pdf) PERKET，译者 @[mnesia](https://www.luogu.com.cn/user/115711)。", "samples": [["1\n3 10", "7"], ["2\n3 8\n5 8", "1"], ["4\n1 7\n2 6\n3 8\n4 9", "1"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [32768, 32768, 32768, 32768, 32768, 32768, 32768, 32768]}}
{"task_id": "P1076", "title": "[NOIP2012 普及组] 寻宝", "difficulty": "challenge", "nl": "The top floor of a legendary treasure tower is said to hold a tempting treasure. After all sorts of hardships, Xiao Ming finally found this treasure tower. A wooden board stands at the entrance of the tower, on which are written several large characters: Treasure Hunt Manual. The manual reads as follows:\n\nThe treasure tower has a total of $N+1$ floors, with the top floor holding the treasure. In addition to the top floor, the treasure tower has $N$ floors, each with $M$ rooms arranged in a circular pattern and numbered counterclockwise from $0$ to $M-1$. Some of the rooms have stairs leading to the floor above, and the staircase design may be different for each floor. Each room has a sign with a number $x$ indicating that starting from this room and going counterclockwise, you need to select the $x$-th room with stairs (assuming the room number is $k$), and go upstairs from that room. For example, if the sign in the current room reads $2$, you start counting counterclockwise and select the second room with stairs to go upstairs. If the current room itself has stairs leading to the upper floor, it is considered as the first room with stairs.\n\nIn bold red font at the end of the Treasure Hunt Manual, it is written: \"Treasure Hunt Notice: the sum of the numbers on each floor's first room signpost (i.e., the number on the signpost in the first entered room on each floor) can be used as the key to open the treasure chest.\"\n\nPlease help Xiao Ming calculate the key to open the treasure chest.", "code": "#include<iostream>\n#include<fstream>\n#include<cstdio>\n#include<algorithm>\n#include<cmath>\n#include<string>\nusing namespace std;\nint pd[10002][202],a[10002][202];\nint main()\n{\n\t//freopen(\"treasure.in\",\"r\",stdin);\n\t//freopen(\"treasure.out\",\"w\",stdout);\n\tint n,m,x,i,j,ans=0,l=0;\n\tscanf(\"%d%d\",&n,&m);//以下的读入不说了\n\tfor(i=1;i<=n;i++)\n\t{\n\t\tl=0;\n\t\tfor(j=0;j<m;j++)\n\t\t{\n\t\t\tscanf(\"%d%d\",&pd[i][j],&a[i][j]);\n\t\t\tif(pd[i][j]==1) l++;//记录该层楼有楼梯的门数\n\t\t}\n\t\tpd[i][m]=l;\n\t}\n\tscanf(\"%d\",&x);\n\ti=1;\n\twhile(i<=n)\n\t{\n\t    ans+=a[i][x];\n\t\tans%=20123;//根据规律，边加边模，值不变，不用long long\n\t    int k=0;\n\t\tfor(j=x;;j++)\n\t\t{\n\t\t\tif(j==m) j=0;\n\t\t\tif(pd[i][j]==1) k++;\n\t\t\tif(k==(a[i][x]-1)%pd[i][m]+1) break;//最关键的停止条件，循环找对，取模，都靠它。\n\t\t}\n\t    x=j;\n\t\ti++;\n\t}\n\tprintf(\"%d\",ans);//小小的输出优化~\n\treturn 0;\n}", "step": ["Initialize some variables and input arrays.", "Iterate through the input arrays, keeping track of the value of l in the process.", "Calculate the value of k and output the final values.", "Return 0 to end the function."], "nl_cn": "传说很遥远的藏宝楼顶层藏着诱人的宝藏。小明历尽千辛万苦终于找到传说中的这个藏宝楼，藏宝楼的门口竖着一个木板，上面写有几个大字：寻宝说明书。说明书的内容如下：\n\n藏宝楼共有$N+1$层，最上面一层是顶层，顶层有一个房间里面藏着宝藏。除了顶层外，藏宝楼另有$N$层，每层$M$个房间，这$M$个房间围成一圈并按逆时针方向依次编号为$0,…,M-1$。其中一些房间有通往上一层的楼梯，每层楼的楼梯设计可能不同。每个房间里有一个指示牌，指示牌上有一个数字$x$，表示从这个房间开始按逆时针方向选择第$x$个有楼梯的房间（假定该房间的编号为k），从该房间上楼，上楼后到达上一层的$k$号房间。比如当前房间的指示牌上写着$2$，则按逆时针方向开始尝试，找到第$2$个有楼梯的房间，从该房间上楼。如果当前房间本身就有楼梯通向上层，该房间作为第一个有楼梯的房间。\n\n寻宝说明书的最后用红色大号字体写着：“寻宝须知：帮助你找到每层上楼房间的指示牌上的数字（即每层第一个进入的房间内指示牌上的数字）总和为打开宝箱的密钥”。\n\n请帮助小明算出这个打开宝箱的密钥。\n", "test_cases": [{"input": "2 3\n1 2\n0 3\n1 4\n0 1\n1 5\n1 2\n1\n", "output": "5"}, {"input": "3 5\n1 2\n0 3\n1 4\n0 5\n0 6\n1 7\n0 8\n0 9\n0 10\n0 11\n0 12\n1 13\n0 14\n1 15\n0 16\n0 17\n0 18\n1 19\n1 20\n1 21\n0 22\n0 23\n0 24\n0 25\n2\n", "output": "23"}, {"input": "3 3\n1 3\n0 2\n0 1\n1 2\n1 1\n0 7\n1 1\n0 3\n0 5\n0 5\n1 3\n1\n", "output": "8"}, {"input": "1 2\n1 1\n0 9\n0 6\n0 10\n0 7\n1\n", "output": "1"}, {"input": "3 2\n1 2\n0 3\n0 4\n1 1\n1 6\n1 2\n1 3\n2 5\n0 2\n0 3\n0 4\n0 5\n2\n", "output": "9"}, {"input": "2 2\n1 2\n0 3\n1 4\n1 5\n0 2\n0 4\n1\n", "output": "6"}, {"input": "2 3\n1 2\n0 3\n1 5\n0 2\n0 4\n1 6\n0 1\n1\n", "output": "8"}], "test": "#undef NDEBUG\n#include<assert.h>\nint main(){\n    assert(solution(\"2 3\\n1 2\\n0 3\\n1 4\\n0 1\\n1 5\\n1 2\\n1\\n\") == \"5\");\n    assert(solution(\"3 5\\n1 2\\n0 3\\n1 4\\n0 5\\n0 6\\n1 7\\n0 8\\n0 9\\n0 10\\n0 11\\n0 12\\n1 13\\n0 14\\n1 15\\n0 16\\n0 17\\n0 18\\n1 19\\n1 20\\n1 21\\n0 22\\n0 23\\n0 24\\n0 25\\n2\\n\") == \"23\");\n    assert(solution(\"3 3\\n1 3\\n0 2\\n0 1\\n1 2\\n1 1\\n0 7\\n1 1\\n0 3\\n0 5\\n0 5\\n1 3\\n1\\n\") == \"8\");\n    assert(solution(\"1 2\\n1 1\\n0 9\\n0 6\\n0 10\\n0 7\\n1\\n\") == \"1\");\n    assert(solution(\"3 2\\n1 2\\n0 3\\n0 4\\n1 1\\n1 6\\n1 2\\n1 3\\n2 5\\n0 2\\n0 3\\n0 4\\n0 5\\n2\\n\") == \"9\");\n    assert(solution(\"2 2\\n1 2\\n0 3\\n1 4\\n1 5\\n0 2\\n0 4\\n1\\n\") == \"6\");\n    assert(solution(\"2 3\\n1 2\\n0 3\\n1 5\\n0 2\\n0 4\\n1 6\\n0 1\\n1\\n\") == \"8\");\n    return 0; \n}", "prompt": "/*The top floor of a legendary treasure tower is said to hold a tempting treasure. After all sorts of hardships, Xiao Ming finally found this treasure tower. A wooden board stands at the entrance of the tower, on which are written several large characters: Treasure Hunt Manual. The manual reads as follows:\n\nThe treasure tower has a total of $N+1$ floors, with the top floor holding the treasure. In addition to the top floor, the treasure tower has $N$ floors, each with $M$ rooms arranged in a circular pattern and numbered counterclockwise from $0$ to $M-1$. Some of the rooms have stairs leading to the floor above, and the staircase design may be different for each floor. Each room has a sign with a number $x$ indicating that starting from this room and going counterclockwise, you need to select the $x$-th room with stairs (assuming the room number is $k$), and go upstairs from that room. For example, if the sign in the current room reads $2$, you start counting counterclockwise and select the second room with stairs to go upstairs. If the current room itself has stairs leading to the upper floor, it is considered as the first room with stairs.\n\nIn bold red font at the end of the Treasure Hunt Manual, it is written: \"Treasure Hunt Notice: the sum of the numbers on each floor's first room signpost (i.e., the number on the signpost in the first entered room on each floor) can be used as the key to open the treasure chest.\"\n\nPlease help Xiao Ming calculate the key to open the treasure chest.\n\ninput_format:\nThe first line consists of two integers, $N$ and $M$, separated by a space. $N$ represents the total number of floors in the treasure building, excluding the top floor, and $M$ represents the number of rooms per floor, excluding the top floor.\n\nThe following $N \\times M$ lines each contain two integers separated by a space. Each line describes the situation in a room. The $(i-1) \\times M+j$ line represents the situation in the $j-1$ room on the $i$th floor ($i=1,2,…, N$; $j=1,2,…,M$). The first integer indicates whether there is a staircase in the room leading to the floor above ($0$ for no, $1$ for yes), and the second integer indicates the number on the signboard. Note that if there is a staircase from room $j$ to the floor above, the room that it leads to must also be room $j$.\n\nThe last line contains a single integer, indicating the room number where Xiao Ming enters from on the ground floor of the treasure building (Note: Room numbers start from $0$).\n\noutput_format:\nAn integer, indicating the key to open the treasure chest, this number may be large, please output the result of $20123$.\n*/\n\n#include<sstream>\n#include<stdlib.h>\n#include<algorithm>\n#include<math.h>\n#include<stdio.h>\n#include<vector>\n#include<string>\n#include<climits>\n#include<cstring>\n#include<iostream>\nusing namespace std;\n\n             \nstring solution(string std_in){\n    istringstream iss(std_in);\n             ", "constraints": "【数据范围】\n\n对于 $50\\%$ 数据，有$0<N≤1000,0<x≤10^4$；  \n对于 $100\\%$ 数据，有$0<N≤10000,0<M≤100,0<x≤10^6$。\n\nNOIP 2012 普及组 第二题", "samples": [["2 3\n1 2\n0 3\n1 4\n0 1\n1 5\n1 2\n1\n", "5"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}}
{"task_id": "P1572", "title": "计算分数", "difficulty": "challenge", "nl": "Csh is locked at home to do fraction calculation problems by his mother, but obviously he doesn't want to sit through so many complicated computations. Besides, Xxq is waiting for him outside to watch a movie together. In order to be able to go to the movies with Xxq as soon as possible, he hands over the remaining calculation problems to you. Can you help him solve the problem?", "code": "#include <bits/stdc++.h>//万能头文件\nusing namespace std;\nstruct fs\n{\n    long long fm,fz;\n};\nfs yf(fs a)\n{\n    long long m=__gcd(a.fm,a.fz);\n    a.fm/=m;\n    a.fz/=m;\n    return a;\n}\nfs jia(fs x,fs y)\n{\n    long long z=x.fm*y.fm;\n    x.fz*=y.fm;\n    y.fz*=x.fm;\n    x.fm=z;\n    y.fm=z;\n    fs answer;\n    answer.fz=x.fz+y.fz;\n    answer.fm=x.fm;\n    return yf(answer);\n}\nfs jian(fs x,fs y)\n{\n    long long z=x.fm*y.fm;\n    x.fz*=y.fm;\n    y.fz*=x.fm;\n    x.fm=z;\n    y.fm=z;\n    fs answer;\n    answer.fz=x.fz-y.fz;\n    answer.fm=x.fm;\n    return yf(answer);//约分是个好习惯\n}\nint main()\n{\n    fs a,b;\n    char ysf;\n    scanf(\"%lld/%lld\",&a.fz,&a.fm);\n    a=yf(a);\n    cin>>ysf;\n    while (scanf(\"%lld/%lld\",&b.fz,&b.fm)!=EOF)\n    {\n        if (ysf==EOF)break;\n        else if (ysf=='+'){a=jia(a,b);}\n        else if (ysf=='-'){a=jian(a,b);}\n        cin>>ysf;\n    }\n    if (a.fm<0&&a.fz>0)\n    {\n        a.fm=abs(a.fm);\n        a.fz-=a.fz*2;\n    }\n    if (a.fm==1)cout<<a.fz;\n    else cout<<a.fz<<'/'<<a.fm;\n    return 0;\n}", "step": ["Initialize variables for the fractions.", "Use a loop to input fractions and calculate their sum.", "Calculate the greatest common divisor using gcd function.", "Simplify the fractions and calculate the sum.", "If necessary, simplify the final fraction.", "Print the final sum in the simplest form."], "nl_cn": "Csh 被老妈关在家里做分数计算题，但显然他不愿意坐这么多复杂的计算。况且在家门口还有 Xxq 在等着他去一起看电影。为了尽快地能去陪 Xxq 看电影，他把剩下的计算题交给了你，你能帮他解决问题吗？\n", "test_cases": [{"input": "2/1+1/3-1/4", "output": "25/12"}, {"input": "3/4+1/2\n", "output": "5/4"}, {"input": "-3/4+1/2\n", "output": "-1/4"}, {"input": "1/3+2/5\n", "output": "11/15"}, {"input": "-4/7+5/7\n", "output": "1/7"}, {"input": "2/3-1/3\n", "output": "1/3"}, {"input": "3/5-1/2\n", "output": "1/10"}, {"input": "9/8+7/4\n", "output": "23/8"}, {"input": "-3/7-2/7\n", "output": "-5/7"}, {"input": "3/4-1/2\n", "output": "1/4"}, {"input": "3/4-1/4\n", "output": "1/2"}, {"input": "-5/7-1/2\n", "output": "-17/14"}, {"input": "1/2+1/3+1/4", "output": "13/12"}, {"input": "-1/2-1/3-1/4", "output": "-13/12"}, {"input": "1/2+1/4\n", "output": "3/4"}, {"input": "3/5+2/5\n", "output": "1"}, {"input": "9/8+2/3\n", "output": "43/24"}, {"input": "1/1+1/1+1/1\n", "output": "3"}, {"input": "0/1+1/1+2/1\n", "output": "3"}, {"input": "0/1+0/1+1/1+2/1\n", "output": "3"}, {"input": "1/2-1/4\n", "output": "1/4"}, {"input": "3/5-2/5\n", "output": "1/5"}, {"input": "9/8-2/3\n", "output": "11/24"}, {"input": "1/1-1/1-1/1\n", "output": "-1"}, {"input": "0/1-1/1-2/1\n", "output": "-3"}, {"input": "0/1-0/1-1/1-2/1\n", "output": "-3"}, {"input": "3/2+1/2-1/4\n", "output": "7/4"}, {"input": "4/1+2/1-6/1\n", "output": "0"}, {"input": "1/1+2/3\n", "output": "5/3"}, {"input": "4/5-1/2\n", "output": "3/10"}, {"input": "1/1+1/2+1/3+1/4\n", "output": "25/12"}], "test": "#undef NDEBUG\n#include<assert.h>\nint main(){\n    assert(solution(\"2/1+1/3-1/4\") == \"25/12\");\n    assert(solution(\"3/4+1/2\\n\") == \"5/4\");\n    assert(solution(\"-3/4+1/2\\n\") == \"-1/4\");\n    assert(solution(\"1/3+2/5\\n\") == \"11/15\");\n    assert(solution(\"-4/7+5/7\\n\") == \"1/7\");\n    assert(solution(\"2/3-1/3\\n\") == \"1/3\");\n    assert(solution(\"3/5-1/2\\n\") == \"1/10\");\n    assert(solution(\"9/8+7/4\\n\") == \"23/8\");\n    assert(solution(\"-3/7-2/7\\n\") == \"-5/7\");\n    assert(solution(\"3/4-1/2\\n\") == \"1/4\");\n    assert(solution(\"3/4-1/4\\n\") == \"1/2\");\n    assert(solution(\"-5/7-1/2\\n\") == \"-17/14\");\n    assert(solution(\"1/2+1/3+1/4\") == \"13/12\");\n    assert(solution(\"-1/2-1/3-1/4\") == \"-13/12\");\n    assert(solution(\"1/2+1/4\\n\") == \"3/4\");\n    assert(solution(\"3/5+2/5\\n\") == \"1\");\n    assert(solution(\"9/8+2/3\\n\") == \"43/24\");\n    assert(solution(\"1/1+1/1+1/1\\n\") == \"3\");\n    assert(solution(\"0/1+1/1+2/1\\n\") == \"3\");\n    assert(solution(\"0/1+0/1+1/1+2/1\\n\") == \"3\");\n    assert(solution(\"1/2-1/4\\n\") == \"1/4\");\n    assert(solution(\"3/5-2/5\\n\") == \"1/5\");\n    assert(solution(\"9/8-2/3\\n\") == \"11/24\");\n    assert(solution(\"1/1-1/1-1/1\\n\") == \"-1\");\n    assert(solution(\"0/1-1/1-2/1\\n\") == \"-3\");\n    assert(solution(\"0/1-0/1-1/1-2/1\\n\") == \"-3\");\n    assert(solution(\"3/2+1/2-1/4\\n\") == \"7/4\");\n    assert(solution(\"4/1+2/1-6/1\\n\") == \"0\");\n    assert(solution(\"1/1+2/3\\n\") == \"5/3\");\n    assert(solution(\"4/5-1/2\\n\") == \"3/10\");\n    assert(solution(\"1/1+1/2+1/3+1/4\\n\") == \"25/12\");\n    return 0; \n}", "prompt": "/*Csh is locked at home to do fraction calculation problems by his mother, but obviously he doesn't want to sit through so many complicated computations. Besides, Xxq is waiting for him outside to watch a movie together. In order to be able to go to the movies with Xxq as soon as possible, he hands over the remaining calculation problems to you. Can you help him solve the problem?\n\ninput_format:\nEnter a line to calculate a fraction.\n\nThe calculation formula contains only numbers, '+', '-', '/'. Where '/' is the fraction line, the left side of the fraction line is the numerator, the right side is the denominator. Enter data to ensure that there are no complex fractions. If the first term of the input formula is positive, there will be no prefix '+' sign; If it is negative, there is a prefix '-'.\n\nAll integers appear as fractions.\n\noutput_format:\nOutput a line for the final result of the calculation (expressed in the simplest fraction or integer).\n\nEnsure that all numbers appearing in the answer (numerator and denominator if the answer is a fraction) are within the representation range of 64-bit signed integers.\n*/\n\n#include<sstream>\n#include<stdlib.h>\n#include<algorithm>\n#include<math.h>\n#include<stdio.h>\n#include<vector>\n#include<string>\n#include<climits>\n#include<cstring>\n#include<iostream>\nusing namespace std;\n\n             \nstring solution(string std_in){\n    istringstream iss(std_in);\n             ", "constraints": "### 数据范围及约定\n\n对于所有测试点，输入计算式长度在 $100$ 以内，分子、分母在 $1000$ 以内。同时保证，直接从前往后直接计算分数的和或者差，然后立刻化简，这么做的中间结果不会超过 int 的范围。\n\n注意输入的分数不一定是最简分数。\n\n\n------------\n2024/2/13 添加 2 组 hack 数据。", "samples": [["2/1+1/3-1/4", "25/12"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288]}}
{"task_id": "P2733", "title": "[USACO3.3]家的范围 Home on the Range", "difficulty": "advanced", "nl": "Farmer John needs to count the number of square pastures (at least 2x2) where he can graze his cows. These pastures are larger squares where none of the points are destroyed, that is, all points are \"1\". \n\nYour job is to count all the different square grazing areas (>=2x2) in the provided data set. Of course, the grazing areas may overlap.", "code": "#include <iostream>\n#include <cstdio>\n#include <cmath>\n#include <algorithm>\n#include <cstring>\nusing namespace std;\nconst int MAX=300;\nconst int INF=0X3F3F3F3F;\nint n;\nchar map[MAX][MAX];\nint num[MAX*MAX];//用桶排进行存储，num[i]表示第i大的矩阵有num[i]个 \nint f[MAX][MAX];//表示以map[i][j]为右下角的矩阵的最大值 \nint main()\n{\n cin>>n;\n for(int i=0;i<n;i++)\n cin>>map[i];\n /*---考虑边界情况---*/ \n for(int i=0;i<n;i++)\n f[i][0]=(map[i][0]=='1');\n for(int j=0;j<n;j++)\n f[0][j]=(map[0][j]=='1');\n /*---全矩阵扫进行DP---*/\n for(int i=1;i<n;i++)\n \tfor(int j=1;j<n;j++)\n \tif(map[i][j]=='1')//当前这个点不是障碍\n \t{\n \t\tf[i][j]=min(min(f[i-1][j],f[i][j-1]),f[i-1][j-1])+1;\n \t\tnum[f[i][j]]++;\n \t}\n /*---统计全部个数（实现方式有点像斐波那契数列）---*/\n for(int i=n;i>0;i--)\n num[i-1]+=num[i];\n /*---输出结束---*/\n for(int i=2;i<=n;i++)\n if(num[i])\n cout<<i<<' '<<num[i]<<endl;\t\t \n}", "step": ["Read in the size of the matrix.", "Initialize arrays for the prefix sum and answer.", "Read in the matrix and calculate the prefix sum.", "Loop through all possible square sizes and positions, checking if the sum of the corresponding elements in the prefix sum array equals the area of the square.", "Keep track of the count of each square size.", "Print the count of each square size greater than 1."], "nl_cn": "农民约翰需要统计那些可以放牧奶牛的正方形牧场(至少是2x2的,在这些较大的正方形中没有一个点是被破坏的，也就是说，所有的点都是“1”)。\n\n你的工作要在被供应的数据组里面统计所有不同的正方形放牧区域(>=2x2)的个数。当然，放牧区域可能是重叠。\n", "test_cases": [{"input": "6\n101111\n001111\n111111\n001111\n101101\n111001", "output": "2 10\n3 4\n4 1"}, {"input": "5\n10001\n01010\n00101\n01010\n10001\n", "output": ""}], "test": "#undef NDEBUG\n#include<assert.h>\nint main(){\n    assert(solution(\"6\\n101111\\n001111\\n111111\\n001111\\n101101\\n111001\") == \"2 10\\n3 4\\n4 1\");\n    assert(solution(\"5\\n10001\\n01010\\n00101\\n01010\\n10001\\n\") == \"\");\n    return 0; \n}", "prompt": "/*Farmer John needs to count the number of square pastures (at least 2x2) where he can graze his cows. These pastures are larger squares where none of the points are destroyed, that is, all points are \"1\". \n\nYour job is to count all the different square grazing areas (>=2x2) in the provided data set. Of course, the grazing areas may overlap.\n\ninput_format:\nLine 1: N, the length of the grazing area.\n\nLines 2 to n+1: N characters separated by spaces. 0 represents \"that section is destroyed\"; 1 represents \"ready to be eaten\".\n\noutput_format:\nOutputs the length and number of sides of those existing squares, a kind of row.\n*/\n\n#include<sstream>\n#include<stdlib.h>\n#include<algorithm>\n#include<math.h>\n#include<stdio.h>\n#include<vector>\n#include<string>\n#include<climits>\n#include<cstring>\n#include<iostream>\nusing namespace std;\n\n             \nstring solution(string std_in){\n    istringstream iss(std_in);\n             ", "constraints": "题目翻译来自NOCOW。\n\nUSACO Training Section 3.3\n", "samples": [["6\n101111\n001111\n111111\n001111\n101101\n111001", "2 10\n3 4\n4 1"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000]}}
{"task_id": "P1085", "title": "[NOIP2004 普及组] 不高兴的津津", "difficulty": "basic", "nl": "Jinjin has started junior high school. Jinjin's mother thinks that she should study harder, so Jinjin not only goes to school, but also attends various subject review classes that her mother has signed up for her. In addition, her mother also sends her to learn recitation, dance, and piano every week. However, if Jinjin has more than eight hours of classes in a day, she will be unhappy, and the longer she attends, the more unhappy she will become. Assuming that Jinjin will not be unhappy for other reasons, and her unhappiness will not last until the next day, please help to check Jinjin's schedule for next week to see if she will be unhappy. If so, on which day will she be the most unhappy.", "code": "#include <stdio.h>\n#include <stdlib.h>\n\nint main() {\n    int a,b;//学校学习小时，课外学习小时\n    int max_time = 0;//当前最大学习总时间\n    int answer = 0;//答案\n    for(int i = 0;i < 7;++i) {//读入七组数据并处理\n        scanf(\"%d %d\",&a,&b);//读入第i+1天的学校学习小时与课外学习小时\n        if(a + b > max_time && a + b > 8) {//如果总时间>8并且当前总时间比之前找到的最大总时间大\n            answer = i + 1;//更新答案为当前星期\n            max_time = a + b;//更新最大值\n        }\n    }\n    printf(\"%d\",answer);//打印答案\n    return 0;\n}", "step": ["Declare and initialize variables for integers and days.", "Use a for loop to receive two integers per day over seven days.", "Calculate the sum of the integers for each day.", "If the sum is greater than the current maximum and greater than 8, update the maximum and set the day to the current iteration.", "Print out the day with the highest sum.", "Exit the program."], "nl_cn": "津津上初中了。妈妈认为津津应该更加用功学习，所以津津除了上学之外，还要参加妈妈为她报名的各科复习班。另外每周妈妈还会送她去学习朗诵、舞蹈和钢琴。但是津津如果一天上课超过八个小时就会不高兴，而且上得越久就会越不高兴。假设津津不会因为其它事不高兴，并且她的不高兴不会持续到第二天。请你帮忙检查一下津津下周的日程安排，看看下周她会不会不高兴；如果会的话，哪天最不高兴。\n", "test_cases": [{"input": "5 3\n6 2\n7 2\n5 3\n5 4\n0 4\n0 6\n", "output": "3"}, {"input": "0 0\n0 0\n0 0\n0 0\n0 0\n0 0\n0 0\n", "output": "0"}, {"input": "4 4\n4 4\n4 4\n4 4\n4 4\n4 4\n4 4\n", "output": "0"}, {"input": "6 0\n1 2\n0 2\n2 2\n2 2\n2 2\n2 2\n", "output": "0"}, {"input": "2 1\n1 2\n3 0\n5 2\n3 2\n4 4\n4 4\n", "output": "0"}, {"input": "0 9\n0 0\n9 0\n0 0\n0 0\n0 0\n0 0\n", "output": "1"}, {"input": "4 0\n2 1\n2 2\n4 0\n2 2\n2 2\n2 2\n", "output": "0"}, {"input": "1 8\n0 9\n1 8\n1 8\n1 8\n1 8\n1 8\n", "output": "1"}, {"input": "8 1\n2 2\n2 2\n2 2\n2 2\n7 1\n2 2\n", "output": "1"}, {"input": "6 0\n6 1\n4 4\n2 2\n0 1\n1 0\n4 4\n", "output": "0"}, {"input": "0 0\n0 2\n0 4\n0 6\n0 8\n0 0\n0 0\n", "output": "0"}, {"input": "10 2\n5 3\n8 2\n3 3\n7 2\n8 2\n2 4\n", "output": "1"}, {"input": "8 0\n7 2\n2 6\n5 3\n0 8\n4 4\n3 5\n", "output": "2"}, {"input": "8 0\n0 8\n8 0\n0 8\n8 0\n0 8\n8 0\n\n", "output": "0"}, {"input": "2 2\n2 2\n2 2\n2 2\n2 2\n2 2\n2 2\n\n", "output": "0"}, {"input": "1 1\n1 1\n1 1\n1 1\n1 1\n1 1\n1 1\n\n", "output": "0"}, {"input": "3 5\n8 0\n8 0\n8 0\n8 0\n8 0\n8 0\n\n", "output": "0"}, {"input": "0 1\n0 2\n0 3\n0 4\n0 5\n0 6\n0 7\n\n", "output": "0"}, {"input": "1 0\n2 0\n3 0\n4 0\n5 0\n6 0\n7 0\n\n", "output": "0"}, {"input": "5 3\n5 3\n5 3\n5 3\n5 3\n5 3\n5 3\n\n", "output": "0"}, {"input": "2 3\n3 2\n3 2\n3 2\n3 2\n3 2\n3 2\n\n", "output": "0"}, {"input": "4 5\n1 7\n1 7\n1 7\n1 7\n1 7\n1 7\n\n", "output": "1"}, {"input": "3 7\n1 1\n1 1\n1 1\n1 1\n1 1\n1 1\n\n", "output": "1"}], "test": "#undef NDEBUG\n#include<assert.h>\nint main(){\n    assert(solution(\"5 3\\n6 2\\n7 2\\n5 3\\n5 4\\n0 4\\n0 6\\n\") == \"3\");\n    assert(solution(\"0 0\\n0 0\\n0 0\\n0 0\\n0 0\\n0 0\\n0 0\\n\") == \"0\");\n    assert(solution(\"4 4\\n4 4\\n4 4\\n4 4\\n4 4\\n4 4\\n4 4\\n\") == \"0\");\n    assert(solution(\"6 0\\n1 2\\n0 2\\n2 2\\n2 2\\n2 2\\n2 2\\n\") == \"0\");\n    assert(solution(\"2 1\\n1 2\\n3 0\\n5 2\\n3 2\\n4 4\\n4 4\\n\") == \"0\");\n    assert(solution(\"0 9\\n0 0\\n9 0\\n0 0\\n0 0\\n0 0\\n0 0\\n\") == \"1\");\n    assert(solution(\"4 0\\n2 1\\n2 2\\n4 0\\n2 2\\n2 2\\n2 2\\n\") == \"0\");\n    assert(solution(\"1 8\\n0 9\\n1 8\\n1 8\\n1 8\\n1 8\\n1 8\\n\") == \"1\");\n    assert(solution(\"8 1\\n2 2\\n2 2\\n2 2\\n2 2\\n7 1\\n2 2\\n\") == \"1\");\n    assert(solution(\"6 0\\n6 1\\n4 4\\n2 2\\n0 1\\n1 0\\n4 4\\n\") == \"0\");\n    assert(solution(\"0 0\\n0 2\\n0 4\\n0 6\\n0 8\\n0 0\\n0 0\\n\") == \"0\");\n    assert(solution(\"10 2\\n5 3\\n8 2\\n3 3\\n7 2\\n8 2\\n2 4\\n\") == \"1\");\n    assert(solution(\"8 0\\n7 2\\n2 6\\n5 3\\n0 8\\n4 4\\n3 5\\n\") == \"2\");\n    assert(solution(\"8 0\\n0 8\\n8 0\\n0 8\\n8 0\\n0 8\\n8 0\\n\\n\") == \"0\");\n    assert(solution(\"2 2\\n2 2\\n2 2\\n2 2\\n2 2\\n2 2\\n2 2\\n\\n\") == \"0\");\n    assert(solution(\"1 1\\n1 1\\n1 1\\n1 1\\n1 1\\n1 1\\n1 1\\n\\n\") == \"0\");\n    assert(solution(\"3 5\\n8 0\\n8 0\\n8 0\\n8 0\\n8 0\\n8 0\\n\\n\") == \"0\");\n    assert(solution(\"0 1\\n0 2\\n0 3\\n0 4\\n0 5\\n0 6\\n0 7\\n\\n\") == \"0\");\n    assert(solution(\"1 0\\n2 0\\n3 0\\n4 0\\n5 0\\n6 0\\n7 0\\n\\n\") == \"0\");\n    assert(solution(\"5 3\\n5 3\\n5 3\\n5 3\\n5 3\\n5 3\\n5 3\\n\\n\") == \"0\");\n    assert(solution(\"2 3\\n3 2\\n3 2\\n3 2\\n3 2\\n3 2\\n3 2\\n\\n\") == \"0\");\n    assert(solution(\"4 5\\n1 7\\n1 7\\n1 7\\n1 7\\n1 7\\n1 7\\n\\n\") == \"1\");\n    assert(solution(\"3 7\\n1 1\\n1 1\\n1 1\\n1 1\\n1 1\\n1 1\\n\\n\") == \"1\");\n    return 0; \n}", "prompt": "/*Jinjin has started junior high school. Jinjin's mother thinks that she should study harder, so Jinjin not only goes to school, but also attends various subject review classes that her mother has signed up for her. In addition, her mother also sends her to learn recitation, dance, and piano every week. However, if Jinjin has more than eight hours of classes in a day, she will be unhappy, and the longer she attends, the more unhappy she will become. Assuming that Jinjin will not be unhappy for other reasons, and her unhappiness will not last until the next day, please help to check Jinjin's schedule for next week to see if she will be unhappy. If so, on which day will she be the most unhappy.\n\ninput_format:\nThe input consists of 7 lines of data, representing Jinyun's schedule from Monday to Sunday. Each line includes two non-negative integers less than 10, separated by a space. The first integer represents the time Jinyun spends on classes at school, and the second integer represents the time her mother arranges for her to attend classes.\n\noutput_format:\nA number. If not unhappy, output $0$, if yes, output the most unhappy day of the week (with $1, 2, 3, 4, 5, 6, 7$to indicate Monday, Tuesday, Wednesday, Thursday, Friday, Saturday, Sunday). If there are two or more days of equal unhappiness, the first day is output.\n*/\n\n#include<sstream>\n#include<stdlib.h>\n#include<algorithm>\n#include<math.h>\n#include<stdio.h>\n#include<vector>\n#include<string>\n#include<climits>\n#include<cstring>\n#include<iostream>\nusing namespace std;\n\n             \nstring solution(string std_in){\n    istringstream iss(std_in);\n             ", "constraints": "NOIP2004 普及组第 1 题\n\n- 2021-10-27：增加一组 hack 数据\n- 2022-06-05：又增加一组 hack 数据", "samples": [["5 3\n6 2\n7 2\n5 3\n5 4\n0 4\n0 6\n", "3"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072]}}
{"task_id": "P2651", "title": "添加括号III", "difficulty": "challenge", "nl": "Now a formula is given in the form of $a_{1}/a_{2}/a_{3}/.../a_{n}$.\n\nIf directly calculated, it means dividing one by another successively, such as $1/2/1/4 = 1/8$.\n\nHowever, Xiao A feels uncomfortable seeing a fraction and hopes to make it an integer by adding some parentheses. One feasible method is $(1/2)/(1/4)=2$.\n\nNow given the expression, the question is whether it is possible to change the order of calculation by adding some parentheses to make it an integer.", "code": "#include<bits/stdc++.h>\nusing namespace std;\nint a[10001],t,n;\nint main()\n{\n    cin>>t;\n    for(int i=1;i<=t;i++)\n\t{\n        cin>>n>>a[1]>>a[2];\n        a[2]/=__gcd(a[1],a[2]);\n        for(int i=3;i<=n;i++)\n\t\t{\n            cin>>a[i];\n            a[2]/=__gcd(a[2],a[i]);\n        }\n        if(a[2]==1)\n            cout<<\"Yes\"<<endl;\n        else\n            cout<<\"No\"<<endl;\n    }\n\treturn 0;\n}", "step": ["Read the value of t.", "For each test case, read the length of the sequence and the first two elements.", "Calculate the greatest common divisor (gcd) of the first two elements.", "For each remaining element, calculate the gcd with the running calculated gcd and divide the second element by this gcd.", "If the final value of the second element is 1, print 'Yes', otherwise print 'No'."], "nl_cn": "现在给出一个表达式，形如 $a_{1}/a_{2}/a_{3}/.../a_{n}$。\n\n如果直接计算，就是一个个除过去，比如 $1/2/1/4 = 1/8$。\n\n然而小$\\text{A}$看到一个分数感觉很不舒服，希望通过添加一些括号使其变成一个整数。一种可行的办法是 $(1/2)/(1/4)=2$ 。\n\n现在给出这个表达式，求问是否可以通过添加一些括号改变运算顺序使其成为一个整数。", "test_cases": [{"input": "2\n4\n1 2 1 4\n5\n6 5 7 9 12", "output": "Yes\nNo"}, {"input": "1\n3\n8 4 2\n", "output": "Yes"}, {"input": "1\n6\n10 5 7 9 12 6\n", "output": "Yes"}, {"input": "3\n2\n7 14\n5\n9 27 81 243 729\n6\n5 7 9 11 13 15\n", "output": "No\nYes\nNo"}, {"input": "1\n5\n8 16 24 32 40\n", "output": "Yes"}, {"input": "3\n4\n5 10 15 30\n2\n5 25\n2\n3 6\n", "output": "Yes\nNo\nNo"}, {"input": "1\n7\n1 5 7 11 13 17 19\n", "output": "No"}, {"input": "2\n4\n2 4 6 10\n2\n3 9\n", "output": "Yes\nNo"}, {"input": "2\n3\n9 3 5\n4\n5 10 15 20", "output": "Yes\nYes"}, {"input": "1\n4\n12 6 18 9", "output": "Yes"}, {"input": "1\n5\n15 20 25 30 35", "output": "No"}, {"input": "4\n4\n24 60 144 240\n2\n3 5\n3\n5 20 35\n4\n12 18 36 72", "output": "Yes\nNo\nNo\nYes"}, {"input": "2\n2\n9 3\n4\n12 24 48 96", "output": "Yes\nYes"}, {"input": "1\n4\n24 48 96 192", "output": "Yes"}, {"input": "1\n5\n1 2 1 4 1\n", "output": "Yes"}, {"input": "1\n3\n10 5 2\n", "output": "Yes"}, {"input": "1\n2\n6 9\n", "output": "No"}, {"input": "1\n3\n12 15 18\n", "output": "No"}, {"input": "1\n4\n3 6 9 12\n", "output": "Yes"}, {"input": "1\n3\n3 6 9\n", "output": "No"}, {"input": "1\n4\n2 4 6 8\n", "output": "Yes"}, {"input": "1\n5\n2 4 6 8 10\n", "output": "Yes"}, {"input": "1\n4\n1 3 5 7\n", "output": "No"}, {"input": "1\n4\n10 15 20 25\n", "output": "No"}, {"input": "1\n3\n4 8 12\n", "output": "Yes"}, {"input": "1\n4\n4 8 12 16\n", "output": "Yes"}, {"input": "1\n3\n6 12 18\n", "output": "Yes"}, {"input": "1\n4\n6 12 18 24\n", "output": "Yes"}, {"input": "1\n3\n8 12 16\n", "output": "No"}, {"input": "1\n4\n3 6 12 24\n", "output": "Yes"}, {"input": "1\n3\n1 2 3\n", "output": "No"}, {"input": "1\n5\n1 1 1 1 1\n", "output": "Yes"}, {"input": "1\n3\n1 3 6\n", "output": "Yes"}, {"input": "1\n4\n7 3 21 42\n", "output": "Yes"}, {"input": "1\n5\n2 4 16 32 64\n", "output": "Yes"}, {"input": "1\n2\n1 1\n", "output": "Yes"}, {"input": "1\n4\n4 2 8 16\n", "output": "Yes"}, {"input": "1\n3\n1 1 1\n", "output": "Yes"}, {"input": "1\n5\n5 10 15 20 25\n", "output": "Yes"}, {"input": "2\n5\n3 9 18 27 36\n4\n1 2 3 4\n", "output": "Yes\nYes"}, {"input": "2\n3\n4 8 12\n2\n2 1\n", "output": "Yes\nYes"}], "test": "#undef NDEBUG\n#include<assert.h>\nint main(){\n    assert(solution(\"2\\n4\\n1 2 1 4\\n5\\n6 5 7 9 12\") == \"Yes\\nNo\");\n    assert(solution(\"1\\n3\\n8 4 2\\n\") == \"Yes\");\n    assert(solution(\"1\\n6\\n10 5 7 9 12 6\\n\") == \"Yes\");\n    assert(solution(\"3\\n2\\n7 14\\n5\\n9 27 81 243 729\\n6\\n5 7 9 11 13 15\\n\") == \"No\\nYes\\nNo\");\n    assert(solution(\"1\\n5\\n8 16 24 32 40\\n\") == \"Yes\");\n    assert(solution(\"3\\n4\\n5 10 15 30\\n2\\n5 25\\n2\\n3 6\\n\") == \"Yes\\nNo\\nNo\");\n    assert(solution(\"1\\n7\\n1 5 7 11 13 17 19\\n\") == \"No\");\n    assert(solution(\"2\\n4\\n2 4 6 10\\n2\\n3 9\\n\") == \"Yes\\nNo\");\n    assert(solution(\"2\\n3\\n9 3 5\\n4\\n5 10 15 20\") == \"Yes\\nYes\");\n    assert(solution(\"1\\n4\\n12 6 18 9\") == \"Yes\");\n    assert(solution(\"1\\n5\\n15 20 25 30 35\") == \"No\");\n    assert(solution(\"4\\n4\\n24 60 144 240\\n2\\n3 5\\n3\\n5 20 35\\n4\\n12 18 36 72\") == \"Yes\\nNo\\nNo\\nYes\");\n    assert(solution(\"2\\n2\\n9 3\\n4\\n12 24 48 96\") == \"Yes\\nYes\");\n    assert(solution(\"1\\n4\\n24 48 96 192\") == \"Yes\");\n    assert(solution(\"1\\n5\\n1 2 1 4 1\\n\") == \"Yes\");\n    assert(solution(\"1\\n3\\n10 5 2\\n\") == \"Yes\");\n    assert(solution(\"1\\n2\\n6 9\\n\") == \"No\");\n    assert(solution(\"1\\n3\\n12 15 18\\n\") == \"No\");\n    assert(solution(\"1\\n4\\n3 6 9 12\\n\") == \"Yes\");\n    assert(solution(\"1\\n3\\n3 6 9\\n\") == \"No\");\n    assert(solution(\"1\\n4\\n2 4 6 8\\n\") == \"Yes\");\n    assert(solution(\"1\\n5\\n2 4 6 8 10\\n\") == \"Yes\");\n    assert(solution(\"1\\n4\\n1 3 5 7\\n\") == \"No\");\n    assert(solution(\"1\\n4\\n10 15 20 25\\n\") == \"No\");\n    assert(solution(\"1\\n3\\n4 8 12\\n\") == \"Yes\");\n    assert(solution(\"1\\n4\\n4 8 12 16\\n\") == \"Yes\");\n    assert(solution(\"1\\n3\\n6 12 18\\n\") == \"Yes\");\n    assert(solution(\"1\\n4\\n6 12 18 24\\n\") == \"Yes\");\n    assert(solution(\"1\\n3\\n8 12 16\\n\") == \"No\");\n    assert(solution(\"1\\n4\\n3 6 12 24\\n\") == \"Yes\");\n    assert(solution(\"1\\n3\\n1 2 3\\n\") == \"No\");\n    assert(solution(\"1\\n5\\n1 1 1 1 1\\n\") == \"Yes\");\n    assert(solution(\"1\\n3\\n1 3 6\\n\") == \"Yes\");\n    assert(solution(\"1\\n4\\n7 3 21 42\\n\") == \"Yes\");\n    assert(solution(\"1\\n5\\n2 4 16 32 64\\n\") == \"Yes\");\n    assert(solution(\"1\\n2\\n1 1\\n\") == \"Yes\");\n    assert(solution(\"1\\n4\\n4 2 8 16\\n\") == \"Yes\");\n    assert(solution(\"1\\n3\\n1 1 1\\n\") == \"Yes\");\n    assert(solution(\"1\\n5\\n5 10 15 20 25\\n\") == \"Yes\");\n    assert(solution(\"2\\n5\\n3 9 18 27 36\\n4\\n1 2 3 4\\n\") == \"Yes\\nYes\");\n    assert(solution(\"2\\n3\\n4 8 12\\n2\\n2 1\\n\") == \"Yes\\nYes\");\n    return 0; \n}", "prompt": "/*Now a formula is given in the form of $a_{1}/a_{2}/a_{3}/.../a_{n}$.\n\nIf directly calculated, it means dividing one by another successively, such as $1/2/1/4 = 1/8$.\n\nHowever, Xiao A feels uncomfortable seeing a fraction and hopes to make it an integer by adding some parentheses. One feasible method is $(1/2)/(1/4)=2$.\n\nNow given the expression, the question is whether it is possible to change the order of calculation by adding some parentheses to make it an integer.\n\ninput_format:\nThere will be multiple expressions in a test case.\n\nThe first line contains an integer $t$, indicating the number of expressions.\n\nFor each expression, the first line contains an integer $n$, and the second line contains $n$ numbers. The $i$-th number represents $a_{i}$.\n\noutput_format:\nOutput $t$line.\n\nFor each expression, output 'Yes' if the order can be changed to integer by adding parentheses, otherwise output' No '.\n*/\n\n#include<sstream>\n#include<stdlib.h>\n#include<algorithm>\n#include<math.h>\n#include<stdio.h>\n#include<vector>\n#include<string>\n#include<climits>\n#include<cstring>\n#include<iostream>\nusing namespace std;\n\n             \nstring solution(string std_in){\n    istringstream iss(std_in);\n             ", "constraints": "- 对于 $40\\%$ 的数据，$n \\le 16$。\n- 对于 $70\\%$ 的数据，$n \\le 100$。\n- 对于 $100\\%$ 的数据， $2 \\le n \\le 10000$，$1 \\le t \\le 100$，$1 \\le a_{i}\\le 2^{31}-1$。", "samples": [["2\n4\n1 2 1 4\n5\n6 5 7 9 12", "Yes\nNo"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072]}}
{"task_id": "P2646", "title": "数数zzy", "difficulty": "challenge", "nl": "zzy stopped paying attention in math class ever since he failed the math exam several times (in fact, he never paid attention before). So he began scribbling on the paper, like writing a strange string. Then he decided to have some fun: count the total number of subsequences in this string that are equal to \"zzy\", **note that they are subsequence, not substring**. However, because the string he wrote is too long and he is a super big newbie, he can't count it himself. So he decided to ask for help from you, the super great master. Can you help him?", "code": "#include <bits/stdc++.h>\nusing namespace std;\nchar s[1000005];\nlong long ans,tot;\nint len;\nint main() {\n\tscanf(\"%s\",s);len=strlen(s);ans=0;\n\tfor(int i=0;i<len;i++){\n\t\tif(s[i]=='z')tot++;\n\t\tif(s[i]=='y')ans+=tot*(tot-1)/2;\n\t}\n\tprintf(\"%lld\\n\",ans);\n\treturn 0;\n}", "step": ["Read a character array.", "Initialize three arrays: z1, z2, y.", "Loop through the character array and for each position i, if i==0, z1[i] equals 1 if xl[0] is 'z' or 0 otherwise.", "If i>0, set z1[i] to z1[i-1]+(xl[i]=='z'?1:0); z2[i] to z2[i-1]+(xl[i]=='z'?z1[i-1]:0).", "If i>=2, set y[i] to y[i-1]+(xl[i]=='y'?z2[i-1]:0).", "Print y[len-1], where len is the length of the character array."], "nl_cn": "zzy 自从数学考试连续跪掉之后，上数学课就从来不认真听了（事实上他以前也不认真听）。于是他开始在草稿纸上写写画画，比如写一串奇怪的字符串。然后他决定理♂性♂愉♂悦♂一下：统计这串字符串当中共有多少个为 `zzy` 的子序列，**注意是子序列而非子串**。但是由于他写的字符串实在是太长啦，而且他是个超级大蒟蒻，根本就数不过来。所以他决定请求你这个超级大神犇的帮助。你可以帮帮他吗？", "test_cases": [{"input": "zlzhy", "output": "1"}, {"input": "zzz\n", "output": "0"}, {"input": "z\n", "output": "0"}, {"input": "zz\n", "output": "0"}, {"input": "zzzz\n", "output": "0"}, {"input": "zzzzz\n", "output": "0"}, {"input": "zzzzzz\n", "output": "0"}, {"input": "zzzzzzz\n", "output": "0"}, {"input": "zzzzzzzz\n", "output": "0"}, {"input": "zzzzzzzzz\n", "output": "0"}, {"input": "zzzzzzzzzz\n", "output": "0"}, {"input": "zzzzzzzzzzz\n", "output": "0"}, {"input": "zzzyzz", "output": "3"}, {"input": "zzy", "output": "1"}, {"input": "zy", "output": "0"}, {"input": "yyyyyzzzzz", "output": "0"}, {"input": "yzzyyzz", "output": "2"}, {"input": "zzzyyzz", "output": "6"}], "test": "#undef NDEBUG\n#include<assert.h>\nint main(){\n    assert(solution(\"zlzhy\") == \"1\");\n    assert(solution(\"zzz\\n\") == \"0\");\n    assert(solution(\"z\\n\") == \"0\");\n    assert(solution(\"zz\\n\") == \"0\");\n    assert(solution(\"zzzz\\n\") == \"0\");\n    assert(solution(\"zzzzz\\n\") == \"0\");\n    assert(solution(\"zzzzzz\\n\") == \"0\");\n    assert(solution(\"zzzzzzz\\n\") == \"0\");\n    assert(solution(\"zzzzzzzz\\n\") == \"0\");\n    assert(solution(\"zzzzzzzzz\\n\") == \"0\");\n    assert(solution(\"zzzzzzzzzz\\n\") == \"0\");\n    assert(solution(\"zzzzzzzzzzz\\n\") == \"0\");\n    assert(solution(\"zzzyzz\") == \"3\");\n    assert(solution(\"zzy\") == \"1\");\n    assert(solution(\"zy\") == \"0\");\n    assert(solution(\"yyyyyzzzzz\") == \"0\");\n    assert(solution(\"yzzyyzz\") == \"2\");\n    assert(solution(\"zzzyyzz\") == \"6\");\n    return 0; \n}", "prompt": "/*zzy stopped paying attention in math class ever since he failed the math exam several times (in fact, he never paid attention before). So he began scribbling on the paper, like writing a strange string. Then he decided to have some fun: count the total number of subsequences in this string that are equal to \"zzy\", **note that they are subsequence, not substring**. However, because the string he wrote is too long and he is a super big newbie, he can't count it himself. So he decided to ask for help from you, the super great master. Can you help him?\n\ninput_format:\nA string $s$ consisting of only lowercase letters.\n\noutput_format:\nA line, a non-negative integer, representing the number of 'zzy' subsequences in the input string.\n*/\n\n#include<sstream>\n#include<stdlib.h>\n#include<algorithm>\n#include<math.h>\n#include<stdio.h>\n#include<vector>\n#include<string>\n#include<climits>\n#include<cstring>\n#include<iostream>\nusing namespace std;\n\n             \nstring solution(string std_in){\n    istringstream iss(std_in);\n             ", "constraints": "#### 数据规模与约定\n\n约定 $|s|$ 表示字符串 $s$ 的长度。\n\n- 对于 $70\\%$ 的数据，保证 $|s| \\le 100$。\n- 对于 $100\\%$ 的数据，保证 $1 \\le |s| \\le 10^6$，答案不超过 $2^{63}-1$。", "samples": [["zlzhy", "1"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}}
{"task_id": "P8762", "title": "[蓝桥杯 2021 国 ABC] 123", "difficulty": "challenge", "nl": "Little Blue discovered an interesting sequence, the first few terms of which are:\n\n$1,1,2,1,2,3,1,2,3,4, \\ldots$\n\nLittle Blue discovered that the first $1$ term of the sequence is the integer $1$, the next 2 terms are the integers from $1$ to $2$, the next 3 terms are the integers from $1$ to $3$, the next 4 terms are the integers from $1$ to $4$, and so on.\n\nLittle Blue wants to know the sum of each consecutive subsequence in this sequence.", "code": "#include<bits/stdc++.h>\n#define ll unsigned long long\n#define F(i,a,b) for (int i=a;i<=b;i++)\n#define Test ios::sync_with_stdio(false),cin.tie(nullptr),cout.tie(nullptr)\nusing namespace std;\nconst int N=1e7+10,NN=1e4+10;\nll n,m,k,x,y,u,v,w,cnt=0,ans=0,t=0,l,r,len,T;\nll mini=INT_MAX,maxi=0,Mod;\nstring s1,s2;\nll a[5];\nll Find(ll n){//二分\n\tll l=1,r=10000000;\n\twhile(l<r){\n\t\tll mid=(l+r)/2;\n\t\tif((1+mid)*mid/2>=n) r=mid;\n\t\telse l=mid+1;\n\t}\n\treturn r;\n}\nll f(ll n){//高斯公式\n\treturn (1+n)*n/2;\n}\nll Ans(ll n){//前 n 行的和\n\treturn n*(n+1)*(n+2)/6;\n}\nint main(){\n\tTest;\n\tcin>>T;\n\twhile(T--){\n\t\tcin>>l>>r;\n\t\ta[1]=l-f(Find(l)-1);//前 l 行\n\t\ta[2]=r-f(Find(r)-1);//前 r 行\n\t\tll ans1=Ans(Find(l)-1)+a[1]*(a[1]-1)/2;//前 l 个数的和\n\t\tll ans2=Ans(Find(r)-1)+(a[2]+1)*a[2]/2;//前 r 个数的和\n\t\tcout<<ans2-ans1<<\"\\n\";\n\t}\n\treturn 0;\n}", "step": ["Initialize two arrays s and f, and fill them using arithmetic progressions.", "Read in the test case number t.", "For each test case, read in the integers r and l, and subtract the sum of a subarray from another subarray, then output the result.", "Find the subarrays by using mathematical formulas with some lower bound functions processing through array s."], "nl_cn": "小蓝发现了一个有趣的数列, 这个数列的前几项如下:\n\n$1,1,2,1,2,3,1,2,3,4, \\ldots$\n\n小蓝发现, 这个数列前 $1$ 项是整数 $1$ , 接下来 $2$ 项是整数 $1$ 至 $2$ , 接下来 $3$ 项是整数 $1$ 至 $3$ , 接下来 $4$ 项是整数 $1$ 至 $4$ , 依次类推。\n\n小蓝想知道, 这个数列中, 连续一段的和是多少。", "test_cases": [{"input": "3\n1 1\n1 3\n5 8", "output": "1\n4\n8"}], "test": "#undef NDEBUG\n#include<assert.h>\nint main(){\n    assert(solution(\"3\\n1 1\\n1 3\\n5 8\") == \"1\\n4\\n8\");\n    return 0; \n}", "prompt": "/*Little Blue discovered an interesting sequence, the first few terms of which are:\n\n$1,1,2,1,2,3,1,2,3,4, \\ldots$\n\nLittle Blue discovered that the first $1$ term of the sequence is the integer $1$, the next 2 terms are the integers from $1$ to $2$, the next 3 terms are the integers from $1$ to $3$, the next 4 terms are the integers from $1$ to $4$, and so on.\n\nLittle Blue wants to know the sum of each consecutive subsequence in this sequence.\n\ninput_format:\nThe first line of input contains an integer $T$, representing the number of queries.\n\nNext, line $T$, each line contains a set of queries, where line $i$contains two integers $l_{i}$and $r_{i}$, representing the sum of the number of $l_{i}$to the number of $r_{i}$in the query sequence.\n\noutput_format:\nOutput $T$lines, each containing an integer representing the answer to the query.\n*/\n\n#include<sstream>\n#include<stdlib.h>\n#include<algorithm>\n#include<math.h>\n#include<stdio.h>\n#include<vector>\n#include<string>\n#include<climits>\n#include<cstring>\n#include<iostream>\nusing namespace std;\n\n             \nstring solution(string std_in){\n    istringstream iss(std_in);\n             ", "constraints": "对于 $10 \\%$ 的评测用例, $1 \\leq T \\leq 30,1 \\leq l_{i} \\leq r_{i} \\leq 100$ 。\n\n对于 $20 \\%$ 的评测用例, $1 \\leq T \\leq 100,1 \\leq l_{i} \\leq r_{i} \\leq 1000$ 。\n\n对于 $40 \\%$ 的评测用例, $1 \\leq T \\leq 1000,1 \\leq l_{i} \\leq r_{i} \\leq 10^{6}$ 。\n\n对于 $70 \\%$ 的评测用例, $1 \\leq T \\leq 10000,1 \\leq l_{i} \\leq r_{i} \\leq 10^{9}$ 。\n\n对于 $80 \\%$ 的评测用例, $1 \\leq T \\leq 1000,1 \\leq l_{i} \\leq r_{i} \\leq 10^{12}$ 。\n\n对于 $90 \\%$ 的评测用例, $1 \\leq T \\leq 10000,1 \\leq l_{i} \\leq r_{i} \\leq 10^{12}$ 。\n\n对于所有评测用例, $1 \\leq T \\leq 100000,1 \\leq l_{i} \\leq r_{i} \\leq 10^{12}$ 。 \n\n蓝桥杯 2021 国赛 A 组 E 题（B 组 F 题，C 组 F 题）。", "samples": [["3\n1 1\n1 3\n5 8", "1\n4\n8"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072]}}
{"task_id": "P4596", "title": "[COCI2011-2012#5] RAZBIBRIGA", "difficulty": "challenge", "nl": "Four words of equal length can be pieced together into a square, as shown in the following picture, where `\"HLAD\", \"NIVA\", \"HSIN\", \"DEDA\"` form a $4\\times 4$ square.\n\n\n\nNow you are given $N$ words of equal length. Find the number of different squares that can be formed by subsets of these words, and output the number of solutions.\n\nNote that **there cannot be duplicate words in the same grid**. If two words differ in at least one character, then they are considered different.", "code": "#include<cstdio>\n#include<cstring>\n#include<algorithm>\n#define ll long long\nusing namespace std;\nconst int M=26;\nll cnt[M][M],n;\nchar s[M];\nll ans;\nint main(){\n  scanf(\"%lld\",&n);\n  for(int i=1;i<=n;i++){\n  \tscanf(\"%s\",s);\n  \tcnt[s[0]-'A'][s[strlen(s)-1]-'A']++;\n  }\n  for(int i=0;i<26;i++){\n  \tfor(int j=0;j<26;j++){\n  \t\tll t1=cnt[i][j];cnt[i][j]--;\n  \t\tfor(int k=0;k<26;k++){\n  \t\t\tll t2=cnt[i][k];cnt[i][k]--;\n  \t\t\tfor(int w=0;w<26;w++){\n  \t\t\t\tll t3=cnt[j][w];cnt[j][w]--;\n  \t\t\t\tll t4=cnt[k][w];\n  \t\t\t\tans+=t1*t2*t3*t4;\n  \t\t\t\tcnt[j][w]++;\n  \t\t\t}\n  \t\t\tcnt[i][k]++;\n  \t\t}\n  \t\tcnt[i][j]++;\n  \t}\n  }\n  printf(\"%lld\\n\",ans);\n  return 0;\n}", "step": ["Initialize an array cnt of size 26x26 with all elements set to 0 and a counter variable ans to 0", "Input the number of words and the words themselves", "Increment the cnt array at index (s[0]-'A',s[strlen(s)-1]-'A') for each word s", "For each i and j from 0 to 25, do: ", " * Decrement cnt[i][j] and loop through k from 0 to 25, then:", "   - Decrement cnt[i][k] and loop through w from 0 to 25, then:", "     + Decrement cnt[j][w] and compute ans+=t1*t2*t3*t4 where t1=cnt[i][j], t2=cnt[i][k], t3=cnt[j][w] and t4=cnt[k][w]", "     + Increment cnt[j][w]", "   - Increment cnt[i][k]", " * Increment cnt[i][j]", "Print the value of ans"], "nl_cn": "四个长度相同的单词可以拼成一个正方形，如下图，`\"HLAD\",\"NIVA\",\"HSIN\",\"DEDA\"` 拼成了一个 $4\\times 4$ 的正方形。\n\n\n\n现在给你 $N$ 个等长的单词，求这些单词的子集可以拼成多少个不同的正方形，输出方案数。\n\n注意，**同一方格内不能有重复的单词**，如果两个单词至少有一个字符不同，那这两个单词就是不同的。", "test_cases": [{"input": "4\nNIVA\nHLAD\nHSIN\nDEDA\n", "output": "2"}, {"input": "6\nBAKA\nBARA\nBALC\nCALC\nARHC\nBLIC\n", "output": "8"}, {"input": "2\nWORD\nWORD\n", "output": "0"}, {"input": "5\nAAAA\nBBBB\nCCCC\nDDDD\nEEEE\n", "output": "0"}, {"input": "3\nABCD\nBCDA\nCDAB\n", "output": "0"}, {"input": "7\nABCDE\nBCDEF\nCDEFG\nDEFGH\nEFGHI\nFGHIJ\nGHIJK\n", "output": "0"}, {"input": "2\nAAAA\nABCD\n", "output": "0"}, {"input": "3\nABCD\nABCE\nABCF\n", "output": "0"}, {"input": "5\nJOHN\nOHNJ\nHSNJO\nNYSHJ\nNIKAS\n", "output": "0"}, {"input": "5\nABCDA\nBCDAB\nCDABC\nDABCD\nABCDE\n", "output": "0"}, {"input": "5\nASDFG\nSDFGH\nDFGHI\nFGHIJ\nGHIJK\n", "output": "0"}, {"input": "4\nABAC\nBADA\nADAA\nDAAA\n", "output": "0"}, {"input": "5\nAAAAA\nBBBBB\nCCCCC\nDDDDD\nEEEEE\n", "output": "0"}, {"input": "3\nABCD\nDCBA\nCDDC\n", "output": "0"}, {"input": "5\nABCD\nABCD\nABCD\nABCD\nABCD\n", "output": "0"}, {"input": "2\nABCD\nDCBA\n", "output": "0"}, {"input": "4\nABCDE\nABUDA\nALOLA\nASADA\n", "output": "0"}, {"input": "4\nAAAA\nAAA\nBBBB\nBBB\n", "output": "0"}, {"input": "5\nAABA\nBBBB\nCCCC\nDDDD\nEEEE\n", "output": "0"}, {"input": "3\nABCD\nDEFG\nEFGH\n", "output": "0"}, {"input": "2\nHELLO\nWORLD\n", "output": "0"}, {"input": "1\nA\n", "output": "0"}, {"input": "0\n", "output": "0"}, {"input": "3\nABC\nDEF\nGHI\n", "output": "0"}, {"input": "4\nABCD\nBCDA\nCDAB\nDABC\n", "output": "0"}, {"input": "2\nABC\nCBA\n", "output": "0"}, {"input": "2\nAB\nCD\n", "output": "0"}, {"input": "5\nABCDE\nFGHIJ\nKLMNO\nPQRST\nUVWXY\n", "output": "0"}, {"input": "3\nAA\nBB\nCC\n", "output": "0"}, {"input": "6\nHHHHH\nIIIII\nJJJJJ\nKKKKK\nLLLLL\nMMMMM\n", "output": "0"}, {"input": "2\nAB\nBA\n", "output": "0"}, {"input": "5\nCODE\nTECH\nHACK\nLOAD\nCART\n", "output": "0"}, {"input": "4\nABCD\nDCBA\nAAAA\nDDDD\n", "output": "0"}, {"input": "8\nCAKE\nMAKE\nBAKE\nRAKE\nLAKE\nFAKE\nDAKE\nTAKE\n", "output": "0"}, {"input": "6\nWORD\nROAD\nCARS\nSODA\nSOFA\nCODA\n", "output": "0"}, {"input": "3\nAAA\nBBB\nCCC\n", "output": "0"}, {"input": "5\nJAVA\nPYTHON\nCPLUS\nRUBY\nSWIFT\n", "output": "0"}, {"input": "4\nCODE\nTEST\nCASE\nFILE\n", "output": "0"}, {"input": "3\nDOG\nCAT\nFROG\n", "output": "0"}, {"input": "1\nZ\n", "output": "0"}, {"input": "7\nAPPLE\nBANANA\nCHERRY\nDURIAN\nEGGPLANT\nFIG\nGRAPE\n", "output": "0"}, {"input": "4\nPOP\nROCK\nJAZZ\nBLUES\n", "output": "0"}, {"input": "2\nGOOD\nBAD\n", "output": "0"}, {"input": "3\nYES\nNO\nMAYBE\n", "output": "0"}, {"input": "6\nONE\nTWO\nTHREE\nFOUR\nFIVE\nSIX\n", "output": "0"}], "test": "#undef NDEBUG\n#include<assert.h>\nint main(){\n    assert(solution(\"4\\nNIVA\\nHLAD\\nHSIN\\nDEDA\\n\") == \"2\");\n    assert(solution(\"6\\nBAKA\\nBARA\\nBALC\\nCALC\\nARHC\\nBLIC\\n\") == \"8\");\n    assert(solution(\"2\\nWORD\\nWORD\\n\") == \"0\");\n    assert(solution(\"5\\nAAAA\\nBBBB\\nCCCC\\nDDDD\\nEEEE\\n\") == \"0\");\n    assert(solution(\"3\\nABCD\\nBCDA\\nCDAB\\n\") == \"0\");\n    assert(solution(\"7\\nABCDE\\nBCDEF\\nCDEFG\\nDEFGH\\nEFGHI\\nFGHIJ\\nGHIJK\\n\") == \"0\");\n    assert(solution(\"2\\nAAAA\\nABCD\\n\") == \"0\");\n    assert(solution(\"3\\nABCD\\nABCE\\nABCF\\n\") == \"0\");\n    assert(solution(\"5\\nJOHN\\nOHNJ\\nHSNJO\\nNYSHJ\\nNIKAS\\n\") == \"0\");\n    assert(solution(\"5\\nABCDA\\nBCDAB\\nCDABC\\nDABCD\\nABCDE\\n\") == \"0\");\n    assert(solution(\"5\\nASDFG\\nSDFGH\\nDFGHI\\nFGHIJ\\nGHIJK\\n\") == \"0\");\n    assert(solution(\"4\\nABAC\\nBADA\\nADAA\\nDAAA\\n\") == \"0\");\n    assert(solution(\"5\\nAAAAA\\nBBBBB\\nCCCCC\\nDDDDD\\nEEEEE\\n\") == \"0\");\n    assert(solution(\"3\\nABCD\\nDCBA\\nCDDC\\n\") == \"0\");\n    assert(solution(\"5\\nABCD\\nABCD\\nABCD\\nABCD\\nABCD\\n\") == \"0\");\n    assert(solution(\"2\\nABCD\\nDCBA\\n\") == \"0\");\n    assert(solution(\"4\\nABCDE\\nABUDA\\nALOLA\\nASADA\\n\") == \"0\");\n    assert(solution(\"4\\nAAAA\\nAAA\\nBBBB\\nBBB\\n\") == \"0\");\n    assert(solution(\"5\\nAABA\\nBBBB\\nCCCC\\nDDDD\\nEEEE\\n\") == \"0\");\n    assert(solution(\"3\\nABCD\\nDEFG\\nEFGH\\n\") == \"0\");\n    assert(solution(\"2\\nHELLO\\nWORLD\\n\") == \"0\");\n    assert(solution(\"1\\nA\\n\") == \"0\");\n    assert(solution(\"0\\n\") == \"0\");\n    assert(solution(\"3\\nABC\\nDEF\\nGHI\\n\") == \"0\");\n    assert(solution(\"4\\nABCD\\nBCDA\\nCDAB\\nDABC\\n\") == \"0\");\n    assert(solution(\"2\\nABC\\nCBA\\n\") == \"0\");\n    assert(solution(\"2\\nAB\\nCD\\n\") == \"0\");\n    assert(solution(\"5\\nABCDE\\nFGHIJ\\nKLMNO\\nPQRST\\nUVWXY\\n\") == \"0\");\n    assert(solution(\"3\\nAA\\nBB\\nCC\\n\") == \"0\");\n    assert(solution(\"6\\nHHHHH\\nIIIII\\nJJJJJ\\nKKKKK\\nLLLLL\\nMMMMM\\n\") == \"0\");\n    assert(solution(\"2\\nAB\\nBA\\n\") == \"0\");\n    assert(solution(\"5\\nCODE\\nTECH\\nHACK\\nLOAD\\nCART\\n\") == \"0\");\n    assert(solution(\"4\\nABCD\\nDCBA\\nAAAA\\nDDDD\\n\") == \"0\");\n    assert(solution(\"8\\nCAKE\\nMAKE\\nBAKE\\nRAKE\\nLAKE\\nFAKE\\nDAKE\\nTAKE\\n\") == \"0\");\n    assert(solution(\"6\\nWORD\\nROAD\\nCARS\\nSODA\\nSOFA\\nCODA\\n\") == \"0\");\n    assert(solution(\"3\\nAAA\\nBBB\\nCCC\\n\") == \"0\");\n    assert(solution(\"5\\nJAVA\\nPYTHON\\nCPLUS\\nRUBY\\nSWIFT\\n\") == \"0\");\n    assert(solution(\"4\\nCODE\\nTEST\\nCASE\\nFILE\\n\") == \"0\");\n    assert(solution(\"3\\nDOG\\nCAT\\nFROG\\n\") == \"0\");\n    assert(solution(\"1\\nZ\\n\") == \"0\");\n    assert(solution(\"7\\nAPPLE\\nBANANA\\nCHERRY\\nDURIAN\\nEGGPLANT\\nFIG\\nGRAPE\\n\") == \"0\");\n    assert(solution(\"4\\nPOP\\nROCK\\nJAZZ\\nBLUES\\n\") == \"0\");\n    assert(solution(\"2\\nGOOD\\nBAD\\n\") == \"0\");\n    assert(solution(\"3\\nYES\\nNO\\nMAYBE\\n\") == \"0\");\n    assert(solution(\"6\\nONE\\nTWO\\nTHREE\\nFOUR\\nFIVE\\nSIX\\n\") == \"0\");\n    return 0; \n}", "prompt": "/*Four words of equal length can be pieced together into a square, as shown in the following picture, where `\"HLAD\", \"NIVA\", \"HSIN\", \"DEDA\"` form a $4\\times 4$ square.\n\n\n\nNow you are given $N$ words of equal length. Find the number of different squares that can be formed by subsets of these words, and output the number of solutions.\n\nNote that **there cannot be duplicate words in the same grid**. If two words differ in at least one character, then they are considered different.\n\ninput_format:\nThe first line, an integer $N$, indicates the number of words.\n\nThen $N$lines, one word per line, consisting of uppercase letters, as shown in the question.\n\noutput_format:\nOne line, an integer, indicates the number of schemes.\n\nThe number of scenarios may be large, you need to open 'long long' or 'int64'.\n*/\n\n#include<sstream>\n#include<stdlib.h>\n#include<algorithm>\n#include<math.h>\n#include<stdio.h>\n#include<vector>\n#include<string>\n#include<climits>\n#include<cstring>\n#include<iostream>\nusing namespace std;\n\n             \nstring solution(string std_in){\n    istringstream iss(std_in);\n             ", "constraints": "$4\\le N\\le 10^{5}$。\n\n每个单词至多有 $10$ 个字符。\n\n单词由大写字母构成。\n\n题目译自 [COCI 2011/2012 #5 T4](https://hsin.hr/coci/archive/2011_2012/contest5_tasks.pdf)。", "samples": [["4\nNIVA\nHLAD\nHSIN\nDEDA\n", "2"], ["6\nBAKA\nBARA\nBALC\nCALC\nARHC\nBLIC\n", "8"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [32000, 32000, 32000, 32000, 32000, 32000, 32000, 32000, 32000, 32000]}}
{"task_id": "P6248", "title": "准备战斗，选择你的英雄", "difficulty": "challenge", "nl": "Currently, there are 31 heroes in the game, and 6 heroes can be dispatched in each game. The actual number of usable heroes will be less than 31. Simply assume that the contribution of each hero to the team can be represented by a positive integer $v_i$. The total ability of the team is equal to the sum of the contributions of all heroes. In particular, for $m$ specific groups of heroes, their appearance together will increase the team's total ability by $x_i$.\n\n**Note: Hero combinations can be repeated, please count multiple times if repeated.**", "code": "#include<bits/stdc++.h>\n#define re register\nusing namespace std;\nint n,m,val[32],g[32][32],ans;\nmap<string,int>mp;\nchar s[12],ss[12];\ninline int read(){\n\tre int t=0;\n\tre char v=getchar();\n\twhile(v<'0')v=getchar();\n\twhile(v>='0')t=(t<<3)+(t<<1)+v-48,v=getchar();\n\treturn t;\n}\nint main(){\n\tn=read(),m=read();\n\tfor(re int i=1;i<=n;++i){\n\t\tscanf(\"%s\",s+1);\n\t\tmp[s+1]=i;\n\t\tval[i]=read();\n\t}\n\tfor(re int i=1;i<=m;++i){\n\t\tscanf(\"%s%s\",s+1,ss+1);\n\t\tre int x=mp[s+1],y=mp[ss+1];\n\t\tre int kk=read();\n\t\tg[x][y]+=kk;\n\t\tg[y][x]+=kk;\n\t}\n\tfor(re int a=1;a<=n;++a)\n\t\tfor(re int b=a+1;b<=n;++b)\n\t\t\tfor(re int c=b+1;c<=n;++c)\n\t\t\t\tfor(re int d=c+1;d<=n;++d)\n\t\t\t\t\tfor(re int e=d+1;e<=n;++e)\n\t\t\t\t\t\tfor(re int f=e+1;f<=n;++f)ans=max(ans,val[a]+val[b]+val[c]+val[d]+val[e]+val[f]+g[a][b]+g[a][c]+g[a][d]+g[a][e]+g[a][f]+g[b][c]+g[b][d]+g[b][e]+g[b][f]+g[c][d]+g[c][e]+g[c][f]+g[d][e]+g[d][f]+g[e][f]);\n\tprintf(\"%d\",ans);\n}", "step": ["Read in n and m.", "For each of the n nodes, read in its name and value.", "For each of the m edges, read in the two nodes it connects and its weight, and store the weights in a matrix.", "Compute the maximum possible value of the function that depends on the n nodes and m edges, using six nested loops to consider all combinations of six nodes at a time.", "Print the maximum possible value of the function."], "nl_cn": "目前，游戏共有 $31$ 个英雄，每局可以派 $6$ 个英雄上场。实际能使用的英雄数将会小于 $31$。简单地假设，每位英雄对团队的贡献可以用一个正整数 $v_i$ 表示。团队的总能力等于所有英雄的贡献之和。特别地，对于 $m$ 组特定的英雄，他们一起出现会让团队总能力提高 $x_i$。\n\n**另注：英雄组合可以重复，若重复请多次计数。**", "test_cases": [{"input": "7 0\nSigma 10\nOrisa 10\nMei 10\nReaper 10\nMoira 10\nLucio 10\nDoomfist 1", "output": "60"}, {"input": "8 2\nPharah 5\nMercy 5\nReinhardt 10\nDVA 10\nSOLDIER:76 12\nTorbjorn 5\nAnna 8\nBaptiste 10\nPharah Mercy 20\nAnna Pharah 5", "output": "75"}, {"input": "7 0\nReaper 10\nJunkrat 10\nHanzo 10\nTracer 10\nZarya 10\nMoira 10\nAna 10\n", "output": "60"}, {"input": "7 0\nZenyatta 10\nTracer 10\nWinston 10\nWidowmaker 10\nReinhardt 10\nLucio 10\nAna 10\n", "output": "60"}, {"input": "8 2\nPharah 5\nMercy 5\nReinhardt 10\nD.Va 10\nSOLDIER:76 12\nTorbjorn 5\nAnna 8\nBaptiste 10\nPharah Mercy 20\nAnna Pharah 5\n", "output": "75"}, {"input": "6 0\nMercy 10\nMercy 10\nMercy 10\nMercy 10\nMercy 10\nMercy 10\n", "output": "60"}, {"input": "6 0\nHanzo 10\nAshe 10\nWidowmaker 10\nJunkrat 10\nTracer 10\nReinhardt 10\n", "output": "60"}, {"input": "7 0\nZarya 10\nDoomfist 10\nWidowmaker 10\nReinhardt 10\nSombra 10\nMei 10\nLucio 1\n", "output": "60"}, {"input": "6 1\nJunkrat 18\nTorbjorn 9\nMei 6\nOrisa 11\nSigma 14\nLucio 8\nMei Junkrat 10\n", "output": "76"}, {"input": "6 1\nSoldier 10\nGenji 10\nReaper 10\nMcCree 10\nTracer 10\nWidowmaker 10\nGenji Widowmaker 15\n", "output": "75"}], "test": "#undef NDEBUG\n#include<assert.h>\nint main(){\n    assert(solution(\"7 0\\nSigma 10\\nOrisa 10\\nMei 10\\nReaper 10\\nMoira 10\\nLucio 10\\nDoomfist 1\") == \"60\");\n    assert(solution(\"8 2\\nPharah 5\\nMercy 5\\nReinhardt 10\\nDVA 10\\nSOLDIER:76 12\\nTorbjorn 5\\nAnna 8\\nBaptiste 10\\nPharah Mercy 20\\nAnna Pharah 5\") == \"75\");\n    assert(solution(\"7 0\\nReaper 10\\nJunkrat 10\\nHanzo 10\\nTracer 10\\nZarya 10\\nMoira 10\\nAna 10\\n\") == \"60\");\n    assert(solution(\"7 0\\nZenyatta 10\\nTracer 10\\nWinston 10\\nWidowmaker 10\\nReinhardt 10\\nLucio 10\\nAna 10\\n\") == \"60\");\n    assert(solution(\"8 2\\nPharah 5\\nMercy 5\\nReinhardt 10\\nD.Va 10\\nSOLDIER:76 12\\nTorbjorn 5\\nAnna 8\\nBaptiste 10\\nPharah Mercy 20\\nAnna Pharah 5\\n\") == \"75\");\n    assert(solution(\"6 0\\nMercy 10\\nMercy 10\\nMercy 10\\nMercy 10\\nMercy 10\\nMercy 10\\n\") == \"60\");\n    assert(solution(\"6 0\\nHanzo 10\\nAshe 10\\nWidowmaker 10\\nJunkrat 10\\nTracer 10\\nReinhardt 10\\n\") == \"60\");\n    assert(solution(\"7 0\\nZarya 10\\nDoomfist 10\\nWidowmaker 10\\nReinhardt 10\\nSombra 10\\nMei 10\\nLucio 1\\n\") == \"60\");\n    assert(solution(\"6 1\\nJunkrat 18\\nTorbjorn 9\\nMei 6\\nOrisa 11\\nSigma 14\\nLucio 8\\nMei Junkrat 10\\n\") == \"76\");\n    assert(solution(\"6 1\\nSoldier 10\\nGenji 10\\nReaper 10\\nMcCree 10\\nTracer 10\\nWidowmaker 10\\nGenji Widowmaker 15\\n\") == \"75\");\n    return 0; \n}", "prompt": "/*Currently, there are 31 heroes in the game, and 6 heroes can be dispatched in each game. The actual number of usable heroes will be less than 31. Simply assume that the contribution of each hero to the team can be represented by a positive integer $v_i$. The total ability of the team is equal to the sum of the contributions of all heroes. In particular, for $m$ specific groups of heroes, their appearance together will increase the team's total ability by $x_i$.\n\n**Note: Hero combinations can be repeated, please count multiple times if repeated.**\n\ninput_format:\nThe first two integers $n$and $m$indicate the number of available heroes and the number of specific combinations.\nNext $n$lines, each giving the name of the first $i$hero, followed by an integer $v_i$.\nThe next $m$line, each with two strings $a$, $b$and an integer $x_i$, indicates that the total ability increases by $x_i$if hero $a$and hero $b$appear together.\n** Guarantee: $a$and $b$are not the same hero. **\n\noutput_format:\nAn integer representing the maximum value of the team's capabilities.\n*/\n\n#include<sstream>\n#include<stdlib.h>\n#include<algorithm>\n#include<math.h>\n#include<stdio.h>\n#include<vector>\n#include<string>\n#include<climits>\n#include<cstring>\n#include<iostream>\nusing namespace std;\n\n             \nstring solution(string std_in){\n    istringstream iss(std_in);\n             ", "constraints": "#### 样例 1 解释\n我们应该选择前 $6$ 名英雄。\n\n---\n\n#### 样例 2 解释\n我们应该选择 Pharah、Mercy、Reinhardt、DVA、SOLDIER:76、Anna\n\n---\n\n#### 数据范围\n对于 $40\\%$ 的数据，$m=0$。  \n对于 $100\\%$ 的数据，$6\\le n \\le 30$，$0\\le m \\le 30$，*$1\\le x_i,v_i \\le 100$*，英雄名字长度 $\\le 10$，字符集包括大小写字母、数字以及冒号（ `:` ）。每个英雄的名字各不相同。\n", "samples": [["7 0\nSigma 10\nOrisa 10\nMei 10\nReaper 10\nMoira 10\nLucio 10\nDoomfist 1", "60"], ["8 2\nPharah 5\nMercy 5\nReinhardt 10\nDVA 10\nSOLDIER:76 12\nTorbjorn 5\nAnna 8\nBaptiste 10\nPharah Mercy 20\nAnna Pharah 5", "75"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000]}}
{"task_id": "P7822", "title": "「RdOI R3」学习算法", "difficulty": "challenge", "nl": "During the summer vacation, there are $n$ days in total, and we assume that MLE has enough time to learn OI every day. MLE has listed $m$ available algorithms to choose from. MLE can only and must learn one algorithm every day.\n\nMoreover, MLE will get tired of learning the same algorithm for a long time, so each algorithm cannot be learned for too many consecutive days. The $i$-th algorithm can be learned for at most $a_i$ consecutive days. **MLE does not have to learn all the algorithms.**\n\nMLE wants to know how many different learning plans he has to spend these $n$ days. Two learning plans are different only if at least one day is spent learning a different algorithm. Since there may be too many plans, you only need to output the number of plans modulo $10^9+7$.", "code": "#include <cstdio>\ntypedef long long ll;\n#define MODNUM 1000000007\n#define MAXN 7001\nll n, m;\nunsigned int dp[MAXN][MAXN];\nll sum[MAXN];\nll a[MAXN];\nint main()\n{\n    ll i, j, k;\n    scanf(\"%lld%lld\", &n, &m);\n    for (i = 1; i <= m; i++)\n        scanf(\"%lld\", &a[i]);\n    if (m == 1 && a[1] < n)\n    {\n        printf(\"0\");\n        return 0;\n    }\n    for (i = 1; i <= m; i++)\n        dp[1][i] = 1;\n    sum[1] = m;\n    for (i = 2; i <= n; i++)\n    {\n        for (j = 1; j <= m; j++)\n        {\n            dp[i][j] = sum[i - 1];\n            if (i > a[j])\n            {\n                if (i == a[j] + 1)\n                    dp[i][j] = (dp[i][j] - 1 + MODNUM) % MODNUM;\n                else\n                    dp[i][j] = (dp[i][j] - (sum[i - a[j] - 1] - dp[i - a[j] - 1][j]) + MODNUM) % MODNUM;\n            }\n        }\n        for (j = 1; j <= m; j++)\n            sum[i] = (sum[i] + dp[i][j]) % MODNUM;\n    }\n    printf(\"%lld\", sum[n]);\n    return 0;\n}", "step": ["Read input values of n and m, array a.", "Check a condition and if true then print 0 and return.", "Calculate dp[i][j] values till n for each element of a, using sum[i] which stores sum of all previously calculated dp values.", "Update sum[i] by adding dp[i][j] values for each j.", "Print sum[n]."], "nl_cn": "暑假一共有 $n$ 天，我们假设 MLE 每天都有足够的时间学 OI。MLE 列出了可供选择的 $m$ 个算法。MLE 每天只能且必须学习一个算法。\n\n而且，MLE 长时间学同一种算法会厌倦，所以每一种算法不能连续学习太多天，第 $i$ 种算法最多可以连续学习 $a_i$ 天。**MLE 没有必要学习全部的算法。**\n\nMLE 想知道，自己有多少种不同的学习安排来度过这 $n$ 天。两种学习安排不同仅当这两种安排中有至少一天学习的算法不同。因为方法可能过多，你只需要输出方案数对 $10^9+7$ 取模即可。", "test_cases": [{"input": "3 2\n1 2", "output": "4"}, {"input": "2 1\n1", "output": "0"}, {"input": "8 5\n4 2 3 4 2", "output": "356314"}, {"input": "1 1\n1\n", "output": "1"}, {"input": "5 1\n5\n", "output": "1"}], "test": "#undef NDEBUG\n#include<assert.h>\nint main(){\n    assert(solution(\"3 2\\n1 2\") == \"4\");\n    assert(solution(\"2 1\\n1\") == \"0\");\n    assert(solution(\"8 5\\n4 2 3 4 2\") == \"356314\");\n    assert(solution(\"1 1\\n1\\n\") == \"1\");\n    assert(solution(\"5 1\\n5\\n\") == \"1\");\n    return 0; \n}", "prompt": "/*During the summer vacation, there are $n$ days in total, and we assume that MLE has enough time to learn OI every day. MLE has listed $m$ available algorithms to choose from. MLE can only and must learn one algorithm every day.\n\nMoreover, MLE will get tired of learning the same algorithm for a long time, so each algorithm cannot be learned for too many consecutive days. The $i$-th algorithm can be learned for at most $a_i$ consecutive days. **MLE does not have to learn all the algorithms.**\n\nMLE wants to know how many different learning plans he has to spend these $n$ days. Two learning plans are different only if at least one day is spent learning a different algorithm. Since there may be too many plans, you only need to output the number of plans modulo $10^9+7$.\n\ninput_format:\nThe first behavior is two integers $n,m$.\nThe second row $m$is an integer $a_1,a_2,\\cdots,a_m$.\n\noutput_format:\nOutput a row of an integer, the result of modulo $10^9+7$.\n*/\n\n#include<sstream>\n#include<stdlib.h>\n#include<algorithm>\n#include<math.h>\n#include<stdio.h>\n#include<vector>\n#include<string>\n#include<climits>\n#include<cstring>\n#include<iostream>\nusing namespace std;\n\n             \nstring solution(string std_in){\n    istringstream iss(std_in);\n             ", "constraints": "### 样例解释\n\n#### 样例 \\#1\n\n第一种算法最多连续学习一天，第二种最多连续学习两天。故共有如下四种学习方式：\n\n- $1,2,2$。\n- $2,1,2$。\n- $2,2,1$。\n- $1,2,1$。\n\n#### 样例 \\#2\n\n由于唯一的一种算法最多只能连续学习一天，所以没有合法的方案可以度过 $2$ 天。\n\n---\n\n### 数据范围\n\n**本题采用捆绑测试，若无特殊说明，测试点的内存限制为 256MB。**\n\n对于所有数据，$1\\le a_i \\le n\\le 7 \\times 10^3$，$1\\le m \\le 7\\times 10^3$。\n\n| subtask | 分值 | $n,m\\le$ | 特殊限制            |\n| ------- | ---- | -------- | ------------------- |\n| $1$     | $5$  | $5$      | 无                 |\n| $2$     | $10$ | $100$    | 无                 |\n| $3$     | $15$ | $500$    | 无                 |\n| $4$     | $20$ | $7\\times 10^3$   | $a_i=1$             |\n| $5$     | $20$ | $7\\times 10^3$   | 内存限制为 $500$ MB |\n| $6$     | $30$ | $7\\times 10^3$   | 无                 |", "samples": [["3 2\n1 2", "4"], ["2 1\n1", "0"], ["8 5\n4 2 3 4 2", "356314"]], "limits": {"time": [2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000], "memory": [262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144]}}
{"task_id": "P1615", "title": "西游记公司", "difficulty": "basic", "nl": "The problem is as follows:\n\nAfter completing their journey to the West and obtaining the Buddhist sutras, Sun Wukong, Zhu Bajie, and Sha Wujing started studying economics at the Department of Economics and Trade at Xiamen University. They graduated using their special abilities after just one hour of study.\n\nThen, they founded three companies: \"Huaguoshan Ecological Tourism Resort Group Co., Ltd.\", \"Gaolaozhuang Pork Cuisine City Co., Ltd.\", and \"Liushahe Ferry Co., Ltd.\" Although these three companies were established by the disciples of Tang Sanzang, the president of the \"Scripture Publishing House,\" each company still maintained a fiscal income of less than 0 yuan.\n\nSo, they came up with a boring way to save their companies: stealing from others! Specifically, before Sun Wukong stole Zhu Bajie's frying pan, Zhu Bajie could keep grabbing Sha Wujing's notebooks.\n\nNow, as the chief strategist under Zhu Bajie, you must help the smart and foolish Zhu Bajie save this company using improper means!\n\nYou can do this: You already know when Sun Wukong will come to steal Zhu Bajie's things, and when Zhu Bajie will go to grab Sha Wujing's things. You also know that Zhu Bajie can steal n notebooks from Sha Wujing per second. Help Zhu Bajie calculate how many notebooks he can steal within a limited amount of time, so that he will have enough time to defend against his elder brother.", "code": "#include<bits/stdc++.h>//万能头文件\nusing namespace std;//标准命名空间\n\nint main(){//主程序开始\n\tlong long int h1, m1, s1, h2, m2, s2,steal;//h1、m1、s1为开始时分秒，h2、m2、s2为结束时分秒\n\tchar ch;//“：”专用变量\n    cin>>h1>>ch>>m1>>ch>>s1>>h2>>ch>>m2>>ch>>s2>>steal;//输入时间\n\tcout<<(3600*(h2 - h1)+60*(m2-m1)+(s2-s1))*steal;//输出猪八戒偷的电脑数量\n\treturn 0;//完美返回\n}//完美结束\n//ps:此题结果非常大，如果你用 int 存，第三个数据会WA。  \n//蒟蒻的第一篇题解，如有错误，欢迎指出~~~", "step": ["Declare necessary variables", "Take input of initial and final times and a value", "Calculate the duration between initial and final times in hours, minutes, and seconds", "Multiply the duration by the given value", "Print the total duration in seconds", "End the program"], "nl_cn": "事情是这样的：  \n\n西游记中的孙沙猪三徒弟在西天取经之后开始进入厦门大学经贸系学习经济，在 $1$ 个小时的学习后，他们用特殊手段毕业了。\n\n然后，他们创办了三个公司：“花果山生态旅游山庄集团公司” “高老庄猪肉美食城有限公司” 和 “流沙河轮渡有限公司”。虽然这三家公司出自 “经卷出版社” 社长唐三藏的徒弟们，但是每家公司都仍然保持着 $0$ 元以下的财政收入。  \n\n于是，他们想到了一个无聊的方法：向别人偷！其中，孙悟空偷猪八戒的平底锅之前，猪八戒可以一直抢沙和尚的笔记本。\n\n现在，作为猪八戒手下首席智士的你，要帮助既聪明又愚蠢的猪八戒用那种不正当的手段挽救这个公司！  \n\n你可以这样做：你已经知道孙悟空什么时候要来偷猪八戒的东西，而猪八戒又要在什么时间去抢沙和尚的东西，又知道猪八戒每秒钟可以偷沙和尚 $n$ 台笔记本，帮猪八戒算一算，自己在有限的时间内能偷到沙和尚多少台笔记本，使得他有足够的时间来防御大师兄。", "test_cases": [{"input": "00:0:00\n0:00:10\n10", "output": "100"}, {"input": "12:00:00\n13:00:00\n5", "output": "18000"}, {"input": "01:00:00\n02:00:00\n1", "output": "3600"}, {"input": "00:00:00\n00:00:01\n100", "output": "100"}, {"input": "12:30:00\n12:35:00\n6", "output": "1800"}, {"input": "06:00:00\n06:05:00\n12", "output": "3600"}, {"input": "12:00:00\n12:00:01\n1", "output": "1"}, {"input": "20:00:00\n21:00:00\n5", "output": "18000"}, {"input": "08:00:00\n08:30:00\n4", "output": "7200"}, {"input": "10:00:00\n10:00:01\n1000", "output": "1000"}, {"input": "00:00:00\n00:00:03\n50", "output": "150"}, {"input": "09:00:00\n10:00:00\n10", "output": "36000"}, {"input": "11:30:00\n11:30:01\n1000", "output": "1000"}, {"input": "01:00:00\n02:00:00\n5\n", "output": "18000"}, {"input": "12:34:56\n12:35:00\n1\n", "output": "4"}, {"input": "00:05:00\n00:06:00\n60\n", "output": "3600"}, {"input": "06:30:00\n07:30:00\n8\n", "output": "28800"}, {"input": "23:00:00\n23:01:00\n1\n", "output": "60"}, {"input": "05:00:00\n05:15:00\n20\n", "output": "18000"}, {"input": "20:00:00\n20:01:00\n30\n", "output": "1800"}, {"input": "08:00:00\n08:00:05\n1000\n", "output": "5000"}, {"input": "07:30:30\n08:30:30\n9\n", "output": "32400"}, {"input": "17:00:00\n18:00:00\n4\n", "output": "14400"}, {"input": "12:00:00\n12:00:02\n100", "output": "200"}, {"input": "00:00:00\n00:01:00\n60", "output": "3600"}, {"input": "00:00:00\n23:59:59\n0", "output": "0"}, {"input": "01:01:01\n01:01:01\n10", "output": "0"}, {"input": "12:00:01\n12:00:01\n1", "output": "0"}, {"input": "01:01:01\n02:02:02\n0", "output": "0"}, {"input": "10:00:00\n10:02:00\n0", "output": "0"}, {"input": "12:00:00\n12:00:02\n0", "output": "0"}, {"input": "23:59:59\n00:00:01\n0", "output": "0"}, {"input": "00:00:00\n00:01:00\n0", "output": "0"}], "test": "#undef NDEBUG\n#include<assert.h>\nint main(){\n    assert(solution(\"00:0:00\\n0:00:10\\n10\") == \"100\");\n    assert(solution(\"12:00:00\\n13:00:00\\n5\") == \"18000\");\n    assert(solution(\"01:00:00\\n02:00:00\\n1\") == \"3600\");\n    assert(solution(\"00:00:00\\n00:00:01\\n100\") == \"100\");\n    assert(solution(\"12:30:00\\n12:35:00\\n6\") == \"1800\");\n    assert(solution(\"06:00:00\\n06:05:00\\n12\") == \"3600\");\n    assert(solution(\"12:00:00\\n12:00:01\\n1\") == \"1\");\n    assert(solution(\"20:00:00\\n21:00:00\\n5\") == \"18000\");\n    assert(solution(\"08:00:00\\n08:30:00\\n4\") == \"7200\");\n    assert(solution(\"10:00:00\\n10:00:01\\n1000\") == \"1000\");\n    assert(solution(\"00:00:00\\n00:00:03\\n50\") == \"150\");\n    assert(solution(\"09:00:00\\n10:00:00\\n10\") == \"36000\");\n    assert(solution(\"11:30:00\\n11:30:01\\n1000\") == \"1000\");\n    assert(solution(\"01:00:00\\n02:00:00\\n5\\n\") == \"18000\");\n    assert(solution(\"12:34:56\\n12:35:00\\n1\\n\") == \"4\");\n    assert(solution(\"00:05:00\\n00:06:00\\n60\\n\") == \"3600\");\n    assert(solution(\"06:30:00\\n07:30:00\\n8\\n\") == \"28800\");\n    assert(solution(\"23:00:00\\n23:01:00\\n1\\n\") == \"60\");\n    assert(solution(\"05:00:00\\n05:15:00\\n20\\n\") == \"18000\");\n    assert(solution(\"20:00:00\\n20:01:00\\n30\\n\") == \"1800\");\n    assert(solution(\"08:00:00\\n08:00:05\\n1000\\n\") == \"5000\");\n    assert(solution(\"07:30:30\\n08:30:30\\n9\\n\") == \"32400\");\n    assert(solution(\"17:00:00\\n18:00:00\\n4\\n\") == \"14400\");\n    assert(solution(\"12:00:00\\n12:00:02\\n100\") == \"200\");\n    assert(solution(\"00:00:00\\n00:01:00\\n60\") == \"3600\");\n    assert(solution(\"00:00:00\\n23:59:59\\n0\") == \"0\");\n    assert(solution(\"01:01:01\\n01:01:01\\n10\") == \"0\");\n    assert(solution(\"12:00:01\\n12:00:01\\n1\") == \"0\");\n    assert(solution(\"01:01:01\\n02:02:02\\n0\") == \"0\");\n    assert(solution(\"10:00:00\\n10:02:00\\n0\") == \"0\");\n    assert(solution(\"12:00:00\\n12:00:02\\n0\") == \"0\");\n    assert(solution(\"23:59:59\\n00:00:01\\n0\") == \"0\");\n    assert(solution(\"00:00:00\\n00:01:00\\n0\") == \"0\");\n    return 0; \n}", "prompt": "/*The problem is as follows:\n\nAfter completing their journey to the West and obtaining the Buddhist sutras, Sun Wukong, Zhu Bajie, and Sha Wujing started studying economics at the Department of Economics and Trade at Xiamen University. They graduated using their special abilities after just one hour of study.\n\nThen, they founded three companies: \"Huaguoshan Ecological Tourism Resort Group Co., Ltd.\", \"Gaolaozhuang Pork Cuisine City Co., Ltd.\", and \"Liushahe Ferry Co., Ltd.\" Although these three companies were established by the disciples of Tang Sanzang, the president of the \"Scripture Publishing House,\" each company still maintained a fiscal income of less than 0 yuan.\n\nSo, they came up with a boring way to save their companies: stealing from others! Specifically, before Sun Wukong stole Zhu Bajie's frying pan, Zhu Bajie could keep grabbing Sha Wujing's notebooks.\n\nNow, as the chief strategist under Zhu Bajie, you must help the smart and foolish Zhu Bajie save this company using improper means!\n\nYou can do this: You already know when Sun Wukong will come to steal Zhu Bajie's things, and when Zhu Bajie will go to grab Sha Wujing's things. You also know that Zhu Bajie can steal n notebooks from Sha Wujing per second. Help Zhu Bajie calculate how many notebooks he can steal within a limited amount of time, so that he will have enough time to defend against his elder brother.\n\ninput_format:\nThe first line: a time, time: minute: second form, indicating the time when Zhu Bajie plans to steal the notebook of the sand monk;\n\nThe second line: a time, time: minute: second form, indicating the time when Sun Wukong intends to steal the pig Bajie pan.\n\n** Note: Time may or may not have a leading zero. **\n\nThe third line: a line of an integer $n$, indicating that pig Bajie can steal the number of sand monk's notebook in one second.\n\nMake sure the first row is earlier than the second row.\n\noutput_format:\nAn integer, indicating the number of Zhubajie can steal the sand monk's notebook.\n*/\n\n#include<sstream>\n#include<stdlib.h>\n#include<algorithm>\n#include<math.h>\n#include<stdio.h>\n#include<vector>\n#include<string>\n#include<climits>\n#include<cstring>\n#include<iostream>\nusing namespace std;\n\n             \nstring solution(string std_in){\n    istringstream iss(std_in);\n             ", "constraints": "对于 $100\\%$ 的数据，保证两个时间合法，$n<32768$。", "samples": [["00:0:00\n0:00:10\n10", "100"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000]}}
{"task_id": "P1596", "title": "[USACO10OCT]Lake Counting S", "difficulty": "challenge", "nl": "Due to recent rainfall, Farmer John's field has accumulated water, which can be represented as an N x M (1 <= N <= 100; 1 <= M <= 100) grid of squares. Each square contains either water ('W') or dry land ('.'). Farmer John wants to determine how many puddles have formed in his field. A puddle is a connected group of squares containing water, where each square is considered adjacent to its eight neighbors. Given a metaphor for Farmer John's field, determine how many puddles he has.", "code": "#include<cstdio>\nusing namespace std;\nchar a[101][101];\nint ans;\nint n,m;\nvoid dfs(int x,int y){\n    a[x][y]='.';\n    int dx,dy;\n    for(int i=-1;i<=1;i++){\n        for(int j=-1;j<=1;j++){\n            dx=x+i;\n            dy=y+j;\n            if(dx>=0&&dx<=n&&dy>=0&&dy<m&&a[dx][dy]=='W'){\n                dfs(dx,dy);\n            }\n        }\n    }\n    return;\n} \nint main(){\n    scanf(\"%d%d\",&n,&m);\n    for(int i=0;i<=n;i++){\n    \tscanf(\"%s\",a[i]);//避免换行带来问题这里直接读入字符串\n    }\n    for(int i=0;i<=n;i++){\n        for(int j=0;j<m;j++){\n            if(a[i][j]=='W'){//如果是W的话就直接开始遍历\n                dfs(i,j);\n                ans++;//水潭加一处\n            }\n        }\n    }\n    printf(\"%d\",ans);\n    return 0;\n}", "step": ["Initialize variables and read input values.", "Read the matrix containing the water bodies.", "Iterate through the entire matrix, check for 'W' characters and apply DFS on them to calculate the connected water bodies.", "Return the final number of connected water bodies."], "nl_cn": "Due to recent rains, water has pooled in various places in Farmer John's field, which is represented by a rectangle of N x M (1 <= N <= 100; 1 <= M <= 100) squares. Each square contains either water ('W') or dry land ('.'). Farmer John would like to figure out how many ponds have formed in his field. A pond is a connected set of squares with water in them, where a square is considered adjacent to all eight of its neighbors. Given a diagram of Farmer John's field, determine how many ponds he has.\n\n\n\n\n", "test_cases": [{"input": "10 12\nW........WW.\n.WWW.....WWW\n....WW...WW.\n.........WW.\n.........W..\n..W......W..\n.W.W.....WW.\nW.W.W.....W.\n.W.W......W.\n..W.......W.\n", "output": "3"}, {"input": "4 4\n....\n.WW.\n.WW.\n....\n", "output": "1"}, {"input": "3 3\nWWW\nWWW\nWWW\n", "output": "1"}, {"input": "2 2\nW.\n.W\n", "output": "1"}, {"input": "1 1\nW\n", "output": "1"}, {"input": "2 3\nWW.\nWW.\n", "output": "1"}, {"input": "1 5\nWWWWW\n", "output": "1"}, {"input": "4 1\nW\nW\n.\nW\n", "output": "2"}, {"input": "2 2\n..\nWW\n", "output": "1"}, {"input": "5 5\n.....\n.....\n.....\n.....\n.....\n", "output": "0"}, {"input": "4 4\n....\n.W..\n...W\n....\n", "output": "2"}, {"input": "5 4\nW..\nW..\nW..\nW..\nW..\n", "output": "1"}, {"input": "5 5\nWWWWW\nWWWWW\nWWWWW\nWWWWW\nWWWWW\n", "output": "1"}, {"input": "2 3\nWWW\nWWW\n", "output": "1"}, {"input": "3 2\nWW\nWW\nWW\n", "output": "1"}, {"input": "2 2\n..\n..\n", "output": "0"}, {"input": "5 5\nWWWWW\nW..WW\nWW.W.\n..W.W\n.W...\n", "output": "1"}, {"input": "3 3\nWWW\nW.W\nWW.\n", "output": "1"}, {"input": "1 10\nWW........\n", "output": "1"}, {"input": "3 3\nWWW\n.W.\nWWW\n", "output": "1"}, {"input": "4 4\nWWWW\nW.W.\nW.W.\n....\n", "output": "1"}, {"input": "5 1\nW\n.\n.\n.\nW\n", "output": "2"}, {"input": "2 2\nWW\nWW\n", "output": "1"}, {"input": "4 4\n....\n....\n....\nWWWW\n", "output": "1"}], "test": "#undef NDEBUG\n#include<assert.h>\nint main(){\n    assert(solution(\"10 12\\nW........WW.\\n.WWW.....WWW\\n....WW...WW.\\n.........WW.\\n.........W..\\n..W......W..\\n.W.W.....WW.\\nW.W.W.....W.\\n.W.W......W.\\n..W.......W.\\n\") == \"3\");\n    assert(solution(\"4 4\\n....\\n.WW.\\n.WW.\\n....\\n\") == \"1\");\n    assert(solution(\"3 3\\nWWW\\nWWW\\nWWW\\n\") == \"1\");\n    assert(solution(\"2 2\\nW.\\n.W\\n\") == \"1\");\n    assert(solution(\"1 1\\nW\\n\") == \"1\");\n    assert(solution(\"2 3\\nWW.\\nWW.\\n\") == \"1\");\n    assert(solution(\"1 5\\nWWWWW\\n\") == \"1\");\n    assert(solution(\"4 1\\nW\\nW\\n.\\nW\\n\") == \"2\");\n    assert(solution(\"2 2\\n..\\nWW\\n\") == \"1\");\n    assert(solution(\"5 5\\n.....\\n.....\\n.....\\n.....\\n.....\\n\") == \"0\");\n    assert(solution(\"4 4\\n....\\n.W..\\n...W\\n....\\n\") == \"2\");\n    assert(solution(\"5 4\\nW..\\nW..\\nW..\\nW..\\nW..\\n\") == \"1\");\n    assert(solution(\"5 5\\nWWWWW\\nWWWWW\\nWWWWW\\nWWWWW\\nWWWWW\\n\") == \"1\");\n    assert(solution(\"2 3\\nWWW\\nWWW\\n\") == \"1\");\n    assert(solution(\"3 2\\nWW\\nWW\\nWW\\n\") == \"1\");\n    assert(solution(\"2 2\\n..\\n..\\n\") == \"0\");\n    assert(solution(\"5 5\\nWWWWW\\nW..WW\\nWW.W.\\n..W.W\\n.W...\\n\") == \"1\");\n    assert(solution(\"3 3\\nWWW\\nW.W\\nWW.\\n\") == \"1\");\n    assert(solution(\"1 10\\nWW........\\n\") == \"1\");\n    assert(solution(\"3 3\\nWWW\\n.W.\\nWWW\\n\") == \"1\");\n    assert(solution(\"4 4\\nWWWW\\nW.W.\\nW.W.\\n....\\n\") == \"1\");\n    assert(solution(\"5 1\\nW\\n.\\n.\\n.\\nW\\n\") == \"2\");\n    assert(solution(\"2 2\\nWW\\nWW\\n\") == \"1\");\n    assert(solution(\"4 4\\n....\\n....\\n....\\nWWWW\\n\") == \"1\");\n    return 0; \n}", "prompt": "/*Due to recent rainfall, Farmer John's field has accumulated water, which can be represented as an N x M (1 <= N <= 100; 1 <= M <= 100) grid of squares. Each square contains either water ('W') or dry land ('.'). Farmer John wants to determine how many puddles have formed in his field. A puddle is a connected group of squares containing water, where each square is considered adjacent to its eight neighbors. Given a metaphor for Farmer John's field, determine how many puddles he has.\n\ninput_format:\nLine 1: Two space-separated integers: N and M \\* Lines 2.. N+1: M characters per line representing one row of Farmer John's field. Each character is either 'W' or '.'. The characters do not have spaces between them.\n\noutput_format:\nLine 1: The number of ponds in Farmer John's field.\n*/\n\n#include<sstream>\n#include<stdlib.h>\n#include<algorithm>\n#include<math.h>\n#include<stdio.h>\n#include<vector>\n#include<string>\n#include<climits>\n#include<cstring>\n#include<iostream>\nusing namespace std;\n\n             \nstring solution(string std_in){\n    istringstream iss(std_in);\n             ", "constraints": "OUTPUT DETAILS: There are three ponds: one in the upper left, one in the lower left, and one along the right side.\n", "samples": [["10 12\nW........WW.\n.WWW.....WWW\n....WW...WW.\n.........WW.\n.........W..\n..W......W..\n.W.W.....WW.\nW.W.W.....W.\n.W.W......W.\n..W.......W.\n", "3\n"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}}
{"task_id": "P3082", "title": "[USACO13MAR] Necklace G", "difficulty": "advanced", "nl": "Bessie collected N stones with letters on them and wants to make a fashionable necklace with them. She values her possessions greatly and doesn't want to share her necklace with other cows that live in the barn on her side. One of these cows has a string of M characters as a name, and Bessie wants to ensure that this name of length M does not appear as a continuous substring in her necklace at any position. Bessie decides to remove some stones from her necklace so that the other cow's name does not appear as a substring. Help Bessie determine the minimum number of stones she must remove.", "code": "#include <bits/stdc++.h>\n#define ll long long\n#define IOS ios::sync_with_stdio(false); cin.tie(0); cout.tie(0);\nconst int N = 10005;\nconst int M = 1005;\nconst int inf = 1e9 + 5;\nusing namespace std;\n\nchar S[N], T[M];\nint n, m ;\nint f[N][M];\nint g[M][32];\n\nint pmt[N];\n\n\nint main()\n{\n    cin >> S + 1 >> T + 1;\n    n = strlen(S + 1), m = strlen(T + 1);\n\n    for (int i = 2, j = 0; i <= m; i++) {\n        while (j && T[j + 1] != T[i]) j = pmt[j];\n        if (T[j + 1] == T[i]) j++;\n        pmt[i] = j;\n    }\n    for (int i = 0; i < m; i++)\n        for (int j = 0; j < 26; j++)\n            if (T[i + 1] == (char)(j + 'a'))\n                g[i][j] = i + 1;\n            else\n                g[i][j] = g[pmt[i]][j];\n    \n    for (int i = 1; i <= n; i++)\n        for (int j = 0; j < m; j++) // caution m!\n            f[i][j] = inf;\n    \n    f[1][g[0][S[1] - 'a']] = 0;\n    f[1][0] = min(f[1][0], 1);\n    for (int i = 1; i <= n; i++) {\n        for (int j = 0; j < m; j++) { // ! caution\n            f[i + 1][j] = min(f[i + 1][j], f[i][j] + 1);\n            f[i + 1][g[j][S[i + 1] - 'a']] = min(f[i + 1][g[j][S[i + 1] - 'a']], f[i][j]);\n        }\n    }\n    int ans = inf;\n    for (int j = 0; j < m; j++)\n        ans = min(ans, f[n][j]);\n    cout << ans << endl;\n    return 0;\n}", "step": ["Take input of strings and their lengths.", "Find the prefix array of the substring that's not present.", "Compute the DP table to find the longest common substring.", "Output the length of the shortest substring that's not common between the two strings."], "nl_cn": "Bessie the cow has arranged a string of N rocks, each containing a single letter of the alphabet, that she wants to build into a fashionable necklace.\n\nBeing protective of her belongings, Bessie does not want to share her necklace with the other cow currently living on her side of the barn.  The other cow has a name that is a string of M characters, and Bessie wants to be sure that this length-M string does not occur as a contiguous substring anywhere within the string representing her necklace (otherwise, the other cow might mistakenly think the necklace is for her).  Bessie decides to remove some of the rocks in her necklace so that the other cow's name does not appear as a substring.  Please help Bessie determine the minimum number of rocks she must remove.\n\n贝西收集了N颗石头，每颗石头上都有一个字母，贝西想把这些石头做成项链。\n\n贝西的身边有另一只奶牛，这只奶牛的名字是一个长度为M的字符串，贝西不希望这只牛的名字出现在她的项链上(项链的子串)，她想知道，最少删掉几颗石头就可以避免这种情况发生。\n", "test_cases": [{"input": "ababaa \naba \n", "output": "1"}, {"input": "xyzxyz \nxy \n", "output": "2"}, {"input": "aaa \naaaaa \n", "output": "0"}, {"input": "abcabc \nabc \n", "output": "2"}, {"input": "xyz \nabcdefg \n", "output": "0"}, {"input": "ab \nababab \n", "output": "0"}, {"input": "a a \na \n", "output": "1"}, {"input": "xyzxyz \nxyz \n", "output": "2"}, {"input": "xyyx \nxyy \n", "output": "1"}, {"input": "xyzxyzxyz \nxyz \n", "output": "3"}, {"input": "abababa \nbab \n", "output": "1"}], "test": "#undef NDEBUG\n#include<assert.h>\nint main(){\n    assert(solution(\"ababaa \\naba \\n\") == \"1\");\n    assert(solution(\"xyzxyz \\nxy \\n\") == \"2\");\n    assert(solution(\"aaa \\naaaaa \\n\") == \"0\");\n    assert(solution(\"abcabc \\nabc \\n\") == \"2\");\n    assert(solution(\"xyz \\nabcdefg \\n\") == \"0\");\n    assert(solution(\"ab \\nababab \\n\") == \"0\");\n    assert(solution(\"a a \\na \\n\") == \"1\");\n    assert(solution(\"xyzxyz \\nxyz \\n\") == \"2\");\n    assert(solution(\"xyyx \\nxyy \\n\") == \"1\");\n    assert(solution(\"xyzxyzxyz \\nxyz \\n\") == \"3\");\n    assert(solution(\"abababa \\nbab \\n\") == \"1\");\n    return 0; \n}", "prompt": "/*Bessie collected N stones with letters on them and wants to make a fashionable necklace with them. She values her possessions greatly and doesn't want to share her necklace with other cows that live in the barn on her side. One of these cows has a string of M characters as a name, and Bessie wants to ensure that this name of length M does not appear as a continuous substring in her necklace at any position. Bessie decides to remove some stones from her necklace so that the other cow's name does not appear as a substring. Help Bessie determine the minimum number of stones she must remove.\n\ninput_format:\n\\* Line 1: The first line is a length-N string describing Bessie's initial necklace; each character is in the range \"a\" through \"z\".\n\n\\* Line 2: The second line is the length-M name of the other cow in the barn, also made of characters from \"a\" to \"z\".\n\noutput_format:\n\\* Line 1: The minimum number of stones that need to be removed from Bessie's necklace so that it does not contain the name of the other cow as a substring.\n*/\n\n#include<sstream>\n#include<stdlib.h>\n#include<algorithm>\n#include<math.h>\n#include<stdio.h>\n#include<vector>\n#include<string>\n#include<climits>\n#include<cstring>\n#include<iostream>\nusing namespace std;\n\n             \nstring solution(string std_in){\n    istringstream iss(std_in);\n             ", "constraints": "```cpp\nFor at least 20% of test cases, N <= 20. \nFor at least 60% of test cases, N <= 1000, M <= 100. \nFor all test cases, N <= 10000, M <= 1000. \nFor all test cases, M <= N. \n```\nThe modified necklace should be \"abbaa\".\n\n---\n\n$\\text{upd 2022.7.29}$：新增加一组 Hack 数据。", "samples": [["ababaa \naba \n", "1 \n"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072]}}
{"task_id": "P1243", "title": "排序集合", "difficulty": "challenge", "nl": "The problem is described in Chinese on a programming website, and it is divided by ````` into multiple lines. \n\nFor a subset of set $N=\\{1,2,\\cdots,n\\}$, a relationship called \"less than\" is defined as follows: \n\nLet $S1=\\{X_1,X_2,\\cdots,X_i\\}$, $(X_1<X_2<\\cdots<X_i)$, $S2=\\{Y_1,Y_2,\\cdots,Y_j\\}$, $(Y_1<Y_2<\\cdots<Y_j)$. If there exists a $k$ $(0\\leq k\\leq \\min(i,j))$ such that $X_1=Y_1,\\cdots,X_k=Y_k$ and $k=i$ or $X_{k+1}<Y_{k+1}$, then $S1$ is said to be \"less than\" $S2$. \n\nYour task is to find the $k$-th smallest subset for any $n(n\\leq 31)$ and $k(k<2^n)$.", "code": "#include<bits/stdc++.h>\nusing namespace std;\nint n,k;\nint main()\n{\n\tscanf(\"%d%d\",&n,&k);\n\tif(k==1)\n\t{\n\t\tprintf(\"0\\n\");\n\t\treturn 0;\n\t}\n\tk--;\n\tfor(int i=1;i<=n;i++)\n\t{\n\t\tif(k==0)\n\t\t{\n\t\t\tbreak;\n\t\t}\n\t\tif(k<=pow(2,n-i))\n\t\t{\n\t\t\tprintf(\"%d \",i);\n\t\t\tk--;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tk-=pow(2,n-i);\n\t\t}\n\t\t\n\t}\n\t\n}", "step": ["Initialize the variables n and k.", "If k is 1, print 0 and return.", "Decrement k by 1.", "Iterate from 1 to n.", "If k is 0, break the loop.", "If k is less than or equal to 2 to the power of n-i, print i and decrement k. Otherwise, subtract 2 to the power of n-i from k."], "nl_cn": "对于集合$N=\\{1,2,\\cdots ,n\\}$的子集，定义一个称之为“小于”的关系：\n\n设$S1=\\{X_1,X_2,\\cdots,X_i\\}$，$(X_1<X_2<\\cdots <X_i)$，$S2=\\{Y_1, Y_2, \\cdots ,Y_j\\}$，$(Y_1<Y_2<\\cdots<Y_j)$，如果存在一个$k$，$(0\\leq k\\leq \\min(i,j))$，使得$X_1=Y_1,\\cdots,X_k=Y_k$，且$k=i$或$X_{k+1}<Y_{k+1}$，则称$S1$“小于”$S2$。\n\n你的任务是，对于任意的$n(n\\leq 31)$及$k(k<2^n)$，求出第k小的子集。\n", "test_cases": [{"input": "3 4\n", "output": "1 2 3"}, {"input": "1 1\n", "output": "0"}, {"input": "2 3\n", "output": "1 2"}, {"input": "3 1\n", "output": "0"}, {"input": "4 1\n", "output": "0"}, {"input": "4 5\n", "output": "1 2 3 4"}, {"input": "2 1\n", "output": "0"}, {"input": "2 2\n", "output": "1"}, {"input": "3 2\n", "output": "1"}, {"input": "3 3\n", "output": "1 2"}, {"input": "4 2\n", "output": "1"}, {"input": "4 3\n", "output": "1 2"}, {"input": "4 4\n", "output": "1 2 3"}, {"input": "5 1\n", "output": "0"}, {"input": "5 2\n", "output": "1"}, {"input": "5 3\n", "output": "1 2"}, {"input": "5 4\n", "output": "1 2 3"}, {"input": "5 5\n", "output": "1 2 3 4"}, {"input": "5 6\n", "output": "1 2 3 4 5"}], "test": "#undef NDEBUG\n#include<assert.h>\nint main(){\n    assert(solution(\"3 4\\n\") == \"1 2 3\");\n    assert(solution(\"1 1\\n\") == \"0\");\n    assert(solution(\"2 3\\n\") == \"1 2\");\n    assert(solution(\"3 1\\n\") == \"0\");\n    assert(solution(\"4 1\\n\") == \"0\");\n    assert(solution(\"4 5\\n\") == \"1 2 3 4\");\n    assert(solution(\"2 1\\n\") == \"0\");\n    assert(solution(\"2 2\\n\") == \"1\");\n    assert(solution(\"3 2\\n\") == \"1\");\n    assert(solution(\"3 3\\n\") == \"1 2\");\n    assert(solution(\"4 2\\n\") == \"1\");\n    assert(solution(\"4 3\\n\") == \"1 2\");\n    assert(solution(\"4 4\\n\") == \"1 2 3\");\n    assert(solution(\"5 1\\n\") == \"0\");\n    assert(solution(\"5 2\\n\") == \"1\");\n    assert(solution(\"5 3\\n\") == \"1 2\");\n    assert(solution(\"5 4\\n\") == \"1 2 3\");\n    assert(solution(\"5 5\\n\") == \"1 2 3 4\");\n    assert(solution(\"5 6\\n\") == \"1 2 3 4 5\");\n    return 0; \n}", "prompt": "/*The problem is described in Chinese on a programming website, and it is divided by ````` into multiple lines. \n\nFor a subset of set $N=\\{1,2,\\cdots,n\\}$, a relationship called \"less than\" is defined as follows: \n\nLet $S1=\\{X_1,X_2,\\cdots,X_i\\}$, $(X_1<X_2<\\cdots<X_i)$, $S2=\\{Y_1,Y_2,\\cdots,Y_j\\}$, $(Y_1<Y_2<\\cdots<Y_j)$. If there exists a $k$ $(0\\leq k\\leq \\min(i,j))$ such that $X_1=Y_1,\\cdots,X_k=Y_k$ and $k=i$ or $X_{k+1}<Y_{k+1}$, then $S1$ is said to be \"less than\" $S2$. \n\nYour task is to find the $k$-th smallest subset for any $n(n\\leq 31)$ and $k(k<2^n)$.\n\ninput_format:\nThe input file is a single line containing two natural numbers separated by Spaces, $n$and $k$.\n\noutput_format:\nThe output file is only one line, so that the elements of this subset are arranged from smallest to largest. Empty set output $0$.\n*/\n\n#include<sstream>\n#include<stdlib.h>\n#include<algorithm>\n#include<math.h>\n#include<stdio.h>\n#include<vector>\n#include<string>\n#include<climits>\n#include<cstring>\n#include<iostream>\nusing namespace std;\n\n             \nstring solution(string std_in){\n    istringstream iss(std_in);\n             ", "constraints": "", "samples": [["3 4\n", "1 2 3\n"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}}
{"task_id": "P2693", "title": "[USACO1.3]号码锁 Combination Lock", "difficulty": "challenge", "nl": "Farmer John's cows keep escaping from his farm, causing a lot of damage. To prevent them from escaping, he purchased a large combination lock to secure the gate.\n\nKnowing his cows are clever, Farmer John wants to ensure that they cannot easily open the lock by simply trying many different combinations. The lock has three dials, each with numbers $1$ to $n$, where $1$ and $n$ are adjacent because the dials are circular. Two combinations can open the lock: one set by Farmer John and another \"preset\" combination set by a locksmith. However, the lock has some tolerance, so the lock will still open if the numbers on each dial differ by at most $2$ from the corresponding number in the valid combination.\n\nFor example, if Farmer John's combination is ($1$,$2$,$3$) and the preset combination is ($4$,$5$,$6$), then the lock can be opened with the combination ($1$,$4$,$5$) (because it's close enough to Farmer John's combination) or ($2$,$4$,$8$) (because it's close enough to the preset combination); it cannot be opened with the combination ($1$,$5$,$6$) because it's not close enough to any valid combination.\n\nGiven Farmer John's combination and the preset combination, please calculate the number of different combinations that can open the lock. The numbers on each dial are ordered, so ($1$,$2$,$3$) and ($3$,$2$,$1$) are considered different combinations.", "code": "#include<bits/stdc++.h>//万能头文件\nusing namespace std;\nint main(){\n    int n,a,b,c,d,e,f,i,j,k,sum=0;\n    cin>>n;\n    cin>>a>>b>>c>>d>>e>>f;\n    for(i=1;i<=n;++i)\n        for(j=1;j<=n;++j)\n            for(k=1;k<=n;++k)  //循环查找符合情况\n        if(((abs(i-a)<=2||abs(i-a)>=n-2)&&(abs(j-b)<=2||abs(j-b)>=n-2)&&(abs(k-c)<=2||abs(k-c)>=n-2))||((abs(i-d)<=2||abs(i-d)>=n-2)&&(abs(j-e)<=2||abs(j-e)>=n-2)&&(abs(k-f)<=2||abs(k-f)>=n-2)))sum++;\n    //判断是否满足打开情况    \n            cout<<sum;//输出情况数\n            return 0;\n}", "step": ["Read in n value.", "Read in numbers for two arrays.", "If n < 5, output a result and return 0.", "Perform a calculation using the input values.", "Output the result of the calculation."], "nl_cn": "农夫约翰的奶牛不停地从他的农场中逃出来，导致了很多损害。为了防止它们再逃出来，他买了一只很大的号码锁以防止奶牛们打开牧场的门。\n\n农夫约翰知道他的奶牛很聪明，所以他希望确保它们不会在简单地试了很多不同的号码组合之后就能轻易开锁。锁上有三个转盘，每个上面有数字 $1$ ~ $n$，因为转盘是圆的，所以 $1$ 和 $n$ 是相邻的。有两种能开锁的号码组合，一种是农夫约翰设定的，还有一种“预设”号码组合是锁匠设定的。但是，锁有一定的容错性，所以，在每个转盘上的数字都与一个合法的号码组合中相应的数字相距两个位置以内时，锁也会打开。\n\n比如说，如果农夫约翰的号码组合是 ( $1$ , $2$ , $3$ )，预设号码组合是 ( $4$ , $5$ , $6$ )，在转盘被设定为 ( $1$ , $4$ , $5$)（因为这和农夫约翰的号码组合足够接近）或 ( $2$ , $4$ , $8$ )（因为这和预设号码组合足够接近）时可以打开锁。注意，( $1$ , $5$ , $6$ )并不会打开锁，因为它与任一号码组合都不够接近。\n\n给出农夫约翰的号码组合和预设号码组合，请计算能够开锁的不同的号码组合的数目。号码是有序的，所以 ( $1$ , $2$ , $3$ ) 与 ( $3$ , $2$ , $1$ ) 不同。\n", "test_cases": [{"input": "50\n1 2 3\n5 6 7\n", "output": "249"}, {"input": "25\n3 4 5\n18 19 20\n", "output": "250"}, {"input": "35\n12 13 14\n5 6 7\n", "output": "250"}, {"input": "45\n5 5 5\n10 10 10\n", "output": "250"}, {"input": "16\n4 6 8\n12 14 16\n", "output": "250"}], "test": "#undef NDEBUG\n#include<assert.h>\nint main(){\n    assert(solution(\"50\\n1 2 3\\n5 6 7\\n\") == \"249\");\n    assert(solution(\"25\\n3 4 5\\n18 19 20\\n\") == \"250\");\n    assert(solution(\"35\\n12 13 14\\n5 6 7\\n\") == \"250\");\n    assert(solution(\"45\\n5 5 5\\n10 10 10\\n\") == \"250\");\n    assert(solution(\"16\\n4 6 8\\n12 14 16\\n\") == \"250\");\n    return 0; \n}", "prompt": "/*Farmer John's cows keep escaping from his farm, causing a lot of damage. To prevent them from escaping, he purchased a large combination lock to secure the gate.\n\nKnowing his cows are clever, Farmer John wants to ensure that they cannot easily open the lock by simply trying many different combinations. The lock has three dials, each with numbers $1$ to $n$, where $1$ and $n$ are adjacent because the dials are circular. Two combinations can open the lock: one set by Farmer John and another \"preset\" combination set by a locksmith. However, the lock has some tolerance, so the lock will still open if the numbers on each dial differ by at most $2$ from the corresponding number in the valid combination.\n\nFor example, if Farmer John's combination is ($1$,$2$,$3$) and the preset combination is ($4$,$5$,$6$), then the lock can be opened with the combination ($1$,$4$,$5$) (because it's close enough to Farmer John's combination) or ($2$,$4$,$8$) (because it's close enough to the preset combination); it cannot be opened with the combination ($1$,$5$,$6$) because it's not close enough to any valid combination.\n\nGiven Farmer John's combination and the preset combination, please calculate the number of different combinations that can open the lock. The numbers on each dial are ordered, so ($1$,$2$,$3$) and ($3$,$2$,$1$) are considered different combinations.\n\ninput_format:\nThe first line of the input is an integer $n$, representing the number of digits on the lock.\n\nThe second line of the input consists of three integers $x, y, z$, representing Farmer John's combination.\n\nThe third line of the input consists of three integers $a, b, c$, representing the preset combination.\n\noutput_format:\nThe output line is an integer representing the number of combinations that can be unlocked.\n*/\n\n#include<sstream>\n#include<stdlib.h>\n#include<algorithm>\n#include<math.h>\n#include<stdio.h>\n#include<vector>\n#include<string>\n#include<climits>\n#include<cstring>\n#include<iostream>\nusing namespace std;\n\n             \nstring solution(string std_in){\n    istringstream iss(std_in);\n             ", "constraints": "#### 输入输出样例 1 解释\n\n每个转盘的标号是 $1$ ~ $50$。农夫约翰的号码组合是 ( $1$ , $2$ , $3$ )，预设号码组合是 ( $5$ , $6$ , $7$ )。\n\n#### 数据规模与约定\n\n对于 $100\\%$ 的数据，保证 $1 \\leq n \\leq 100$，$1 \\leq x, y, z, a, b, c \\leq n$。", "samples": [["50\n1 2 3\n5 6 7\n", "249"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}}
{"task_id": "P6051", "title": "[RC-02] 求和", "difficulty": "challenge", "nl": "Little Q gives you several lines of strings, which may contain some integers with other characters in between. You need to output the sum of all integers in each line. If there is no number in a line, then do not output anything. **There is always a space or a period between any two integers (see Example 3).**\n\nNote that all integers in the input are simple integers, i.e., there are no extra signs in front of the integers. If there is a period, it should be treated as a delimiter.", "code": "#include<bits/stdc++.h>\nusing namespace std;\nstring s;\nint n,sum;\nbool flag,f;\nint main()\n{\n    while(getline(cin,s)){\n    \tn=sum=0;\n    \tflag=false;\n    \tf=false;\n    \tfor(int i=0;i<s.size();i++){\n    \t\tif(s[i]>='0'&&s[i]<='9') f=true;//判断字符串有没有数字\n    \t\tif(s[i-1]>='0'&&s[i-1]<='9'&&(s[i]<'0'||s[i]>'9')) continue;//数字在前面且该字符不是数字，跳过字符\n    \t\tif(s[i]=='-'&&s[i+1]>='0'&&s[i+1]<='9') flag=true;//判断是否为负数\n    \t\tif(s[i]>='0'&&s[i]<='9'){//如果为数字，保存到计数器里\n    \t\t\tn=n*10+(s[i]-'0');\n    \t\t\tif(s[i+1]<'0'||s[i+1]>'9'){\n    \t\t\t\tif(flag==true) n=-n,flag=false;\n    \t\t\t\tsum+=n,n=0;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif(f==true) cout<<sum<<endl;\n\t}\n    return 0;\n}", "step": ["Read input from user using getline() method.", "Initialize n and sum variables to 0 and flags to false.", "Iterate through each character of input and check if it is a digit or not.", "If it is a digit, convert it to an integer and add it to a running total n.", "If a non-digit character is encountered after a series of digits, add the running total n to the main sum and reset n to 0.", "If the current line has at least one digit, print the sum of all digits in the line."], "nl_cn": "小 Q 给你了几行字符串，字符串中间包含有一些整数，整数之间可能会有其他字符。你需要输出每行中所有整数的和。如果一个行里面一个数都没有则不要输出。**每两个整数之间一定有间隔字符（见样例 $3$）。**\n\n请注意，题目中的整数都是简单的整数，即：整数前面没有多余的符号。假如数据中有 `.`，视作分隔符。", "test_cases": [{"input": "su57jdkjth54hjsns-321d 8 ejre\nerg(&-^%\n\nweruy4uhnd-", "output": "-202\n4"}, {"input": "          4532984       d    -1", "output": "4532983"}, {"input": "1-1\n1 -1\n1--5\n1-----------1\n-1-1\n--1\n-2.3", "output": "2\n0\n-4\n0\n0\n-1\n1"}, {"input": "", "output": ""}, {"input": "-23", "output": "-23"}, {"input": "abc7", "output": "7"}, {"input": "9", "output": "9"}, {"input": "10 20 30", "output": "60"}, {"input": "-5 -10 -15", "output": "-30"}, {"input": "12345", "output": "12345"}, {"input": "0 0 0 0", "output": "0"}, {"input": "a1b2c3d4e5f6", "output": "21"}, {"input": "1 2 3 4 5 6 7 8 9 10\n", "output": "55"}, {"input": "10\n", "output": "10"}, {"input": "0\n", "output": "0"}, {"input": "-5\n", "output": "-5"}, {"input": "abc\n", "output": ""}, {"input": "1a2b3c4d5e6f7g8h9i10j\n", "output": "55"}, {"input": ".......1.......2.......3.......4.......\n", "output": "10"}, {"input": "1a.b2c.d3e\n", "output": "6"}, {"input": "1 a 2 b 3 c 4 d 5 e 6 f 7 g 8 h 9 i 10 j\n", "output": "55"}, {"input": "----------\n", "output": ""}, {"input": "-1\n", "output": "-1"}, {"input": "x -1 y -2 z -3 w -4 u -5 v -6 t -7 s -8 r -9 q -10\n", "output": "-55"}, {"input": "1 2 3 4 5\n", "output": "15"}, {"input": "-123\n", "output": "-123"}, {"input": "1\n", "output": "1"}, {"input": "1 2 3 4\n", "output": "10"}, {"input": "123\n", "output": "123"}, {"input": "-12345\n", "output": "-12345"}, {"input": "1234567890\n", "output": "1234567890"}, {"input": "-1 -2 -3 -4 -5\n", "output": "-15"}, {"input": "abcdefghijklmn1234\n", "output": "1234"}, {"input": "-1 -2 -3 -4 -5 -6 -7 -8 -9 -10\n", "output": "-55"}, {"input": "-1234567890\n", "output": "-1234567890"}], "test": "#undef NDEBUG\n#include<assert.h>\nint main(){\n    assert(solution(\"su57jdkjth54hjsns-321d 8 ejre\\nerg(&-^%\\n\\nweruy4uhnd-\") == \"-202\\n4\");\n    assert(solution(\"          4532984       d    -1\") == \"4532983\");\n    assert(solution(\"1-1\\n1 -1\\n1--5\\n1-----------1\\n-1-1\\n--1\\n-2.3\") == \"2\\n0\\n-4\\n0\\n0\\n-1\\n1\");\n    assert(solution(\"\") == \"\");\n    assert(solution(\"-23\") == \"-23\");\n    assert(solution(\"abc7\") == \"7\");\n    assert(solution(\"9\") == \"9\");\n    assert(solution(\"10 20 30\") == \"60\");\n    assert(solution(\"-5 -10 -15\") == \"-30\");\n    assert(solution(\"12345\") == \"12345\");\n    assert(solution(\"0 0 0 0\") == \"0\");\n    assert(solution(\"a1b2c3d4e5f6\") == \"21\");\n    assert(solution(\"1 2 3 4 5 6 7 8 9 10\\n\") == \"55\");\n    assert(solution(\"10\\n\") == \"10\");\n    assert(solution(\"0\\n\") == \"0\");\n    assert(solution(\"-5\\n\") == \"-5\");\n    assert(solution(\"abc\\n\") == \"\");\n    assert(solution(\"1a2b3c4d5e6f7g8h9i10j\\n\") == \"55\");\n    assert(solution(\".......1.......2.......3.......4.......\\n\") == \"10\");\n    assert(solution(\"1a.b2c.d3e\\n\") == \"6\");\n    assert(solution(\"1 a 2 b 3 c 4 d 5 e 6 f 7 g 8 h 9 i 10 j\\n\") == \"55\");\n    assert(solution(\"----------\\n\") == \"\");\n    assert(solution(\"-1\\n\") == \"-1\");\n    assert(solution(\"x -1 y -2 z -3 w -4 u -5 v -6 t -7 s -8 r -9 q -10\\n\") == \"-55\");\n    assert(solution(\"1 2 3 4 5\\n\") == \"15\");\n    assert(solution(\"-123\\n\") == \"-123\");\n    assert(solution(\"1\\n\") == \"1\");\n    assert(solution(\"1 2 3 4\\n\") == \"10\");\n    assert(solution(\"123\\n\") == \"123\");\n    assert(solution(\"-12345\\n\") == \"-12345\");\n    assert(solution(\"1234567890\\n\") == \"1234567890\");\n    assert(solution(\"-1 -2 -3 -4 -5\\n\") == \"-15\");\n    assert(solution(\"abcdefghijklmn1234\\n\") == \"1234\");\n    assert(solution(\"-1 -2 -3 -4 -5 -6 -7 -8 -9 -10\\n\") == \"-55\");\n    assert(solution(\"-1234567890\\n\") == \"-1234567890\");\n    return 0; \n}", "prompt": "/*Little Q gives you several lines of strings, which may contain some integers with other characters in between. You need to output the sum of all integers in each line. If there is no number in a line, then do not output anything. **There is always a space or a period between any two integers (see Example 3).**\n\nNote that all integers in the input are simple integers, i.e., there are no extra signs in front of the integers. If there is a period, it should be treated as a delimiter.\n\ninput_format:\nOne string per line.\n\noutput_format:\nFor each string containing an integer, output a line of one number, the sum of the numbers.\n*/\n\n#include<sstream>\n#include<stdlib.h>\n#include<algorithm>\n#include<math.h>\n#include<stdio.h>\n#include<vector>\n#include<string>\n#include<climits>\n#include<cstring>\n#include<iostream>\nusing namespace std;\n\n             \nstring solution(string std_in){\n    istringstream iss(std_in);\n             ", "constraints": "【样例解释】\n\n- 第一个样例中，第一行有 $57,54,-321,8$ 几个数，和为 $-202$；第二、三行没有数字；第四行只有一个 $4$，输出 $4$。\n- 第二个样例中只有一行，有两个数，和为 $4532893$。\n- 第三个样例的第一行，由于每两个整数之间一定有间隔字符，所以把 `-` 视为间隔字符，输出 $2$。第五行，第一个数为 $-1$，因此把第二个 `-` 视为间隔字符，和为 $-1+1=0$。第七行，将 `.` 视为间隔字符，和为 $-2+3=1$。\n\n【数据范围】\n\n说明：「条件 A」指数据中不存在除数字、空格、换行、水平制表符之外的其他字符；「条件 B」指每两个数之间一定用且只用一个空格隔开。\n\n**由于数据在 Windows 下制造，行末可能有多余的 `\\r` 字符。请注意。**\n\n对于 $10\\%$ 的数据，满足条件 A 和 B，每行一定有且仅有 $10$ 个数；\n\n对于 $40\\%$ 的数据，满足条件 A 和 B，且不存在空行；\n\n对于 $50\\%$ 的数据，满足条件 A 和 B；\n\n对于 $70\\%$ 的数据，满足条件 A；\n\n对于 $100\\%$ 的数据，不存在除水平制表符、空格、换行外的不可见字符，每行不超过 $1000$ 个字符，每行最多包含 $200$ 个整数，不超过 $100$ 行，每个整数均 $\\in[-10^7,10^7]$。", "samples": [["su57jdkjth54hjsns-321d 8 ejre\nerg(&-^%\n\nweruy4uhnd-", "-202\n4"], ["          4532984       d    -1", "4532983"], ["1-1\n1 -1\n1--5\n1-----------1\n-1-1\n--1\n-2.3", "2\n0\n-4\n0\n0\n-1\n1"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}}
{"task_id": "P2001", "title": "硬币的面值", "difficulty": "challenge", "nl": "A has n types of coins and wants to buy a item that costs no more than m yuan. He doesn't want to get any change (too dirty), but also doesn't want to carry too many coins. The coins can be repeated, and the values of these n types of coins are known. What is the minimum number of coins needed to combine all possible prices?", "code": "#include<algorithm>\n#include<iostream>\n#include<cstdio>\n#define re register\n#define ll long long\nusing namespace std;\nll n,m,sum,ans,a[2000001];          //硬币数组\ninline ll qread()\n{\n\tchar c=getchar();ll num=0,f=1;\n\tfor(;!isdigit(c);c=getchar()) if(c=='-') f=-1;\n\tfor(;isdigit(c);c=getchar()) num=num*10+c-'0';\n\treturn num*f;\n}                \nint main()\n{\n    n=qread(),m=qread();\n    for(re int i=1;i<=n;++i)\n    a[i]=qread();   \n    a[n+1]=m;                   \n    sort(a+1,a+1+n+1);             //让硬币从小到大排序，为的是下面的判断。。\n    if(a[1]!=1)                 \n    {\n        printf(\"No answer!!!\\n\");   //没有面额为1的直接输出No answer！！！\n        return 0;                   //直接退出程序。\n    }\n    for(re int i=1;i<=n;++i)\n    {\n        while(sum<a[i+1]-1)          //取最大值，看不懂的话上面有例子。\n        {\n            sum+=a[i];\n            ans++;                    //计数器。\n            if(sum>=m)\n            {\n                printf(\"%lld\\n\",ans);    //输出硬币数，直接退出程序。\n                return 0;\n            }\n        }   \n    }\n    cout<<ans+1<<'\\n';           //不然的话输出ans+1。 \n    return 0;\n}", "step": ["Read input values n and m.", "Read n integers and store them in an array a.", "Add m to the end of the array a and sort it.", "Check if the first element of the sorted array 'a' is equal to 1.", "Calculate the minimum number of jumps required to reach 'm'.", "Print the result."], "nl_cn": "小 A 有 $n$ 种硬币，现在要买一样不超过 $m$ 元的商品，他不想得到找钱（多脏啊），同时又不想带太多的硬币，且硬币可以重复，现在已知这 $n$ 种硬币的价值，请问最少需要多少硬币就能组合成所有可能的价格？\n", "test_cases": [{"input": "5 31\r\n1 2 8 4 16\r\n", "output": "5"}, {"input": "5 31\n1 2 8 4 16\n", "output": "5"}, {"input": "2 3\r\n1 2\r\n", "output": "2"}, {"input": "2 2\r\n1 2\r\n", "output": "2"}, {"input": "5 20\r\n1 2 4 8 16\r\n", "output": "5"}, {"input": "3 7\r\n1 2 4\r\n", "output": "3"}, {"input": "4 11\r\n1 2 3 5\r\n", "output": "4"}, {"input": "1 1\r\n1\r\n", "output": "1"}], "test": "#undef NDEBUG\n#include<assert.h>\nint main(){\n    assert(solution(\"5 31\\r\\n1 2 8 4 16\\r\\n\") == \"5\");\n    assert(solution(\"5 31\\n1 2 8 4 16\\n\") == \"5\");\n    assert(solution(\"2 3\\r\\n1 2\\r\\n\") == \"2\");\n    assert(solution(\"2 2\\r\\n1 2\\r\\n\") == \"2\");\n    assert(solution(\"5 20\\r\\n1 2 4 8 16\\r\\n\") == \"5\");\n    assert(solution(\"3 7\\r\\n1 2 4\\r\\n\") == \"3\");\n    assert(solution(\"4 11\\r\\n1 2 3 5\\r\\n\") == \"4\");\n    assert(solution(\"1 1\\r\\n1\\r\\n\") == \"1\");\n    return 0; \n}", "prompt": "/*A has n types of coins and wants to buy a item that costs no more than m yuan. He doesn't want to get any change (too dirty), but also doesn't want to carry too many coins. The coins can be repeated, and the values of these n types of coins are known. What is the minimum number of coins needed to combine all possible prices?\n\ninput_format:\nThe first row has two numbers: $n, m$.\n\nThe next line, a total of $n$numbers, indicates the face value of the coin.\n\noutput_format:\nA number in a row indicates the minimum number of coins needed. If No solution please output 'No answer!!! '.\n*/\n\n#include<sstream>\n#include<stdlib.h>\n#include<algorithm>\n#include<math.h>\n#include<stdio.h>\n#include<vector>\n#include<string>\n#include<climits>\n#include<cstring>\n#include<iostream>\nusing namespace std;\n\n             \nstring solution(string std_in){\n    istringstream iss(std_in);\n             ", "constraints": "【数据范围】\n\n只有 9、10 会卡人，放心贪\n\n对于 $20\\%$ 的数据，$1 \\le n \\le 10$，$1 \\le m \\le 100$。  \n对于 $60\\%$ 的数据，$1 \\le n \\le 1000$，$1 \\le m \\le 10000$。  \n对于 $80\\%$ 的数据，$1 \\le n \\le 30000$，$1 \\le m \\le 2 \\times {10}^9$。  \n对于 $100\\%$ 的数据，$1 \\le n \\le 2 \\times {10}^5$，$1 \\le m \\le 2^{63}$。\n", "samples": [["5 31\r\n1 2 8 4 16\r\n", "5\r\n"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}}
{"task_id": "P3819", "title": "松江 1843 路", "difficulty": "advanced", "nl": "Laifang Road is a road with a length of $L$ meters, and its coordinates range from 0 to $L$. There are $N$ houses built along the road, and the $i$-th house is built at coordinate $x_i$, where $r_i$ people live.\n\nThe government plans to build a bus station on this road for Bus 1843 of Songjiang. They hope to provide the most convenience for the maximum number of residents, so they want to minimize the **sum** of distances from each resident's home to the bus station.\n\nWhere should the bus station be built?", "code": "#include<bits/stdc++.h>\nusing namespace std;\nlong long s[100001],people[100001];\nint main()\n{\n    long long n,l,k,i,end,tou;//end指当前的最后一间房屋，tou只当前第一间房屋。\n    long long ans=0;\n    cin>>l>>n;\n    for(i=1;i<=n;i++)\n      cin>>s[i]>>people[i];\n    end=n;\n    tou=1;\n    while(end>tou)\n    {\n        k=min(people[tou],people[end]);\n        people[tou]-=k;\n        people[end]-=k;\n        ans+=k*(s[end]-s[tou]);\n        if(people[end]==0) end--;\n        if(people[tou]==0) tou++;//如果房间被清空，则指针变动.\n    }\n    cout<<ans;\n    return 0;\n}", "step": ["Read the values of l and n.", "Read the distance values and the number of people corresponding to each distance.", "Create variables end and tou and initialize them.", "Loop through all elements in the given array and calculate distance travelled by each person.", "Print the total distance travelled by all people."], "nl_cn": "涞坊路是一条长 $L$ 米的道路，道路上的坐标范围从 $0$ 到 $L$，路上有 $N$ 座房子，第 $i$ 座房子建在坐标为 $x_i$ 的地方，其中住了 $r_i$ 人。\n\n松江 1843 路公交车要在这条路上建一个公交站，市政府希望让最多的人得到方便，因此希望所有的每一个的居民，从家到车站的距离的**总和**最短。\n\n公交站应该建在哪里呢？", "test_cases": [{"input": "100 3\n20 3\n50 2\n70 1\n", "output": "110"}, {"input": "100 2\n0 1\n100 10\n", "output": "100"}, {"input": "10000000000 5\n3282894320 391\n4394338332 929\n6932893249 181\n7823822843 440\n9322388365 623\n", "output": "5473201404068"}, {"input": "100 1\n50 1\n", "output": "0"}, {"input": "1000 2\n0 5\n500 7\n", "output": "2500"}, {"input": "500 2\n100 6\n400 2\n", "output": "600"}, {"input": "100000 2\n50000 100\n75000 50\n", "output": "1250000"}, {"input": "1 1\n0 1\n", "output": "0"}, {"input": "20 1\n10 5\n", "output": "0"}, {"input": "100 2\n0 10\n100 5\n", "output": "500"}, {"input": "5000 5\n1000 5\n2000 10\n3000 15\n4000 20\n4500 25\n", "output": "62500"}, {"input": "50 2\n10 10\n20 10\n", "output": "100"}, {"input": "100 2\n0 10\n50 10\n", "output": "500"}], "test": "#undef NDEBUG\n#include<assert.h>\nint main(){\n    assert(solution(\"100 3\\n20 3\\n50 2\\n70 1\\n\") == \"110\");\n    assert(solution(\"100 2\\n0 1\\n100 10\\n\") == \"100\");\n    assert(solution(\"10000000000 5\\n3282894320 391\\n4394338332 929\\n6932893249 181\\n7823822843 440\\n9322388365 623\\n\") == \"5473201404068\");\n    assert(solution(\"100 1\\n50 1\\n\") == \"0\");\n    assert(solution(\"1000 2\\n0 5\\n500 7\\n\") == \"2500\");\n    assert(solution(\"500 2\\n100 6\\n400 2\\n\") == \"600\");\n    assert(solution(\"100000 2\\n50000 100\\n75000 50\\n\") == \"1250000\");\n    assert(solution(\"1 1\\n0 1\\n\") == \"0\");\n    assert(solution(\"20 1\\n10 5\\n\") == \"0\");\n    assert(solution(\"100 2\\n0 10\\n100 5\\n\") == \"500\");\n    assert(solution(\"5000 5\\n1000 5\\n2000 10\\n3000 15\\n4000 20\\n4500 25\\n\") == \"62500\");\n    assert(solution(\"50 2\\n10 10\\n20 10\\n\") == \"100\");\n    assert(solution(\"100 2\\n0 10\\n50 10\\n\") == \"500\");\n    return 0; \n}", "prompt": "/*Laifang Road is a road with a length of $L$ meters, and its coordinates range from 0 to $L$. There are $N$ houses built along the road, and the $i$-th house is built at coordinate $x_i$, where $r_i$ people live.\n\nThe government plans to build a bus station on this road for Bus 1843 of Songjiang. They hope to provide the most convenience for the maximum number of residents, so they want to minimize the **sum** of distances from each resident's home to the bus station.\n\nWhere should the bus station be built?\n\ninput_format:\nEnter $L$and $N$on the first line.\n\nNext comes a $N$line, each with two integers $x_i$and $r_i$.\n\noutput_format:\nAn integer, the sum of the smallest distances from each person's home to the station.\n*/\n\n#include<sstream>\n#include<stdlib.h>\n#include<algorithm>\n#include<math.h>\n#include<stdio.h>\n#include<vector>\n#include<string>\n#include<climits>\n#include<cstring>\n#include<iostream>\nusing namespace std;\n\n             \nstring solution(string std_in){\n    istringstream iss(std_in);\n             ", "constraints": "### 样例解释 1\n\n当建在坐标 $40$ 的时候，所有人距离车站的距离总和为 $|20-40| \\times 3+|50-40| \\times 2+|70-40| \\times 1=110$。\n\n### 数据范围和约定\n\n对于 $10\\% $的数据，$1\\le N \\le 50$，$R_i=1$。\n\n对于 $30\\%$ 的数据，$1 \\le N \\le 100$，$R_i \\le 10$，$1 \\le L \\le 1000$。\n\n对于 $70\\%$ 的数据，$1 \\le N \\le 1000$，$R_i \\le 100$，$1 \\le L \\le 10^6$。\n\n对于全部数据，$1 \\le L \\le 10^{10}$，$1 \\le N \\le 10^5$，$0 \\le x_i \\le L$，$1 \\le r_i \\le 1000$。", "samples": [["100 3\n20 3\n50 2\n70 1\n", "110\n"], ["100 2\n0 1\n100 10\n", "100\n"], ["10000000000 5\n3282894320 391\n4394338332 929\n6932893249 181\n7823822843 440\n9322388365 623\n", "5473201404068\n"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}}
{"task_id": "P1510", "title": "精卫填海", "difficulty": "challenge", "nl": "【Copyright】\n\nThis is an adapted problem.\n\n【Problem Description】\n\n\"There is a mountain named Mount Jiu, on which grow a great deal of jujube trees. On the mountain there is a bird with a crow-like appearance, yellow beak, and red feet called Jingwei. Jingwei was the youngest daughter of Emperor Yan. Her name literally means \"I can explain myself.\" Jingwei often carries pebbles and small rocks from the mountain to throw into the East Sea in order to fill it up. One day, Jingwei drowned in the sea. Since then, she has been constantly trying to fill up the sea by carrying stones and pebbles in her beak.\"\n\nFinally, Jingwei is about to fill up the East Sea! There is only a small area left to be filled. At the same time, there are not many rocks left on the western mountain. Can Jingwei fill up the East Sea?\n\nIn fact, it still needs at least a volume of v of rocks to fill the remaining area in the East Sea, and there are n rocks left on the Western Mountains, with volumes and the stamina required to carry them into the East Sea being k and m respectively. Jingwei has been filling the sea for such a long time and she is tired now. She only has remaining stamina c.", "code": "#include<cstdio>\n#include<cstring>\n#include<iostream>\n#include<algorithm>\n#define int long long\n#define MAXN 10000+3\nusing namespace std;\n\ninline int read(){//（推销一波）如老衲所见 必有大数据 所以还是有必要来个快读优化的QAQ \n    int x=0,f=1;char ch=getchar();\n    while (ch<'0'||ch>'9') {if(ch=='-')f=-1; ch=getchar();}\n    while (ch>='0'&&ch<='9'){x=(x<<3)+(x<<1)+ch-'0'; ch=getchar();}\n    return x*f;\n}\n\nint vn,n,c,sum;//vn：need—v（所需总体积） n：石子个数 c：总体力 \nint v[MAXN],w[MAXN],f[MAXN];//v：石子体积 w：所需体力  \n\nsigned main()\n{\n\tvn=read(),n=read(),c=read();\n\tfor(int i=1;i<=n;i++){\n\t\tv[i]=read(),w[i]=read();\n//\t\tcout<<v[i]<<\" \"<<w[i]<<endl;\n\t\tsum+=v[i];\n//\t\tcout<<sum<<endl;\n\t}\n\tif(sum<vn){//若石子总体积<vn，直接输出Impossible （特判一波）\n\t\tcout<<\"Impossible\"<<endl;\n\t\treturn 0;\n\t}\n//\tcout<<\"ha\"<<endl;静态测试 检查代码在哪里出的锅QAQ \n\tfor(int i=1;i<=n;i++){\n\t\tfor(int j=c;j>=w[i];j--){\n\t\t\tf[j]=max(f[j],f[j-w[i]]+v[i]);\n\t\t}\n\t}\n\tfor(int i=0;i<=vn;i++){//从小到大搜 第一个大于vn的直接输出\n\t\tif(f[i]>=vn){\n\t\t\tcout<<c-i<<endl;\n\t\t\treturn 0;\n\t\t}\n\t}\n\tcout<<\"Impossible\"<<endl;\n\treturn 0;\n}", "step": ["Read input number of items, volume, and load.", "Read input values ​​and weights of items.", "Check if the total item volume is smaller than the given volume. If so, print 'Impossible' and return.", "Calculate the minimum cost for items.", "Find the minimum cost and print the result.", "If there is no result, print 'Impossible'."], "nl_cn": "【版权说明】\n\n本题为改编题。\n\n【问题描述】\n\n发鸠之山，其上多柘木。有鸟焉，其状如乌，文首，白喙，赤足，名曰精卫，其名自詨。是炎帝之少女，名曰女娃。女娃游于东海，溺而不返，故为精卫。常衔西山之木石，以堙于东海。——《山海经》\n\n精卫终于快把东海填平了！只剩下了最后的一小片区域了。同时，西山上的木石也已经不多了。精卫能把东海填平吗？\n\n事实上，东海未填平的区域还需要至少体积为v的木石才可以填平，而西山上的木石还剩下n块，每块的体积和把它衔到东海需要的体力分别为k和m。精卫已经填海填了这么长时间了，她也很累了，她还剩下的体力为c。\n", "test_cases": [{"input": "100 2 10\n50 5\n50 5", "output": "0"}, {"input": "10 2 1\n50 5\n10 2", "output": "Impossible"}, {"input": "100 2 10\n50 5\n50 10\n", "output": "Impossible"}, {"input": "100 5 10\n10 1\n20 3\n30 4\n40 5\n50 10\n", "output": "Impossible"}, {"input": "100 5 10\n10 1\n20 3\n20 4\n40 5\n50 10\n", "output": "Impossible"}, {"input": "15 2 1\n2 1\n10 10\n", "output": "Impossible"}, {"input": "160 5 18\n10 2\n5 1\n50 5\n60 6\n35 3", "output": "1"}, {"input": "1 1 1\n1 1\n1 1\n", "output": "0"}, {"input": "100 3 10\n15 5\n15 5\n15 5\n", "output": "Impossible"}, {"input": "100 5 10\n20 10\n20 10\n20 10\n20 10\n20 10\n", "output": "Impossible"}, {"input": "1000 10 10\n100 5\n200 5\n300 5\n400 5\n500 5\n100 5\n200 5\n300 5\n400 5\n500 5\n", "output": "0"}, {"input": "1000 10 20\n120 10\n120 10\n120 10\n120 10\n120 10\n120 10\n120 10\n120 10\n120 10\n120 10\n", "output": "Impossible"}, {"input": "1000000000 1 1\n1000000000 1\n", "output": "0"}], "test": "#undef NDEBUG\n#include<assert.h>\nint main(){\n    assert(solution(\"100 2 10\\n50 5\\n50 5\") == \"0\");\n    assert(solution(\"10 2 1\\n50 5\\n10 2\") == \"Impossible\");\n    assert(solution(\"100 2 10\\n50 5\\n50 10\\n\") == \"Impossible\");\n    assert(solution(\"100 5 10\\n10 1\\n20 3\\n30 4\\n40 5\\n50 10\\n\") == \"Impossible\");\n    assert(solution(\"100 5 10\\n10 1\\n20 3\\n20 4\\n40 5\\n50 10\\n\") == \"Impossible\");\n    assert(solution(\"15 2 1\\n2 1\\n10 10\\n\") == \"Impossible\");\n    assert(solution(\"160 5 18\\n10 2\\n5 1\\n50 5\\n60 6\\n35 3\") == \"1\");\n    assert(solution(\"1 1 1\\n1 1\\n1 1\\n\") == \"0\");\n    assert(solution(\"100 3 10\\n15 5\\n15 5\\n15 5\\n\") == \"Impossible\");\n    assert(solution(\"100 5 10\\n20 10\\n20 10\\n20 10\\n20 10\\n20 10\\n\") == \"Impossible\");\n    assert(solution(\"1000 10 10\\n100 5\\n200 5\\n300 5\\n400 5\\n500 5\\n100 5\\n200 5\\n300 5\\n400 5\\n500 5\\n\") == \"0\");\n    assert(solution(\"1000 10 20\\n120 10\\n120 10\\n120 10\\n120 10\\n120 10\\n120 10\\n120 10\\n120 10\\n120 10\\n120 10\\n\") == \"Impossible\");\n    assert(solution(\"1000000000 1 1\\n1000000000 1\\n\") == \"0\");\n    return 0; \n}", "prompt": "/*【Copyright】\n\nThis is an adapted problem.\n\n【Problem Description】\n\n\"There is a mountain named Mount Jiu, on which grow a great deal of jujube trees. On the mountain there is a bird with a crow-like appearance, yellow beak, and red feet called Jingwei. Jingwei was the youngest daughter of Emperor Yan. Her name literally means \"I can explain myself.\" Jingwei often carries pebbles and small rocks from the mountain to throw into the East Sea in order to fill it up. One day, Jingwei drowned in the sea. Since then, she has been constantly trying to fill up the sea by carrying stones and pebbles in her beak.\"\n\nFinally, Jingwei is about to fill up the East Sea! There is only a small area left to be filled. At the same time, there are not many rocks left on the western mountain. Can Jingwei fill up the East Sea?\n\nIn fact, it still needs at least a volume of v of rocks to fill the remaining area in the East Sea, and there are n rocks left on the Western Mountains, with volumes and the stamina required to carry them into the East Sea being k and m respectively. Jingwei has been filling the sea for such a long time and she is tired now. She only has remaining stamina c.\n\ninput_format:\nThe first line of the input file is three integers: v, n, and c.\n\nFrom the second to the n+1 row, the volume of each piece of wood and the strength required to carry it to the East Sea are shown.\n\noutput_format:\nThe output file has only one line, if Jingwei can fill the East China Sea, then output her maximum physical strength after filling the East China Sea, otherwise output 'Impossible' (without quotes).\n*/\n\n#include<sstream>\n#include<stdlib.h>\n#include<algorithm>\n#include<math.h>\n#include<stdio.h>\n#include<vector>\n#include<string>\n#include<climits>\n#include<cstring>\n#include<iostream>\nusing namespace std;\n\n             \nstring solution(string std_in){\n    istringstream iss(std_in);\n             ", "constraints": "### 数据范围及约定\n\n- 对于 $20\\%$ 的数据，$0<n \\le 50$；\n- 对于 $50\\%$ 的数据，$0<n \\le 1000$；\n- 对于 $100\\%$ 的数据，$0<n \\le 10^4$，所有读入的数均属于 $[0,10^4]$，最后答案不大于 $c$。\n", "samples": [["100 2 10\n50 5\n50 5", "0"], ["10 2 1\n50 5\n10 2", "Impossible"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}}
{"task_id": "P1517", "title": "高精求小数幂", "difficulty": "challenge", "nl": "Calculating very large precision values is a common problem. For example, calculating national debt can be a difficult task for many computer systems.\n\nYour task is to write a program that calculates the exact value of R, where R is a real number (0.0 < R <= 9999.9), and n is an integer such that 0 < n <= 250.", "code": "#include <bits/stdc++.h>\nusing namespace std;\nconst int MAXN = 1300;\t\t//100000^250有1250位 \nint pt;\nstruct Bign{\n\tint s[MAXN], len;\n\tBign(int num = 0){\n\t\tmemset(s, 0, sizeof(s));\n\t\tlen = 1;\n\t\ts[1] = num;\n\t}\n\tBign operator * (int b)const{\n\t\tBign c;\n\t\tc.len = len + 10;\n\t\tfor (int i = 1; i <= c.len; i++){\n\t\t\tc.s[i] += s[i] * b;\n\t\t\tc.s[i+1] = c.s[i] / 10;\n\t\t\tc.s[i] %= 10;\n\t\t}\n\t\tc.clean();\n\t\treturn c;\n\t}\n\tvoid clean(){\n\t\twhile (len > 1 && !s[len]) len--;\n\t}\n};\nostream& operator << (ostream &out, const Bign &x){\n\tint i;\n\tfor (i = x.len; i > 0 && i > pt; i--)\t\t//输出整数部分 \n\t\tout << x.s[i];\n\tif (i){\t\t\t\t\t\t\t//若i不为0，表示还有小数部分 \n\t\tout << \".\";\t\t\t\t\t//先输出\".\" \n\t\tfor (i = pt; i > 0; i--)\t//再输出小数部分 \n\t\t\tout << x.s[i];\n\t}\n\treturn out;\t\n}\nint main(){\n\tdouble a;\n\tint n; \n\twhile (cin >> a >> n){\n\t\t//求a的小数位数 \n\t\tpt = 0;\t\t\t\t\t\t\t\t//pt记录a的小数位数 \n\t\twhile (fabs(a - round(a)) > 1e-6){\t//若a不等于a的整数部分，表示a不是整数 \n\t\t\tpt++;\t\t\t\t\t\t\t//小数位数加一位 \n\t\t\ta *= 10;\n\t\t}\n\t\tpt *= n;\t\t\t\t\t\t\t//a^n的小数位数等于a的小数位数 ×n \n\t\t//求s = a ^ n \n\t\tBign s = 1;\n\t\tfor (int i = 1; i <= n; i++)\n\t\t\ts = s * (int)round(a);\n\t\tcout << s << endl;\n\t}\n\treturn 0;\n}", "step": ["Define a variable MAXN and a structure Bign which uses an array to represent a big number.", "Overload the operator multiplication in the structure Bign.", "Define a function to clean extra leading zeroes in the array s.", "Overload the operator << to print out the structured Bign number with the specified number precision.", "In the main function, read in a floating-point number a and an integer n, calculate the specified number precision using an algorithm.", "Calculate the result of a^n and output the structured Bign number result."], "nl_cn": "Problems involving the computation of exact values of very large magnitude and precision are common. For example, the computation of the national debt is a taxing experience for many computer systems.\n\nThis problem requires that you write a program to compute the exact value of Rn where R is a real number ( 0.0 < R <= 9999.9) and n is an integer such that 0 < n <= 250.\n", "test_cases": [{"input": "95.123  2\n0.4321  5\n5.1234  7\n6.7592  3\n98.999  5\n1.0100 10\n", "output": "9048.385129\n.01506334182914325601\n92663.3181348508776705891407804544\n308.806114738688\n9509420210.697891990494999\n1.10462212541120451001"}, {"input": "9999.9 1\n", "output": "9999.9"}, {"input": "754.91 1\n", "output": "754.91"}, {"input": "1234.567 1\n", "output": "1234.567"}, {"input": "95.123 2\n", "output": "9048.385129"}, {"input": "0.4321 5\n", "output": ".01506334182914325601"}, {"input": "5.1234 7\n", "output": "92663.3181348508776705891407804544"}, {"input": "6.7592 3\n", "output": "308.806114738688"}, {"input": "98.999 5\n", "output": "9509420210.697891990494999"}, {"input": "1.0100 10\n", "output": "1.10462212541120451001"}], "test": "#undef NDEBUG\n#include<assert.h>\nint main(){\n    assert(solution(\"95.123  2\\n0.4321  5\\n5.1234  7\\n6.7592  3\\n98.999  5\\n1.0100 10\\n\") == \"9048.385129\\n.01506334182914325601\\n92663.3181348508776705891407804544\\n308.806114738688\\n9509420210.697891990494999\\n1.10462212541120451001\");\n    assert(solution(\"9999.9 1\\n\") == \"9999.9\");\n    assert(solution(\"754.91 1\\n\") == \"754.91\");\n    assert(solution(\"1234.567 1\\n\") == \"1234.567\");\n    assert(solution(\"95.123 2\\n\") == \"9048.385129\");\n    assert(solution(\"0.4321 5\\n\") == \".01506334182914325601\");\n    assert(solution(\"5.1234 7\\n\") == \"92663.3181348508776705891407804544\");\n    assert(solution(\"6.7592 3\\n\") == \"308.806114738688\");\n    assert(solution(\"98.999 5\\n\") == \"9509420210.697891990494999\");\n    assert(solution(\"1.0100 10\\n\") == \"1.10462212541120451001\");\n    return 0; \n}", "prompt": "/*Calculating very large precision values is a common problem. For example, calculating national debt can be a difficult task for many computer systems.\n\nYour task is to write a program that calculates the exact value of R, where R is a real number (0.0 < R <= 9999.9), and n is an integer such that 0 < n <= 250.\n\ninput_format:\nThe input will consist of a set (less than 11) of pairs of values for R and n. The R value will occupy columns 1 through  6, and the n value will be in columns 8 and 9.\n\n\n\n\noutput_format:\nThe output will consist of one line for each line of input giving the exact value of R^n. Leading zeros should be suppressed in the output. Insignificant trailing zeros must not be printed. Don't print the decimal point if the result is an integer.\n*/\n\n#include<sstream>\n#include<stdlib.h>\n#include<algorithm>\n#include<math.h>\n#include<stdio.h>\n#include<vector>\n#include<string>\n#include<climits>\n#include<cstring>\n#include<iostream>\nusing namespace std;\n\n             \nstring solution(string std_in){\n    istringstream iss(std_in);\n             ", "constraints": "If you don't know how to determine wheather encounted the end of input:\n\ns is a string and n is an integer\n\nC++\nwhile(cin>>s>>n) \n\n{ \n...\n} \nc\nwhile(scanf(\"%s%d\",s,&n)==2) //to see if the scanf read in as many items as you want\n\n\n{ \n...\n}", "samples": [["95.123  2\n0.4321  5\n5.1234  7\n6.7592  3\n98.999  5\n1.0100 10\n", "9048.385129\n.01506334182914325601\n92663.3181348508776705891407804544\n308.806114738688\n9509420210.697891990494999\n1.10462212541120451001\n"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}}
{"task_id": "P5710", "title": "【深基3.例2】数的性质", "difficulty": "basic", "nl": "Some integers may have the following properties:\n\n- Property 1: being even;\n- Property 2: being greater than $4$ and not greater than $12$.\n\nLittle A likes integers that satisfy both properties; Uim likes integers that satisfy at least one of the properties; BaYeYong likes integers that satisfy exactly one of the properties; and Miss Beauty likes integers that don't satisfy either of the properties. Now given an integer $x$, please determine whether they like this integer or not.", "code": "#include <iostream>\n#include <cstdio>\n#include <algorithm>\n#include <cstring>\nusing namespace std;\nint x;\nbool a, b;\nint main(){\n\tscanf(\"%d\", &x);\n\ta = !(x & 1), b = (x > 4 && x <= 12);//a满足性质1，b满足性质2\n\tprintf(\"%d %d %d %d\", a & b, a | b, (a && !b || b && !a), !a && !b);\n   //按条件输出就好啦QWQ\n}", "step": ["Read the input integer from the user.", "Calculate the values of two boolean variables 'a' and 'b' based on the input integer.", "Compute the values of four logical expressions using the boolean variables 'a' and 'b'.", "Print the values of the logical expressions."], "nl_cn": "一些整数可能拥有以下的性质：\n\n- 性质 1：是偶数；\n- 性质 2：大于 $4$ 且不大于 $12$。\n\n小 A 喜欢这两个性质同时成立的整数；Uim 喜欢这至少符合其中一种性质的整数；八尾勇喜欢刚好有符合其中一个性质的整数；正妹喜欢不符合这两个性质的整数。现在给出一个整数 $x$，请问他们是否喜欢这个整数？", "test_cases": [{"input": "12", "output": "1 1 0 0"}, {"input": "20", "output": "0 1 1 0"}, {"input": "3", "output": "0 0 0 1"}, {"input": "8", "output": "1 1 0 0"}, {"input": "5", "output": "0 1 1 0"}, {"input": "11", "output": "0 1 1 0"}, {"input": "6", "output": "1 1 0 0"}, {"input": "9", "output": "0 1 1 0"}, {"input": "18", "output": "0 1 1 0"}, {"input": "22", "output": "0 1 1 0"}, {"input": "7\n", "output": "0 1 1 0"}, {"input": "-3\n", "output": "0 0 0 1"}, {"input": "1\n", "output": "0 0 0 1"}, {"input": "-1\n", "output": "0 0 0 1"}], "test": "#undef NDEBUG\n#include<assert.h>\nint main(){\n    assert(solution(\"12\") == \"1 1 0 0\");\n    assert(solution(\"20\") == \"0 1 1 0\");\n    assert(solution(\"3\") == \"0 0 0 1\");\n    assert(solution(\"8\") == \"1 1 0 0\");\n    assert(solution(\"5\") == \"0 1 1 0\");\n    assert(solution(\"11\") == \"0 1 1 0\");\n    assert(solution(\"6\") == \"1 1 0 0\");\n    assert(solution(\"9\") == \"0 1 1 0\");\n    assert(solution(\"18\") == \"0 1 1 0\");\n    assert(solution(\"22\") == \"0 1 1 0\");\n    assert(solution(\"7\\n\") == \"0 1 1 0\");\n    assert(solution(\"-3\\n\") == \"0 0 0 1\");\n    assert(solution(\"1\\n\") == \"0 0 0 1\");\n    assert(solution(\"-1\\n\") == \"0 0 0 1\");\n    return 0; \n}", "prompt": "/*Some integers may have the following properties:\n\n- Property 1: being even;\n- Property 2: being greater than $4$ and not greater than $12$.\n\nLittle A likes integers that satisfy both properties; Uim likes integers that satisfy at least one of the properties; BaYeYong likes integers that satisfy exactly one of the properties; and Miss Beauty likes integers that don't satisfy either of the properties. Now given an integer $x$, please determine whether they like this integer or not.\n\ninput_format:\nEnter an integer $x(0\\le x \\le 1000)$\n\noutput_format:\nOutput this $4$individual like this number, if like output '1', otherwise output '0', separated by a space. The output order is: Small A, Uim, Yao Yong, Masami.\n*/\n\n#include<sstream>\n#include<stdlib.h>\n#include<algorithm>\n#include<math.h>\n#include<stdio.h>\n#include<vector>\n#include<string>\n#include<climits>\n#include<cstring>\n#include<iostream>\nusing namespace std;\n\n             \nstring solution(string std_in){\n    istringstream iss(std_in);\n             ", "constraints": "", "samples": [["12", "1 1 0 0"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000]}}
{"task_id": "P3741", "title": "honoka的键盘", "difficulty": "basic", "nl": "One day, she typed a string consisting of only two characters. When this string contains the substring \"VK\", honoka loves this string very much. Therefore, she wants to change at most one character (or make no change) to maximize the number of occurrences of \"VK\" in this string. Given the original string, please calculate how many times she can make the substring \"VK\" appear at most (we consider that \"VK\" appears only when 'V' and 'K' are adjacent).", "code": "#include<iostream>\n#include<iomanip>\n#include<algorithm>\n#include<string>\nusing namespace std;\nint main()\n{\n\tint n,c=-1,cnt=0;\n\tstring s,a=\"VK\";\n\tcin >> n >> s;\n\twhile (s.find(a, c + 1) != -1)\n\t{\n\t\t\tcnt++;\n\t\t\tint t = s.find(a, c + 1);\n\t\t\ts[t] = 'T';\n\t\t\ts[t + 1] = 'T';\n\t\t\tc = t;\n\t}\n\tfor (int i = 0; i < s.length()-1; i++)\n\t{\n\t\tstring w = \"KK\";\n\t\tstring e = \"VV\";\n\t\tif (s.find(w) != -1){ cnt++; break; }\n\t\tif (s.find(e) != -1){ cnt++; break; }\n\t}\n\t\n\tcout << cnt;\n}", "step": ["Read the integer n and string s from input.", "Loop through the string s and count the number of occurrences of \"VK\". Set the pair of characters to true to mark them as used.", "Loop through the string s again and count the number of identical adjacent characters that are not already marked as used. Set the flag tf to true if a pair is found.", "Output the total number of occurrences of \"VK\" and identical adjacent characters."], "nl_cn": "一天，她打出了一个只有这两个字符的字符串。当这个字符串里含有 `VK` 这个字符串的时候，honoka 就特别喜欢这个字符串。所以，她想改变至多一个字符（或者不做任何改变）来最大化这个字符串内 `VK` 出现的次数。给出原来的字符串，请计算她最多能使这个字符串内出现多少次 `VK`（只有当 `V` 和 `K` 正好相邻时，我们认为出现了 `VK`。）", "test_cases": [{"input": "2\nVK\n", "output": "1"}, {"input": "2\nVV", "output": "1"}, {"input": "1\nV", "output": "0"}, {"input": "20\nVKKKKKKKKKVVVVVVVVVK", "output": "3"}, {"input": "4\nKVKV\n", "output": "1"}, {"input": "3\nVVK\n", "output": "1"}, {"input": "8\nVVKKVVVV\n", "output": "2"}, {"input": "6\nKKKKVV\n", "output": "1"}, {"input": "5\nVVKKV\n", "output": "1"}, {"input": "7\nKVKKVKV\n", "output": "2"}, {"input": "8\nVKVVVVVK\n", "output": "3"}, {"input": "6\nKKVVVV\n", "output": "1"}, {"input": "15\nVVVVVVVVVVVVVKV\n", "output": "2"}, {"input": "7\nVKVKVKV\n", "output": "3"}, {"input": "8\nKVKKVKVV\n", "output": "3"}, {"input": "3\nVKV\n", "output": "1"}, {"input": "5\nKKKKV\n", "output": "1"}, {"input": "5\nVVVVV\n", "output": "1"}, {"input": "6\nVVVVKV\n", "output": "2"}, {"input": "9\nKVKVVVKVV\n", "output": "3"}, {"input": "10\nVVVVVKKKKK\n", "output": "2"}, {"input": "18\nVKVKVKVKVKVKVKVKVK\n", "output": "9"}, {"input": "4\nVKKV\n", "output": "1"}, {"input": "10\nKKKVVVKKKV\n", "output": "2"}, {"input": "8\nVKVKVVKV\n", "output": "3"}, {"input": "10\nKVKKVVVKVV\n", "output": "3"}, {"input": "5\nVKVKV\n", "output": "2"}, {"input": "6\nVKVVKV\n", "output": "2"}, {"input": "5\nVKVVK\n", "output": "2"}, {"input": "12\nKVKKVVVVVVVK\n", "output": "3"}], "test": "#undef NDEBUG\n#include<assert.h>\nint main(){\n    assert(solution(\"2\\nVK\\n\") == \"1\");\n    assert(solution(\"2\\nVV\") == \"1\");\n    assert(solution(\"1\\nV\") == \"0\");\n    assert(solution(\"20\\nVKKKKKKKKKVVVVVVVVVK\") == \"3\");\n    assert(solution(\"4\\nKVKV\\n\") == \"1\");\n    assert(solution(\"3\\nVVK\\n\") == \"1\");\n    assert(solution(\"8\\nVVKKVVVV\\n\") == \"2\");\n    assert(solution(\"6\\nKKKKVV\\n\") == \"1\");\n    assert(solution(\"5\\nVVKKV\\n\") == \"1\");\n    assert(solution(\"7\\nKVKKVKV\\n\") == \"2\");\n    assert(solution(\"8\\nVKVVVVVK\\n\") == \"3\");\n    assert(solution(\"6\\nKKVVVV\\n\") == \"1\");\n    assert(solution(\"15\\nVVVVVVVVVVVVVKV\\n\") == \"2\");\n    assert(solution(\"7\\nVKVKVKV\\n\") == \"3\");\n    assert(solution(\"8\\nKVKKVKVV\\n\") == \"3\");\n    assert(solution(\"3\\nVKV\\n\") == \"1\");\n    assert(solution(\"5\\nKKKKV\\n\") == \"1\");\n    assert(solution(\"5\\nVVVVV\\n\") == \"1\");\n    assert(solution(\"6\\nVVVVKV\\n\") == \"2\");\n    assert(solution(\"9\\nKVKVVVKVV\\n\") == \"3\");\n    assert(solution(\"10\\nVVVVVKKKKK\\n\") == \"2\");\n    assert(solution(\"18\\nVKVKVKVKVKVKVKVKVK\\n\") == \"9\");\n    assert(solution(\"4\\nVKKV\\n\") == \"1\");\n    assert(solution(\"10\\nKKKVVVKKKV\\n\") == \"2\");\n    assert(solution(\"8\\nVKVKVVKV\\n\") == \"3\");\n    assert(solution(\"10\\nKVKKVVVKVV\\n\") == \"3\");\n    assert(solution(\"5\\nVKVKV\\n\") == \"2\");\n    assert(solution(\"6\\nVKVVKV\\n\") == \"2\");\n    assert(solution(\"5\\nVKVVK\\n\") == \"2\");\n    assert(solution(\"12\\nKVKKVVVVVVVK\\n\") == \"3\");\n    return 0; \n}", "prompt": "/*One day, she typed a string consisting of only two characters. When this string contains the substring \"VK\", honoka loves this string very much. Therefore, she wants to change at most one character (or make no change) to maximize the number of occurrences of \"VK\" in this string. Given the original string, please calculate how many times she can make the substring \"VK\" appear at most (we consider that \"VK\" appears only when 'V' and 'K' are adjacent).\n\ninput_format:\nThe first line gives a number $n$, which represents the length of the string.\n\nThe second line gives a string $s$.\n\noutput_format:\nThe first line outputs an integer representing the answer.\n*/\n\n#include<sstream>\n#include<stdlib.h>\n#include<algorithm>\n#include<math.h>\n#include<stdio.h>\n#include<vector>\n#include<string>\n#include<climits>\n#include<cstring>\n#include<iostream>\nusing namespace std;\n\n             \nstring solution(string std_in){\n    istringstream iss(std_in);\n             ", "constraints": "对于 $100\\%$ 的数据，$1\\le n\\le 100$。", "samples": [["2\nVK\n", "1"], ["2\nVV", "1"], ["1\nV", "0"], ["20\nVKKKKKKKKKVVVVVVVVVK", "3"], ["4\nKVKV\n", "1\n"]], "limits": {"time": [400, 400, 400, 400, 400, 400, 400, 400, 400, 400, 400, 400, 400, 400, 400, 400, 400, 400, 400, 400, 400, 400, 400, 400, 400, 400, 400, 400, 400, 400, 400, 400, 400, 400, 400, 400, 400, 400, 400, 400, 400, 400, 400, 400, 400, 400, 400, 400, 400, 400], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}}
{"task_id": "P9044", "title": "[PA2021] Koszulki", "difficulty": "basic", "nl": "$n$ people participate in a competition, where person $i$ has a score of $a_i$. \n\nThe organizer decides to give out at least $k$ gifts. \n\nHowever, if $\\exists 1 \\leq x, y \\leq n, a_x \\geq a_y$ and person $x$ did not receive a gift but person $y$ did, then person $x$ will be dissatisfied. \n\nThe organizer wishes for everyone to be satisfied, find the minimum number of gifts to be given out.", "code": "#include <bits/stdc++.h>\nusing namespace std;\nint x,n,k,ans,ton[122];\nint main()\n{\n\tcin>>n>>k;\n\tfor(int i = 1;i<=n;i++) \n\t    cin>>x,ton[x]++;//在线操作 \n\tfor(int i = 120;i>0;i--)\n\t{ \n\t    ans+=ton[i];\n\t    if(ans>=k)\n\t\t\tbreak;\n\t}\n\tcout<<ans;\n\treturn 0;\n}", "step": ["Initialize variables x, n, k, ans, and ton.", "Input values for n and k.", "Loop through array and store count of each value in ton[] array.", "Loop through ton[] array in reverse order, updating ans and breaking out of loop when ans is greater than or equal to k.", "Output the value of ans.", "End of program."], "nl_cn": "$n$ 个人参加一场比赛，其中第 $i$ 个人的得分为 $a_i$。\n\n主办方决定至少颁发 $k$ 件礼物。\n\n但是，若 $\\exist 1 \\leq x, y \\leq n, a_x \\geq a_y$ 且 $x$ 未拿到礼物但 $y$ 拿到礼物，$x$ 会不满意。\n\n主办方希望每个人都满意，求颁发的礼物数量的最小值。", "test_cases": [{"input": "5 3\n75 90 120 75 40", "output": "4"}, {"input": "3 2\n10 5 12\n", "output": "2"}, {"input": "8 5\n5 10 8 15 20 25 30 35\n", "output": "5"}, {"input": "6 4\n3 2 5 1 6 4\n", "output": "4"}, {"input": "4 2\n1 3 2 4\n", "output": "2"}, {"input": "1 1\n10\n", "output": "1"}, {"input": "2 2\n7 7\n", "output": "2"}, {"input": "7 3\n8 10 5 7 3 9 6\n", "output": "3"}, {"input": "10 5\n10 9 8 7 6 5 4 3 2 1\n", "output": "5"}, {"input": "5 4\n5 2 3 4 1\n", "output": "4"}, {"input": "3 1\n100 200 300\n", "output": "1"}, {"input": "2 2\n9 8\n", "output": "2"}, {"input": "6 3\n5 2 5 4 3 1\n", "output": "3"}, {"input": "4 3\n1 2 3 4\n", "output": "3"}, {"input": "5 2\n20 10 15 17 23\n", "output": "2"}, {"input": "4 1\n5 4 3 2\n", "output": "1"}, {"input": "10 5\n100 90 80 70 60 50 40 30 20 10", "output": "5"}, {"input": "6 4\n10 20 30 40 50 60", "output": "4"}, {"input": "4 2\n75 50 100 80", "output": "2"}, {"input": "9 5\n10 20 30 40 50 60 70 80 90", "output": "5"}, {"input": "6 3\n70 80 90 100 110 120", "output": "3"}, {"input": "4 4\n50 60 70 80", "output": "4"}, {"input": "7 3\n20 30 40 50 60 70 80", "output": "3"}, {"input": "10 1\n100 90 80 70 60 50 40 30 20 10", "output": "1"}, {"input": "7 5\n10 20 30 40 50 60 70", "output": "5"}, {"input": "3 2\n50 60 70\n", "output": "2"}, {"input": "4 2\n80 70 60 50\n", "output": "2"}, {"input": "3 1\n1 2 5\n", "output": "1"}, {"input": "5 2\n10 7 3 5 2\n", "output": "2"}, {"input": "2 1\n99 100\n", "output": "1"}, {"input": "3 2\n40 50 60\n", "output": "2"}, {"input": "6 4\n70 80 50 80 70 60\n", "output": "4"}, {"input": "5 3\n10 20 30 40 50\n", "output": "3"}, {"input": "5 4\n80 90 100 70 60\n", "output": "4"}, {"input": "3 1\n1 2 3\n", "output": "1"}, {"input": "6 5\n100 90 80 70 60 50\n", "output": "5"}, {"input": "3 2\n80 60 40\n", "output": "2"}, {"input": "5 4\n100 90 80 70 60\n", "output": "4"}, {"input": "3 2\n100 80 90\n", "output": "2"}, {"input": "9 6\n85 75 65 60 90 95 80 70 55\n", "output": "6"}, {"input": "4 3\n100 100 90 80\n", "output": "3"}, {"input": "6 4\n90 85 80 75 70 65\n", "output": "4"}, {"input": "7 5\n70 80 90 85 75 65 60\n", "output": "5"}, {"input": "3 2\n100 90 110\n", "output": "2"}, {"input": "10 7\n60 70 80 85 90 95 75 65 55 50\n", "output": "7"}, {"input": "4 2\n90 80 70 60\n", "output": "2"}, {"input": "5 3\n85 80 90 75 65\n", "output": "3"}], "test": "#undef NDEBUG\n#include<assert.h>\nint main(){\n    assert(solution(\"5 3\\n75 90 120 75 40\") == \"4\");\n    assert(solution(\"3 2\\n10 5 12\\n\") == \"2\");\n    assert(solution(\"8 5\\n5 10 8 15 20 25 30 35\\n\") == \"5\");\n    assert(solution(\"6 4\\n3 2 5 1 6 4\\n\") == \"4\");\n    assert(solution(\"4 2\\n1 3 2 4\\n\") == \"2\");\n    assert(solution(\"1 1\\n10\\n\") == \"1\");\n    assert(solution(\"2 2\\n7 7\\n\") == \"2\");\n    assert(solution(\"7 3\\n8 10 5 7 3 9 6\\n\") == \"3\");\n    assert(solution(\"10 5\\n10 9 8 7 6 5 4 3 2 1\\n\") == \"5\");\n    assert(solution(\"5 4\\n5 2 3 4 1\\n\") == \"4\");\n    assert(solution(\"3 1\\n100 200 300\\n\") == \"1\");\n    assert(solution(\"2 2\\n9 8\\n\") == \"2\");\n    assert(solution(\"6 3\\n5 2 5 4 3 1\\n\") == \"3\");\n    assert(solution(\"4 3\\n1 2 3 4\\n\") == \"3\");\n    assert(solution(\"5 2\\n20 10 15 17 23\\n\") == \"2\");\n    assert(solution(\"4 1\\n5 4 3 2\\n\") == \"1\");\n    assert(solution(\"10 5\\n100 90 80 70 60 50 40 30 20 10\") == \"5\");\n    assert(solution(\"6 4\\n10 20 30 40 50 60\") == \"4\");\n    assert(solution(\"4 2\\n75 50 100 80\") == \"2\");\n    assert(solution(\"9 5\\n10 20 30 40 50 60 70 80 90\") == \"5\");\n    assert(solution(\"6 3\\n70 80 90 100 110 120\") == \"3\");\n    assert(solution(\"4 4\\n50 60 70 80\") == \"4\");\n    assert(solution(\"7 3\\n20 30 40 50 60 70 80\") == \"3\");\n    assert(solution(\"10 1\\n100 90 80 70 60 50 40 30 20 10\") == \"1\");\n    assert(solution(\"7 5\\n10 20 30 40 50 60 70\") == \"5\");\n    assert(solution(\"3 2\\n50 60 70\\n\") == \"2\");\n    assert(solution(\"4 2\\n80 70 60 50\\n\") == \"2\");\n    assert(solution(\"3 1\\n1 2 5\\n\") == \"1\");\n    assert(solution(\"5 2\\n10 7 3 5 2\\n\") == \"2\");\n    assert(solution(\"2 1\\n99 100\\n\") == \"1\");\n    assert(solution(\"3 2\\n40 50 60\\n\") == \"2\");\n    assert(solution(\"6 4\\n70 80 50 80 70 60\\n\") == \"4\");\n    assert(solution(\"5 3\\n10 20 30 40 50\\n\") == \"3\");\n    assert(solution(\"5 4\\n80 90 100 70 60\\n\") == \"4\");\n    assert(solution(\"3 1\\n1 2 3\\n\") == \"1\");\n    assert(solution(\"6 5\\n100 90 80 70 60 50\\n\") == \"5\");\n    assert(solution(\"3 2\\n80 60 40\\n\") == \"2\");\n    assert(solution(\"5 4\\n100 90 80 70 60\\n\") == \"4\");\n    assert(solution(\"3 2\\n100 80 90\\n\") == \"2\");\n    assert(solution(\"9 6\\n85 75 65 60 90 95 80 70 55\\n\") == \"6\");\n    assert(solution(\"4 3\\n100 100 90 80\\n\") == \"3\");\n    assert(solution(\"6 4\\n90 85 80 75 70 65\\n\") == \"4\");\n    assert(solution(\"7 5\\n70 80 90 85 75 65 60\\n\") == \"5\");\n    assert(solution(\"3 2\\n100 90 110\\n\") == \"2\");\n    assert(solution(\"10 7\\n60 70 80 85 90 95 75 65 55 50\\n\") == \"7\");\n    assert(solution(\"4 2\\n90 80 70 60\\n\") == \"2\");\n    assert(solution(\"5 3\\n85 80 90 75 65\\n\") == \"3\");\n    return 0; \n}", "prompt": "/*$n$ people participate in a competition, where person $i$ has a score of $a_i$. \n\nThe organizer decides to give out at least $k$ gifts. \n\nHowever, if $\\exists 1 \\leq x, y \\leq n, a_x \\geq a_y$ and person $x$ did not receive a gift but person $y$ did, then person $x$ will be dissatisfied. \n\nThe organizer wishes for everyone to be satisfied, find the minimum number of gifts to be given out.\n\ninput_format:\nFirst line, two integers $n, k$.\n\nIn the second row, $n$integers $a_1, a_2, \\cdots, a_n$.\n\noutput_format:\nOne line, an integer, represents the desired value.\n*/\n\n#include<sstream>\n#include<stdlib.h>\n#include<algorithm>\n#include<math.h>\n#include<stdio.h>\n#include<vector>\n#include<string>\n#include<climits>\n#include<cstring>\n#include<iostream>\nusing namespace std;\n\n             \nstring solution(string std_in){\n    istringstream iss(std_in);\n             ", "constraints": "#### 样例 #1 解释\n最优方案为除了最后一人以外全部送礼物。\n#### 数据范围\n对于 $100\\%$ 的数据，$1 \\leq k \\leq n \\leq 2 \\times 10^3$，$1 \\leq a_i \\leq 120$。", "samples": [["5 3\n75 90 120 75 40", "4"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288]}}
{"task_id": "P5196", "title": "[USACO19JAN]Cow Poetry G", "difficulty": "advanced", "nl": "Unknown to Farmer John, Bessie is also passionate about supporting artistic creation! Recently, she has been studying many great poets, and now she wants to try writing some poetry of her own.\n\nBessie knows N (1≤N≤5000) words that she wants to include in her poems. She has already calculated the length of each word she knows in syllables, and has grouped these words into different \"rhyme groups\". Each word only rhymes with other words in the same rhyme group.\n\nEach of Bessie's poems consists of M (1≤M≤10^5) lines, each of which must be composed of K (1≤K≤5000) syllables. In addition, Bessie's poems must follow a specified rhyme scheme.\n\nBessie wants to know how many different poems she can write that meet these conditions.", "code": "#include<cstdio>\n#include<iostream>\n#include<algorithm>\n#define N 5005\nusing namespace std;\ntypedef long long LL;\nint n,m,k;\nLL s[N],c[N];\nLL f[N],g[N];\nLL nd[30];\nconst LL mod=1000000007;\nLL ksm(LL b,LL k)\n{\n\tif(k==0) return 1;\n\tif(k==1) return b%mod;\n\tLL q=ksm(b,k>>1);\n\tif(k&1) return q*q%mod*b%mod;\n\telse return q*q%mod;\n}\nbool cmp(LL x,LL y)\n{\n\treturn x>y;\n}\nint main()\n{\n\tscanf(\"%d%d%d\",&n,&m,&k);\n\tfor(int i=1;i<=n;i++)\n\t\tscanf(\"%lld%lld\",&s[i],&c[i]);\n\tf[0]=1;\n\tfor(int j=0;j<=k;j++)\n\tif(f[j]) \n\t\tfor(int i=1;i<=n;i++)\n\t\t\tif(j+s[i]<=k)\tf[j+s[i]]=(f[j+s[i]]+f[j])%mod;\n\tfor(int i=1;i<=n;i++)\n\t\tg[c[i]]=(g[c[i]]+f[k-s[i]])%mod;\n\twhile(m--)\n\t{\n\t\tchar s[5];\n\t\tscanf(\"%s\",s);\n\t\tnd[s[0]-'A']++;\n\t}\n\tsort(nd,nd+26,cmp);\n\tsort(g+1,g+n+1,cmp);\n\tLL ans=1;\n\tfor(int i=0;i<26&&nd[i];i++)\n\t{\n\t\tLL x=nd[i],sum=0;\n\t\tfor(int j=1;j<=n&&g[j];j++)\n\t\t\tsum=(sum+ksm(g[j],x))%mod;\n\t\tans=ans*sum%mod; \t\n\t}\n\tprintf(\"%lld\\n\",ans);\n\treturn 0;\n}", "step": ["Read input values n, m, and k.", "Read arrays s and c of length n.", "Calculate the array f, where f[j] is the number of ways to fill a backpack with size j using some of the items in s.", "Calculate the array g, where g[c[i]] is the sum of f[k-s[i]] for all i.", "Sort the array g in descending order.", "Sort the array nd (an array containing the frequencies of each letter) in descending order.", "Calculate ans by raising each g[i] to the power of nd[i] and summing the results modulo mod.", "Output the value of ans."], "nl_cn": "不为Farmer John所知的是，Bessie还热衷于资助艺术创作！最近，她开始研究许多伟大的诗人们，而现在，她想要尝试创作一些属于自己的诗歌了。\nBessie认识N（1≤N≤5000）个单词，她想要将她们写进她的诗。Bessie已经计算了她认识的每个单词的长度，以音节为单位，并且她将这些单词划分成了不同的“韵部”。每个单词仅与属于同一韵部的其他单词押韵。\n\nBessie的每首诗由M行组成（1≤M≤10^5），每一行必须由K（1≤K≤5000）个音节构成。此外，Bessie的诗必须遵循某个指定的押韵模式。\n\nBessie想要知道她可以写出多少首符合限制条件的不同的诗。", "test_cases": [{"input": "3 3 10\n3 1\n4 1\n3 2\nA\nB\nA", "output": "960"}, {"input": "1 1 1\n1 1\nA\n", "output": "1"}, {"input": "3 3 10\n3 1\n4 1\n3 2\nA\nA\nB\n", "output": "960"}, {"input": "1 1 5\n5 1\nA\n", "output": "1"}, {"input": "3 2 6\n3 1\n3 2\nA\nA\n", "output": "32"}], "test": "#undef NDEBUG\n#include<assert.h>\nint main(){\n    assert(solution(\"3 3 10\\n3 1\\n4 1\\n3 2\\nA\\nB\\nA\") == \"960\");\n    assert(solution(\"1 1 1\\n1 1\\nA\\n\") == \"1\");\n    assert(solution(\"3 3 10\\n3 1\\n4 1\\n3 2\\nA\\nA\\nB\\n\") == \"960\");\n    assert(solution(\"1 1 5\\n5 1\\nA\\n\") == \"1\");\n    assert(solution(\"3 2 6\\n3 1\\n3 2\\nA\\nA\\n\") == \"32\");\n    return 0; \n}", "prompt": "/*Unknown to Farmer John, Bessie is also passionate about supporting artistic creation! Recently, she has been studying many great poets, and now she wants to try writing some poetry of her own.\n\nBessie knows N (1≤N≤5000) words that she wants to include in her poems. She has already calculated the length of each word she knows in syllables, and has grouped these words into different \"rhyme groups\". Each word only rhymes with other words in the same rhyme group.\n\nEach of Bessie's poems consists of M (1≤M≤10^5) lines, each of which must be composed of K (1≤K≤5000) syllables. In addition, Bessie's poems must follow a specified rhyme scheme.\n\nBessie wants to know how many different poems she can write that meet these conditions.\n\ninput_format:\nThe first line of input contains N, M, and K.\nThe following N lines, each containing two integers si (1≤si≤K) and ci (1≤ci≤N). This means that Bessie knows a word whose length (in syllables) is si and belongs to the verse ci.\n\nThe last M lines describe Bessie's desired rhyme pattern, with each line containing a capital letter ei. All lines with rhyme patterns equal to ei must end with words in the same rhyme part. Lines with different ei values do not have to end in words with different vowels.\n\noutput_format:\nOutput the number of different poems Bessie can write that meet these limitations. Since this number can be very large, calculate the remainder of 1,000,000,007 for this number.\n*/\n\n#include<sstream>\n#include<stdlib.h>\n#include<algorithm>\n#include<math.h>\n#include<stdio.h>\n#include<vector>\n#include<string>\n#include<climits>\n#include<cstring>\n#include<iostream>\nusing namespace std;\n\n             \nstring solution(string std_in){\n    istringstream iss(std_in);\n             ", "constraints": "在这个例子中，Bessie认识三个单词。前两个单词押韵，长度分别为三个音节和四个音节，最后一个单词长度为三个音节，不与其他单词押韵。她想要写一首三行的诗，每行包含十个音节，并且第一行和最后一行押韵。共有960首这样的诗。以下是一首满足要求的诗（其中1，2、3分别代表第一个、第二个、第三个单词）：121 123 321。", "samples": [["3 3 10\n3 1\n4 1\n3 2\nA\nB\nA", "960"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}}
{"task_id": "P6182", "title": "[USACO10OPEN]Time Travel S", "difficulty": "advanced", "nl": "Farmer John has bought a time machine, which enables him to manage his cows conveniently.\n\nHe now has $N$ operations ($1 \\leq N \\leq 8 \\times 10^4$), each of which can only be one of the following:\n\n1. `a x`: Add a cow with number $x$ ($1 \\leq x \\leq 10^6$).\n2. `s`: Sell the cow added most recently (guaranteed that there is at least one cow at this time).\n3. `t x`: Return to the state before the $x$th operation (guaranteed that the $x$th operation exists).\n\nAfter each operation, you need to output the newest cow number that FJ owns. If there is no cow, output $-1$ instead.", "code": "#include<cstdio>\n#include<iostream>\nusing namespace std;\nconst int N=8e4+10;\nint n,num[N],t[N],pre[N],top;\nint main(){\n    scanf(\"%d\",&n);\n    char ch;int x;\n    for(int i=1;i<=n;i++){\n        scanf(\" %c\",&ch);\n        if(ch=='a'){ \n          scanf(\"%d\",&x);num[++top]=x;\n            t[i]=top;pre[t[i]]=t[i-1];\n        }else if(ch=='t'){\n            scanf(\"%d\",&x);t[i]=t[x-1];\n        }else t[i]=pre[t[i-1]];\n        printf(\"%d\\n\",t[i]?num[t[i]]:-1);\n    }\n    return 0;\n}", "step": ["Read the input number n", "Initialize variables and arrays", "Loop over input characters", "If character is 'a', then read the integer x and perform push operation", "If character is 't', then read the integer x and perform tracking of previous item", "If character is anything else, then perform pop operation", "Print the top element of the resulting stack"], "nl_cn": "Farmer John 买了台时光机，这使得他可以方便地管理自己的奶牛群。\n\n他现在有 $N$ 个操作（$1 \\leq N \\leq 8 \\times 10^4$），每次操作仅可能是如下三种之一：\n\n1. `a x`：添加一头编号为 $x$ 的奶牛（$1 \\leq x \\leq 10^6$）。\n2. `s`：卖掉最近添加的奶牛（保证此时至少有一头奶牛）。\n3. `t x`：回到**第 $x$ 次操作前**的状态（保证第 $x$ 次操作存在）。\n\n你需要在 FJ 执行每次操作后输出他拥有的最新的奶牛的编号。特别地，如果没有奶牛，输出 $-1$。", "test_cases": [{"input": "12\na 5\na 3\na 7\ns\nt 2\na 2\nt 4\na 4\ns\nt 7\ns\ns", "output": "5\n3\n7\n3\n5\n2\n7\n4\n7\n2\n5\n-1"}, {"input": "1\na 1\n", "output": "1"}, {"input": "2\na 1\na 2\n", "output": "1\n2"}, {"input": "3\na 7\ns\ns\n", "output": "7\n-1\n-1"}, {"input": "2\na 100\ns\n", "output": "100\n-1"}, {"input": "4\na 2\ns\ns\ns\n", "output": "2\n-1\n-1\n-1"}, {"input": "2\na 50\ns\n", "output": "50\n-1"}, {"input": "3\na 3\ns\na 6\n", "output": "3\n-1\n6"}, {"input": "4\na 5\ns\ns\ns\n", "output": "5\n-1\n-1\n-1"}, {"input": "7\na 10\na 20\na 30\na 40\na 50\ns\ns\n", "output": "10\n20\n30\n40\n50\n40\n30"}, {"input": "2\ns\ns\n", "output": "-1\n-1"}, {"input": "6\na 100\na 200\na 300\na 400\ns\ns\n", "output": "100\n200\n300\n400\n300\n200"}, {"input": "5\na 8\na 9\na 10\ns\ns\n", "output": "8\n9\n10\n9\n8"}, {"input": "5\na 3\na 6\na 1\na 4\ns\n", "output": "3\n6\n1\n4\n1"}, {"input": "3\na 3\na 2\ns\n", "output": "3\n2\n3"}, {"input": "9\na 5\ns\na 3\ns\na 7\ns\na 2\ns\ns\n", "output": "5\n-1\n3\n-1\n7\n-1\n2\n-1\n-1"}, {"input": "7\na 5\ns\nt 1\na 3\nt 2\nt 4\ns\n", "output": "5\n-1\n-1\n3\n5\n-1\n-1"}, {"input": "5\na 3\na 9\na 2\nt 1\na 6\n", "output": "3\n9\n2\n-1\n6"}, {"input": "7\na 1\ns\nt 1\na 5\ns\na 9\ns\n", "output": "1\n-1\n-1\n5\n-1\n9\n-1"}, {"input": "4\na 6\na 8\nt 1\ns\n", "output": "6\n8\n-1\n-1"}, {"input": "2\na 9\nt 1\n", "output": "9\n-1"}], "test": "#undef NDEBUG\n#include<assert.h>\nint main(){\n    assert(solution(\"12\\na 5\\na 3\\na 7\\ns\\nt 2\\na 2\\nt 4\\na 4\\ns\\nt 7\\ns\\ns\") == \"5\\n3\\n7\\n3\\n5\\n2\\n7\\n4\\n7\\n2\\n5\\n-1\");\n    assert(solution(\"1\\na 1\\n\") == \"1\");\n    assert(solution(\"2\\na 1\\na 2\\n\") == \"1\\n2\");\n    assert(solution(\"3\\na 7\\ns\\ns\\n\") == \"7\\n-1\\n-1\");\n    assert(solution(\"2\\na 100\\ns\\n\") == \"100\\n-1\");\n    assert(solution(\"4\\na 2\\ns\\ns\\ns\\n\") == \"2\\n-1\\n-1\\n-1\");\n    assert(solution(\"2\\na 50\\ns\\n\") == \"50\\n-1\");\n    assert(solution(\"3\\na 3\\ns\\na 6\\n\") == \"3\\n-1\\n6\");\n    assert(solution(\"4\\na 5\\ns\\ns\\ns\\n\") == \"5\\n-1\\n-1\\n-1\");\n    assert(solution(\"7\\na 10\\na 20\\na 30\\na 40\\na 50\\ns\\ns\\n\") == \"10\\n20\\n30\\n40\\n50\\n40\\n30\");\n    assert(solution(\"2\\ns\\ns\\n\") == \"-1\\n-1\");\n    assert(solution(\"6\\na 100\\na 200\\na 300\\na 400\\ns\\ns\\n\") == \"100\\n200\\n300\\n400\\n300\\n200\");\n    assert(solution(\"5\\na 8\\na 9\\na 10\\ns\\ns\\n\") == \"8\\n9\\n10\\n9\\n8\");\n    assert(solution(\"5\\na 3\\na 6\\na 1\\na 4\\ns\\n\") == \"3\\n6\\n1\\n4\\n1\");\n    assert(solution(\"3\\na 3\\na 2\\ns\\n\") == \"3\\n2\\n3\");\n    assert(solution(\"9\\na 5\\ns\\na 3\\ns\\na 7\\ns\\na 2\\ns\\ns\\n\") == \"5\\n-1\\n3\\n-1\\n7\\n-1\\n2\\n-1\\n-1\");\n    assert(solution(\"7\\na 5\\ns\\nt 1\\na 3\\nt 2\\nt 4\\ns\\n\") == \"5\\n-1\\n-1\\n3\\n5\\n-1\\n-1\");\n    assert(solution(\"5\\na 3\\na 9\\na 2\\nt 1\\na 6\\n\") == \"3\\n9\\n2\\n-1\\n6\");\n    assert(solution(\"7\\na 1\\ns\\nt 1\\na 5\\ns\\na 9\\ns\\n\") == \"1\\n-1\\n-1\\n5\\n-1\\n9\\n-1\");\n    assert(solution(\"4\\na 6\\na 8\\nt 1\\ns\\n\") == \"6\\n8\\n-1\\n-1\");\n    assert(solution(\"2\\na 9\\nt 1\\n\") == \"9\\n-1\");\n    return 0; \n}", "prompt": "/*Farmer John has bought a time machine, which enables him to manage his cows conveniently.\n\nHe now has $N$ operations ($1 \\leq N \\leq 8 \\times 10^4$), each of which can only be one of the following:\n\n1. `a x`: Add a cow with number $x$ ($1 \\leq x \\leq 10^6$).\n2. `s`: Sell the cow added most recently (guaranteed that there is at least one cow at this time).\n3. `t x`: Return to the state before the $x$th operation (guaranteed that the $x$th operation exists).\n\nAfter each operation, you need to output the newest cow number that FJ owns. If there is no cow, output $-1$ instead.\n\ninput_format:\nThe first line is an integer $N$.\n\nNext $N$lines, each describing an operation.\n\noutput_format:\nLine $i$outputs the number of the latest cow owned by FJ after the $i$operation. In particular, if there is no cow, output $-1$.\n*/\n\n#include<sstream>\n#include<stdlib.h>\n#include<algorithm>\n#include<math.h>\n#include<stdio.h>\n#include<vector>\n#include<string>\n#include<climits>\n#include<cstring>\n#include<iostream>\nusing namespace std;\n\n             \nstring solution(string std_in){\n    istringstream iss(std_in);\n             ", "constraints": "下面是样例解释，其中拥有的奶牛已经按添加顺序排好。\n\n| 操作编号 | 操作  | 拥有的奶牛 | 输出 |\n| -------- | ----- | ---------- | ---- |\n| 1        | `a 5` | 5          | 5    |\n| 2        | `a 3` | 5,3        | 3    |\n| 3        | `a 7` | 5,3,7      | 7    |\n| 4        | `s`   | 5,3        | 3    |\n| 5        | `t 2` | 5          | 5    |\n| 6        | `a 2` | 5,2        | 2    |\n| 7        | `t 4` | 5,3,7      | 7    |\n| 8        | `a 4` | 5,3,7,4    | 4    |\n| 9        | `s`   | 5,3,7      | 7    |\n| 10       | `t 7` | 5,2        | 2    |\n| 11       | `s`   | 5          | 5    |\n| 12       | `s`   | /          | -1   |", "samples": [["12\na 5\na 3\na 7\ns\nt 2\na 2\nt 4\na 4\ns\nt 7\ns\ns", "5\n3\n7\n3\n5\n2\n7\n4\n7\n2\n5\n-1"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}}
{"task_id": "P3003", "title": "[USACO10DEC]Apple Delivery S", "difficulty": "challenge", "nl": "Bessie needs to give two fresh red apples to two friends in her herd. Of course, she has to travel on C (1 <= C <= 200,000) cow paths, which often connect P (1 <= P <= 100,000) conveniently numbered pastures and form a usual graph form: no cow path goes from a pasture to itself, the cow paths are bidirectional, each cow path has an associated distance, and most importantly, it is always possible to reach any other pasture from any pasture. Each cow path connects two different pastures P1_i (1 <= P1_i <= P) and P2_i (1 <= P2_i <= P), and the distance between them is D_i. The total of all distances D_i does not exceed 2,000,000,000.\n\nIf Bessie starts at pasture PB (1 <= PB <= P), and visits pastures PA1 (1 <= PA1 <= P) and PA2 (1 <= PA2 <= P) in any order, what is the shortest total distance she needs to travel? Of course, these three pastures are all distinct.\n\nConsider this map of pasture numbers and distances with parentheses:\n\n          3          2         2\n      [1]-----[2]------[3]-----[4]\n        \\     / \\              /\n       7\\   /4  \\3           /2\n         \\ /     \\          /\n         [5]-----[6]------[7]\n              1       2\n\nIf Bessie starts at pasture [5] and needs to deliver the apples to pastures [1] and [4], her optimal path would be:\n\n5 -> 6 -> 7 -> 4* -> 3 -> 2 -> 1*\n\nwith a total distance of 12.", "code": "#include<bits/stdc++.h>\nstruct node\n{\n\tint from,to,dis,next;\n}edge[400001];\nint n,m,num,head[200001],dis[200001],book[200001];\nstd::deque<int> b;\nvoid add(int u,int v,int w)\n{\n\tedge[++num].from=u;\n\tedge[num].to=v;\n\tedge[num].dis=w;\n\tedge[num].next=head[u];\n\thead[u]=num;\n\treturn;\n}\n\nint spfa(int s,int t)\n{\n\tmemset(book,0,sizeof(book));\n\tmemset(dis,0x7f,sizeof(dis));\n\tb.push_front(s);\n\tbook[s]=1;\n\tdis[s]=0;\n\twhile(b.size())\n\t{\n\t\tint x=b.front();\n\t\tb.pop_front();\n\t\tbook[x]=0;\n\t\tfor(int i=head[x];i;i=edge[i].next)\n\t\t\tif(dis[edge[i].to]>dis[x]+edge[i].dis)\n\t\t\t{\n\t\t\t\tdis[edge[i].to]=dis[x]+edge[i].dis;\n\t\t\t\tif(!book[edge[i].to])\n\t\t\t\t{\n\t\t\t\t\tbook[edge[i].to]=1;\n\t\t\t\t\tif(b.size()&&dis[edge[i].to]<dis[b.front()])\n\t\t\t\t\t\tb.push_front(edge[i].to);\n\t\t\t\t\telse\n\t\t\t\t\t\tb.push_back(edge[i].to);\n\t\t\t\t}\n\t\t\t}\n\t}\n\n\treturn dis[t];\n}\n\nint main()\n{\n\tint s,a,b;\n\tscanf(\"%d%d%d%d%d\",&m,&n,&s,&a,&b);\n\tfor(int i=1;i<=m;i++)\n\t{\n\t\tint u,v,w;\n\t\tscanf(\"%d%d%d\",&u,&v,&w);\n\t\tadd(u,v,w);\n\t\tadd(v,u,w);\n\t}\n\t\n\tprintf(\"%d\",std::min(spfa(s,a),spfa(s,b))+spfa(a,b));\n\treturn 0;\n}", "step": ["Define a struct node with 4 variables.", "Define global variables.", "Add an edge in the graph by inserting the Start node, Destination node and the weight of the edge.", "Initialize all the values of book with 0 and values of dis with 0x7f.", "Implement the SPFA algorithm technique to find the shortest path between any two nodes.", "Print the minimum value of shortest path between s->a, s->b and a->b."], "nl_cn": "Bessie has two crisp red apples to deliver to two of her friends in the herd. Of course, she travels the C (1 <= C <= 200,000)\n\ncowpaths which are arranged as the usual graph which connects P (1 <= P <= 100,000) pastures conveniently numbered from 1..P: no cowpath leads from a pasture to itself, cowpaths are bidirectional, each cowpath has an associated distance, and, best of all, it is always possible to get from any pasture to any other pasture. Each cowpath connects two differing pastures P1\\_i (1 <= P1\\_i <= P) and P2\\_i (1 <= P2\\_i <= P) with a distance between them of D\\_i. The sum of all the distances D\\_i does not exceed 2,000,000,000.\n\nWhat is the minimum total distance Bessie must travel to deliver both apples by starting at pasture PB (1 <= PB <= P) and visiting pastures PA1 (1 <= PA1 <= P) and PA2 (1 <= PA2 <= P) in any order. All three of these pastures are distinct, of course.\n\nConsider this map of bracketed pasture numbers and cowpaths with distances:\n\n```cpp\n               3        2       2\n           [1]-----[2]------[3]-----[4]\n             \\     / \\              /\n             7\\   /4  \\3           /2\n               \\ /     \\          /\n               [5]-----[6]------[7]\n                    1       2\n```\nIf Bessie starts at pasture [5] and delivers apples to pastures [1] and [4], her best path is:\n\n5 -> 6-> 7 -> 4\\* -> 3 -> 2 -> 1\\*\n\nwith a total distance of 12.", "test_cases": [{"input": "9 7 5 1 4 \n5 1 7 \n6 7 2 \n4 7 2 \n5 6 1 \n5 2 4 \n4 3 2 \n1 2 3 \n3 2 2 \n2 6 3 \n", "output": "12"}, {"input": "2 2 1 2 1 \n1 2 1 \n2 1 3 \n", "output": "1"}, {"input": "5 4 1 2 3 \n1 2 1 \n2 3 1 \n3 4 1 \n4 5 1 \n", "output": "2"}, {"input": "3 3 1 2 3 \n1 2 1 \n2 3 1 \n3 1 1 \n", "output": "2"}, {"input": "4 4 1 2 3 \n1 2 1 \n2 3 1 \n3 4 1 \n4 1 1 \n", "output": "2"}, {"input": "4 5 1 2 3 \n1 2 1 \n2 3 1 \n3 4 1 \n4 1 1 \n2 4 1 \n", "output": "2"}, {"input": "5 5 1 2 5 \n1 2 1 \n2 3 1 \n3 4 1 \n4 5 1 \n5 2 1 \n", "output": "2"}, {"input": "3 3 3 1 2 \n1 2 1 \n2 3 2 \n3 1 3 \n", "output": "3"}, {"input": "5 3 4 2 5 \n4 3 7 \n5 3 3 \n2 3 1 \n5 4 6 \n", "output": "10"}, {"input": "4 3 2 1 4 \n2 3 8 \n1 2 5 \n4 1 4 \n", "output": "9"}, {"input": "3 2 1 2 3 \n1 2 1 \n2 3 2 \n", "output": "3"}, {"input": "5 5 1 2 3 \n1 2 1 \n2 3 1 \n3 4 1 \n4 5 1 \n2 4 2 \n", "output": "2"}, {"input": "7 6 4 1 3 \n1 2 2 \n2 3 2 \n3 5 4 \n5 4 2 \n4 1 2 \n2 4 2 \n", "output": "6"}, {"input": "6 3 1 2 3 \n1 2 1 \n2 3 1 \n1 3 2 \n", "output": "2"}, {"input": "5 4 3 1 2 \n1 2 1 \n2 3 1 \n3 4 1 \n4 5 1 \n", "output": "2"}, {"input": "1 1 1 1 1 \n1 1 1 \n", "output": "0"}, {"input": "4 3 1 2 3 \n1 2 5 \n1 3 7 \n2 3 3 \n", "output": "8"}, {"input": "3 3 1 2 3 \n1 2 1 \n1 3 2 \n2 3 3 \n", "output": "4"}, {"input": "4 3 1 2 3 \n1 2 3 \n2 3 4 \n3 4 5 \n", "output": "7"}, {"input": "5 4 2 1 4 \n1 2 1 \n2 3 2 \n3 4 3 \n4 5 4 \n", "output": "7"}, {"input": "4 3 1 2 3 \n1 2 3 \n2 3 1 \n3 4 2 \n", "output": "4"}], "test": "#undef NDEBUG\n#include<assert.h>\nint main(){\n    assert(solution(\"9 7 5 1 4 \\n5 1 7 \\n6 7 2 \\n4 7 2 \\n5 6 1 \\n5 2 4 \\n4 3 2 \\n1 2 3 \\n3 2 2 \\n2 6 3 \\n\") == \"12\");\n    assert(solution(\"2 2 1 2 1 \\n1 2 1 \\n2 1 3 \\n\") == \"1\");\n    assert(solution(\"5 4 1 2 3 \\n1 2 1 \\n2 3 1 \\n3 4 1 \\n4 5 1 \\n\") == \"2\");\n    assert(solution(\"3 3 1 2 3 \\n1 2 1 \\n2 3 1 \\n3 1 1 \\n\") == \"2\");\n    assert(solution(\"4 4 1 2 3 \\n1 2 1 \\n2 3 1 \\n3 4 1 \\n4 1 1 \\n\") == \"2\");\n    assert(solution(\"4 5 1 2 3 \\n1 2 1 \\n2 3 1 \\n3 4 1 \\n4 1 1 \\n2 4 1 \\n\") == \"2\");\n    assert(solution(\"5 5 1 2 5 \\n1 2 1 \\n2 3 1 \\n3 4 1 \\n4 5 1 \\n5 2 1 \\n\") == \"2\");\n    assert(solution(\"3 3 3 1 2 \\n1 2 1 \\n2 3 2 \\n3 1 3 \\n\") == \"3\");\n    assert(solution(\"5 3 4 2 5 \\n4 3 7 \\n5 3 3 \\n2 3 1 \\n5 4 6 \\n\") == \"10\");\n    assert(solution(\"4 3 2 1 4 \\n2 3 8 \\n1 2 5 \\n4 1 4 \\n\") == \"9\");\n    assert(solution(\"3 2 1 2 3 \\n1 2 1 \\n2 3 2 \\n\") == \"3\");\n    assert(solution(\"5 5 1 2 3 \\n1 2 1 \\n2 3 1 \\n3 4 1 \\n4 5 1 \\n2 4 2 \\n\") == \"2\");\n    assert(solution(\"7 6 4 1 3 \\n1 2 2 \\n2 3 2 \\n3 5 4 \\n5 4 2 \\n4 1 2 \\n2 4 2 \\n\") == \"6\");\n    assert(solution(\"6 3 1 2 3 \\n1 2 1 \\n2 3 1 \\n1 3 2 \\n\") == \"2\");\n    assert(solution(\"5 4 3 1 2 \\n1 2 1 \\n2 3 1 \\n3 4 1 \\n4 5 1 \\n\") == \"2\");\n    assert(solution(\"1 1 1 1 1 \\n1 1 1 \\n\") == \"0\");\n    assert(solution(\"4 3 1 2 3 \\n1 2 5 \\n1 3 7 \\n2 3 3 \\n\") == \"8\");\n    assert(solution(\"3 3 1 2 3 \\n1 2 1 \\n1 3 2 \\n2 3 3 \\n\") == \"4\");\n    assert(solution(\"4 3 1 2 3 \\n1 2 3 \\n2 3 4 \\n3 4 5 \\n\") == \"7\");\n    assert(solution(\"5 4 2 1 4 \\n1 2 1 \\n2 3 2 \\n3 4 3 \\n4 5 4 \\n\") == \"7\");\n    assert(solution(\"4 3 1 2 3 \\n1 2 3 \\n2 3 1 \\n3 4 2 \\n\") == \"4\");\n    return 0; \n}", "prompt": "/*Bessie needs to give two fresh red apples to two friends in her herd. Of course, she has to travel on C (1 <= C <= 200,000) cow paths, which often connect P (1 <= P <= 100,000) conveniently numbered pastures and form a usual graph form: no cow path goes from a pasture to itself, the cow paths are bidirectional, each cow path has an associated distance, and most importantly, it is always possible to reach any other pasture from any pasture. Each cow path connects two different pastures P1_i (1 <= P1_i <= P) and P2_i (1 <= P2_i <= P), and the distance between them is D_i. The total of all distances D_i does not exceed 2,000,000,000.\n\nIf Bessie starts at pasture PB (1 <= PB <= P), and visits pastures PA1 (1 <= PA1 <= P) and PA2 (1 <= PA2 <= P) in any order, what is the shortest total distance she needs to travel? Of course, these three pastures are all distinct.\n\nConsider this map of pasture numbers and distances with parentheses:\n\n          3          2         2\n      [1]-----[2]------[3]-----[4]\n        \\     / \\              /\n       7\\   /4  \\3           /2\n         \\ /     \\          /\n         [5]-----[6]------[7]\n              1       2\n\nIf Bessie starts at pasture [5] and needs to deliver the apples to pastures [1] and [4], her optimal path would be:\n\n5 -> 6 -> 7 -> 4* -> 3 -> 2 -> 1*\n\nwith a total distance of 12.\n\ninput_format:\n\\* Line 1: Line 1 contains five space-separated integers: C, P, PB, PA1, and PA2\n\n\\* Lines 2..C+1: Line i+1 describes cowpath i by naming two pastures it connects and the distance between them: P1\\_i, P2\\_i, D\\_i\n\noutput_format:\n\\* Line 1: The shortest distance Bessie must travel to deliver both apples\n*/\n\n#include<sstream>\n#include<stdlib.h>\n#include<algorithm>\n#include<math.h>\n#include<stdio.h>\n#include<vector>\n#include<string>\n#include<climits>\n#include<cstring>\n#include<iostream>\nusing namespace std;\n\n             \nstring solution(string std_in){\n    istringstream iss(std_in);\n             ", "constraints": "", "samples": [["9 7 5 1 4 \n5 1 7 \n6 7 2 \n4 7 2 \n5 6 1 \n5 2 4 \n4 3 2 \n1 2 3 \n3 2 2 \n2 6 3 \n", "12 \n"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}}
{"task_id": "P8295", "title": "[COCI2012-2013#2] MORTADELA", "difficulty": "basic", "nl": "National chain supermarket (NSC) boasts that their Italian sausages are the cheapest in the country. In reality, if a customer can find cheaper sausages in other chain supermarkets, NSC will make up the difference. Matej and Filip decided to take on this challenge. They will visit N different chain stores one by one to find not only sausages cheaper than NSC, but also the cheapest on the market. If they succeed, they can buy the cheapest sausages at the NSC branch near their school. NSC hopes that no one can find cheaper sausages, because all chain supermarkets (including NSC) represent sausage prices in a complex way: X yuan Y grams of sausage. Write a program to give the prices of sausages in NSC and the other N chain stores, so that Matej and Filip can pay the price of 1000 grams of cooked sausages close to the NSC near their school.", "code": "#include <iostream>\n#include <cstdio>\n#include <algorithm>\nusing namespace std;\n\nint main()\n{\n\tint x, y;\n\tscanf(\"%d%d\", &x, &y);\n\tdouble ans = 1.0 * x / y * 1000;  //乘上 1.0 强制变成浮点数。 \n\tint n;\n\tscanf(\"%d\", &n);\n\tfor (int i = 1; i <= n; i++)\n\t{\n\t\tscanf(\"%d%d\", &x, &y);\n\t\tans = min(ans, 1.0 * x / y * 1000);\n\t}\n\tprintf(\"%.2lf\", ans);  //强制保留两位小数。 \n\treturn 0;\n}", "step": ["Take integer inputs x and y from the user.", "Calculate ratio by dividing x by y and multiply the result by 1000.", "Take an integer input n from the user.", "Use a loop to take input n number of times to get x and y from the user.", "Calculate the ratio between x and y and multiply by 1000. Compare this value with the previous minimum value.", "Print the final minimum value."], "nl_cn": "全国连锁超市（NSC）喜欢吹嘘它们的意式肉肠是全国最低的。\n\n实际上，如果顾客打算在其他连锁超市里找到更便宜的肉肠，那么 NSC 会向其补上差价。\n\nMatej 和 Filip 决定接受这个挑战。他们将会挨个走访 $N$ 家不同连锁店，来找到不仅比 NSC 便宜的熟香肠，而且在市场上最便宜的。如果他们成功了，他们就可以在他们学校附近的 NSC 分店买到最便宜的香肠。\n\nNSC 希望没有人能找到更便宜的香肠，因为所有所有连锁超市（包括 NSC）都以一种复杂的方式表示香肠的价格：$X$ 元 $Y$ 克香肠。\n\n请编写一个程序，给定 NSC 与其余 $N$ 家连锁店中的香肠价格，求 Matej 和 Filip 必须为靠近学校的 NSC 中的 $1000$ 克熟香肠支付的价格。", "test_cases": [{"input": "5 100\n3\n4 100\n3 100\n7 100", "output": "30.00"}, {"input": "13 6\n5\n56 679\n35 120\n99 999\n56 73\n37 532", "output": "69.55"}, {"input": "100 5\n3\n99 8\n65 14\n78 10", "output": "4642.86"}, {"input": "9 3\n2\n3 1\n4 1\n6 8\n1 1\n", "output": "3000.00"}, {"input": "20 8\n3\n30 80\n40 120\n35 90", "output": "333.33"}, {"input": "1 2\n1\n1 2\n", "output": "500.00"}, {"input": "7 3\n1\n5 2\n10 3\n20 6\n", "output": "2333.33"}, {"input": "15 5\n2\n12 4\n20 5\n25 3\n", "output": "3000.00"}, {"input": "20 4\n4\n15 5\n30 6\n25 3\n", "output": "3000.00"}, {"input": "100 20\n3\n80 5\n160 8\n200 10\n", "output": "5000.00"}, {"input": "10 50\n1\n10 50\n", "output": "200.00"}, {"input": "3 15\n5\n3 15\n2 10\n4 20\n", "output": "200.00"}, {"input": "100 10\n5\n10 10\n20 20\n30 30\n40 40\n50 50\n", "output": "1000.00"}, {"input": "3 10\n2\n1 10\n7 40\n", "output": "100.00"}, {"input": "8 10\n3\n3 15\n7 35\n4 20\n", "output": "200.00"}, {"input": "8 4\n3\n6 3\n4 2\n3 1\n", "output": "2000.00"}, {"input": "3 1\n5\n10 2\n15 3\n20 4\n25 5\n", "output": "3000.00"}], "test": "#undef NDEBUG\n#include<assert.h>\nint main(){\n    assert(solution(\"5 100\\n3\\n4 100\\n3 100\\n7 100\") == \"30.00\");\n    assert(solution(\"13 6\\n5\\n56 679\\n35 120\\n99 999\\n56 73\\n37 532\") == \"69.55\");\n    assert(solution(\"100 5\\n3\\n99 8\\n65 14\\n78 10\") == \"4642.86\");\n    assert(solution(\"9 3\\n2\\n3 1\\n4 1\\n6 8\\n1 1\\n\") == \"3000.00\");\n    assert(solution(\"20 8\\n3\\n30 80\\n40 120\\n35 90\") == \"333.33\");\n    assert(solution(\"1 2\\n1\\n1 2\\n\") == \"500.00\");\n    assert(solution(\"7 3\\n1\\n5 2\\n10 3\\n20 6\\n\") == \"2333.33\");\n    assert(solution(\"15 5\\n2\\n12 4\\n20 5\\n25 3\\n\") == \"3000.00\");\n    assert(solution(\"20 4\\n4\\n15 5\\n30 6\\n25 3\\n\") == \"3000.00\");\n    assert(solution(\"100 20\\n3\\n80 5\\n160 8\\n200 10\\n\") == \"5000.00\");\n    assert(solution(\"10 50\\n1\\n10 50\\n\") == \"200.00\");\n    assert(solution(\"3 15\\n5\\n3 15\\n2 10\\n4 20\\n\") == \"200.00\");\n    assert(solution(\"100 10\\n5\\n10 10\\n20 20\\n30 30\\n40 40\\n50 50\\n\") == \"1000.00\");\n    assert(solution(\"3 10\\n2\\n1 10\\n7 40\\n\") == \"100.00\");\n    assert(solution(\"8 10\\n3\\n3 15\\n7 35\\n4 20\\n\") == \"200.00\");\n    assert(solution(\"8 4\\n3\\n6 3\\n4 2\\n3 1\\n\") == \"2000.00\");\n    assert(solution(\"3 1\\n5\\n10 2\\n15 3\\n20 4\\n25 5\\n\") == \"3000.00\");\n    return 0; \n}", "prompt": "/*National chain supermarket (NSC) boasts that their Italian sausages are the cheapest in the country. In reality, if a customer can find cheaper sausages in other chain supermarkets, NSC will make up the difference. Matej and Filip decided to take on this challenge. They will visit N different chain stores one by one to find not only sausages cheaper than NSC, but also the cheapest on the market. If they succeed, they can buy the cheapest sausages at the NSC branch near their school. NSC hopes that no one can find cheaper sausages, because all chain supermarkets (including NSC) represent sausage prices in a complex way: X yuan Y grams of sausage. Write a program to give the prices of sausages in NSC and the other N chain stores, so that Matej and Filip can pay the price of 1000 grams of cooked sausages close to the NSC near their school.\n\ninput_format:\nThe first line of two positive integers $X_ {\\ textrm {NSC}} \\ (1 \\ le X_ {\\ textrm {NSC}} \\ le 100) $and $Y_ {\\ textrm {NSC}} \\ (1 \\ le Y_ {\\ textrm {NSC}} \\ le 10 ^ 3) $, Indicates that $X_{\\textrm{NSC}}$is the price of $Y_{\\textrm{NSC}}$gram sausage in the NSC chain.\n\nIn the second row, a positive integer $N\\ (1\\le N\\le 100)$indicates the number of chains (excluding NCS).\n\nThe next $N$line, each with two positive integers $X_i,Y_i\\ (X_i\\le 100, Y_i\\le 10^3)$, indicates that $X_i$is the price of $Y_i$gram sausage in the first $i$chain.\n\noutput_format:\nOutput only one line, a real number, representing the result, keeping $2 decimal places.\n*/\n\n#include<sstream>\n#include<stdlib.h>\n#include<algorithm>\n#include<math.h>\n#include<stdio.h>\n#include<vector>\n#include<string>\n#include<climits>\n#include<cstring>\n#include<iostream>\nusing namespace std;\n\n             \nstring solution(string std_in){\n    istringstream iss(std_in);\n             ", "constraints": "", "samples": [["5 100\n3\n4 100\n3 100\n7 100", "30.00"], ["13 6\n5\n56 679\n35 120\n99 999\n56 73\n37 532", "69.55"], ["100 5\n3\n99 8\n65 14\n78 10", "4642.86"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [32768, 32768, 32768, 32768, 32768, 32768, 32768, 32768, 32768, 32768]}}
{"task_id": "P1679", "title": "神奇的四次方数", "difficulty": "challenge", "nl": "With your help, v神 has found the perfect university for his classmates and needs to inform them. dm is in charge of communicating with the class, but v神 has asked for your help because dm is currently occupied with a math problem. The task is to decompose an integer m into the sum of n fourth power numbers, with n being the smallest possible value. For example, if m=706 and 706=5^4+3^4, then n=2.", "code": "#include<cstdio>\n#include<cstring>\n#include<cmath>\n#define min(x,y) (x<y?x:y)\nconst int MAXN=200010;\nint s[MAXN],f[MAXN];\nint m;\n\nint main()\n{\n    scanf(\"%d\",&m);\n    for(int i=1;i<=m;i++)\n        f[i]=1e8;\n    int n=ceil(sqrt(sqrt(m))+1);\n    for(int i=1;i<=n;i++)\n        s[i]=i*i*i*i;\n    for(int i=1;i<=n;i++)\n        for(int j=s[i];j<=m;j++)\n            f[j]=min(f[j],f[j-s[i]]+1);\n    printf(\"%d\\n\",f[m]);\n}", "step": ["Initialize an array 'f' with very large values. Read an integer 'm' from the input.", "Calculate the square root of the square root of 'm' and add 1 to it to get integer 'n'.", "Calculate the fourth power of integers from 1 to 'n' and store them in an array 's'.", "Fill up the array 'f' with minimum values required for summing up i using fourth powers. Check all the integers from i to m and update the minimum number of fourth powers required to make up each number.", "Print the minimum number of fourth powers required for summing up to 'm'."], "nl_cn": "在你的帮助下，v神终于帮同学找到了最合适的大学，接下来就要通知同学了。在班级里负责联络网的是dm同学，于是v神便找到了dm同学，可dm同学正在忙于研究一道有趣的数学题，为了请dm出山，v神只好请你帮忙解决这道题了。\n\n题目描述：将一个整数m分解为n个四次方数的和的形式，要求n最小。例如，m=706,706=5^4+3^4,则n=2。\n", "test_cases": [{"input": "706", "output": "2"}, {"input": "0", "output": "0"}, {"input": "1", "output": "1"}, {"input": "16", "output": "1"}, {"input": "81", "output": "1"}, {"input": "256", "output": "1"}, {"input": "1296", "output": "1"}, {"input": "4096", "output": "1"}, {"input": "20000", "output": "2"}, {"input": "10000\n", "output": "1"}], "test": "#undef NDEBUG\n#include<assert.h>\nint main(){\n    assert(solution(\"706\") == \"2\");\n    assert(solution(\"0\") == \"0\");\n    assert(solution(\"1\") == \"1\");\n    assert(solution(\"16\") == \"1\");\n    assert(solution(\"81\") == \"1\");\n    assert(solution(\"256\") == \"1\");\n    assert(solution(\"1296\") == \"1\");\n    assert(solution(\"4096\") == \"1\");\n    assert(solution(\"20000\") == \"2\");\n    assert(solution(\"10000\\n\") == \"1\");\n    return 0; \n}", "prompt": "/*With your help, v神 has found the perfect university for his classmates and needs to inform them. dm is in charge of communicating with the class, but v神 has asked for your help because dm is currently occupied with a math problem. The task is to decompose an integer m into the sum of n fourth power numbers, with n being the smallest possible value. For example, if m=706 and 706=5^4+3^4, then n=2.\n\ninput_format:\nOne line, an integer m.\n\noutput_format:\nOne line, one integer n.\n*/\n\n#include<sstream>\n#include<stdlib.h>\n#include<algorithm>\n#include<math.h>\n#include<stdio.h>\n#include<vector>\n#include<string>\n#include<climits>\n#include<cstring>\n#include<iostream>\nusing namespace std;\n\n             \nstring solution(string std_in){\n    istringstream iss(std_in);\n             ", "constraints": "### 数据范围及约定\n\n- 对于 $30\\%$ 的数据，$m \\le 5000$；\n- 对于 $100\\%$ 的数据，$m \\le 100,000$。", "samples": [["706", "2"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}}
{"task_id": "P2077", "title": "红绿灯", "difficulty": "challenge", "nl": "In a city, there is a straight road with $N$ intersections, each equipped with a traffic light. The distance between adjacent intersections is known to be $A_i$ kilometers $(1 \\leq i < N)$. The red light duration of each intersection is $R_i$, and the green light duration is $G_i$. There is no yellow light. Now, a car starts from a position $M$ km away from intersection $1$ when all traffic lights just switch from red to green. What is the time it takes for this car to pass through each intersection (the car cannot run a red light and travels at a speed of $1$ km per minute)?", "code": "#include<bits/stdc++.h>\n#include<iostream> \nusing namespace std;\nconst int N=1e5+10;\nint dist[N],r[N],g[N],t[N];\nint main()\n{\n\tint n,m;\n\tscanf(\"%d%d\",&n,&m);\n\tfor(int i=1;i<n;i++) scanf(\"%d\",&dist[i]);\n\tfor(int i=1;i<=n;i++) scanf(\"%d\",&r[i]);\n\tfor(int i=1;i<=n;i++) scanf(\"%d\",&g[i]);\n\tfor(int i=1;i<=n;i++)\n\t{\n\t\tif(i!=1) m+=dist[i-1];\n\t\tint t=r[i]+g[i];\n\t\tint mod=m%t; \n\t\tif(g[i]<mod)\n\t\t{\n\t\t\tm+=t-mod;\n\t\t} \n\t\tprintf(\"%d\\n\",m);\n\t}\n\treturn 0;\n}", "step": ["Read input values n and m", "Read dist array", "Read r and g arrays", "Iterate through stations", "Calculate time for stopping at current station", "Print the time"], "nl_cn": "在一个城市，有一条笔直的公路，在这条公路上有 $N$ 个十字路口，每个路口都设有一个红绿灯，已知相邻的两个路口距离为 $A_i$ 千米 $(1\\le i < N)$，每个路口的红灯时间为 $R_i$，绿灯时间为 $G_i$，没有黄灯，现在有一辆车从距离 $1$ 号十字路口 $M$ 千米的位置出发，且此时所有路口的红绿灯刚好从红灯跳到绿灯，问这辆车通过每个路口的时间(不能闯红灯，这辆车的速度为 $1$ 千米每分钟)。\n", "test_cases": [{"input": "5 3\n2 4 3 2\n3 4 3 4 3\n2 3 2 3 1\n", "output": "5\n7\n11\n14\n16"}, {"input": "2 3\n3\n3 2 3\n1 2 1\n", "output": "3\n6"}, {"input": "1 10\n\n1\n1\n", "output": "10"}, {"input": "5 1\n1 1 1 1\n1 2 3 4 5\n1 2 3 4 5\n", "output": "1\n2\n3\n4\n5"}, {"input": "0 0\n\n\n\n\n", "output": ""}, {"input": "1 2\n2\n5 10\n5 10\n", "output": "2"}, {"input": "2 3\n3\n1 2\n2 1\n", "output": "3\n6"}, {"input": "6 2\n2 2 2 2 2\n1 1 1 1 1 1\n2 2 2 2 2 2\n", "output": "2\n4\n6\n8\n10\n12"}, {"input": "6 1\n1 1 1 1 1\n1 1 1 1 1 1\n2 2 2 2 2 2\n", "output": "1\n2\n3\n4\n5\n6"}], "test": "#undef NDEBUG\n#include<assert.h>\nint main(){\n    assert(solution(\"5 3\\n2 4 3 2\\n3 4 3 4 3\\n2 3 2 3 1\\n\") == \"5\\n7\\n11\\n14\\n16\");\n    assert(solution(\"2 3\\n3\\n3 2 3\\n1 2 1\\n\") == \"3\\n6\");\n    assert(solution(\"1 10\\n\\n1\\n1\\n\") == \"10\");\n    assert(solution(\"5 1\\n1 1 1 1\\n1 2 3 4 5\\n1 2 3 4 5\\n\") == \"1\\n2\\n3\\n4\\n5\");\n    assert(solution(\"0 0\\n\\n\\n\\n\\n\") == \"\");\n    assert(solution(\"1 2\\n2\\n5 10\\n5 10\\n\") == \"2\");\n    assert(solution(\"2 3\\n3\\n1 2\\n2 1\\n\") == \"3\\n6\");\n    assert(solution(\"6 2\\n2 2 2 2 2\\n1 1 1 1 1 1\\n2 2 2 2 2 2\\n\") == \"2\\n4\\n6\\n8\\n10\\n12\");\n    assert(solution(\"6 1\\n1 1 1 1 1\\n1 1 1 1 1 1\\n2 2 2 2 2 2\\n\") == \"1\\n2\\n3\\n4\\n5\\n6\");\n    return 0; \n}", "prompt": "/*In a city, there is a straight road with $N$ intersections, each equipped with a traffic light. The distance between adjacent intersections is known to be $A_i$ kilometers $(1 \\leq i < N)$. The red light duration of each intersection is $R_i$, and the green light duration is $G_i$. There is no yellow light. Now, a car starts from a position $M$ km away from intersection $1$ when all traffic lights just switch from red to green. What is the time it takes for this car to pass through each intersection (the car cannot run a red light and travels at a speed of $1$ km per minute)?\n\ninput_format:\nThe first line has two positive integers $N$and $M$\n\nThe second row $N- $1 is a positive integer $A_i$\n\nThe third line is $N$positive integer $R_i$, which is the red light time (minutes).\n\nThe fourth line is $N$positive integer $G_i$, which is the green time (minutes).\n\noutput_format:\nA total of $N$lines, each with a positive integer, is the earliest time the car passes through each intersection.\n*/\n\n#include<sstream>\n#include<stdlib.h>\n#include<algorithm>\n#include<math.h>\n#include<stdio.h>\n#include<vector>\n#include<string>\n#include<climits>\n#include<cstring>\n#include<iostream>\nusing namespace std;\n\n             \nstring solution(string std_in){\n    istringstream iss(std_in);\n             ", "constraints": "对于 $50\\%$ 的数据   $N\\le 1000$；\n\n对于 $100\\%$ 的数据   $N\\le 10^5$，$M,A_i\\le 10$，$R_i，G_i\\le 5$。\n", "samples": [["5 3\n2 4 3 2\n3 4 3 4 3\n2 3 2 3 1\n", "5\n7\n11\n14\n16\n"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}}
{"task_id": "P5705", "title": "【深基2.例7】数字反转", "difficulty": "basic", "nl": "Input a floating number between 100 and 1000, including one decimal place, such as 123.4. Reverse the number to 4.321 and output it.", "code": "#include <cstdio>\n\nusing namespace std;\nchar a, b, c, d;\nint main(){\n\tscanf(\"%c%c%c.%c\", &a, &b, &c, &d);\n\tprintf(\"%c.%c%c%c\", d, c, b, a);\n\treturn 0;\n}", "step": ["Declare four char variables", "Read four characters from standard input", "Print the four characters in reverse order"], "nl_cn": "输入一个不小于 $100$ 且小于 $1000$，同时包括小数点后一位的一个浮点数，例如 $123.4$ ，要求把这个数字翻转过来，变成 $4.321$ 并输出。", "test_cases": [{"input": "123.4", "output": "4.321"}, {"input": "100.0\n", "output": "0.001"}, {"input": "547.6\n", "output": "6.745"}, {"input": "333.1\n", "output": "1.333"}, {"input": "999.9\n", "output": "9.999"}, {"input": "234.5\n", "output": "5.432"}, {"input": "432.1\n", "output": "1.234"}, {"input": "789.0\n", "output": "0.987"}, {"input": "176.8\n", "output": "8.671"}, {"input": "639.2\n", "output": "2.936"}, {"input": "825.7\n", "output": "7.528"}, {"input": "456.3\n", "output": "3.654"}, {"input": "567.8\n", "output": "8.765"}, {"input": "888.8\n", "output": "8.888"}, {"input": "345.2\n", "output": "2.543"}, {"input": "721.5\n", "output": "5.127"}, {"input": "123.0\n", "output": "0.321"}, {"input": "909.9\n", "output": "9.909"}, {"input": "678.9\n", "output": "9.876"}, {"input": "511.1\n", "output": "1.115"}, {"input": "199.9", "output": "9.991"}, {"input": "250.5\n", "output": "5.052"}, {"input": "365.2\n", "output": "2.563"}, {"input": "478.6\n", "output": "6.874"}, {"input": "513.9\n", "output": "9.315"}, {"input": "654.3\n", "output": "3.456"}, {"input": "777.7\n", "output": "7.777"}, {"input": "587.6\n", "output": "6.785"}, {"input": "433.1\n", "output": "1.334"}, {"input": "244.8\n", "output": "8.442"}, {"input": "811.7\n", "output": "7.118"}, {"input": "978.3\n", "output": "3.879"}, {"input": "399.5\n", "output": "5.993"}, {"input": "722.4\n", "output": "4.227"}, {"input": "511.6\n", "output": "6.115"}, {"input": "278.2\n", "output": "2.872"}, {"input": "621.9\n", "output": "9.126"}, {"input": "456.7\n", "output": "7.654"}, {"input": "111.1\n", "output": "1.111"}, {"input": "222.2\n", "output": "2.222"}, {"input": "333.3\n", "output": "3.333"}, {"input": "444.4\n", "output": "4.444"}, {"input": "555.5\n", "output": "5.555"}, {"input": "666.6\n", "output": "6.666"}, {"input": "200.0\n", "output": "0.002"}, {"input": "300.0\n", "output": "0.003"}, {"input": "400.0\n", "output": "0.004"}, {"input": "500.0\n", "output": "0.005"}, {"input": "600.0\n", "output": "0.006"}, {"input": "700.0\n", "output": "0.007"}, {"input": "800.0\n", "output": "0.008"}], "test": "#undef NDEBUG\n#include<assert.h>\nint main(){\n    assert(solution(\"123.4\") == \"4.321\");\n    assert(solution(\"100.0\\n\") == \"0.001\");\n    assert(solution(\"547.6\\n\") == \"6.745\");\n    assert(solution(\"333.1\\n\") == \"1.333\");\n    assert(solution(\"999.9\\n\") == \"9.999\");\n    assert(solution(\"234.5\\n\") == \"5.432\");\n    assert(solution(\"432.1\\n\") == \"1.234\");\n    assert(solution(\"789.0\\n\") == \"0.987\");\n    assert(solution(\"176.8\\n\") == \"8.671\");\n    assert(solution(\"639.2\\n\") == \"2.936\");\n    assert(solution(\"825.7\\n\") == \"7.528\");\n    assert(solution(\"456.3\\n\") == \"3.654\");\n    assert(solution(\"567.8\\n\") == \"8.765\");\n    assert(solution(\"888.8\\n\") == \"8.888\");\n    assert(solution(\"345.2\\n\") == \"2.543\");\n    assert(solution(\"721.5\\n\") == \"5.127\");\n    assert(solution(\"123.0\\n\") == \"0.321\");\n    assert(solution(\"909.9\\n\") == \"9.909\");\n    assert(solution(\"678.9\\n\") == \"9.876\");\n    assert(solution(\"511.1\\n\") == \"1.115\");\n    assert(solution(\"199.9\") == \"9.991\");\n    assert(solution(\"250.5\\n\") == \"5.052\");\n    assert(solution(\"365.2\\n\") == \"2.563\");\n    assert(solution(\"478.6\\n\") == \"6.874\");\n    assert(solution(\"513.9\\n\") == \"9.315\");\n    assert(solution(\"654.3\\n\") == \"3.456\");\n    assert(solution(\"777.7\\n\") == \"7.777\");\n    assert(solution(\"587.6\\n\") == \"6.785\");\n    assert(solution(\"433.1\\n\") == \"1.334\");\n    assert(solution(\"244.8\\n\") == \"8.442\");\n    assert(solution(\"811.7\\n\") == \"7.118\");\n    assert(solution(\"978.3\\n\") == \"3.879\");\n    assert(solution(\"399.5\\n\") == \"5.993\");\n    assert(solution(\"722.4\\n\") == \"4.227\");\n    assert(solution(\"511.6\\n\") == \"6.115\");\n    assert(solution(\"278.2\\n\") == \"2.872\");\n    assert(solution(\"621.9\\n\") == \"9.126\");\n    assert(solution(\"456.7\\n\") == \"7.654\");\n    assert(solution(\"111.1\\n\") == \"1.111\");\n    assert(solution(\"222.2\\n\") == \"2.222\");\n    assert(solution(\"333.3\\n\") == \"3.333\");\n    assert(solution(\"444.4\\n\") == \"4.444\");\n    assert(solution(\"555.5\\n\") == \"5.555\");\n    assert(solution(\"666.6\\n\") == \"6.666\");\n    assert(solution(\"200.0\\n\") == \"0.002\");\n    assert(solution(\"300.0\\n\") == \"0.003\");\n    assert(solution(\"400.0\\n\") == \"0.004\");\n    assert(solution(\"500.0\\n\") == \"0.005\");\n    assert(solution(\"600.0\\n\") == \"0.006\");\n    assert(solution(\"700.0\\n\") == \"0.007\");\n    assert(solution(\"800.0\\n\") == \"0.008\");\n    return 0; \n}", "prompt": "/*Input a floating number between 100 and 1000, including one decimal place, such as 123.4. Reverse the number to 4.321 and output it.\n\ninput_format:\nA floating-point number in a row\n\noutput_format:\nA floating-point number in a row\n*/\n\n#include<sstream>\n#include<stdlib.h>\n#include<algorithm>\n#include<math.h>\n#include<stdio.h>\n#include<vector>\n#include<string>\n#include<climits>\n#include<cstring>\n#include<iostream>\nusing namespace std;\n\n             \nstring solution(string std_in){\n    istringstream iss(std_in);\n             ", "constraints": "", "samples": [["123.4", "4.321"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000]}}
{"task_id": "P1605", "title": "迷宫", "difficulty": "challenge", "nl": "Given a maze of $N \\times M$ squares with $T$ obstacles, obstacles cannot be passed through.\n\nThere are four ways to move in the maze, up, down, left, and right, and only one square can be moved at a time. It is guaranteed that there are no obstacles on the starting point.\n\nGiven the starting point coordinates and the ending point coordinates, each square can be passed through at most once. How many ways are there to reach the ending point coordinates from the starting point coordinates?", "code": "#include<iostream>//个人建议不使用万能头文件，如果要使用万能头文件，就不能定义数组map；\n#include<cstdlib>\n#include<cstdio>\n#include<cmath>\nusing namespace std;\nint map[6][6];//地图；\nbool temp[6][6];//走过的标记；\nint dx[4]={0,0,1,-1};//打表；\nint dy[4]={-1,1,0,0};//打表；\nint total,fx,fy,sx,sy,T,n,m,l,r;//total计数器，fx，fy是终点坐标，sx，sy是起点坐标，T是障碍总数，n，m是地图的长和宽，l，r是障碍的横坐标和纵坐标；\nvoid walk(int x,int y)//定义walk；\n{\n    if(x==fx&&y==fy)//fx表示结束x坐标，fy表示结束y坐标；\n    {\n        total++;//总数增加；\n        return;//返回，继续搜索；\n    }\n    else\n    {\n        for(int i=0;i<=3;i++)//0——3是左，右，下，上四个方向；\n        {\n            if(temp[x+dx[i]][y+dy[i]]==0&&map[x+dx[i]][y+dy[i]]==1)//判断没有走过和没有障碍；\n            {\n                temp[x][y]=1;//走过的地方打上标记；\n                walk(x+dx[i],y+dy[i]);\n                temp[x][y]=0;//还原状态；\n            }    \n        } \n    }\n}\nint main()\n{\n    cin>>n>>m>>T;//n，m长度宽度，T障碍个数 \n    for(int ix=1;ix<=n;ix++)\n        for(int iy=1;iy<=m;iy++)\n            map[ix][iy]=1;//把地图刷成1；\n    cin>>sx>>sy;//起始x，y \n    cin>>fx>>fy;//结束x，y \n    for(int u=1;u<=T;u++)\n    {\n        cin>>l>>r;//l，r是障碍坐标；\n        map[l][r]=0;\n    }\n    walk(sx,sy);\n    cout<<total;//输出总数；\n    return 0;\n}", "step": ["Initialize variables and input the dimensions of the map, starting point, ending point, and number of obstacles.", "Create the map with the given dimensions and mark the starting and ending points.", "Input the locations of the obstacles on the map and mark them as obstacles.", "Use recursion to backtrack and explore every possible path from the starting point to the ending point, avoiding obstacles.", "Increment a counter variable for each successful path found.", "Output the total number of successful paths."], "nl_cn": "给定一个 $N \\times M$ 方格的迷宫，迷宫里有 $T$ 处障碍，障碍处不可通过。\n\n在迷宫中移动有上下左右四种方式，每次只能移动一个方格。数据保证起点上没有障碍。\n\n给定起点坐标和终点坐标，每个方格最多经过一次，问有多少种从起点坐标到终点坐标的方案。", "test_cases": [{"input": "2 2 1\n1 1 2 2\n1 2\n", "output": "1"}, {"input": "3 3 1\n1 1 3 3\n2 2\n", "output": "2"}, {"input": "4 4 2\n1 1 4 4\n2 2\n3 3\n", "output": "4"}, {"input": "2 3 1\n1 1 2 3\n2 2\n", "output": "1"}, {"input": "4 4 2\n1 1 4 4\n2 3\n3 2\n", "output": "8"}, {"input": "2 2 0\n1 1 2 2\n", "output": "2"}, {"input": "1 5 0\n1 1 1 5\n", "output": "1"}, {"input": "2 2 2\n1 1 1 2\n2 1\n", "output": "1"}, {"input": "3 3 3\n1 1 3 3\n1 2\n2 2\n3 1\n", "output": "0"}, {"input": "5 5 4\n1 3 5 5\n2 2\n3 3\n5 4\n4 5\n", "output": "0"}], "test": "#undef NDEBUG\n#include<assert.h>\nint main(){\n    assert(solution(\"2 2 1\\n1 1 2 2\\n1 2\\n\") == \"1\");\n    assert(solution(\"3 3 1\\n1 1 3 3\\n2 2\\n\") == \"2\");\n    assert(solution(\"4 4 2\\n1 1 4 4\\n2 2\\n3 3\\n\") == \"4\");\n    assert(solution(\"2 3 1\\n1 1 2 3\\n2 2\\n\") == \"1\");\n    assert(solution(\"4 4 2\\n1 1 4 4\\n2 3\\n3 2\\n\") == \"8\");\n    assert(solution(\"2 2 0\\n1 1 2 2\\n\") == \"2\");\n    assert(solution(\"1 5 0\\n1 1 1 5\\n\") == \"1\");\n    assert(solution(\"2 2 2\\n1 1 1 2\\n2 1\\n\") == \"1\");\n    assert(solution(\"3 3 3\\n1 1 3 3\\n1 2\\n2 2\\n3 1\\n\") == \"0\");\n    assert(solution(\"5 5 4\\n1 3 5 5\\n2 2\\n3 3\\n5 4\\n4 5\\n\") == \"0\");\n    return 0; \n}", "prompt": "/*Given a maze of $N \\times M$ squares with $T$ obstacles, obstacles cannot be passed through.\n\nThere are four ways to move in the maze, up, down, left, and right, and only one square can be moved at a time. It is guaranteed that there are no obstacles on the starting point.\n\nGiven the starting point coordinates and the ending point coordinates, each square can be passed through at most once. How many ways are there to reach the ending point coordinates from the starting point coordinates?\n\ninput_format:\nThe first three positive integers $N,M, and T$represent the length and width of the maze and the total number of obstacles, respectively.\n\nThe second is the four positive integers $SX,SY,FX,FY$, $SX,SY$for the starting coordinates, and $FX,FY$for the end coordinates.\n\nNext, the $T$line, with two positive integers per line, represents the coordinates of the obstacle points.\n\noutput_format:\nOutputs the total number of schemes from the start coordinates to the end coordinates.\n*/\n\n#include<sstream>\n#include<stdlib.h>\n#include<algorithm>\n#include<math.h>\n#include<stdio.h>\n#include<vector>\n#include<string>\n#include<climits>\n#include<cstring>\n#include<iostream>\nusing namespace std;\n\n             \nstring solution(string std_in){\n    istringstream iss(std_in);\n             ", "constraints": "对于 $100\\%$ 的数据，$1 \\le N,M \\le 5$，$1 \\le T \\le 10$，$1 \\le SX,FX \\le n$，$1 \\le SY,FY \\le m$。", "samples": [["2 2 1\n1 1 2 2\n1 2\n", "1"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}}
{"task_id": "P2836", "title": "加油问题", "difficulty": "advanced", "nl": "An American travel agent is often asked to estimate the minimum cost of driving from one city to another by car. He has a list of most gas stations on the usual route. The list includes the location of all gas stations and the current price of gasoline per gallon.\n\nTo simplify the cost estimation process, the agent uses the following rules of simplified car driver behavior:\n\n● Unless the car cannot reach the next gas station (if any) or destination with the gasoline in the tank, and there is no less than half of the maximum capacity of gasoline in the tank, the driver never stops at a gas station.\n\n● At every stop at a gas station, the driver always fills up the tank.\n\n● After stopping at a gas station, the driver spends $2.00 on snacks and candy for the journey.\n\n● When driving to a gas station or destination, the driver does not need to have more gasoline than necessary. There is no need for \"safety margin\".\n\n● The fuel tank is always full when the driver starts the journey.\n\n● When paying at each gas station, round up to the nearest cent (1 dollar equals 100 cents).\n\nYou must write a program to estimate how much the driver will have to pay for gas and food at least on the journey.", "code": "#include<bits/stdc++.h>\nusing namespace std;\nconst int N=100;\ndouble len,L,S,sum,x[N],y[N],minx;\nint n;\nvoid dfs(int t,double ans,double sum){\n\tif(sum>minx)return;\n\tif(t==n+1){\n\t\tminx=min(minx,sum);\t\n\t\treturn;\n\t}\n\tif(ans*S>=x[t+1]-x[t]){\n\t\tif(ans>=L/2)dfs(t+1,ans-(x[t+1]-x[t])/S,sum);\n\t\telse{\n\t\t\tdfs(t+1,ans-(x[t+1]-x[t])/S,sum);\n\t\t\tdfs(t+1,L-(x[t+1]-x[t])/S,sum+2+(L-ans)*y[t]);\n\t\t}\n\t}else dfs(t+1,L-(x[t+1]-x[t])/S,sum+2+(L-ans)*y[t]);\n}\nsigned main(){\n\tcin >> len >> L >> S >> sum >> n;\n\tminx=sum;\n\tfor(int i=1; i<=n; ++i){\n\t\tcin >> x[i] >> y[i];\n\t\ty[i]/=100;\n\t\tminx+=20+L*y[i];\n\t}\n\tminx = 2e18;\n\tx[n+1]=len;\n\tdfs(1,L-x[1]/S,sum);\n\tprintf(\"%.2lf\",minx);\n\treturn 0;\n}", "step": ["Initialize arrays and variables.", "Read input values.", "Set initial values.", "Calculate minimum cost for each section.", "Calculate the final minimum cost.", "Print the final minimum cost."], "nl_cn": "一个美国旅行代理商经常被要求去估计开车从一个城市旅行至另一个城市的最小费用。他有一个在通常路线上的大多数加油站的列表。列表包括了所有加油站的位置及当前每加仑汽油的价格。\n\n为了简化估计费用的过程，代理商使用了以下的简化汽车驾驶员行为的规则：\n\n●    除非汽车无法用油箱里的汽油达到下一个加油站（如果有的话）或目的地，在油箱里还有不少于最大容量一半的汽油时，驾驶员从不在加油站停下来。\n\n●    在每一个停下的加油站，驾驶员总是将油加满。\n\n●    在一个加油站停下之后，驾驶员将为旅程在快餐和糖果上花去2.00元。\n\n●    在驶向加油站或目的地时，驾驶员不需要超过必须量的汽油。不需要“安全余量”。\n\n●    驾驶员开始旅行时油箱总是满的\n\n●    每个加油站付款时四舍五入到分（1元等于100分）。\n\n你必须写一个程序以估计驾驶员在旅程上至少要为汽油和食品付多少钱。\n", "test_cases": [{"input": "475.6\n11.9 27.4 14.98 6\n102.0 99.9\n220.0 132.9\n256.3 147.9\n275.0 102.9\n277.6 112.9\n381.8 100.9", "output": "27.31"}], "test": "#undef NDEBUG\n#include<assert.h>\nint main(){\n    assert(solution(\"475.6\\n11.9 27.4 14.98 6\\n102.0 99.9\\n220.0 132.9\\n256.3 147.9\\n275.0 102.9\\n277.6 112.9\\n381.8 100.9\") == \"27.31\");\n    return 0; \n}", "prompt": "/*An American travel agent is often asked to estimate the minimum cost of driving from one city to another by car. He has a list of most gas stations on the usual route. The list includes the location of all gas stations and the current price of gasoline per gallon.\n\nTo simplify the cost estimation process, the agent uses the following rules of simplified car driver behavior:\n\n● Unless the car cannot reach the next gas station (if any) or destination with the gasoline in the tank, and there is no less than half of the maximum capacity of gasoline in the tank, the driver never stops at a gas station.\n\n● At every stop at a gas station, the driver always fills up the tank.\n\n● After stopping at a gas station, the driver spends $2.00 on snacks and candy for the journey.\n\n● When driving to a gas station or destination, the driver does not need to have more gasoline than necessary. There is no need for \"safety margin\".\n\n● The fuel tank is always full when the driver starts the journey.\n\n● When paying at each gas station, round up to the nearest cent (1 dollar equals 100 cents).\n\nYou must write a program to estimate how much the driver will have to pay for gas and food at least on the journey.\n\ninput_format:\nThe first 2 lines provide information about the origin and destination. The subsequent lines represent gas stations along the route, with each gas station represented by one line. The exact format and meaning of the items in the input data are as follows:\n\nFirst line: a real number - the distance from the origin to the destination (in miles)\n\nSecond line: three real numbers and one integer\n\n- The first real number is the maximum capacity of the car's fuel tank (in gallons)\n- The second real number is the number of miles the car can travel per gallon of gas\n- The third real number is the cost of filling up the car's tank in the origin city (in yuan)\n- The integer (less than 51) is the number of gas stations on the route, denoted as n\n\nEach subsequent line: two real numbers\n\n- The first real number is the distance from the origin to the gas station (in miles)\n- The second real number is the price per gallon of gasoline sold at that gas station (in cents)\n\nAll data in the input are positive. Gas stations on a route are arranged in ascending order according to their distance from the origin. There are no gas stations on the route that are farther from the origin than the distance from the origin to the destination. Gas stations along the route are arranged in such a way that any car can travel from the origin to the destination.\n\noutput_format:\nA single line, a real number (two decimal digits reserved), represents the smallest cost (unit: yuan).\n*/\n\n#include<sstream>\n#include<stdlib.h>\n#include<algorithm>\n#include<math.h>\n#include<stdio.h>\n#include<vector>\n#include<string>\n#include<climits>\n#include<cstring>\n#include<iostream>\nusing namespace std;\n\n             \nstring solution(string std_in){\n    istringstream iss(std_in);\n             ", "constraints": "### 数据范围及约定\n\n对于全部数据，$n \\le 51$。", "samples": [["475.6\n11.9 27.4 14.98 6\n102.0 99.9\n220.0 132.9\n256.3 147.9\n275.0 102.9\n277.6 112.9\n381.8 100.9", "27.31"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000]}}
{"task_id": "P5541", "title": "[USACO19FEB]Sleepy Cow Herding S", "difficulty": "challenge", "nl": "Farmer John's N cows always wander to distant places on the farm! He needs your help to bring them back together.\nThe pasture on the farm is generally a narrow area - we can imagine it as a number line, and cows can occupy any integer position on the number line. These N cows are currently located at different integer positions, and Farmer John wants to move them so that they occupy N adjacent positions (for example, positions 6, 7, 8).\nUnfortunately, the cows are very sleepy now, and it is not easy for Farmer John to make them concentrate and obey commands to move. At any time, he can only make a cow at an \"endpoint\" (the smallest or largest position among all cows) move. When he moves a cow, he can command it to move to any unoccupied integer position, as long as it is not an endpoint in the new position. As time goes on, such movements can bring cows closer and closer together.\nRequest the minimum and maximum possible values of the number of moves required to bring the cows together at adjacent positions.", "code": "#include<cmath>\n#include<cstdio>\n#include<cstring>\n#include<iostream>\n#include<algorithm> \nusing namespace std;\n \nint n,a[100005],x=0;\n\nint ansmin(){\n\tif((a[n-2]-a[0]==n-2&&a[n-1]-a[n-2]>2)||(a[n-1]-a[1]==n-2&&a[1]-a[0]>2))\n    //特判，如果a[n-2]到a[0]或a[n-1]到a[1]的间隔正好是N-2，而且a[n-1]到a[n-2]或a[1]到a[0]的距离大于2\n    //那么只要a[n-1]和a[n-2]或a[1]和a[0]各移动一次就可以了（你可以模拟试一试）\n\t\treturn 2;\n\tint j=0;\n\tfor(int i=0;i<n;i++){\n    \twhile(j<n-1&&a[j+1]-a[i]<=n-1)\n\t\t\tj++;\n    \tx=max(x,j-i+1);\n\t}\n\treturn n-x;\n}\n\nint ansmax(){\n\treturn max(a[n-2]-a[0],a[n-1]-a[1])-n+2;\n}\n\nint main(){\n\tscanf(\"%d\",&n);\n\tfor(int i=0;i<n;i++)\n\t\tscanf(\"%d\",&a[i]);\n\tsort(a,a+n);\n\tprintf(\"%d\\n%d\\n\",ansmin(),ansmax());\n\treturn 0;\n}", "step": ["Accept an integer value n as input.", "Accept an input array of n integers.", "Sort the input array in ascending order.", "Compute the ansmin using mathematical calculations based on the sorted array.", "Compute the ansmax using mathematical calculations based on the sorted array.", "Print the values of ansmin and ansmax."], "nl_cn": "Farmer John的N头奶牛，总是会迷路走到农场上遥远的地方去！他需要你帮助将她们一起赶回来。\n农场的草地大体是一块狭长的区域——我们可以将其想象成一条数轴，奶牛可以占据数轴上的任意整数位置。这N头奶牛现在正位于不同的整数位置，Farmer John想要移动她们，使得她们占据N个相邻的位置（例如，位置6、7、8）。\n\n不幸的是，奶牛们现在很困，Farmer John要让她们集中精力听从命令移动并不容易。任意时刻，他只能使得一头处在“端点”（在所有奶牛中位置最小或最大）位置的奶牛移动。当他移动奶牛时，他可以命令她走到任意一个未被占用的整数位置，只要在新的位置上她不再是一个端点。可以看到随着时间的推移，这样的移动可以使奶牛们趋向越来越近。\n\n请求出使得奶牛们集中到相邻位置所进行的移动次数的最小和最大可能值。", "test_cases": [{"input": "3 \n4 \n7 \n9", "output": "1\n2"}, {"input": "3 \n-1 \n0 \n1\n", "output": "0\n0"}], "test": "#undef NDEBUG\n#include<assert.h>\nint main(){\n    assert(solution(\"3 \\n4 \\n7 \\n9\") == \"1\\n2\");\n    assert(solution(\"3 \\n-1 \\n0 \\n1\\n\") == \"0\\n0\");\n    return 0; \n}", "prompt": "/*Farmer John's N cows always wander to distant places on the farm! He needs your help to bring them back together.\nThe pasture on the farm is generally a narrow area - we can imagine it as a number line, and cows can occupy any integer position on the number line. These N cows are currently located at different integer positions, and Farmer John wants to move them so that they occupy N adjacent positions (for example, positions 6, 7, 8).\nUnfortunately, the cows are very sleepy now, and it is not easy for Farmer John to make them concentrate and obey commands to move. At any time, he can only make a cow at an \"endpoint\" (the smallest or largest position among all cows) move. When he moves a cow, he can command it to move to any unoccupied integer position, as long as it is not an endpoint in the new position. As time goes on, such movements can bring cows closer and closer together.\nRequest the minimum and maximum possible values of the number of moves required to bring the cows together at adjacent positions.\n\ninput_format:\nEnter an integer N(N<=100000), and then enter N number, indicating the position of N cows.\n\noutput_format:\nThe first line of output contains the minimum number of moves Farmer John needs to make to round up the cows. The second row contains the maximum number of moves he can make to gather the cows together.\n*/\n\n#include<sstream>\n#include<stdlib.h>\n#include<algorithm>\n#include<math.h>\n#include<stdio.h>\n#include<vector>\n#include<string>\n#include<climits>\n#include<cstring>\n#include<iostream>\nusing namespace std;\n\n             \nstring solution(string std_in){\n    istringstream iss(std_in);\n             ", "constraints": " 2019 USACO二月月赛银牌组第一题", "samples": [["3 \n4 \n7 \n9", "1\n2"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144]}}
{"task_id": "P2779", "title": "[AHOI2016初中组] 黑白序列", "difficulty": "advanced", "nl": "First of all, for any positive integer $n$, if a black-and-white sequence consists of consecutive $n$ black colors followed by consecutive $n$ white colors, then it is definitely a black-and-white sequence that Xiaoxue likes.\n\nSecondly, if there are two black-and-white sequences that Xiaoxue likes, then she will definitely like the new sequence obtained by concatenating these two sequences. Xiaoxue will not like any other black-and-white sequences.\n\nFor example, if the characters `B` and `W` represent black and white respectively, then `BW`, `BBWW`, `BBBWWW` and `BWBW`, `BWBBWW`, `BWBBWWBW` are all black-and-white sequences that Xiaoxue likes, while `W`, `WW`, `WB`, `WBBW` and `BBBWW` are not.\n\nNow, Xiaokeke has prepared an unfinished black-and-white sequence, represented by `B` and `W` for black and white respectively, and represented by `?` for undetermined position. He wants to know how many different ways there are to determine the color of each `?` position, such that the resulting sequence is a black-and-white sequence that Xiaoxue likes.\n\nTwo schemes are considered different if they differ in at least one position, and positions that are not `?` are not allowed to be modified.\n\nThe answer should be modulo $10^9+9$ (a prime number).", "code": "#include<bits/stdc++.h>\nusing namespace std;\nconst int p=1e9+9;\nchar str[500006]; \nint dp[500006]={1},n;\nint main() {\n    cin>>str+1;\n    n=strlen(str+1);\n    for(int i=1;i<=n;i++) {\n    \tif(str[i]!='W') {\n    \t\tint l=i,r=i+1;\n    \t\tfor(int j=i;l>=1&&r<=n;j++) {\n    \t\t\tif(str[l]=='W'||str[r]=='B') break;\n    \t\t\tdp[r]=(dp[r]+dp[l-1])%p;\n    \t\t\tl--,r++;\n\t\t\t}\n\t\t}\n\t}\n\tcout<<dp[n];\n    return 0;\n}", "step": ["Read input string.", "Initialize dp array with 1.", "Iterate over every index of the string.", "If the current index character is not 'W', expand left and right while checking if the substring is symmetrical and increment the corresponding dp value.", "Output the value of dp at the end."], "nl_cn": "首先，对于任何正整数 $n$，如果一个黑白序列是由连续 $n$ 个黑接上连续 $n$ 个白，那一定是小雪喜欢的黑白序列。\n\n其次，如果有两个黑白序列小雪都喜欢，那么把这两个序列接起来得到的新序列，小雪也一定喜欢。小雪不会喜欢更多别的黑白序列。\n\n例如，如果用字符 `B` 和 `W` 分别表示黑色，`W` 表示白色，那么 `BW`，`BBWW`，`BBBWWW` 以及 `BWBW`，`BWBBWW`，`BWBBWWBW` 都是小雪喜欢的黑白序列。而 `W`，`WW`，`WB`，`WBBW` 以及 `BBBWW` 都不是小雪喜欢的黑白序列。\n\n现在小可可准备了一个未完成的黑白序列，用 `B` 和 `W` 表示黑色和白色，用 `?` 表示尚未确定，他希望知道一共有多少种不同的方法，在决定了每一个 `?` 位置的颜色后可以得到一个小雪喜欢的黑白序列。\n\n两个方案若有至少一位不同才能算是不同的，不是 `?` 的位置是不允许修改的。\n\n答案对 $10^9 + 9$（一个素数）取模。\n\n\n\n\n\n", "test_cases": [{"input": "B?B?????", "output": "6"}, {"input": "??BB????W???BB??????", "output": "26"}, {"input": "????????B???????????W??B?????W????????????????????W????????W", "output": "10058904"}, {"input": "BW", "output": "1"}, {"input": "BBWW", "output": "1"}, {"input": "BBBWWW", "output": "1"}, {"input": "BWBW", "output": "1"}, {"input": "BWBBWW", "output": "1"}, {"input": "BWBBWWBW", "output": "1"}, {"input": "W", "output": "0"}, {"input": "WW", "output": "0"}, {"input": "WB", "output": "0"}, {"input": "WBBW", "output": "0"}, {"input": "BBBWW", "output": "0"}, {"input": "BW?\n", "output": "0"}, {"input": "W?\n", "output": "0"}], "test": "#undef NDEBUG\n#include<assert.h>\nint main(){\n    assert(solution(\"B?B?????\") == \"6\");\n    assert(solution(\"??BB????W???BB??????\") == \"26\");\n    assert(solution(\"????????B???????????W??B?????W????????????????????W????????W\") == \"10058904\");\n    assert(solution(\"BW\") == \"1\");\n    assert(solution(\"BBWW\") == \"1\");\n    assert(solution(\"BBBWWW\") == \"1\");\n    assert(solution(\"BWBW\") == \"1\");\n    assert(solution(\"BWBBWW\") == \"1\");\n    assert(solution(\"BWBBWWBW\") == \"1\");\n    assert(solution(\"W\") == \"0\");\n    assert(solution(\"WW\") == \"0\");\n    assert(solution(\"WB\") == \"0\");\n    assert(solution(\"WBBW\") == \"0\");\n    assert(solution(\"BBBWW\") == \"0\");\n    assert(solution(\"BW?\\n\") == \"0\");\n    assert(solution(\"W?\\n\") == \"0\");\n    return 0; \n}", "prompt": "/*First of all, for any positive integer $n$, if a black-and-white sequence consists of consecutive $n$ black colors followed by consecutive $n$ white colors, then it is definitely a black-and-white sequence that Xiaoxue likes.\n\nSecondly, if there are two black-and-white sequences that Xiaoxue likes, then she will definitely like the new sequence obtained by concatenating these two sequences. Xiaoxue will not like any other black-and-white sequences.\n\nFor example, if the characters `B` and `W` represent black and white respectively, then `BW`, `BBWW`, `BBBWWW` and `BWBW`, `BWBBWW`, `BWBBWWBW` are all black-and-white sequences that Xiaoxue likes, while `W`, `WW`, `WB`, `WBBW` and `BBBWW` are not.\n\nNow, Xiaokeke has prepared an unfinished black-and-white sequence, represented by `B` and `W` for black and white respectively, and represented by `?` for undetermined position. He wants to know how many different ways there are to determine the color of each `?` position, such that the resulting sequence is a black-and-white sequence that Xiaoxue likes.\n\nTwo schemes are considered different if they differ in at least one position, and positions that are not `?` are not allowed to be modified.\n\nThe answer should be modulo $10^9+9$ (a prime number).\n\ninput_format:\nThe first line inputs a string of length greater than zero, consisting of `B`, `W`, and `?`.\n\noutput_format:\nOutput an integer representing the answer.\n*/\n\n#include<sstream>\n#include<stdlib.h>\n#include<algorithm>\n#include<math.h>\n#include<stdio.h>\n#include<vector>\n#include<string>\n#include<climits>\n#include<cstring>\n#include<iostream>\nusing namespace std;\n\n             \nstring solution(string std_in){\n    istringstream iss(std_in);\n             ", "constraints": "#### 样例输入输出 1 解释\n有六种合法方案，依次得到的最终黑白序列为： \n\n- `BBBBWWWW`，\n- `BBBWWWBW`，\n- `BWBBBWWW`，\n- `BWBBWWBW`，\n- `BWBWBBWW`，\n- `BWBWBWBW`。\n\n#### 数据规模与约定\n\n- 对于 $20\\%$ 的数据，输入长度不超过 $22$。\n- 对于 $60\\%$ 的数据，输入长度不超过 $5000$。\n- 对于 $100\\%$ 的数据，输入长度不超过 $500000$，保证序列中只含 `W`，`B`，`?` 三种字符，其中 `?` 是英文字符。", "samples": [["B?B?????", "6"], ["??BB????W???BB??????", "26"], ["????????B???????????W??B?????W????????????????????W????????W", "10058904"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}}
{"task_id": "P7901", "title": "「PMOI-0」潇湘の雨", "difficulty": "basic", "nl": "Lanuxhem needs to choose a point on a $2n\\times 2n$ matrix with coordinates $(x,y)$. \n\nNow he needs to choose a starting point on the matrix and then move through $k$ points according to the following rules: \n\n- They can only move to a neighboring point (up, down, left, or right) that is inside the matrix.\n\n- They must go through all the points on the matrix exactly once in each round of moves. After going through all points they consider the round complete.\n\n- After going through $k$ points, the last round of moves may not be complete.\n\nLanuxhem wants to know the minimum number of times they need to pass through the starting point.", "code": "#include<bits/stdc++.h>\nusing namespace std;\nlong long n,k,x,y;\nint main()\n{\n\tscanf(\"%lld%lld%lld%lld\",&n,&k,&x,&y);\n\tprintf(\"%lld\\n\",k/4/n/n);\n\treturn 0;\n}", "step": ["Define some constants and include necessary libraries.", "Define a 'read' and 'print' function.", "Define variables for input.", "Calculate and print the output value."], "nl_cn": "言琢დ 在一个 $2n \\times 2n$ 的矩阵中坐标为 $(x,y)$ 的一个点上。\n\n现在 Lanuxhem 需要任意选择矩阵上的一个点作为起点，然后依次经过 $k$ 个点，移动规则如下：\n\n- 每次移动只能选择与目前相邻（上下左右）的点作为本次移动的目标点。不能选择矩阵外的点。\n\n- 每一轮移动必须正好经过矩阵上的所有点，不能重复经过同一个点。每经过所有点后，视为一轮移动结束。\n\n- 注意依次经过 $k$ 个点后，最后一轮移动可能并没有完成。\n\n现在 Lanuxhem 想知道，他最少会经过 言琢დ 多少次。", "test_cases": [{"input": "2 16 1 1", "output": "1"}, {"input": "4 256 0 0\n", "output": "4"}], "test": "#undef NDEBUG\n#include<assert.h>\nint main(){\n    assert(solution(\"2 16 1 1\") == \"1\");\n    assert(solution(\"4 256 0 0\\n\") == \"4\");\n    return 0; \n}", "prompt": "/*Lanuxhem needs to choose a point on a $2n\\times 2n$ matrix with coordinates $(x,y)$. \n\nNow he needs to choose a starting point on the matrix and then move through $k$ points according to the following rules: \n\n- They can only move to a neighboring point (up, down, left, or right) that is inside the matrix.\n\n- They must go through all the points on the matrix exactly once in each round of moves. After going through all points they consider the round complete.\n\n- After going through $k$ points, the last round of moves may not be complete.\n\nLanuxhem wants to know the minimum number of times they need to pass through the starting point.\n\ninput_format:\nOn the first line, enter four positive integers $n,k,x,y$.\n\noutput_format:\nThe first line outputs an integer representing the answer.\n*/\n\n#include<sstream>\n#include<stdlib.h>\n#include<algorithm>\n#include<math.h>\n#include<stdio.h>\n#include<vector>\n#include<string>\n#include<climits>\n#include<cstring>\n#include<iostream>\nusing namespace std;\n\n             \nstring solution(string std_in){\n    istringstream iss(std_in);\n             ", "constraints": "### 样例说明\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/37e99o4k.png)\n\n$\\color{red}დ$ 代表 言琢დ 所在位置，红色线表示 lhm 第一轮的路径。\n\n### 数据规模与约定\n\n**本题采用捆绑测试。**\n\n| 子任务编号 | 分值 | $n,k\\le$ |\n| :----------: | :----------: | :----------: |\n| $1$ | $30$ | $10^4$ |\n| $2$ | $30$ | $10^9$ |\n| $3$ | $40$ | $10^{18}$ |\n\n对于所有数据，保证 $1\\le n,k\\le10^{18}$，$1\\le x,y\\le 2n$。", "samples": [["2 16 1 1", "1"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072]}}
{"task_id": "P8462", "title": "「REOI-1」奶油蛋糕", "difficulty": "challenge", "nl": "A cake on the table can be seen as an infinite [plane rectangular coordinate system], with every cake being located on an integer point in the coordinate system.\n\nEvery minute, William adds some layers of cream to each cake following the rule: if the i-th cake has not been eaten by Cocoa for i consecutive times, then i layers of cream will be sprayed on it.\n\nAfter William finishes creaming all cakes, Cocoa will pick one and eat one layer of the cream on that cake. If Cocoa eats one layer of cream on a cake, William will immediately add one layer to the same cake and this will not be considered as a time that the cake hasn't been eaten (i.e. the next i will still be 1).\n\nSince there are too many cakes, Cocoa doesn't know where to start. So she decides to try a mobile eating method. The eating sequence of Cocoa's cakes in m minutes can be expressed by a string of length m. The t-th character may be `N`, `S`, `W`, or `E`, respectively, indicating that Cocoa will eat the cake on the north, south, west, or east of the cake eaten in t-th minute. \n\nIn the first minute, Cocoa will pick up the cake at point $(x,y)$ because the cake has not been sprayed cream yet. Therefore, neither William nor Cocoa will take any action.\n\nCocoa wants to know how much cream is left on each cake after m minutes.\n\nIn this problem, up and right represent the positive y-axis and the positive x-axis, respectively.\n\n---\nSummary:\n\nThere is an $n\\times n$ area where the ground will be covered by i units of dust in the i-th minute after no one passes it. The dust will not be cleared even if someone passes, but dust falls one unit per minute after someone passes. A person moves within this $n\\times n$ area and his movement path can be described as a string consisting of $\\text{N,S,W,E}$, where each letter represents north, south, west, or east respectively. The person starts at point $(x,y)$ and moves one unit per minute. \n\nFind out how much dust is left at each location in the end.\n\nIt is guaranteed that the person will not move out of the area.", "code": "#include<bits/stdc++.h>\n#define N 55\n\nusing namespace std;\n\nint read()\n{\n    int x = 0,f = 1;\n    char c = getchar();\n    while(c<'0' || c>'9')\n\t{\n        if(c=='-') f = -1;\n        c = getchar();\n    }\n    while(c>='0' && c<='9')\n\t{\n        x = (x<<3)+(x<<1)+(c^48);\n        c = getchar();\n    }\n    return x*f;\n}\n\nint a[N][N],b[N][N];\n\nint main()\n{\n\tint n=read(),m=read(),y=read(),x=read();\n\tmemset(a,0,sizeof(a));\n\tfor (int i=1;i<=n;i++)\n\t\tfor (int j=1;j<=n;j++)\n\t\t\tb[i][j] = 1;\n\tx = n-x+1;\n\twhile(m--)\n\t{\n\t\tchar c;\n\t\tcin >> c;\n\t\tb[x][y] = 0;\n\t\tfor (int i=1;i<=n;i++)\n\t\t\tfor (int j=1;j<=n;j++)\n\t\t\t\ta[i][j] += b[i][j];\n\t\tif (c=='N') x--;\n\t\tif (c=='S') x++;\n\t\tif (c=='W') y--;\n\t\tif (c=='E') y++;\n\t\tfor (int i=1;i<=n;i++)\n\t\t\tfor (int j=1;j<=n;j++)\n\t\t\t\tb[i][j]++;\n\t}\n\tfor (int i=1;i<=n;i++)\n\t{\n\t\tfor (int j=1;j<=n;j++)\n\t\t\tcout << a[i][j] << \" \";\n\t\tcout << endl;\n\t}\n\treturn 0; \n}", "step": ["Define an integer constructor method to read input from user", "Initialize 2-D arrays of integers", "Read input from user and fill the 2-D arrays using a loop", "Update the arrays using input values", "Perform logical operations on given input and update the arrays", "Print the final result"], "nl_cn": "在桌子上的蛋糕可以看作是一个无限大的[平面直角坐标系]，每一个蛋糕都位于坐标系的整点上。 \n\n每一分钟，威廉会给每个蛋糕都涂上若干层奶油，规则如下：如果蛋糕连续第 $i$ 次没有被珂朵莉吃到，那么就会在蛋糕上挤上 $i$ 层奶油。  \n\n每次在威廉挤完所有蛋糕的奶油后，珂朵莉会拿起一块蛋糕，把这个蛋糕上的奶油给吃掉一层。特别的，如果珂朵莉吃掉了蛋糕上的一层奶油，威廉马上会贴心的再次给这个蛋糕补上一层，且不计入连续没有被吃到的次数里（即下一次的 $i$ 依旧为 $1$ ）。  \n\n由于蛋糕太多，珂朵莉实在不知道从何下手，所以她决定按照移动的吃法进行试吃。  \n总共 $m$ 个分钟，珂朵莉的吃蛋糕序列可以用一个长度为 $m$ 的字符串表达。第 $t$ 个字符可能为 `N`，`S`，`W`，`E`分别表示珂朵莉在第 $t+1$ 分钟会吃掉第 $t$ 分钟吃掉蛋糕的上，下，左，右方位的蛋糕。  \n珂朵莉第 $1$ 个分钟会拿起位于点 $(x,y)$ 的蛋糕，因为蛋糕目前没有被挤上奶油，所以珂朵莉既不会进行试吃，威廉也不会立刻给她补上奶油。\n\n珂朵莉想知道在 $m$ 分钟后，这些蛋糕在最后都还剩多少层奶油。\n\n本题中的上和右分别表示 $y$ 轴正方向和 $x$ 轴正方向。\n\n---\n简要题面：\n\n有一个 $n\\times n$ 的地块，一个连续 $i$ 分钟没人经过的地面在第 $i$ 分钟会落上 $i$ 个单位的灰，有人经过时不会落灰但灰也不会清零，在人走后第一分钟又会落上一个单位的灰，以此类推。有一个人在这个 $n\\times n$ 的范围内移动，他的移动轨迹可以描述为一个由 $\\text{N,S,W,E}$ 组成的字符串，每个字母分别表示上、下、左、右。这个人一开始在点 $(x,y)$，每一分钟移动一步。\n\n求最后每一个位置上落下的灰的量。\n\n保证这个人没有超过移动的范围。\n", "test_cases": [{"input": "5 4 1 1\nNENW", "output": "10 10 10 10 10 \n10 10 10 10 10 \n10 6 10 10 10 \n4 4 10 10 10 \n6 10 10 10 10"}, {"input": "7 14 1 1\nNENENENENESSSS", "output": "105 105 105 105 105 105 105 \n105 105 105 105 55 61 105 \n105 105 105 49 51 69 105 \n105 105 51 49 105 79 105 \n105 61 55 105 105 91 105 \n79 69 105 105 105 105 105 \n91 105 105 105 105 105 105"}, {"input": "10 70 2 2\nNWSNSNNNSNNSSNNSENNNNEESNWSESESSWENNSEWESWWWESEEESENNSENWNESNWSNNNEESS", "output": "2485 2485 2485 2485 2485 2485 2485 2485 2485 2485 \n2485 1407 1205 1267 2485 2485 2485 2485 2485 2485 \n2485 1435 1281 1167 2485 2485 2485 2217 2281 2347 \n2485 1465 2485 1255 1041 2485 2485 2155 2485 2415 \n1557 1497 2485 2485 969 1177 2485 1733 1807 2485 \n1471 1531 1315 907 935 1267 2485 1473 1647 2485 \n1631 2485 2485 1357 1381 1407 1435 1499 1645 2485 \n2021 2347 2485 2485 2485 2485 1465 1497 2485 2485 \n2087 2415 2485 2485 2485 2485 2485 2485 2485 2485 \n2485 2485 2485 2485 2485 2485 2485 2485 2485 2485"}, {"input": "5 4 2 1\nNENW", "output": "10 10 10 10 10 \n10 10 10 10 10 \n10 10 6 10 10 \n10 4 4 10 10 \n10 6 10 10 10"}], "test": "#undef NDEBUG\n#include<assert.h>\nint main(){\n    assert(solution(\"5 4 1 1\\nNENW\") == \"10 10 10 10 10 \\n10 10 10 10 10 \\n10 6 10 10 10 \\n4 4 10 10 10 \\n6 10 10 10 10\");\n    assert(solution(\"7 14 1 1\\nNENENENENESSSS\") == \"105 105 105 105 105 105 105 \\n105 105 105 105 55 61 105 \\n105 105 105 49 51 69 105 \\n105 105 51 49 105 79 105 \\n105 61 55 105 105 91 105 \\n79 69 105 105 105 105 105 \\n91 105 105 105 105 105 105\");\n    assert(solution(\"10 70 2 2\\nNWSNSNNNSNNSSNNSENNNNEESNWSESESSWENNSEWESWWWESEEESENNSENWNESNWSNNNEESS\") == \"2485 2485 2485 2485 2485 2485 2485 2485 2485 2485 \\n2485 1407 1205 1267 2485 2485 2485 2485 2485 2485 \\n2485 1435 1281 1167 2485 2485 2485 2217 2281 2347 \\n2485 1465 2485 1255 1041 2485 2485 2155 2485 2415 \\n1557 1497 2485 2485 969 1177 2485 1733 1807 2485 \\n1471 1531 1315 907 935 1267 2485 1473 1647 2485 \\n1631 2485 2485 1357 1381 1407 1435 1499 1645 2485 \\n2021 2347 2485 2485 2485 2485 1465 1497 2485 2485 \\n2087 2415 2485 2485 2485 2485 2485 2485 2485 2485 \\n2485 2485 2485 2485 2485 2485 2485 2485 2485 2485\");\n    assert(solution(\"5 4 2 1\\nNENW\") == \"10 10 10 10 10 \\n10 10 10 10 10 \\n10 10 6 10 10 \\n10 4 4 10 10 \\n10 6 10 10 10\");\n    return 0; \n}", "prompt": "/*A cake on the table can be seen as an infinite [plane rectangular coordinate system], with every cake being located on an integer point in the coordinate system.\n\nEvery minute, William adds some layers of cream to each cake following the rule: if the i-th cake has not been eaten by Cocoa for i consecutive times, then i layers of cream will be sprayed on it.\n\nAfter William finishes creaming all cakes, Cocoa will pick one and eat one layer of the cream on that cake. If Cocoa eats one layer of cream on a cake, William will immediately add one layer to the same cake and this will not be considered as a time that the cake hasn't been eaten (i.e. the next i will still be 1).\n\nSince there are too many cakes, Cocoa doesn't know where to start. So she decides to try a mobile eating method. The eating sequence of Cocoa's cakes in m minutes can be expressed by a string of length m. The t-th character may be `N`, `S`, `W`, or `E`, respectively, indicating that Cocoa will eat the cake on the north, south, west, or east of the cake eaten in t-th minute. \n\nIn the first minute, Cocoa will pick up the cake at point $(x,y)$ because the cake has not been sprayed cream yet. Therefore, neither William nor Cocoa will take any action.\n\nCocoa wants to know how much cream is left on each cake after m minutes.\n\nIn this problem, up and right represent the positive y-axis and the positive x-axis, respectively.\n\n---\nSummary:\n\nThere is an $n\\times n$ area where the ground will be covered by i units of dust in the i-th minute after no one passes it. The dust will not be cleared even if someone passes, but dust falls one unit per minute after someone passes. A person moves within this $n\\times n$ area and his movement path can be described as a string consisting of $\\text{N,S,W,E}$, where each letter represents north, south, west, or east respectively. The person starts at point $(x,y)$ and moves one unit per minute. \n\nFind out how much dust is left at each location in the end.\n\nIt is guaranteed that the person will not move out of the area.\n\ninput_format:\nThe first row of four positive integers $n,m,x,y$, meaning as shown on the surface, where $x,y$indicates horizontal and vertical coordinates, not array subscripts.\nThe second line is a string of length $m$, representing the sequence of Kodori's moves.\n\noutput_format:\nThere are $n$rows, the number of $n$in each row, and the number of $j$in the first row of $i$indicates the amount of gray on the coordinate $(j,n-i+1)$\n*/\n\n#include<sstream>\n#include<stdlib.h>\n#include<algorithm>\n#include<math.h>\n#include<stdio.h>\n#include<vector>\n#include<string>\n#include<climits>\n#include<cstring>\n#include<iostream>\nusing namespace std;\n\n             \nstring solution(string std_in){\n    istringstream iss(std_in);\n             ", "constraints": "**本题 y 轴朝上，x 轴朝右，样例输出中的左下角表示 $(1,1)$，第一分钟珂朵莉在初始点处，第二分钟移动到相应的位置，第 $m+1$ 分钟移动到最后一个点，但是总共只有 $m$ 分钟，因此最后一个点不受移动的影响**\n\n---\n**样例 1 解释：**\n\n珂朵莉的移动路径为 $(1,1)\\rightarrow(1,2)\\rightarrow(2,2)\\rightarrow(2,3)\\rightarrow(1,3)$，共 $4$ 分钟。\n\n对于第 $1$ 分钟，$(1,1)$ 奶油层数不变，其余点被挤上了 $1$ 层奶油。\n\n对于第 $2$ 分钟，$(1,2)$ 奶油层数不变，$(1,1)$ 被挤上了 $1$ 层奶油，其余点挤上 $2$ 层奶油。\n\n对于第 $3$ 分钟，$(2,2)$ 奶油层数不变，$(1,1)$ 挤上 $2$ 层奶油，$(1,2)$ 挤上 $1$ 层奶油，其余点挤上 $3$ 层奶油。\n\n对于第 $4$ 分钟，$(2,3)$ 奶油层数不变，$(1,1)$ 挤上 $3$ 层奶油，$(1,2)$ 挤上 $2$ 层奶油，$(2,2)$ 挤上 $1$ 层奶油，其余点挤上 $4$ 层奶油。\n\n**注意最后珂朵莉移动到了 $(1,3)$，但是时间只有 $4$ 分钟，所以实际上不会对 $(1,3)$ 造成影响。初始点不一定在 $(1,1)$。**\n\n$1\\le n\\leq 50,1\\leq m\\le 1000$。", "samples": [["5 4 1 1\nNENW", "10 10 10 10 10 \n10 10 10 10 10 \n10 6 10 10 10 \n4 4 10 10 10 \n6 10 10 10 10 \n"], ["7 14 1 1\nNENENENENESSSS", "105 105 105 105 105 105 105 \n105 105 105 105 55 61 105 \n105 105 105 49 51 69 105 \n105 105 51 49 105 79 105 \n105 61 55 105 105 91 105 \n79 69 105 105 105 105 105 \n91 105 105 105 105 105 105 \n"], ["10 70 2 2\nNWSNSNNNSNNSSNNSENNNNEESNWSESESSWENNSEWESWWWESEEESENNSENWNESNWSNNNEESS", "2485 2485 2485 2485 2485 2485 2485 2485 2485 2485 \n2485 1407 1205 1267 2485 2485 2485 2485 2485 2485 \n2485 1435 1281 1167 2485 2485 2485 2217 2281 2347 \n2485 1465 2485 1255 1041 2485 2485 2155 2485 2415 \n1557 1497 2485 2485 969 1177 2485 1733 1807 2485 \n1471 1531 1315 907 935 1267 2485 1473 1647 2485 \n1631 2485 2485 1357 1381 1407 1435 1499 1645 2485 \n2021 2347 2485 2485 2485 2485 1465 1497 2485 2485 \n2087 2415 2485 2485 2485 2485 2485 2485 2485 2485 \n2485 2485 2485 2485 2485 2485 2485 2485 2485 2485 \n"], ["5 4 2 1\nNENW", "10 10 10 10 10 \n10 10 10 10 10 \n10 10 6 10 10 \n10 4 4 10 10 \n10 6 10 10 10 \n"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000], "memory": [131072, 131072, 131072, 131072, 131072]}}
{"task_id": "P1115", "title": "最大子段和", "difficulty": "challenge", "nl": "Given a sequence $a$ of length $n$, select a contiguous non-empty subsequence of $a$ such that the sum of the subsequence is maximum.", "code": "#include<bits/stdc++.h>\nusing namespace std;\nint n,a[200020],b[200020],i,ans=-2147483647;\n\n// b[i] 表示截止到 i 时，第 i 个数所在的有效序列的元素和。\n\nint main(){\n   cin>>n;\n   for(i=1;i<=n;i++){\n       cin>>a[i];\n       if(i==1) b[i]=a[i];\n       else b[i]=max(a[i],b[i-1]+a[i]);\n       ans=max(ans,b[i]);\n   }\n   cout<<ans;\n   return 0;\n}", "step": ["Declare necessary variables.", "Take input the number of elements in the array.", "Take input the elements of the array.", "Calculate the maximum sum of a subarray using Dynamic Programming.", "Print the maximum sum."], "nl_cn": "给出一个长度为 $n$ 的序列 $a$，选出其中连续且非空的一段使得这段和最大。\n", "test_cases": [{"input": "7\n2 -4 3 -1 2 -4 3\n", "output": "4"}, {"input": "5\n1 2 3 4 5\n", "output": "15"}, {"input": "4\n-1 -2 -3 -4\n", "output": "-1"}, {"input": "8\n5 -10 15 -20 25 -30 35 -40\n", "output": "35"}, {"input": "3\n1 1 1\n", "output": "3"}, {"input": "6\n-1 -2 -3 4 -5 -6\n", "output": "4"}, {"input": "2\n10 -5\n", "output": "10"}, {"input": "1\n100\n", "output": "100"}, {"input": "9\n-10 -5 -20 -15 -30 -25 -40 -35 -50\n", "output": "-5"}, {"input": "5\n0 0 0 0 0\n", "output": "0"}, {"input": "4\n-100 -200 -300 -400\n", "output": "-100"}, {"input": "7\n-1 2 -3 4 -5 6 -7\n", "output": "6"}, {"input": "2\n1 1\n", "output": "2"}, {"input": "3\n-50 100 -50\n", "output": "100"}, {"input": "4\n-5 -10 -15 -20\n", "output": "-5"}, {"input": "6\n-1 -1 -1 -1 -1 -1\n", "output": "-1"}, {"input": "5\n100 200 300 400 500\n", "output": "1500"}, {"input": "9\n-1 2 -3 4 -5 6 -7 8 -9\n", "output": "8"}, {"input": "8\n-5 -10 -15 -20 -25 -30 -35 -40\n", "output": "-5"}, {"input": "6\n5 -5 10 -10 15 -15\n", "output": "15"}, {"input": "3\n1000 1000 1000\n", "output": "3000"}, {"input": "4\n1000 -1000 1000 -1000\n", "output": "1000"}, {"input": "3\n-1000 -1000 -1000\n", "output": "-1000"}, {"input": "5\n1 -1 1 -1 1\n", "output": "1"}, {"input": "6\n5 5 5 5 5 5\n", "output": "30"}, {"input": "3\n-1 -2 -3\n", "output": "-1"}, {"input": "7\n10 -5 7 -2 9 -4 3\n", "output": "19"}, {"input": "4\n-10 -5 -20 -15\n", "output": "-5"}, {"input": "2\n-1000 1000\n", "output": "1000"}, {"input": "7\n1 2 3 4 5 6 7\n", "output": "28"}, {"input": "3\n-1 0 1\n", "output": "1"}, {"input": "5\n-5 -5 -5 -5 -5\n", "output": "-5"}, {"input": "6\n-1 -2 -3 -4 -5 -6\n", "output": "-1"}, {"input": "5\n10 20 30 40 50\n", "output": "150"}, {"input": "6\n-2 5 -3 7 -4 2\n", "output": "9"}, {"input": "3\n-10 -5 -1\n", "output": "-1"}, {"input": "2\n0 0\n", "output": "0"}, {"input": "1\n9\n", "output": "9"}, {"input": "5\n-2 -3 4 -1 -2\n", "output": "4"}, {"input": "6\n1 2 -1 5 -2 3\n", "output": "8"}, {"input": "4\n7 -4 5 -6\n", "output": "8"}, {"input": "1\n-5\n", "output": "-5"}, {"input": "5\n-1 0 -1 2 -1\n", "output": "2"}, {"input": "8\n-1 -3 5 -2 10 -4 2 -1\n", "output": "13"}, {"input": "3\n3 2 1\n", "output": "6"}, {"input": "4\n-2 -2 -2 -2\n", "output": "-2"}, {"input": "7\n-1 -2 -3 0 -1 -2 -3\n", "output": "0"}, {"input": "5\n1 -2 3 -4 5\n", "output": "5"}, {"input": "3\n-4 -3 -2\n", "output": "-2"}, {"input": "4\n-1 -2 3 4\n", "output": "7"}, {"input": "6\n1 1 1 1 1 1\n", "output": "6"}, {"input": "5\n5 5 5 5 5\n", "output": "25"}, {"input": "2\n-1 10\n", "output": "10"}, {"input": "3\n1 2 -3\n", "output": "3"}, {"input": "4\n1 -2 3 4\n", "output": "7"}, {"input": "5\n-5 -5 -5 -5 5\n", "output": "5"}, {"input": "6\n100 -100 100 -100 100 -100\n", "output": "100"}, {"input": "8\n-8 -7 -6 -5 -4 -3 -2 -1\n", "output": "-1"}, {"input": "6\n-1 2 -3 4 -5 6\n", "output": "6"}, {"input": "3\n1 2 3\n", "output": "6"}, {"input": "5\n-1 -2 -3 -4 -5\n", "output": "-1"}, {"input": "2\n10 20\n", "output": "30"}, {"input": "6\n-1 0 -1 0 -1 0\n", "output": "0"}, {"input": "8\n10 20 -30 40 -50 60 -70 80\n", "output": "80"}, {"input": "10\n1 2 3 4 5 6 7 8 9 10\n", "output": "55"}, {"input": "5\n1 1 1 1 1\n", "output": "5"}, {"input": "7\n-1 -1 -1 -1 -1 -1 -1\n", "output": "-1"}, {"input": "6\n-1 -1 2 -2 1 -1\n", "output": "2"}, {"input": "3\n100 200 300\n", "output": "600"}, {"input": "4\n-10 0 10 20\n", "output": "30"}, {"input": "5\n-10 -10 -10 -10 -10\n", "output": "-10"}, {"input": "6\n-100 100 -200 200 -300 300\n", "output": "300"}, {"input": "8\n1 2 3 -1 -2 -3 1 2\n", "output": "6"}, {"input": "9\n-1 -2 -3 1 2 3 -1 -2 -3\n", "output": "6"}], "test": "#undef NDEBUG\n#include<assert.h>\nint main(){\n    assert(solution(\"7\\n2 -4 3 -1 2 -4 3\\n\") == \"4\");\n    assert(solution(\"5\\n1 2 3 4 5\\n\") == \"15\");\n    assert(solution(\"4\\n-1 -2 -3 -4\\n\") == \"-1\");\n    assert(solution(\"8\\n5 -10 15 -20 25 -30 35 -40\\n\") == \"35\");\n    assert(solution(\"3\\n1 1 1\\n\") == \"3\");\n    assert(solution(\"6\\n-1 -2 -3 4 -5 -6\\n\") == \"4\");\n    assert(solution(\"2\\n10 -5\\n\") == \"10\");\n    assert(solution(\"1\\n100\\n\") == \"100\");\n    assert(solution(\"9\\n-10 -5 -20 -15 -30 -25 -40 -35 -50\\n\") == \"-5\");\n    assert(solution(\"5\\n0 0 0 0 0\\n\") == \"0\");\n    assert(solution(\"4\\n-100 -200 -300 -400\\n\") == \"-100\");\n    assert(solution(\"7\\n-1 2 -3 4 -5 6 -7\\n\") == \"6\");\n    assert(solution(\"2\\n1 1\\n\") == \"2\");\n    assert(solution(\"3\\n-50 100 -50\\n\") == \"100\");\n    assert(solution(\"4\\n-5 -10 -15 -20\\n\") == \"-5\");\n    assert(solution(\"6\\n-1 -1 -1 -1 -1 -1\\n\") == \"-1\");\n    assert(solution(\"5\\n100 200 300 400 500\\n\") == \"1500\");\n    assert(solution(\"9\\n-1 2 -3 4 -5 6 -7 8 -9\\n\") == \"8\");\n    assert(solution(\"8\\n-5 -10 -15 -20 -25 -30 -35 -40\\n\") == \"-5\");\n    assert(solution(\"6\\n5 -5 10 -10 15 -15\\n\") == \"15\");\n    assert(solution(\"3\\n1000 1000 1000\\n\") == \"3000\");\n    assert(solution(\"4\\n1000 -1000 1000 -1000\\n\") == \"1000\");\n    assert(solution(\"3\\n-1000 -1000 -1000\\n\") == \"-1000\");\n    assert(solution(\"5\\n1 -1 1 -1 1\\n\") == \"1\");\n    assert(solution(\"6\\n5 5 5 5 5 5\\n\") == \"30\");\n    assert(solution(\"3\\n-1 -2 -3\\n\") == \"-1\");\n    assert(solution(\"7\\n10 -5 7 -2 9 -4 3\\n\") == \"19\");\n    assert(solution(\"4\\n-10 -5 -20 -15\\n\") == \"-5\");\n    assert(solution(\"2\\n-1000 1000\\n\") == \"1000\");\n    assert(solution(\"7\\n1 2 3 4 5 6 7\\n\") == \"28\");\n    assert(solution(\"3\\n-1 0 1\\n\") == \"1\");\n    assert(solution(\"5\\n-5 -5 -5 -5 -5\\n\") == \"-5\");\n    assert(solution(\"6\\n-1 -2 -3 -4 -5 -6\\n\") == \"-1\");\n    assert(solution(\"5\\n10 20 30 40 50\\n\") == \"150\");\n    assert(solution(\"6\\n-2 5 -3 7 -4 2\\n\") == \"9\");\n    assert(solution(\"3\\n-10 -5 -1\\n\") == \"-1\");\n    assert(solution(\"2\\n0 0\\n\") == \"0\");\n    assert(solution(\"1\\n9\\n\") == \"9\");\n    assert(solution(\"5\\n-2 -3 4 -1 -2\\n\") == \"4\");\n    assert(solution(\"6\\n1 2 -1 5 -2 3\\n\") == \"8\");\n    assert(solution(\"4\\n7 -4 5 -6\\n\") == \"8\");\n    assert(solution(\"1\\n-5\\n\") == \"-5\");\n    assert(solution(\"5\\n-1 0 -1 2 -1\\n\") == \"2\");\n    assert(solution(\"8\\n-1 -3 5 -2 10 -4 2 -1\\n\") == \"13\");\n    assert(solution(\"3\\n3 2 1\\n\") == \"6\");\n    assert(solution(\"4\\n-2 -2 -2 -2\\n\") == \"-2\");\n    assert(solution(\"7\\n-1 -2 -3 0 -1 -2 -3\\n\") == \"0\");\n    assert(solution(\"5\\n1 -2 3 -4 5\\n\") == \"5\");\n    assert(solution(\"3\\n-4 -3 -2\\n\") == \"-2\");\n    assert(solution(\"4\\n-1 -2 3 4\\n\") == \"7\");\n    assert(solution(\"6\\n1 1 1 1 1 1\\n\") == \"6\");\n    assert(solution(\"5\\n5 5 5 5 5\\n\") == \"25\");\n    assert(solution(\"2\\n-1 10\\n\") == \"10\");\n    assert(solution(\"3\\n1 2 -3\\n\") == \"3\");\n    assert(solution(\"4\\n1 -2 3 4\\n\") == \"7\");\n    assert(solution(\"5\\n-5 -5 -5 -5 5\\n\") == \"5\");\n    assert(solution(\"6\\n100 -100 100 -100 100 -100\\n\") == \"100\");\n    assert(solution(\"8\\n-8 -7 -6 -5 -4 -3 -2 -1\\n\") == \"-1\");\n    assert(solution(\"6\\n-1 2 -3 4 -5 6\\n\") == \"6\");\n    assert(solution(\"3\\n1 2 3\\n\") == \"6\");\n    assert(solution(\"5\\n-1 -2 -3 -4 -5\\n\") == \"-1\");\n    assert(solution(\"2\\n10 20\\n\") == \"30\");\n    assert(solution(\"6\\n-1 0 -1 0 -1 0\\n\") == \"0\");\n    assert(solution(\"8\\n10 20 -30 40 -50 60 -70 80\\n\") == \"80\");\n    assert(solution(\"10\\n1 2 3 4 5 6 7 8 9 10\\n\") == \"55\");\n    assert(solution(\"5\\n1 1 1 1 1\\n\") == \"5\");\n    assert(solution(\"7\\n-1 -1 -1 -1 -1 -1 -1\\n\") == \"-1\");\n    assert(solution(\"6\\n-1 -1 2 -2 1 -1\\n\") == \"2\");\n    assert(solution(\"3\\n100 200 300\\n\") == \"600\");\n    assert(solution(\"4\\n-10 0 10 20\\n\") == \"30\");\n    assert(solution(\"5\\n-10 -10 -10 -10 -10\\n\") == \"-10\");\n    assert(solution(\"6\\n-100 100 -200 200 -300 300\\n\") == \"300\");\n    assert(solution(\"8\\n1 2 3 -1 -2 -3 1 2\\n\") == \"6\");\n    assert(solution(\"9\\n-1 -2 -3 1 2 3 -1 -2 -3\\n\") == \"6\");\n    return 0; \n}", "prompt": "/*Given a sequence $a$ of length $n$, select a contiguous non-empty subsequence of $a$ such that the sum of the subsequence is maximum.\n\ninput_format:\nThe first line is an integer representing the length of the sequence, denoted as $n$.\n\nThe second line consists of $n$ integers, where the $i$-th integer represents the $i$-th number of the sequence, denoted as $a_i$.\n\noutput_format:\nOutput a line with an integer representing the answer.\n*/\n\n#include<sstream>\n#include<stdlib.h>\n#include<algorithm>\n#include<math.h>\n#include<stdio.h>\n#include<vector>\n#include<string>\n#include<climits>\n#include<cstring>\n#include<iostream>\nusing namespace std;\n\n             \nstring solution(string std_in){\n    istringstream iss(std_in);\n             ", "constraints": "#### 样例 1 解释\n\n选取 $[3, 5]$ 子段 $\\{3, -1, 2\\}$，其和为 $4$。\n\n#### 数据规模与约定\n\n- 对于 $40\\%$ 的数据，保证 $n \\leq 2 \\times 10^3$。\n- 对于 $100\\%$ 的数据，保证 $1 \\leq n \\leq 2 \\times 10^5$，$-10^4 \\leq a_i \\leq 10^4$。\n", "samples": [["7\n2 -4 3 -1 2 -4 3\n", "4"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000]}}
{"task_id": "P3843", "title": "[TJOI2007]迷路", "difficulty": "advanced", "nl": "The speed of two people walking is one unit distance per second, and their routes are parallel to the coordinate axis. Therefore, if the two people continue to walk infinitely, we want to know the closest distance between them each second. (We only consider the distance between the two people after each second of walking, not their distance at a certain moment within this 1 second.)", "code": "#include<bits/stdc++.h>\nusing namespace std;\nint n,m;\nint Time;\nint s[5],t[2];\nvector<pair<int,int>> num[2];\ndouble ans = 1e12;\ndouble getdis(){\n\treturn sqrt((s[2]-s[0])*(s[2]-s[0])+(s[3]-s[1])*(s[3]-s[1]));\n}\nint main(){\n\tscanf(\"%d%d%d\",&s[0],&s[1],&n);\n\twhile(n--){\n\t\tstatic int tpa,tpc;\n\t\tstatic char tpb;\n\t\tscanf(\"%d %c\",&tpa,&tpb);\n\t\tif(tpa < 0){\n\t\t\ttpc = -1;\n\t\t\ttpa = (~tpa)+1;\n\t\t}else{\n\t\t\ttpc = 1;\n\t\t}\n\t\tt[0] += tpa;\n\t\tif(tpb == 'Y'){\n\t\t\twhile(tpa--){\n\t\t\t\tnum[0].push_back({0,tpc});\n\t\t\t}\n\t\t}else{\n\t\t\twhile(tpa--){\n\t\t\t\tnum[0].push_back({tpc,0});\n\t\t\t}\n\t\t}\n\t}\n\tscanf(\"%d%d%d\",&s[2],&s[3],&m);\n\twhile(m--){\n\t\tstatic int tpa,tpc;\n\t\tstatic char tpb;\n\t\tscanf(\"%d %c\",&tpa,&tpb);\n\t\tif(tpa < 0){\n\t\t\ttpc = -1;\n\t\t\ttpa = (~tpa)+1;\n\t\t}else{\n\t\t\ttpc = 1;\n\t\t}\n\t\tt[1] += tpa;\n\t\tif(tpb == 'Y'){\n\t\t\twhile(tpa--){\n\t\t\t\tnum[1].push_back({0,tpc});\n\t\t\t}\n\t\t}else{\n\t\t\twhile(tpa--){\n\t\t\t\tnum[1].push_back({tpc,0});\n\t\t\t}\n\t\t}\n\t}\n\tTime = __gcd(t[0],t[1]);\n\tans = getdis();\n\tfor(int i = 0; i < t[0]*t[1]/Time; i++){\n\t\tstatic int tpa,tpb;\n\t\ttpa = i%t[0];\n\t\ttpb = i%t[1];\n\t\ts[0] += num[0][tpa].first;\n\t\ts[1] += num[0][tpa].second;\n\t\ts[2] += num[1][tpb].first;\n\t\ts[3] += num[1][tpb].second;\n\t\tans = min(ans,getdis());\n\t}\n\tprintf(\"%.2lf\",ans);\n\treturn 0;\n}", "step": ["Define a function to find greatest common factor", "Define a struct array to store the obstacles’ information", "Read the initial position and obstacles information", "Read the target position and obstacles information", "Calculate the factor and the total obstacles", "Calculate the shortest path based on the obstacles information"], "nl_cn": "两个人行走的速度都是每秒一个单位距离，而且他们的路线都是平行于坐标轴的。基于\n\n此，如果两个人无限的走下去，我们想知道他们每一秒相离最近的距离。（我们只考虑两人\n\n在每秒行走后相离的距离，不考虑他们在这 1 秒内某个时刻的距离）\n", "test_cases": [{"input": "0 0 4\n-1 Y\n-1 X\n1 Y\n1 X\n1 0 4\n-1 X\n1 Y\n1 X\n-1 Y", "output": "1.00"}, {"input": "0 0 1\n1 X\n1 0 1\n-1 Y\n", "output": "1.00"}, {"input": "0 0 1\n-1 X\n0 0 1\n1 X\n", "output": "0.00"}, {"input": "0 0 2\n-1 X\n1 X\n0 0 2\n1 X\n-1 X\n", "output": "0.00"}, {"input": "0 0 4\n1 Y\n-1 X\n1 X\n-1 X\n1 0 4\n-1 X\n1 X\n1 X\n1 Y\n", "output": "1.00"}, {"input": "0 0 1\n1 X\n0 0 5\n1 X\n1 X\n1 X\n1 X\n1 X\n", "output": "0.00"}, {"input": "1 1 1\n-1 X\n1 1 1\n1 X\n", "output": "0.00"}, {"input": "0 0 2\n1 Y\n-1 Y\n-1 -1 2\n-1 X\n1 Y", "output": "1.41"}, {"input": "0 0 2\n-1 X\n1 Y\n1 1 2\n1 X\n-1 Y", "output": "1.41"}, {"input": "0 0 1\n1 X\n-1 -1 1\n1 Y", "output": "1.41"}, {"input": "1 1 5\n1 X\n1 Y\n-1 X\n-1 Y\n1 X\n0 0 2\n-1 Y\n1 Y", "output": "1.41"}, {"input": "0 0 1\n1 Y\n1 1 1\n1 X", "output": "1.41"}, {"input": "0 0 1\n1 X\n0 0 1\n-1 X\n", "output": "0.00"}, {"input": "0 0 1\n1 Y\n0 0 1\n-1 Y\n", "output": "0.00"}, {"input": "0 0 3\n-1 Y\n-1 X\n-1 Y\n0 0 3\n1 X\n1 Y\n-1 X\n", "output": "0.00"}, {"input": "0 0 3\n-1 X\n1 X\n-1 Y\n0 0 3\n-1 Y\n1 Y\n-1 X\n", "output": "0.00"}, {"input": "1 1 1\n1 Y\n1 1 1\n1 X\n", "output": "0.00"}, {"input": "0 0 1\n1 X\n0 0 2\n-1 X\n1 X\n", "output": "0.00"}, {"input": "0 0 4\n1 X\n1 Y\n-1 X\n-1 Y\n0 0 4\n-1 Y\n1 Y\n1 X\n-1 X\n", "output": "0.00"}, {"input": "0 0 3\n-1 Y\n1 X\n1 Y\n0 0 2\n-2 X\n2 Y\n", "output": "0.00"}, {"input": "0 0 4\n-1 X\n-1 X\n-1 X\n-1 X\n0 0 4\n-1 X\n-1 X\n-1 X\n-1 X\n", "output": "0.00"}, {"input": "0 0 2\n1 Y\n-1 Y\n1 0 2\n1 X\n-1 X\n", "output": "1.00"}, {"input": "0 0 1\n10 X\n-10 0 1\n10 X\n", "output": "10.00"}, {"input": "1 1 1\n-1 X\n-1 1 1\n-1 Y\n", "output": "1.41"}, {"input": "0 0 3\n-1 X\n-2 X\n-3 X\n0 0 3\n-1 X\n-2 X\n-3 X\n", "output": "0.00"}], "test": "#undef NDEBUG\n#include<assert.h>\nint main(){\n    assert(solution(\"0 0 4\\n-1 Y\\n-1 X\\n1 Y\\n1 X\\n1 0 4\\n-1 X\\n1 Y\\n1 X\\n-1 Y\") == \"1.00\");\n    assert(solution(\"0 0 1\\n1 X\\n1 0 1\\n-1 Y\\n\") == \"1.00\");\n    assert(solution(\"0 0 1\\n-1 X\\n0 0 1\\n1 X\\n\") == \"0.00\");\n    assert(solution(\"0 0 2\\n-1 X\\n1 X\\n0 0 2\\n1 X\\n-1 X\\n\") == \"0.00\");\n    assert(solution(\"0 0 4\\n1 Y\\n-1 X\\n1 X\\n-1 X\\n1 0 4\\n-1 X\\n1 X\\n1 X\\n1 Y\\n\") == \"1.00\");\n    assert(solution(\"0 0 1\\n1 X\\n0 0 5\\n1 X\\n1 X\\n1 X\\n1 X\\n1 X\\n\") == \"0.00\");\n    assert(solution(\"1 1 1\\n-1 X\\n1 1 1\\n1 X\\n\") == \"0.00\");\n    assert(solution(\"0 0 2\\n1 Y\\n-1 Y\\n-1 -1 2\\n-1 X\\n1 Y\") == \"1.41\");\n    assert(solution(\"0 0 2\\n-1 X\\n1 Y\\n1 1 2\\n1 X\\n-1 Y\") == \"1.41\");\n    assert(solution(\"0 0 1\\n1 X\\n-1 -1 1\\n1 Y\") == \"1.41\");\n    assert(solution(\"1 1 5\\n1 X\\n1 Y\\n-1 X\\n-1 Y\\n1 X\\n0 0 2\\n-1 Y\\n1 Y\") == \"1.41\");\n    assert(solution(\"0 0 1\\n1 Y\\n1 1 1\\n1 X\") == \"1.41\");\n    assert(solution(\"0 0 1\\n1 X\\n0 0 1\\n-1 X\\n\") == \"0.00\");\n    assert(solution(\"0 0 1\\n1 Y\\n0 0 1\\n-1 Y\\n\") == \"0.00\");\n    assert(solution(\"0 0 3\\n-1 Y\\n-1 X\\n-1 Y\\n0 0 3\\n1 X\\n1 Y\\n-1 X\\n\") == \"0.00\");\n    assert(solution(\"0 0 3\\n-1 X\\n1 X\\n-1 Y\\n0 0 3\\n-1 Y\\n1 Y\\n-1 X\\n\") == \"0.00\");\n    assert(solution(\"1 1 1\\n1 Y\\n1 1 1\\n1 X\\n\") == \"0.00\");\n    assert(solution(\"0 0 1\\n1 X\\n0 0 2\\n-1 X\\n1 X\\n\") == \"0.00\");\n    assert(solution(\"0 0 4\\n1 X\\n1 Y\\n-1 X\\n-1 Y\\n0 0 4\\n-1 Y\\n1 Y\\n1 X\\n-1 X\\n\") == \"0.00\");\n    assert(solution(\"0 0 3\\n-1 Y\\n1 X\\n1 Y\\n0 0 2\\n-2 X\\n2 Y\\n\") == \"0.00\");\n    assert(solution(\"0 0 4\\n-1 X\\n-1 X\\n-1 X\\n-1 X\\n0 0 4\\n-1 X\\n-1 X\\n-1 X\\n-1 X\\n\") == \"0.00\");\n    assert(solution(\"0 0 2\\n1 Y\\n-1 Y\\n1 0 2\\n1 X\\n-1 X\\n\") == \"1.00\");\n    assert(solution(\"0 0 1\\n10 X\\n-10 0 1\\n10 X\\n\") == \"10.00\");\n    assert(solution(\"1 1 1\\n-1 X\\n-1 1 1\\n-1 Y\\n\") == \"1.41\");\n    assert(solution(\"0 0 3\\n-1 X\\n-2 X\\n-3 X\\n0 0 3\\n-1 X\\n-2 X\\n-3 X\\n\") == \"0.00\");\n    return 0; \n}", "prompt": "/*The speed of two people walking is one unit distance per second, and their routes are parallel to the coordinate axis. Therefore, if the two people continue to walk infinitely, we want to know the closest distance between them each second. (We only consider the distance between the two people after each second of walking, not their distance at a certain moment within this 1 second.)\n\ninput_format:\nThere are two similar sections in the input file that describe the walking tracks of little A and little B. In every part\n\nThe first row has three integers, sx, sy, and m, with the first two integers representing its initial position and the third integer representing the broken line in the track\n\nThe number of the following m lines, each line has an integer d and a non-space character c, d and c are separated by a space.\n\nd represents the distance traveled by little A or little B in the positive direction of the coordinate, while c is' X 'or' Y ', indicating whether it is the X axis or Y\n\nThe axes. The input data guarantees that in each section, we start from the starting point (sx, sy), after performing m steps, we will be able to\n\nSo back to the starting point, this orbit is closed.\n\noutput_format:\nThe output file contains only one real number, accurate to two decimal places. The closest distance between two people that can be observed,\n\nIf it is possible for two people to reach the same point at some time, the output is 0.00.\n*/\n\n#include<sstream>\n#include<stdlib.h>\n#include<algorithm>\n#include<math.h>\n#include<stdio.h>\n#include<vector>\n#include<string>\n#include<climits>\n#include<cstring>\n#include<iostream>\nusing namespace std;\n\n             \nstring solution(string std_in){\n    istringstream iss(std_in);\n             ", "constraints": "100%的数据中，对于任何 m 和 d，有 1 ≤ m, d ≤ 100，轨道的初始坐标的绝对值不超\n\n过 2 000。\n", "samples": [["0 0 4\n-1 Y\n-1 X\n1 Y\n1 X\n1 0 4\n-1 X\n1 Y\n1 X\n-1 Y", "1.00"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000]}}
{"task_id": "P2692", "title": "覆盖", "difficulty": "challenge", "nl": "The playground can be seen as an N by M grid, as shown in Figure (1) for a 4 by 5 grid. Each male student is responsible for cleaning a number of contiguous rows, and each female student is responsible for cleaning a number of contiguous columns. For example, there are two male students, the first one is responsible for rows 1 and 2, and the second one is responsible for row 4, as shown in blue in Figure (2). The areas they clean may overlap, for example, there are two female students, the first one is responsible for columns 3 and 4, and the second one is responsible for columns 4 and 5, as shown in red in Figure (3). As can be easily seen from Figure (3), the number of covered squares is 18, which means these four students together clean 18 squares.\n\n ![image] \n\nAfter the teacher gives WSR the cleaning arrangement data at school, WSR needs to quickly calculate how many squares these students have cleaned in total.", "code": "#include<bits/stdc++.h>//万能头文件 \nusing namespace std;\nint i,j,n,m,g,b,x,y,num=0,sum=0;\nbool a[5001],o[5001];//a标记行,b标记列,初始化为0 \nint main()\n{\n\t\n\tcin>>n>>m>>b>>g;//n行,m列,男生b,女生g \n\tfor(i=1;i<=b;++i)//先输入男生 \n\t{\n\t\tcin>>x>>y;//从x行打扫到y行 \n\t\tfor(j=x;j<=y;j++)\n\t\t{\n\t\t\tif(a[j]!=1)//如果这一行没有被打扫过 \n\t\t\t{\n\t\t\t\ta[j]=1;//标记为1 \n\t\t\t\tnum+=m;//累加这一行格子数 \n\t\t\t\tsum++;//记录行数 \n\t\t\t}\n\t\t}\n\t}\n\tfor(i=1;i<=g;++i)//再输入女生 \n\t{\n\t\tcin>>x>>y;//从x列打扫到y列 \n\t\tfor(j=x;j<=y;++j)\n\t\t{\n\t\t\tif(o[j]!=1)//如果这一列没有被打扫过\n\t\t\t{\n\t\t\t\to[j]=1;//标记为1 \n\t\t\t\tnum+=n-sum;//累加\n\t\t\t\t//这里注意不需要累加一整列,\n\t\t\t\t//只需累加没有被男生打扫过的格子 \n\t\t\t}\n\t\t}\n\t}\n\tcout<<num;//输出 \n}", "step": ["Read input integers", "Update l array based on b input", "Update p array based on g input", "Calculate ans based on the updated arrays", "Print ans", "Return 0 to end the program"], "nl_cn": "操场可以看成是N 行M 列的方格矩阵，如下图(1)是一个4 行5 列的方格矩阵。每个男生负责打扫一些连续的行，每个女生负责打扫一些连续的列。比如有两个男生，第一个男生负责第1、2 两行、第二个男生负责第4 行，如图(2)的蓝色。打扫的区域可能重复，比如，又有两个女生，第一个女生负责打扫第3、4 两列，第二个女生负责打扫第4、5 两列，如图(3)的红色。从图(3)可以容易看出，有颜色覆盖的方格数为18，即这4 名学生总共打扫了18 个方格。\n\n  \n\n老师要WSR在学校给出打扫安排的数据后快速计算出这些学生总共打扫了多少方格？\n", "test_cases": [{"input": "4 5 2 2\n1 2\n4 4\n3 4\n4 5", "output": "18"}, {"input": "2 3 1 2\n1 1\n1 2\n2 3\n1 2\n", "output": "6"}, {"input": "5 5 2 2\n2 2\n4 5\n3 3\n3 4\n", "output": "19"}, {"input": "5 6 2 1\n2 3\n4 5\n3 4\n", "output": "26"}], "test": "#undef NDEBUG\n#include<assert.h>\nint main(){\n    assert(solution(\"4 5 2 2\\n1 2\\n4 4\\n3 4\\n4 5\") == \"18\");\n    assert(solution(\"2 3 1 2\\n1 1\\n1 2\\n2 3\\n1 2\\n\") == \"6\");\n    assert(solution(\"5 5 2 2\\n2 2\\n4 5\\n3 3\\n3 4\\n\") == \"19\");\n    assert(solution(\"5 6 2 1\\n2 3\\n4 5\\n3 4\\n\") == \"26\");\n    return 0; \n}", "prompt": "/*The playground can be seen as an N by M grid, as shown in Figure (1) for a 4 by 5 grid. Each male student is responsible for cleaning a number of contiguous rows, and each female student is responsible for cleaning a number of contiguous columns. For example, there are two male students, the first one is responsible for rows 1 and 2, and the second one is responsible for row 4, as shown in blue in Figure (2). The areas they clean may overlap, for example, there are two female students, the first one is responsible for columns 3 and 4, and the second one is responsible for columns 4 and 5, as shown in red in Figure (3). As can be easily seen from Figure (3), the number of covered squares is 18, which means these four students together clean 18 squares.\n\n ![image] \n\nAfter the teacher gives WSR the cleaning arrangement data at school, WSR needs to quickly calculate how many squares these students have cleaned in total.\n\ninput_format:\nThe first line contains 4 positive integers: N, M, B, G. N represents the number of rows in the square matrix, M represents the number of columns in the square matrix, B represents the number of male students, and G represents the number of female students.\n\nNext, there are B lines, each containing two integers x and y. It indicates that a certain male student is responsible for cleaning from the x-th row to the y-th row (inclusive) of the matrix. It is guaranteed that 1 ≤ x ≤ y ≤ N.\n\nAfter that, there are G lines, each containing two integers x and y. It indicates that a certain female student is responsible for cleaning from the x-th column to the y-th column (inclusive) of the matrix. It is guaranteed that 1 ≤ x ≤ y ≤ M.\n\noutput_format:\nAn integer indicating the area being cleaned. (i.e. the total number of cells)\n*/\n\n#include<sstream>\n#include<stdlib.h>\n#include<algorithm>\n#include<math.h>\n#include<stdio.h>\n#include<vector>\n#include<string>\n#include<climits>\n#include<cstring>\n#include<iostream>\nusing namespace std;\n\n             \nstring solution(string std_in){\n    istringstream iss(std_in);\n             ", "constraints": "不会可以自己画图。\n\n### 数据范围与约定\n\n对于 $80\\%$ 的数据，$1 \\le N,M,B,G \\le 10^2$。\n\n对于 $100\\%$ 的数据，$ 1 \\le N,M,B,G \\le 5 \\times 10^3$。", "samples": [["4 5 2 2\n1 2\n4 4\n3 4\n4 5", "18"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}}
{"task_id": "P3110", "title": "[USACO14DEC]Piggy Back S", "difficulty": "advanced", "nl": "Bessie and her sister Elsie graze in different pastures during the day and both wish to walk back to the barn to rest at night. As savvy cows, they have developed a plan to minimize the total energy they expend walking.\n\nWhen Bessie travels from one field to an adjacent field, she expends B units of energy, while Elsie expends E units of energy when moving to an adjacent field. However, if Bessie and Elsie are in the same field, Bessie can carry Elsie with her to the adjacent field for a cost of only P units of energy (where P may be much smaller than B+E, the combined cost of Bessie and Elsie moving to adjacent fields individually). If P is small, the most energy-efficient plan may be for Bessie and Elsie to both travel to a meeting field and then hike the remaining distance to the barn together. Of course, if P is large, it may still be most reasonable for Bessie and Elsie to travel separately. One thing is for sure, Bessie and Elsie are not thrilled with the term \"piggyback\" as they fail to see how the pigs on the farm get all the credit for this impressive mode of transportation.\n\nGiven B, E, and P, along with the layout of fields on the farm, compute the minimum energy expenditure required for Bessie and Elsie to reach the barn.", "code": "#include<stdio.h>\n#include<queue>\n#include<algorithm>\nusing namespace std;\nint b;int e;int p;int nx;int m;\nstruct node//保存到点1，2，n的距离\n{\n    int num;int d1;int d2;int d3;\n}n[40010];int now;\nstruct data//邻接表\n{\n    int v;int next;\n}edge[80020];int cnt;int alist[40010];\nvoid add(int u,int v)\n{\n    edge[++cnt].v=v;\n    edge[cnt].next=alist[u];\n    alist[u]=cnt;\n    return;\n}\nqueue <node> q;\nint res=0x3f3f3f3f;\nint main()\n{\n    scanf(\"%d%d%d%d%d\",&b,&e,&p,&nx,&m);\n    for(int i=0;i<m;i++)//建图\n    {\n        int u;int v;\n        scanf(\"%d%d\",&u,&v);\n        add(u,v);add(v,u);\n    }\n    for(int i=1;i<=nx;i++)//初始化\n    {\n        n[i].num=i;\n        n[i].d1=-1;\n        n[i].d2=-1;\n        n[i].d3=-1;\n    }\n    n[1].d1=0;n[2].d2=0;n[nx].d3=0;\n    q.push(n[1]);//bfs膜板，裸的bfs\n    while(!q.empty())\n    {\n        now=q.front().num;q.pop();\n        int next=alist[now];\n        while(next)\n        {\n            int v=edge[next].v;\n            if(n[v].d1==-1)\n            {\n                n[v].d1=n[now].d1+1;\n                q.push(n[v]);\n            }\n            next=edge[next].next;\n        }\n    }\n    q.push(n[2]);//同上\n    while(!q.empty())\n    {\n        now=q.front().num;q.pop();\n        int next=alist[now];\n        while(next)\n        {\n            int v=edge[next].v;\n            if(n[v].d2==-1)\n            {\n                n[v].d2=n[now].d2+1;\n                q.push(n[v]);\n            }\n            next=edge[next].next;\n        }\n    }\n    q.push(n[nx]);//同上\n    while(!q.empty())\n    {\n        now=q.front().num;q.pop();\n        int next=alist[now];\n        while(next)\n        {\n            int v=edge[next].v;\n            if(n[v].d3==-1)\n            {\n                n[v].d3=n[now].d3+1;\n                q.push(n[v]);\n            }\n            next=edge[next].next;\n        }\n    }\n    for(int i=1;i<=nx;i++)//处理答案\n    {\n        if(n[i].d1==-1||n[i].d2==-1||n[i].d3==-1)//前提是该点必须能到达1，2，和n\n        continue;\n        res=min(res,n[i].d1*b+n[i].d2*e+n[i].d3*p);\n    }\n    printf(\"%d\",res);\n    return 0;//拜拜程序~\n}", "step": ["Initialize variables including edge info", "Implement the AddEdge function to add edges to the graph", "Implement SPFA function to calculate distances between points", "Call the SPFA function for the first, second, and the nth node to calculate distances", "Calculate the minimum cost by finding the minimum sum of each distance and its corresponding cost", "Print the minimum cost"], "nl_cn": "Bessie and her sister Elsie graze in different fields during the day, and in the evening they both want to walk back to the barn to rest. Being clever bovines, they come up with a plan to minimize the total amount of energy they both spend while walking.\n\nBessie spends B units of energy when walking from a field to an adjacent field, and Elsie spends E units of energy when she walks to an adjacent field.  However, if Bessie and Elsie are together in the same field, Bessie can carry Elsie on her shoulders and both can move to an adjacent field while spending only P units of energy (where P might be considerably less than B+E, the amount Bessie and Elsie would have spent individually walking to the adjacent field).  If P is very small, the most energy-efficient solution may involve Bessie and Elsie traveling to a common meeting field, then traveling together piggyback for the rest of the journey to the barn.  Of course, if P is large, it may still make the most sense for Bessie and Elsie to travel\n\nseparately.  On a side note, Bessie and Elsie are both unhappy with the term \"piggyback\", as they don't see why the pigs on the farm should deserve all the credit for this remarkable form of\n\ntransportation.\n\nGiven B, E, and P, as well as the layout of the farm, please compute the minimum amount of energy required for Bessie and Elsie to reach the barn.\n\n", "test_cases": [{"input": "4 4 5 8 8 \n1 4 \n2 3 \n3 4 \n4 7 \n2 5 \n5 6 \n6 8 \n7 8 ", "output": "22"}, {"input": "1 1 2 2 1 \n1 2 \n", "output": "1"}, {"input": "4 4 5 8 8\n1 4\n2 3\n3 4\n4 7\n2 5\n5 6\n6 8\n7 8 ", "output": "22"}, {"input": "1 1 1 2 1\n1 2", "output": "1"}, {"input": "10 5 5 5 10 \n1 2 \n1 3 \n1 4 \n2 3 \n2 5 \n3 4 \n4 7 \n2 5 \n5 6 \n", "output": "15"}, {"input": "1 1 1 3 3 \n1 2 \n2 3 \n2 4 \n", "output": "2"}, {"input": "1 2 3 3 3 \n1 2 \n2 3 \n", "output": "4"}, {"input": "0 0 0 4 5 \n1 2 \n3 4 \n1 3 \n2 4 \n3 2 \n", "output": "0"}], "test": "#undef NDEBUG\n#include<assert.h>\nint main(){\n    assert(solution(\"4 4 5 8 8 \\n1 4 \\n2 3 \\n3 4 \\n4 7 \\n2 5 \\n5 6 \\n6 8 \\n7 8 \") == \"22\");\n    assert(solution(\"1 1 2 2 1 \\n1 2 \\n\") == \"1\");\n    assert(solution(\"4 4 5 8 8\\n1 4\\n2 3\\n3 4\\n4 7\\n2 5\\n5 6\\n6 8\\n7 8 \") == \"22\");\n    assert(solution(\"1 1 1 2 1\\n1 2\") == \"1\");\n    assert(solution(\"10 5 5 5 10 \\n1 2 \\n1 3 \\n1 4 \\n2 3 \\n2 5 \\n3 4 \\n4 7 \\n2 5 \\n5 6 \\n\") == \"15\");\n    assert(solution(\"1 1 1 3 3 \\n1 2 \\n2 3 \\n2 4 \\n\") == \"2\");\n    assert(solution(\"1 2 3 3 3 \\n1 2 \\n2 3 \\n\") == \"4\");\n    assert(solution(\"0 0 0 4 5 \\n1 2 \\n3 4 \\n1 3 \\n2 4 \\n3 2 \\n\") == \"0\");\n    return 0; \n}", "prompt": "/*Bessie and her sister Elsie graze in different pastures during the day and both wish to walk back to the barn to rest at night. As savvy cows, they have developed a plan to minimize the total energy they expend walking.\n\nWhen Bessie travels from one field to an adjacent field, she expends B units of energy, while Elsie expends E units of energy when moving to an adjacent field. However, if Bessie and Elsie are in the same field, Bessie can carry Elsie with her to the adjacent field for a cost of only P units of energy (where P may be much smaller than B+E, the combined cost of Bessie and Elsie moving to adjacent fields individually). If P is small, the most energy-efficient plan may be for Bessie and Elsie to both travel to a meeting field and then hike the remaining distance to the barn together. Of course, if P is large, it may still be most reasonable for Bessie and Elsie to travel separately. One thing is for sure, Bessie and Elsie are not thrilled with the term \"piggyback\" as they fail to see how the pigs on the farm get all the credit for this impressive mode of transportation.\n\nGiven B, E, and P, along with the layout of fields on the farm, compute the minimum energy expenditure required for Bessie and Elsie to reach the barn.\n\ninput_format:\nINPUT: (file piggyback.in)\n\nThe first line of input contains the positive integers B, E, P, N, and M. All of these are at most 40,000. B, E, and P are described above. N is the number of fields in the farm (numbered 1.. N, where N >= 3), and M is the number of connections between fields.  Bessie and Elsie start in fields 1 and 2, respectively.  The barn resides in field N.\n\nThe next M lines in the input each describe a connection between a pair of different fields, specified by the integer indices of the two fields.  Connections are bi-directional.  It is always possible to travel from field 1 to field N, and field 2 to field N, along a series of such connections.\n\noutput_format:\nOUTPUT: (file piggyback.out)\n\nA single integer specifying the minimum amount of energy Bessie and\n\nElsie collectively need to spend to reach the barn.  In the example\n\nshown here, Bessie travels from 1 to 4 and Elsie travels from 2 to 3\n\nto 4.  Then, they travel together from 4 to 7 to 8.\n*/\n\n#include<sstream>\n#include<stdlib.h>\n#include<algorithm>\n#include<math.h>\n#include<stdio.h>\n#include<vector>\n#include<string>\n#include<climits>\n#include<cstring>\n#include<iostream>\nusing namespace std;\n\n             \nstring solution(string std_in){\n    istringstream iss(std_in);\n             ", "constraints": "", "samples": [["4 4 5 8 8 \n1 4 \n2 3 \n3 4 \n4 7 \n2 5 \n5 6 \n6 8 \n7 8 ", "22 \n"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}}
{"task_id": "P5743", "title": "【深基7.习8】猴子吃桃", "difficulty": "basic", "nl": "A monkey bought some peaches. On the first day, he ate half of the peaches and one more. On each following day, he ate half of the remaining peaches and one more. On the $n$-th day, he found that there was only one peach left. How many peaches did the monkey buy?", "code": "#include<iostream>\nusing namespace std;\nint n,ans=1;//一定要赋值为1！\nint main(){\n\tcin>>n;\n\tfor(int i=1;i<n;i++){//因为第n天没吃，所以之要算n-1天就行了。\n\t\tans+=1;//先加上嘴馋吃的那一个，每天吃一半的是在这个的基础上\n\t\tans*=2;//加上嘴馋吃的那一个以后才是一半\n\t}\n\tcout<<ans<<endl;//输出总数\n\treturn 0;//拜拜！\n}", "step": ["Take an integer input from the user.", "Initialize ans with 1.", "Using for loop, perform the following operations: increase ans by 1 and then multiply it by 2.", "Print the value of ans.", "Return 0 to exit the program."], "nl_cn": "一只小猴买了若干个桃子。第一天他刚好吃了这些桃子的一半，又贪嘴多吃了一个；接下来的每一天它都会吃剩余的桃子的一半外加一个。第 $n$ 天早上起来一看，只剩下 $1$ 个桃子了。请问小猴买了几个桃子？", "test_cases": [{"input": "4", "output": "22"}, {"input": "0\n", "output": "1"}, {"input": "1", "output": "1"}, {"input": "3\n", "output": "10"}, {"input": "2\n", "output": "4"}, {"input": "5\n", "output": "46"}, {"input": "6\n", "output": "94"}, {"input": "7\n", "output": "190"}, {"input": "8\n", "output": "382"}, {"input": "9\n", "output": "766"}, {"input": "10\n", "output": "1534"}, {"input": "11\n", "output": "3070"}, {"input": "12\n", "output": "6142"}, {"input": "13\n", "output": "12286"}, {"input": "14\n", "output": "24574"}, {"input": "15\n", "output": "49150"}, {"input": "16\n", "output": "98302"}, {"input": "17\n", "output": "196606"}, {"input": "18\n", "output": "393214"}, {"input": "19\n", "output": "786430"}, {"input": "20\n", "output": "1572862"}], "test": "#undef NDEBUG\n#include<assert.h>\nint main(){\n    assert(solution(\"4\") == \"22\");\n    assert(solution(\"0\\n\") == \"1\");\n    assert(solution(\"1\") == \"1\");\n    assert(solution(\"3\\n\") == \"10\");\n    assert(solution(\"2\\n\") == \"4\");\n    assert(solution(\"5\\n\") == \"46\");\n    assert(solution(\"6\\n\") == \"94\");\n    assert(solution(\"7\\n\") == \"190\");\n    assert(solution(\"8\\n\") == \"382\");\n    assert(solution(\"9\\n\") == \"766\");\n    assert(solution(\"10\\n\") == \"1534\");\n    assert(solution(\"11\\n\") == \"3070\");\n    assert(solution(\"12\\n\") == \"6142\");\n    assert(solution(\"13\\n\") == \"12286\");\n    assert(solution(\"14\\n\") == \"24574\");\n    assert(solution(\"15\\n\") == \"49150\");\n    assert(solution(\"16\\n\") == \"98302\");\n    assert(solution(\"17\\n\") == \"196606\");\n    assert(solution(\"18\\n\") == \"393214\");\n    assert(solution(\"19\\n\") == \"786430\");\n    assert(solution(\"20\\n\") == \"1572862\");\n    return 0; \n}", "prompt": "/*A monkey bought some peaches. On the first day, he ate half of the peaches and one more. On each following day, he ate half of the remaining peaches and one more. On the $n$-th day, he found that there was only one peach left. How many peaches did the monkey buy?\n\ninput_format:\nEnter a positive integer $n$to indicate the number of days.\n\noutput_format:\nOutput how many peaches the monkey bought.\n*/\n\n#include<sstream>\n#include<stdlib.h>\n#include<algorithm>\n#include<math.h>\n#include<stdio.h>\n#include<vector>\n#include<string>\n#include<climits>\n#include<cstring>\n#include<iostream>\nusing namespace std;\n\n             \nstring solution(string std_in){\n    istringstream iss(std_in);\n             ", "constraints": "数据保证，$1\\le n\\le20$。", "samples": [["4", "22\n"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000]}}
{"task_id": "P7679", "title": "[COCI2008-2009#5] JABUKA", "difficulty": "challenge", "nl": "Mirko has $R$ red apples and $G$ green apples. He wants to distribute them to some friends so that each friend gets the same amount of red apples and green apples. Mirko doesn't like apples himself so he won't keep any. For example, if Mirko has $4$ red apples and $8$ green apples, there are several ways to distribute them:\n\n- Give them all to one friend.\n- Give them to two friends, each getting $2$ red and $4$ green apples.\n- Give them to four friends, each getting $1$ red and $2$ green apples.\n\nGiven $R$ and $G$, help Mirko find all possible ways to distribute the apples. It is guaranteed that at least one such distribution exists.", "code": "#include<bits/stdc++.h>\n\nusing namespace std;\ntypedef vector<int> vi;\n#define PB push_back\n\n//最大公因数\nint gcd(int a,int b) {  return b > 0 ? gcd(b, a%b) : a;  } \nint main()\n{\n  ios::sync_with_stdio(0);\n  cin.tie(0);\n  int a,b;\n  vi num;\n  cin>>a>>b;\n  int k = gcd(a,b);\n  int n=int(sqrt(gcd(a,b)));\n  for(int i=1;i<=n;i++){\n      if(k%i==0){\n          cout<<i<<\" \"<<a/i<<\" \"<<b/i<<endl;\n          if(i*i!=k)  num.PB(k/i);\n      }\n  }\n  for(int i=num.size()-1;i>=0;i--){\n      cout<<num[i]<<\" \"<<a/num[i]<<\" \"<<b/num[i]<<endl;\n  }\n}", "step": ["Initialize variables and vectors.", "Compute gcd of a and b.", "Get the square root of gcd.", "Find factors of gcd using a loop.", "Print out factors.", "Print out factors in reverse order using a loop."], "nl_cn": "Mirko 拥有 $R$ 个红苹果和 $G$ 个绿苹果，他想把他分给若干个朋友，使得所有朋友分得的红苹果个数和绿苹果个数都一样。由于 Mirko 自己不喜欢苹果，所以他不会给自己留苹果。\n\n例如，假设 Mirko 有 $4$ 个红苹果和 $8$ 个绿苹果，则以下是分配苹果的所有方案：\n\n- 分给一个朋友，即将 $4$ 个红苹果和 $8$ 个绿苹果全部分给这个朋友。\n- 分给两个朋友，每个朋友分得 $2$ 个红苹果和 $4$ 个红苹果。 \n- 分给四个朋友，每个朋友分得 $1$ 个红苹果和 $2$ 个红苹果。\n\n现给定 $R,G$，请你帮助 Mirko 找到所有的分配苹果的方案。可以证明一定存在分配苹果的方案。", "test_cases": [{"input": "4 8", "output": "1 4 8\n2 2 4\n4 1 2"}, {"input": "15 12", "output": "1 15 12\n3 5 4"}, {"input": "42 105", "output": "1 42 105\n3 14 35\n7 6 15\n21 2 5"}, {"input": "1 1\n", "output": "1 1 1"}, {"input": "8 12\n", "output": "1 8 12\n2 4 6\n4 2 3"}, {"input": "7 14\n", "output": "1 7 14\n7 1 2"}, {"input": "30 18\n", "output": "1 30 18\n2 15 9\n3 10 6\n6 5 3"}, {"input": "3 18\n", "output": "1 3 18\n3 1 6"}, {"input": "21 7\n", "output": "1 21 7\n7 3 1"}, {"input": "12 8\n", "output": "1 12 8\n2 6 4\n4 3 2"}, {"input": "2 4\n", "output": "1 2 4\n2 1 2"}, {"input": "7 7\n", "output": "1 7 7\n7 1 1"}, {"input": "10 20\n", "output": "1 10 20\n2 5 10\n5 2 4\n10 1 2"}, {"input": "6 18\n", "output": "1 6 18\n2 3 9\n3 2 6\n6 1 3"}, {"input": "25 100\n", "output": "1 25 100\n5 5 20\n25 1 4"}, {"input": "3 9\n", "output": "1 3 9\n3 1 3"}, {"input": "30 60\n", "output": "1 30 60\n2 15 30\n3 10 20\n5 6 12\n6 5 10\n10 3 6\n15 2 4\n30 1 2"}, {"input": "9 12\n", "output": "1 9 12\n3 3 4"}, {"input": "16 32\n", "output": "1 16 32\n2 8 16\n4 4 8\n8 2 4\n16 1 2"}, {"input": "21 63\n", "output": "1 21 63\n3 7 21\n7 3 9\n21 1 3"}, {"input": "5 10\n", "output": "1 5 10\n5 1 2"}, {"input": "11 11\n", "output": "1 11 11\n11 1 1"}, {"input": "0 0\n", "output": ""}, {"input": "100 100\n", "output": "1 100 100\n2 50 50\n4 25 25\n5 20 20\n10 10 10\n20 5 5\n25 4 4\n50 2 2\n100 1 1"}, {"input": "17 18\n", "output": "1 17 18"}, {"input": "7 9\n", "output": "1 7 9"}, {"input": "18 27\n", "output": "1 18 27\n3 6 9\n9 2 3"}, {"input": "6 9\n", "output": "1 6 9\n3 2 3"}, {"input": "3 5\n", "output": "1 3 5"}, {"input": "1000 1000\n", "output": "1 1000 1000\n2 500 500\n4 250 250\n5 200 200\n8 125 125\n10 100 100\n20 50 50\n25 40 40\n40 25 25\n50 20 20\n100 10 10\n125 8 8\n200 5 5\n250 4 4\n500 2 2\n1000 1 1"}], "test": "#undef NDEBUG\n#include<assert.h>\nint main(){\n    assert(solution(\"4 8\") == \"1 4 8\\n2 2 4\\n4 1 2\");\n    assert(solution(\"15 12\") == \"1 15 12\\n3 5 4\");\n    assert(solution(\"42 105\") == \"1 42 105\\n3 14 35\\n7 6 15\\n21 2 5\");\n    assert(solution(\"1 1\\n\") == \"1 1 1\");\n    assert(solution(\"8 12\\n\") == \"1 8 12\\n2 4 6\\n4 2 3\");\n    assert(solution(\"7 14\\n\") == \"1 7 14\\n7 1 2\");\n    assert(solution(\"30 18\\n\") == \"1 30 18\\n2 15 9\\n3 10 6\\n6 5 3\");\n    assert(solution(\"3 18\\n\") == \"1 3 18\\n3 1 6\");\n    assert(solution(\"21 7\\n\") == \"1 21 7\\n7 3 1\");\n    assert(solution(\"12 8\\n\") == \"1 12 8\\n2 6 4\\n4 3 2\");\n    assert(solution(\"2 4\\n\") == \"1 2 4\\n2 1 2\");\n    assert(solution(\"7 7\\n\") == \"1 7 7\\n7 1 1\");\n    assert(solution(\"10 20\\n\") == \"1 10 20\\n2 5 10\\n5 2 4\\n10 1 2\");\n    assert(solution(\"6 18\\n\") == \"1 6 18\\n2 3 9\\n3 2 6\\n6 1 3\");\n    assert(solution(\"25 100\\n\") == \"1 25 100\\n5 5 20\\n25 1 4\");\n    assert(solution(\"3 9\\n\") == \"1 3 9\\n3 1 3\");\n    assert(solution(\"30 60\\n\") == \"1 30 60\\n2 15 30\\n3 10 20\\n5 6 12\\n6 5 10\\n10 3 6\\n15 2 4\\n30 1 2\");\n    assert(solution(\"9 12\\n\") == \"1 9 12\\n3 3 4\");\n    assert(solution(\"16 32\\n\") == \"1 16 32\\n2 8 16\\n4 4 8\\n8 2 4\\n16 1 2\");\n    assert(solution(\"21 63\\n\") == \"1 21 63\\n3 7 21\\n7 3 9\\n21 1 3\");\n    assert(solution(\"5 10\\n\") == \"1 5 10\\n5 1 2\");\n    assert(solution(\"11 11\\n\") == \"1 11 11\\n11 1 1\");\n    assert(solution(\"0 0\\n\") == \"\");\n    assert(solution(\"100 100\\n\") == \"1 100 100\\n2 50 50\\n4 25 25\\n5 20 20\\n10 10 10\\n20 5 5\\n25 4 4\\n50 2 2\\n100 1 1\");\n    assert(solution(\"17 18\\n\") == \"1 17 18\");\n    assert(solution(\"7 9\\n\") == \"1 7 9\");\n    assert(solution(\"18 27\\n\") == \"1 18 27\\n3 6 9\\n9 2 3\");\n    assert(solution(\"6 9\\n\") == \"1 6 9\\n3 2 3\");\n    assert(solution(\"3 5\\n\") == \"1 3 5\");\n    assert(solution(\"1000 1000\\n\") == \"1 1000 1000\\n2 500 500\\n4 250 250\\n5 200 200\\n8 125 125\\n10 100 100\\n20 50 50\\n25 40 40\\n40 25 25\\n50 20 20\\n100 10 10\\n125 8 8\\n200 5 5\\n250 4 4\\n500 2 2\\n1000 1 1\");\n    return 0; \n}", "prompt": "/*Mirko has $R$ red apples and $G$ green apples. He wants to distribute them to some friends so that each friend gets the same amount of red apples and green apples. Mirko doesn't like apples himself so he won't keep any. For example, if Mirko has $4$ red apples and $8$ green apples, there are several ways to distribute them:\n\n- Give them all to one friend.\n- Give them to two friends, each getting $2$ red and $4$ green apples.\n- Give them to four friends, each getting $1$ red and $2$ green apples.\n\nGiven $R$ and $G$, help Mirko find all possible ways to distribute the apples. It is guaranteed that at least one such distribution exists.\n\ninput_format:\nEnter only one line, two integers $R,G$, representing the number of red apples and the number of green apples respectively.\n\noutput_format:\nOutput a number of lines, each line of three integers, representing the number of friends assigned, the number of red apples and the number of green apples assigned to each friend.\n\nIf there are multiple schemes, please arrange the ** output in ascending order by the number of ** friends.\n\nData is guaranteed not to exceed output limits.\n*/\n\n#include<sstream>\n#include<stdlib.h>\n#include<algorithm>\n#include<math.h>\n#include<stdio.h>\n#include<vector>\n#include<string>\n#include<climits>\n#include<cstring>\n#include<iostream>\nusing namespace std;\n\n             \nstring solution(string std_in){\n    istringstream iss(std_in);\n             ", "constraints": "**【数据范围】**\n\n对于所有数据，$1\\leqslant R,G\\leqslant 10^9$。\n\n**【题目来源】**\n\n本题来源自 **_[COCI 2008-2009](https://hsin.hr/coci/archive/2008_2009/) [CONTEST 5](https://hsin.hr/coci/archive/2008_2009/contest5_tasks.pdf) T2 JABUKA_**，按照原题数据配置，满分 $50$ 分。\n\n由 [Eason_AC](https://www.luogu.com.cn/user/112917) 翻译整理提供。", "samples": [["4 8", "1 4 8\n2 2 4\n4 1 2"], ["15 12", "1 15 12\n3 5 4"], ["42 105", "1 42 105\n3 14 35\n7 6 15\n21 2 5"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000], "memory": [32768, 32768, 32768, 32768, 32768, 32768]}}
{"task_id": "P2505", "title": "[HAOI2012]道路", "difficulty": "advanced", "nl": "There are n cities in country C, connected by m one-way roads. A path is considered to be the shortest path if and only if there is no other path from its starting point to its ending point with a smaller total length. Two different shortest paths are distinct if and only if they contain different sequences of roads. We need to evaluate the importance of each road by calculating how many different shortest paths pass through it. Now, this task is entrusted to you.", "code": "#include <cmath>\n#include <cstdio>\n#include <cstring>\n#include <iostream>\n#include <algorithm>\nusing namespace std;\ninline int read() {\n    int res = 0; bool bo = 0; char c;\n    while (((c = getchar()) < '0' || c > '9') && c != '-');\n    if (c == '-') bo = 1; else res = c - 48;\n    while ((c = getchar()) >= '0' && c <= '9')\n        res = (res << 3) + (res << 1) + (c - 48);\n    return bo ? ~res + 1 : res;\n}\nconst int N = 1505, M = 5005, INF = 0x3f3f3f3f, PYZ = 1e9 + 7;\nint n, m, ecnt, nxt[M], adj[N], st[M], go[M], val[M], dis[M], len, que[M << 1],\ncnt[N], cnt1[N], cnt2[N], H, T, tot, q[N], ans[M];\nbool vis[N], ins[M];\nvoid add_edge(int u, int v, int w) {\n    nxt[++ecnt] = adj[u]; adj[u] = ecnt; st[ecnt] = u; go[ecnt] = v; val[ecnt] = w;\n}\nvoid spfa(int S) {\n    int i; memset(dis, INF, sizeof(dis));\n    memset(ins, 0, sizeof(ins));\n    dis[que[len = 1] = S] = 0;\n    for (i = 1; i <= len; i++) {\n        int u = que[i]; vis[u] = 0;\n        for (int e = adj[u], v; e; e = nxt[e])\n            if (dis[u] + val[e] < dis[v = go[e]]) {\n                dis[v] = dis[u] + val[e];\n                if (!vis[v]) vis[que[++len] = v] = 1;\n            }\n    }\n    for (i = 1; i <= m; i++)\n        if (dis[st[i]] + val[i] == dis[go[i]])\n            ins[i] = 1;\n}\nvoid topo(int S) {\n    memset(cnt, 0, sizeof(cnt));\n    memset(cnt1, 0, sizeof(cnt1));\n    memset(cnt2, 0, sizeof(cnt2));\n    int i; H = tot = 0; cnt1[que[T = 1] = S] = 1;\n    for (i = 1; i <= m; i++) if (ins[i]) cnt[go[i]]++;\n    while (H < T) {\n        int u = que[++H]; q[++tot] = u;\n        for (int e = adj[u], v; e; e = nxt[e]) {\n            if (!ins[e]) continue;\n            v = go[e]; if (!(--cnt[v])) que[++T] = v;\n            (cnt1[v] += cnt1[u]) %= PYZ;\n        }\n    }\n    for (i = tot; i; i--) {\n        int u = q[i]; cnt2[u]++;\n        for (int e = adj[u], v; e; e = nxt[e]) {\n            if (!ins[e]) continue;\n            (cnt2[u] += cnt2[v = go[e]]) %= PYZ;\n        }\n    }\n}\nvoid solve(int S) {\n    int i; spfa(S); topo(S);\n    for (i = 1; i <= m; i++) if (ins[i])\n        (ans[i] += 1ll * cnt1[st[i]] * cnt2[go[i]] % PYZ) %= PYZ;\n}\nint main() {\n    int i, x, y, z; n = read(); m = read();\n    for (i = 1; i <= m; i++) x = read(), y = read(),\n        z = read(), add_edge(x, y, z);\n    for (i = 1; i <= n; i++) solve(i);\n    for (i = 1; i <= m; i++) printf(\"%d\\n\", ans[i]);\n    return 0;\n}", "step": ["Read input values n and m.", "Add edges to the graph.", "Iterate through each node and call the solve() method.", "The solve() method performs the modified Bellman-Ford algorithm followed by topological sort.", "The result is stored in ans array which is printed at last."], "nl_cn": "C 国有 $n$ 座城市，城市之间通过 $m$ 条**单向**道路连接。一条路径被称为最短路，当且仅当不存在从它的起点到终点的另外一条路径总长度比它小。两条最短路不同，当且仅当它们包含的道路序列不同。我们需要对每条道路的重要性进行评估，评估方式为计算有多少条不同的最短路经过该道路。现在，这个任务交给了你。\n", "test_cases": [{"input": "4 4\n1 2 5\n2 3 5\n3 4 5\n1 4 8", "output": "2\n3\n2\n1"}, {"input": "2 2\n1 2 10\n2 1 5\n", "output": "1\n1"}, {"input": "2 2\n1 2 10\n2 1 15\n", "output": "1\n1"}, {"input": "3 3\n1 2 10\n1 3 20\n2 3 30\n", "output": "1\n1\n1"}, {"input": "2 1\n1 2 3\n", "output": "1"}, {"input": "5 5\n1 2 10\n1 3 2\n1 4 3\n1 5 1\n3 5 2\n", "output": "1\n1\n1\n1\n1"}, {"input": "3 3\n1 2 1\n1 3 1\n2 3 1\n", "output": "1\n1\n1"}, {"input": "2 1\n1 2 1\n", "output": "1"}, {"input": "2 2\n1 2 1\n2 1 1\n", "output": "1\n1"}, {"input": "2 1\n1 2 5\n", "output": "1"}, {"input": "3 3\n1 2 10\n2 3 10\n1 3 10\n", "output": "1\n1\n1"}, {"input": "2 1\n1 2 10\n", "output": "1"}], "test": "#undef NDEBUG\n#include<assert.h>\nint main(){\n    assert(solution(\"4 4\\n1 2 5\\n2 3 5\\n3 4 5\\n1 4 8\") == \"2\\n3\\n2\\n1\");\n    assert(solution(\"2 2\\n1 2 10\\n2 1 5\\n\") == \"1\\n1\");\n    assert(solution(\"2 2\\n1 2 10\\n2 1 15\\n\") == \"1\\n1\");\n    assert(solution(\"3 3\\n1 2 10\\n1 3 20\\n2 3 30\\n\") == \"1\\n1\\n1\");\n    assert(solution(\"2 1\\n1 2 3\\n\") == \"1\");\n    assert(solution(\"5 5\\n1 2 10\\n1 3 2\\n1 4 3\\n1 5 1\\n3 5 2\\n\") == \"1\\n1\\n1\\n1\\n1\");\n    assert(solution(\"3 3\\n1 2 1\\n1 3 1\\n2 3 1\\n\") == \"1\\n1\\n1\");\n    assert(solution(\"2 1\\n1 2 1\\n\") == \"1\");\n    assert(solution(\"2 2\\n1 2 1\\n2 1 1\\n\") == \"1\\n1\");\n    assert(solution(\"2 1\\n1 2 5\\n\") == \"1\");\n    assert(solution(\"3 3\\n1 2 10\\n2 3 10\\n1 3 10\\n\") == \"1\\n1\\n1\");\n    assert(solution(\"2 1\\n1 2 10\\n\") == \"1\");\n    return 0; \n}", "prompt": "/*There are n cities in country C, connected by m one-way roads. A path is considered to be the shortest path if and only if there is no other path from its starting point to its ending point with a smaller total length. Two different shortest paths are distinct if and only if they contain different sequences of roads. We need to evaluate the importance of each road by calculating how many different shortest paths pass through it. Now, this task is entrusted to you.\n\ninput_format:\nThe first line contains two positive integers n and m.\n\nThe following m lines each contain three positive integers u, v, and w, representing a road of length w from u to v.\n\noutput_format:\nThe output should have a $m$line, and the $i$line contains a number representing the number of shortest circuits passing through the $i$path modulo $10^9+7$.\n*/\n\n#include<sstream>\n#include<stdlib.h>\n#include<algorithm>\n#include<math.h>\n#include<stdio.h>\n#include<vector>\n#include<string>\n#include<climits>\n#include<cstring>\n#include<iostream>\nusing namespace std;\n\n             \nstring solution(string std_in){\n    istringstream iss(std_in);\n             ", "constraints": "数据规模\n\n$30\\%$ 的数据满足：$n\\leq 15, m\\leq 30$。\n\n$60\\%$ 的数据满足：$n\\leq 300, m\\leq 1000$。\n\n$100\\%$ 的数据满足：$n\\leq 1500, m\\leq 5000, w\\leq 10000$。\n", "samples": [["4 4\n1 2 5\n2 3 5\n3 4 5\n1 4 8", "2\n3\n2\n1"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}}
{"task_id": "P6394", "title": "樱花，还有你", "difficulty": "advanced", "nl": "But don't worry, let's keep going without stopping or turning back. Aren't there still $k$ cherry blossom trees ahead? I calculated that you need to collect exactly $n$ cherry blossoms. I also found out that you can collect at most $s_i$ cherry blossoms under the $i$-th tree (collecting 0 cherry blossoms also counts as collecting cherry blossoms).\n\nWell, let me test you! How many ways do you have to collect exactly $n$ cherry blossoms?\n\nIn particular, if you cannot collect $n$ cherry blossoms, please tell me `impossible`.\n\nNote: if you collect $n$ cherry blossoms early, you can tell me right away, or you can continue walking with me until we reach the $k$-th cherry blossom tree and then we must part ways! Different plans are formed after you collect cherry blossoms at any tree during the period.", "code": "#include<iostream>\n#include<cstdio>\nusing namespace std;\n\nconst int M=10086001;\nint f[5001];\nlong long s[5001];//前缀和\nint num,ans;\n\nint main()\n{\n\tint n,t,i,j,p,k;\n\tcin>>n>>k;\n\t\n\ts[0]=f[0]=1;\n\n\tfor(i=1;i<=k;i++)\n\t{\n\t\tcin>>t;\n\t\t\n\t\tfor(j=1;j<=n;j++)//更新前缀和\n\t\ts[j]=s[j-1]+f[j];\n\t\t\n\t\tfor(p=n;p>=0;p--)//多重背包\n\t\tf[p]=(f[p]+s[p-1]-s[p-min(t,p)-1])%M;//利用前缀和\n\t\t\n\t\tnum+=t;//判断是否有解\n\t\tans=(ans+f[n])%M;//累加第i棵树下收集n朵花的方案\n\t\t\n\t}\n\t\n\tif(num<n)\n\tcout<<\"impossible\";\n\telse\n\tcout<<ans;\n\treturn 0;\n}", "step": ["Initialize variables and take input values for n, k, and s array.", "Check if sum of s array is less than n, if yes then print 'impossible' and exit the program.", "Call the DFS function with arguments 0 and 1.", "If tot is greater than n in the DFS function then return.", "If d is equal to k+1, check if tot is equal to n, if yes then increment ans variable.", "If tot is equal to n and d is less than or equal to k+1, increment ans variable.", "For i=0 to s[d], call DFS function with updated arguments.", "Print the final value of ans."], "nl_cn": "**与题意有关的句子已加粗。**\n\n但别急，我们就这样彳亍而行吧，**需不着停留或回头**，前面不是**还有 $k$ 棵樱花树么**？我算了算，你可要收集**恰好 $n$ 朵樱花**。我还发现，在第 $i$ 棵树下**最多**能收集到 $s_i$ 朵樱花（收集了 $0$ 朵樱花也算收集了樱花）。  \n\n呐，考考你吧！你有多少种方案能够收集到**恰好 $n$ 朵樱花**呢？\n\n**特殊地，如果你收集不到 $n$ 朵樱花，请告诉我 `impossible`。**   \n\n注意：如果你早早地收集到了 $n$ 朵樱花，你可以立刻告诉我，也可以陪我继续向前走，一直到第 $k$ 棵樱花树下收集了樱花后就必须交差啦！期间你在任何一棵树收集完樱花后就告诉我，形成的方案都是不同的哦！", "test_cases": [{"input": "3 4\n1 1 1 1", "output": "5"}, {"input": "10 9\n9 6 8 7 9 6 5 4 3", "output": "68345"}, {"input": "10 5\n2 2 2 2 1", "output": "impossible"}, {"input": "1 1\n1\n", "output": "1"}, {"input": "5 5\n1 1 1 1 1\n", "output": "1"}, {"input": "2 1\n2\n", "output": "1"}, {"input": "10 1\n10\n", "output": "1"}], "test": "#undef NDEBUG\n#include<assert.h>\nint main(){\n    assert(solution(\"3 4\\n1 1 1 1\") == \"5\");\n    assert(solution(\"10 9\\n9 6 8 7 9 6 5 4 3\") == \"68345\");\n    assert(solution(\"10 5\\n2 2 2 2 1\") == \"impossible\");\n    assert(solution(\"1 1\\n1\\n\") == \"1\");\n    assert(solution(\"5 5\\n1 1 1 1 1\\n\") == \"1\");\n    assert(solution(\"2 1\\n2\\n\") == \"1\");\n    assert(solution(\"10 1\\n10\\n\") == \"1\");\n    return 0; \n}", "prompt": "/*But don't worry, let's keep going without stopping or turning back. Aren't there still $k$ cherry blossom trees ahead? I calculated that you need to collect exactly $n$ cherry blossoms. I also found out that you can collect at most $s_i$ cherry blossoms under the $i$-th tree (collecting 0 cherry blossoms also counts as collecting cherry blossoms).\n\nWell, let me test you! How many ways do you have to collect exactly $n$ cherry blossoms?\n\nIn particular, if you cannot collect $n$ cherry blossoms, please tell me `impossible`.\n\nNote: if you collect $n$ cherry blossoms early, you can tell me right away, or you can continue walking with me until we reach the $k$-th cherry blossom tree and then we must part ways! Different plans are formed after you collect cherry blossoms at any tree during the period.\n\ninput_format:\nThe first row of two positive integers $n,k$indicates that there are $n$cherry blossoms to collect, and there are $k$cherry trees ahead.\n\nThe next line is $k$with positive integers $s_1,s_2,\\cdots,s_k$, where $s_i$indicates that at most $s_i$cherry blossom is collected under the first $i$cherry tree.\n\noutput_format:\nAn integer in a row represents the number of schemes that collected exactly $n$cherry blossoms.\n\n** Because the answer may be too large, please print the value of the answer modulo to $10086001. **\n\nIn particular, if you don't collect $n$cherry blossoms, output a string 'impossible'.\n*/\n\n#include<sstream>\n#include<stdlib.h>\n#include<algorithm>\n#include<math.h>\n#include<stdio.h>\n#include<vector>\n#include<string>\n#include<climits>\n#include<cstring>\n#include<iostream>\nusing namespace std;\n\n             \nstring solution(string std_in){\n    istringstream iss(std_in);\n             ", "constraints": "#### 样例解释 #1\n我们以下列方式表示一种方案：$(a_1,a_2,\\cdots,a_{len})$，其中 $\\sum_{i=1}^{len} a_i =n$，$len$ 表示在第 $len$ 棵樱花树下收集完樱花后就交差了，$a_i$ 表示在第 $i$ 棵树下收集了 $a_i$ 朵樱花。\n\n那么有下列 $5$ 种方案：$(1,1,1)$，$(1,1,1,0)$，$(0,1,1,1)$，$(1,0,1,1)$，$(1,1,0,1)$。\n\n---\n\n#### 样例解释 #3\n最多能收集到 $9$ 朵樱花，所以不能收集到 $10$ 朵樱花，输出 `impossible`。\n\n---\n\n#### 数据范围\n**本题采用捆绑测试。**\n- Subtask 1（5 Points），$\\sum s_i < n$。\n- Subtask 2（20 Points），$n,k \\leq 20$。\n- Subtask 3（55 Points），$n,k \\leq 5\\times 10^2$。\n- Subtask 4（20 Points），$n,k \\leq 5\\times 10^3$。\n\n对于 $100\\%$ 的数据，$1 \\leq n,k \\leq 5\\times 10^3$，$0 \\leq s_i \\leq n$。\n\n---\n\n#### 题目背景 ( 续 )\n&emsp;&emsp;何等聪明的你一定会站在某棵树下，捧着 $n$ 朵可爱的樱花，像孩子似的向我邀功吧。  \n&emsp;&emsp;那就别怪我成全你哦，我会轻跳起来，环住你的脖子，揭起你的口罩，尝一尝你的嘴唇。  \n&emsp;&emsp;你会不会说，“像樱花一样甜”呢？  \n&emsp;&emsp;反正，我的脸一定已经像樱花一样红了吧。  \n&emsp;&emsp;……  \n&emsp;&emsp;当你看到这封信，别哭呀……  \n&emsp;&emsp;冬天从这座城市夺走的，春天会补偿我们的。  \n&emsp;&emsp;待你好了，陪我去看樱花，可好？  \n\nYours,   \nYi", "samples": [["3 4\n1 1 1 1", "5"], ["10 9\n9 6 8 7 9 6 5 4 3", "68345"], ["10 5\n2 2 2 2 1", "impossible"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [65536, 65536, 65536, 65536, 65536, 65536, 65536, 65536, 65536, 65536, 65536, 65536, 65536, 65536, 65536, 65536, 65536, 65536, 65536, 65536]}}
{"task_id": "P8772", "title": "[蓝桥杯 2022 省 A] 求和", "difficulty": "challenge", "nl": "Given $n$ integers $a_{1}, a_{2}, \\cdots, a_{n}$, find the sum of the product of every pair of integers, i.e.,\n\n$$\nS=a_{1} \\cdot a_{2}+a_{1} \\cdot a_{3}+\\cdots+a_{1} \\cdot a_{n}+a_{2} \\cdot a_{3}+\\cdots+a_{n-2} \\cdot a_{n-1}+a_{n-2} \\cdot a_{n}+a_{n-1} \\cdot a_{n}\n$$", "code": "#include<bits/stdc++.h>\n#define MAXN 200005\n\nint n, a[MAXN];\nlong long sum[MAXN], ans;\n\nint main()\n{\n    std::cin >> n;\n    for(int i = 1; i <= n; i++)\n    {\n        std::cin >> a[i];\n        sum[i] = sum[i - 1] + a[i];\n    }\n    for(int i = 1; i <= n - 1; i++)\n        ans += a[i] *(sum[n] - sum[i]);\n    std::cout << ans << std::endl;\n    return 0;\n}", "step": ["Declare variables: n, a, tmp, ans", "Read value of n", "Loop through each number from 1 to n, read value of a", "Compute ans by adding the product of a and tmp with ans, and update tmp by adding a to it", "Print ans", "Return 0"], "nl_cn": "给定 $n$ 个整数 $a_{1}, a_{2}, \\cdots, a_{n}$, 求它们两两相乘再相加的和，即\n\n$$\nS=a_{1} \\cdot a_{2}+a_{1} \\cdot a_{3}+\\cdots+a_{1} \\cdot a_{n}+a_{2} \\cdot a_{3}+\\cdots+a_{n-2} \\cdot a_{n-1}+a_{n-2} \\cdot a_{n}+a_{n-1} \\cdot a_{n}\n$$\n", "test_cases": [{"input": "4\n1 3 6 9", "output": "117"}, {"input": "2\n0 0\n", "output": "0"}, {"input": "1\n100\n", "output": "0"}, {"input": "5\n-1 1 -1 1 -1\n", "output": "-2"}, {"input": "1\n0\n", "output": "0"}, {"input": "2\n-5 -10\n", "output": "50"}, {"input": "1\n1000\n", "output": "0"}, {"input": "1\n5", "output": "0"}, {"input": "2\n-10 10", "output": "-100"}, {"input": "0\n", "output": "0"}, {"input": "8\n1 1 1 1 1 1 1 1", "output": "28"}, {"input": "2\n0 5\n", "output": "0"}, {"input": "5\n0 0 0 0 0\n", "output": "0"}, {"input": "1\n-100\n", "output": "0"}, {"input": "6\n0 0 0 0 0 0\n", "output": "0"}, {"input": "2\n-10 -10\n", "output": "100"}, {"input": "1\n42\n", "output": "0"}, {"input": "2\n10 20\n", "output": "200"}], "test": "#undef NDEBUG\n#include<assert.h>\nint main(){\n    assert(solution(\"4\\n1 3 6 9\") == \"117\");\n    assert(solution(\"2\\n0 0\\n\") == \"0\");\n    assert(solution(\"1\\n100\\n\") == \"0\");\n    assert(solution(\"5\\n-1 1 -1 1 -1\\n\") == \"-2\");\n    assert(solution(\"1\\n0\\n\") == \"0\");\n    assert(solution(\"2\\n-5 -10\\n\") == \"50\");\n    assert(solution(\"1\\n1000\\n\") == \"0\");\n    assert(solution(\"1\\n5\") == \"0\");\n    assert(solution(\"2\\n-10 10\") == \"-100\");\n    assert(solution(\"0\\n\") == \"0\");\n    assert(solution(\"8\\n1 1 1 1 1 1 1 1\") == \"28\");\n    assert(solution(\"2\\n0 5\\n\") == \"0\");\n    assert(solution(\"5\\n0 0 0 0 0\\n\") == \"0\");\n    assert(solution(\"1\\n-100\\n\") == \"0\");\n    assert(solution(\"6\\n0 0 0 0 0 0\\n\") == \"0\");\n    assert(solution(\"2\\n-10 -10\\n\") == \"100\");\n    assert(solution(\"1\\n42\\n\") == \"0\");\n    assert(solution(\"2\\n10 20\\n\") == \"200\");\n    return 0; \n}", "prompt": "/*Given $n$ integers $a_{1}, a_{2}, \\cdots, a_{n}$, find the sum of the product of every pair of integers, i.e.,\n\n$$\nS=a_{1} \\cdot a_{2}+a_{1} \\cdot a_{3}+\\cdots+a_{1} \\cdot a_{n}+a_{2} \\cdot a_{3}+\\cdots+a_{n-2} \\cdot a_{n-1}+a_{n-2} \\cdot a_{n}+a_{n-1} \\cdot a_{n}\n$$\n\ninput_format:\nThe first line of input contains an integer $n$.\n\nThe second line contains $n$integers $a_{1}, a_{2}, \\cdots a_{n}$.\n\noutput_format:\nOutput an integer $S$, representing the desired sum. Please use the appropriate data type for the calculation.\n*/\n\n#include<sstream>\n#include<stdlib.h>\n#include<algorithm>\n#include<math.h>\n#include<stdio.h>\n#include<vector>\n#include<string>\n#include<climits>\n#include<cstring>\n#include<iostream>\nusing namespace std;\n\n             \nstring solution(string std_in){\n    istringstream iss(std_in);\n             ", "constraints": "对于 $30 \\%$ 的数据, $1 \\leq n \\leq 1000,1 \\leq a_{i} \\leq 100$ 。\n\n对于所有评测用例, $1 \\leq n \\leq 2\\times10^5,1 \\leq a_{i} \\leq 1000$ 。 \n\n蓝桥杯 2022 省赛 A 组 C 题。", "samples": [["4\n1 3 6 9", "117"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072]}}
{"task_id": "P7748", "title": "[COCI2013-2014#2] VOLIM", "difficulty": "basic", "nl": "There are 8 people sitting in a circle as shown in the figure.\n\n\n\nOne of them is holding a box which will explode after 210 seconds when the game starts.\n\nThe host will ask the box holder a question, and the box holder can choose the following ways:\n\n- If the question is skipped or answered incorrectly, the host will continue to ask the next question.\n- If the question is answered correctly, the box holder will pass the box to the person on his/her **left side**, who will become the new box holder.\n\nNow you know the time and answer status for each person who answers the questions.\n\nGiven the number of the initial box holder and the number of questions, find the number of the box holder when the box explodes.\n\nThe time for passing the box and the time between two questions is **neglected**, and the data ensures that the box explodes when it is held by someone and the questions are not finished.", "code": "#include <bits/stdc++.h>\n\nusing namespace std;\ninline int rd();\nint sum, T, n;\nchar c;\nint k;\nint main(){\n    cin >> k >> n;\n    while(sum < 210){\n\t\tcin >> T >> c;\n\t\tsum += T;\n\t\tif(sum >= 210) break;\n\t\tif(c == 'T') k %= 8, k++;\n    }\n    printf(\"%d\", k);\n    return 0;\n}\ninline int rd(){\n\tchar c;\n\tbool flag = 0;\n\twhile((c = getchar()) < '0' || c > '9')\n\t    if(c == '-') flag = 1;\n\tint res = c - '0';\n\twhile((c = getchar()) >= '0' && c <= '9')\n\t    res = (res << 3) + (res << 1) + c - '0';\n\treturn flag ? -res : res;\n}", "step": ["Read two integer inputs k and n.", "In a while loop with a condition, read two integer inputs T and a character input c.", "Add T to sum.", "If sum is greater than or equal to 210, break the loop.", "If c is equal to 'T', take the modulus of k with 8 and increment it by 1.", "After the loop is terminated, print k."], "nl_cn": "有 $8$ 个人坐成一圈，如图所示。\n\n\n\n他们中的某一个人会拿着一个箱子，这个箱子会在比赛开始后 $210$ 秒爆炸。\n\n主持人会问拿箱人问题，拿箱人可以选择以下方式：\n\n- 若跳过或回答错误，主持人会接着问下一个问题。\n- 若回答正确，则拿箱人把箱子传递给他**左手边**第一个人，这个人成为新的拿箱人。\n\n现在你知道对于每个问题，回答该问题的人所用的时间与回答情况。\n\n给定游戏开始时拿箱人的编号与问题的数量，求出箱子爆炸时拿箱人的编号。\n\n箱子传递时间与两个问题之间的时间**忽略不计**，数据保证箱子爆炸时箱子在某个人手上，且问题没有问完。", "test_cases": [{"input": "1 \n5 \n20 T \n50 T \n80 T \n50 T \n30 T", "output": "5"}, {"input": "3 \n5 \n100 T \n100 N \n100 T \n100 T \n100 N", "output": "4"}, {"input": "5\n6\n70 T\n50 P\n30 N\n50 T\n30 P\n80 T", "output": "7"}, {"input": "7\n3\n50 N\n100 N\n200 T\n", "output": "7"}, {"input": "3\n3\n30 P\n50 N\n100 T\n", "output": "4"}, {"input": "1\n4\n80 P\n50 T\n100 N\n40 N\n", "output": "2"}, {"input": "6\n5\n80 N\n50 T\n60 N\n90 N\n30 T\n", "output": "7"}, {"input": "1\n5\n20 T\n50 T\n80 T\n50 T\n30 T", "output": "5"}, {"input": "3\n5\n100 T\n100 N\n100 T\n100 T\n100 N", "output": "4"}, {"input": "5\n5\n100 T\n30 N\n20 N\n100 T\n20 T", "output": "6"}, {"input": "8\n6\n100 T\n10 P\n30 T\n100 T\n10 T\n60 P", "output": "2"}, {"input": "7\n4\n100 T\n100 T\n100 T\n100 T\n", "output": "1"}, {"input": "4\n2\n210 T\n210 T\n", "output": "4"}, {"input": "8\n7\n100 P\n200 N\n300 P\n400 T\n500 N\n600 P\n700 T\n", "output": "8"}, {"input": "7\n6\n100 T\n200 N\n300 P\n400 N\n500 T\n600 P\n", "output": "8"}, {"input": "1\n3\n100 P\n200 T\n300 P\n", "output": "1"}, {"input": "7\n5\n100 T\n200 N\n300 P\n400 T\n500 N\n600 P\n", "output": "8"}, {"input": "1\n3\n200 T\n100 N\n100 T\n", "output": "2"}, {"input": "5\n6\n90 T\n50 P\n30 N\n70 T\n60 N\n40 T\n", "output": "6"}, {"input": "7\n3\n100 T\n100 T\n100 T\n", "output": "1"}, {"input": "2\n4\n90 T\n80 N\n40 T\n30 T\n", "output": "3"}, {"input": "4\n5\n50 T\n30 N\n20 P\n40 T\n90 T\n", "output": "6"}, {"input": "8\n2\n100 T\n200 T\n", "output": "1"}, {"input": "3\n5\n10 P\n20 P\n30 P\n40 P\n50 P\n", "output": "3"}], "test": "#undef NDEBUG\n#include<assert.h>\nint main(){\n    assert(solution(\"1 \\n5 \\n20 T \\n50 T \\n80 T \\n50 T \\n30 T\") == \"5\");\n    assert(solution(\"3 \\n5 \\n100 T \\n100 N \\n100 T \\n100 T \\n100 N\") == \"4\");\n    assert(solution(\"5\\n6\\n70 T\\n50 P\\n30 N\\n50 T\\n30 P\\n80 T\") == \"7\");\n    assert(solution(\"7\\n3\\n50 N\\n100 N\\n200 T\\n\") == \"7\");\n    assert(solution(\"3\\n3\\n30 P\\n50 N\\n100 T\\n\") == \"4\");\n    assert(solution(\"1\\n4\\n80 P\\n50 T\\n100 N\\n40 N\\n\") == \"2\");\n    assert(solution(\"6\\n5\\n80 N\\n50 T\\n60 N\\n90 N\\n30 T\\n\") == \"7\");\n    assert(solution(\"1\\n5\\n20 T\\n50 T\\n80 T\\n50 T\\n30 T\") == \"5\");\n    assert(solution(\"3\\n5\\n100 T\\n100 N\\n100 T\\n100 T\\n100 N\") == \"4\");\n    assert(solution(\"5\\n5\\n100 T\\n30 N\\n20 N\\n100 T\\n20 T\") == \"6\");\n    assert(solution(\"8\\n6\\n100 T\\n10 P\\n30 T\\n100 T\\n10 T\\n60 P\") == \"2\");\n    assert(solution(\"7\\n4\\n100 T\\n100 T\\n100 T\\n100 T\\n\") == \"1\");\n    assert(solution(\"4\\n2\\n210 T\\n210 T\\n\") == \"4\");\n    assert(solution(\"8\\n7\\n100 P\\n200 N\\n300 P\\n400 T\\n500 N\\n600 P\\n700 T\\n\") == \"8\");\n    assert(solution(\"7\\n6\\n100 T\\n200 N\\n300 P\\n400 N\\n500 T\\n600 P\\n\") == \"8\");\n    assert(solution(\"1\\n3\\n100 P\\n200 T\\n300 P\\n\") == \"1\");\n    assert(solution(\"7\\n5\\n100 T\\n200 N\\n300 P\\n400 T\\n500 N\\n600 P\\n\") == \"8\");\n    assert(solution(\"1\\n3\\n200 T\\n100 N\\n100 T\\n\") == \"2\");\n    assert(solution(\"5\\n6\\n90 T\\n50 P\\n30 N\\n70 T\\n60 N\\n40 T\\n\") == \"6\");\n    assert(solution(\"7\\n3\\n100 T\\n100 T\\n100 T\\n\") == \"1\");\n    assert(solution(\"2\\n4\\n90 T\\n80 N\\n40 T\\n30 T\\n\") == \"3\");\n    assert(solution(\"4\\n5\\n50 T\\n30 N\\n20 P\\n40 T\\n90 T\\n\") == \"6\");\n    assert(solution(\"8\\n2\\n100 T\\n200 T\\n\") == \"1\");\n    assert(solution(\"3\\n5\\n10 P\\n20 P\\n30 P\\n40 P\\n50 P\\n\") == \"3\");\n    return 0; \n}", "prompt": "/*There are 8 people sitting in a circle as shown in the figure.\n\n\n\nOne of them is holding a box which will explode after 210 seconds when the game starts.\n\nThe host will ask the box holder a question, and the box holder can choose the following ways:\n\n- If the question is skipped or answered incorrectly, the host will continue to ask the next question.\n- If the question is answered correctly, the box holder will pass the box to the person on his/her **left side**, who will become the new box holder.\n\nNow you know the time and answer status for each person who answers the questions.\n\nGiven the number of the initial box holder and the number of questions, find the number of the box holder when the box explodes.\n\nThe time for passing the box and the time between two questions is **neglected**, and the data ensures that the box explodes when it is held by someone and the questions are not finished.\n\ninput_format:\nThe first line is an integer $K$, indicating the number of the person who took the box at the beginning of the game.\n\nThe second line contains an integer $N$, indicating the number of questions.\n\nNext is the $N$line, each line has an integer $T$and a character, indicating the time and response of the person who answered the question:\n\n- The value is $\\tt T$, indicating that the answer is correct.\n- The value is $\\tt N$, indicating an incorrect answer.\n- The value is $\\tt P$, indicating skip.\n\noutput_format:\nIt's just one line, an integer, the number of the person holding the box when it exploded.\n*/\n\n#include<sstream>\n#include<stdlib.h>\n#include<algorithm>\n#include<math.h>\n#include<stdio.h>\n#include<vector>\n#include<string>\n#include<climits>\n#include<cstring>\n#include<iostream>\nusing namespace std;\n\n             \nstring solution(string std_in){\n    istringstream iss(std_in);\n             ", "constraints": "#### 数据规模与约定\n\n对于 $100\\%$ 的数据，有 $1\\le K\\le 8$，$1\\le N,T\\le 100$。\n\n#### 来源\n\n**本题译自 [COCI2013-2014](https://hsin.hr/coci/archive/2013_2014/) [CONTEST 2](https://hsin.hr/coci/archive/2013_2014/contest2_tasks.pdf) _T1 VOLIM_。**\n\n按照原题数据配置，本题满分 $50$ 分。", "samples": [["1 \n5 \n20 T \n50 T \n80 T \n50 T \n30 T", "5"], ["3 \n5 \n100 T \n100 N \n100 T \n100 T \n100 N", "4"], ["5\n6\n70 T\n50 P\n30 N\n50 T\n30 P\n80 T", "7"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [32768, 32768, 32768, 32768, 32768, 32768, 32768, 32768, 32768, 32768, 32768, 32768, 32768]}}
{"task_id": "P1293", "title": "班级聚会", "difficulty": "challenge", "nl": "After 25 years of graduation, our protagonist is preparing for a class reunion. After countless phone calls, he finally got the addresses of all his classmates. Some of them are still in the same city, but most of them are scattered in other cities. However, he found a coincidence that all the addresses are distributed along a railway line. He is preparing to invite everyone but cannot decide where to hold the party. Finally, he decided to choose a location that minimizes the traveling cost for everyone.\n\nUnfortunately, our protagonist is not good at math or computers. He asks for your help in writing a program to choose the best location for the reunion based on the addresses of his classmates. In case of a tie in cost, the city closest to Moscow should be chosen.", "code": "#include <cmath>\n    #include <cstdio>\n    #include <cstring>\n    #include <iostream>\n    #include <algorithm>\n    using namespace std;\n    const int N = 50000;\n    int n, cost = 0;\n    int people[N], dis[N], Suf[N], val[N], sum = 0, ans = 0;\n    char name[200][200];\n    int main()\n    {\n        int i = 1;\n        while(scanf(\"%d%d%s\", &people[i], &dis[i], name[i]) != EOF)\n        {\n            cost += people[i] * dis[i];\n            Suf[i] = Suf[i - 1] + people[i];\n            sum += people[i];\n            ++i;\n        }\n        val[i] = cost;\n        for(int j = i - 1;j >= 1;--j)\n        {\n            val[j] = val[j + 1] + abs(dis[j] - dis[j + 1]) * (sum - Suf[j]) - (abs(dis[j] - dis[j + 1]) * Suf[j]);\n            if(val[j] < cost)\n                cost = val[j], ans = j;\n        }\n        printf(\"%s %d\\n\", name[ans], cost);\n        return 0;\n}", "step": ["Input the number of people, distance and the name of each person", "Calculate the total cost by multiplying number of people with distance", "Calculate the suffix sum of number of people", "Calculate the total number of people", "Calculate the minimum cost and the corresponding person's name required to travel", "Output the minimum cost and the corresponding person's name"], "nl_cn": "毕业25年以后，我们的主人公开始准备同学聚会。打了无数电话后他终于搞到了所有同学的地址。他们有些人仍在本城市，但大多数人分散在其他的城市。不过，他发现一个巧合，所有地址都恰好分散在一条铁路线上。他准备出发邀请但无法决定应该在哪个地方举行宴会。最后他决定选择一个地点，使大家旅行的花费和最小。\n\n不幸的是，我们的主人公既不擅长数学，也不擅长计算机。他请你帮忙写一个程序，根据他同学的地址，选择聚会的最佳地点。花费相同时优先取靠近莫斯科的城市。\n", "test_cases": [{"input": "7 9289 Vladivostok\n5 8523 Chabarovsk\n3 5184 Irkutsk\n8 2213 Yalutorovsk\n10 0 Moscow\n", "output": "Yalutorovsk 112125"}], "test": "#undef NDEBUG\n#include<assert.h>\nint main(){\n    assert(solution(\"7 9289 Vladivostok\\n5 8523 Chabarovsk\\n3 5184 Irkutsk\\n8 2213 Yalutorovsk\\n10 0 Moscow\\n\") == \"Yalutorovsk 112125\");\n    return 0; \n}", "prompt": "/*After 25 years of graduation, our protagonist is preparing for a class reunion. After countless phone calls, he finally got the addresses of all his classmates. Some of them are still in the same city, but most of them are scattered in other cities. However, he found a coincidence that all the addresses are distributed along a railway line. He is preparing to invite everyone but cannot decide where to hold the party. Finally, he decided to choose a location that minimizes the traveling cost for everyone.\n\nUnfortunately, our protagonist is not good at math or computers. He asks for your help in writing a program to choose the best location for the reunion based on the addresses of his classmates. In case of a tie in cost, the city closest to Moscow should be chosen.\n\ninput_format:\nEach line of the input file describes information about a city.\n\nThe first is the number of students in the city, followed by the distance (km) from the city to Moscow (the starting point), and finally the name of the city. The last line always describes Moscow, which is at one end of the railway line at a distance of zero.\n\noutput_format:\nThe name of the city and the cost of the trip (one way), separated by a space. It costs one ruble per kilometer.\n*/\n\n#include<sstream>\n#include<stdlib.h>\n#include<algorithm>\n#include<math.h>\n#include<stdio.h>\n#include<vector>\n#include<string>\n#include<climits>\n#include<cstring>\n#include<iostream>\nusing namespace std;\n\n             \nstring solution(string std_in){\n    istringstream iss(std_in);\n             ", "constraints": "### 数据范围及约定\n\n对于全部数据，保证城市数量 $ \\le 150$，距离 $ \\le 10000$，同学个数 $ \\le 50$。", "samples": [["7 9289 Vladivostok\n5 8523 Chabarovsk\n3 5184 Irkutsk\n8 2213 Yalutorovsk\n10 0 Moscow\n", "Yalutorovsk 112125\n"]], "limits": {"time": [1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000]}}
{"task_id": "P7910", "title": "[CSP-J 2021] 插入排序", "difficulty": "challenge", "nl": "Insertion sort is a very common and simple sorting algorithm. Little Z is a freshman in college, and today H teacher just taught the insertion sort algorithm in class.\n\nAssuming that the time to compare two elements is $\\mathcal O(1)$, the insertion sort can complete the sorting of an array of length $n$ in $\\mathcal O(n^2)$ time complexity. Without loss of generality, assuming that these $n$ numbers are stored in $a_1, a_2, \\ldots, a_n$ respectively, the following pseudocode gives a simplest implementation of the insertion sort algorithm:\n\nHere is a sample code in C/C++:\n\n```cpp\nfor (int i = 1; i <= n; i++)\n    for (int j = i; j >= 2; j--)\n        if (a[j] < a[j-1]) {\n            int t = a[j-1];\n            a[j-1] = a[j];\n            a[j] = t;\n        }\n```\n\nHere is a sample code in Pascal:\n\n```pascal\nfor i:=1 to n do\n    for j:=i downto 2 do\n        if a[j]<a[j-1] then\n            begin\n                t:=a[i];\n                a[i]:=a[j];\n                a[j]:=t;\n            end;\n```\n\nIn order to help Little Z better understand the insertion sort, H teacher left this homework for Little Z:\n\nH teacher gave an array $a$ of length $n$, whose array index starts from $1$, and all elements in the array are non-negative integers. Little Z needs to support $Q$ operations on the array $a$. There are two types of operations, with parameters as follows:\n\n$1\\ x\\ v$: This is the first type of operation, which will change the value of the $x$th element of $a$, namely $a_x$, to $v$. Ensure that $1 \\le x \\le n$ and $1 \\le v \\le 10^9$. **Note that this operation will change the elements in the array. The modified array will be retained and will affect subsequent operations.**\n\n$2\\ x$: This is the second type of operation. Assuming that H teacher sorts the $a$ array according to **the pseudocode above**, you need to tell H teacher the original position of the $x$th element of $a$, namely $a_x$, in the new sorted array. Ensure that $1 \\le x \\le n$. **Note that this operation will not change the elements in the array. The sorted array will not be retained and will not affect subsequent operations.**\n\nH teacher doesn't like too many modifications, so he guarantees that the number of type 1 operations will not exceed $5000$.\n\nLittle Z has not learned competitive programming, so he does not know how to solve this problem. He found you to help him.", "code": "#include<iostream>\n#include<cstdio>\n#include<algorithm>\nusing namespace std;\nconst int MAXN=8005;\nint n,q;\nint t[MAXN];\nstruct node{\n\tint pre,id;\n}a[MAXN];\nbool cmp(node x,node y){\n\tif(x.pre!=y.pre) return x.pre<y.pre;\n\treturn x.id<y.id;\n}//两个元素之间的优先级\nint main(){\n\t//freopen(\"sort.in\",\"r\",stdin);\n\t//freopen(\"sort.out\",\"w\",stdout);\n\tscanf(\"%d%d\",&n,&q); \n\tfor(int i=1;i<=n;i++){\n\t\tscanf(\"%d\",&a[i].pre);\n\t\ta[i].id=i;\n\t}//输入\n\tsort(a+1,a+n+1,cmp);//排序\n\tfor(int i=1;i<=n;i++)\n\t\tt[a[i].id]=i;\n\tfor(int i=1;i<=q;i++){\n\t\tint opt,x,v;\n\t\tscanf(\"%d\",&opt);\n\t\tif(opt==1){//单点修改\n\t\t\tscanf(\"%d%d\",&x,&v);//Ax->v\n\t\t\ta[t[x]].pre=v;\n\t\t\tfor(int j=n;j>=2;j--)\n\t\t\t\tif(cmp(a[j],a[j-1])){\n\t\t\t\t\tnode kkksc03=a[j];\n\t\t\t\t\ta[j]=a[j-1];\n\t\t\t\t\ta[j-1]=kkksc03;\n\t\t\t\t}//前扫\n\t\t\tfor(int j=2;j<=n;j++)\n\t\t\t\tif(cmp(a[j],a[j-1])){\n\t\t\t\t\tnode kkksc03=a[j];\n\t\t\t\t\ta[j]=a[j-1];\n\t\t\t\t\ta[j-1]=kkksc03;\n\t\t\t\t}//后扫\n\t\t\tfor(int i=1;i<=n;i++)\n\t\t\t\tt[a[i].id]=i;//更新关系\n\t\t}\n\t\telse{\n\t\t\tscanf(\"%d\",&x);\n\t\t\tprintf(\"%d\\n\",t[x]);\n\t\t}\n\t}\n\treturn 0;\n}", "step": ["Initialize n and q as integer values", "Input pre and id as nodes and sort them based on the value of pre in cmp function", "Traversal each node of a and update index array t based on the id", "Input opt and check if opt is equal to 1", "If opt is equal to 1, update the value of pre to v and rearrange the node", "For each node of a, update the index array t based on the id"], "nl_cn": "插入排序是一种非常常见且简单的排序算法。小 Z 是一名大一的新生，今天 H 老师刚刚在上课的时候讲了插入排序算法。\n\n假设比较两个元素的时间为 $\\mathcal O(1)$，则插入排序可以以 $\\mathcal O(n^2)$ 的时间复杂度完成长度为 $n$ 的数组的排序。不妨假设这 $n$ 个数字分别存储在 $a_1, a_2, \\ldots, a_n$ 之中，则如下伪代码给出了插入排序算法的一种最简单的实现方式：\n\n这下面是 C/C++ 的示范代码：\n\n```cpp\nfor (int i = 1; i <= n; i++)\n\tfor (int j = i; j >= 2; j--)\n\t\tif (a[j] < a[j-1]) {\n\t\t\tint t = a[j-1];\n\t\t\ta[j-1] = a[j];\n\t\t\ta[j] = t;\n\t\t}\n```\n\n这下面是 Pascal 的示范代码：\n\n```pascal\nfor i:=1 to n do\n\tfor j:=i downto 2 do\n\t\tif a[j]<a[j-1] then\n\t\t\tbegin\n\t\t\t\tt:=a[i];\n\t\t\t\ta[i]:=a[j];\n\t\t\t\ta[j]:=t;\n\t\t\tend;\n```\n\n为了帮助小 Z 更好的理解插入排序，小 Z 的老师 H 老师留下了这么一道家庭作业：\n\nH 老师给了一个长度为 $n$ 的数组 $a$，数组下标从 $1$ 开始，并且数组中的所有元素均为非负整数。小 Z 需要支持在数组 $a$ 上的 $Q$ 次操作，操作共两种，参数分别如下：\n\n$1~x~v$：这是第一种操作，会将 $a$ 的第 $x$ 个元素，也就是 $a_x$ 的值，修改为 $v$。保证 $1 \\le x \\le n$，$1 \\le v \\le 10^9$。**注意这种操作会改变数组的元素，修改得到的数组会被保留，也会影响后续的操作**。\n\n$2~x$：这是第二种操作，假设 H 老师按照**上面的伪代码**对 $a$ 数组进行排序，你需要告诉 H 老师原来 $a$ 的第 $x$ 个元素，也就是 $a_x$，在排序后的新数组所处的位置。保证 $1 \\le x \\le n$。**注意这种操作不会改变数组的元素，排序后的数组不会被保留，也不会影响后续的操作**。\n\nH 老师不喜欢过多的修改，所以他保证类型 $1$ 的操作次数不超过 $5000$。\n\n小 Z 没有学过计算机竞赛，因此小 Z 并不会做这道题。他找到了你来帮助他解决这个问题。", "test_cases": [{"input": "3 4\n3 2 1\n2 3\n1 3 2\n2 2\n2 3\n", "output": "1\n1\n2"}, {"input": "1 1\n1\n2 1\n", "output": "1"}, {"input": "2 3\n5 3\n2 1\n1 2 5\n2 1\n", "output": "2\n1"}, {"input": "2 2\n10 20\n2 1\n2 2\n", "output": "1\n2"}, {"input": "3 2\n100 200 300\n1 3 400\n2 2\n", "output": "2"}, {"input": "1 1\n9\n2 1\n", "output": "1"}, {"input": "2 2\n100 200\n2 1\n2 2\n", "output": "1\n2"}, {"input": "1 1\n5\n2 1\n", "output": "1"}], "test": "#undef NDEBUG\n#include<assert.h>\nint main(){\n    assert(solution(\"3 4\\n3 2 1\\n2 3\\n1 3 2\\n2 2\\n2 3\\n\") == \"1\\n1\\n2\");\n    assert(solution(\"1 1\\n1\\n2 1\\n\") == \"1\");\n    assert(solution(\"2 3\\n5 3\\n2 1\\n1 2 5\\n2 1\\n\") == \"2\\n1\");\n    assert(solution(\"2 2\\n10 20\\n2 1\\n2 2\\n\") == \"1\\n2\");\n    assert(solution(\"3 2\\n100 200 300\\n1 3 400\\n2 2\\n\") == \"2\");\n    assert(solution(\"1 1\\n9\\n2 1\\n\") == \"1\");\n    assert(solution(\"2 2\\n100 200\\n2 1\\n2 2\\n\") == \"1\\n2\");\n    assert(solution(\"1 1\\n5\\n2 1\\n\") == \"1\");\n    return 0; \n}", "prompt": "/*Insertion sort is a very common and simple sorting algorithm. Little Z is a freshman in college, and today H teacher just taught the insertion sort algorithm in class.\n\nAssuming that the time to compare two elements is $\\mathcal O(1)$, the insertion sort can complete the sorting of an array of length $n$ in $\\mathcal O(n^2)$ time complexity. Without loss of generality, assuming that these $n$ numbers are stored in $a_1, a_2, \\ldots, a_n$ respectively, the following pseudocode gives a simplest implementation of the insertion sort algorithm:\n\nHere is a sample code in C/C++:\n\n```cpp\nfor (int i = 1; i <= n; i++)\n    for (int j = i; j >= 2; j--)\n        if (a[j] < a[j-1]) {\n            int t = a[j-1];\n            a[j-1] = a[j];\n            a[j] = t;\n        }\n```\n\nHere is a sample code in Pascal:\n\n```pascal\nfor i:=1 to n do\n    for j:=i downto 2 do\n        if a[j]<a[j-1] then\n            begin\n                t:=a[i];\n                a[i]:=a[j];\n                a[j]:=t;\n            end;\n```\n\nIn order to help Little Z better understand the insertion sort, H teacher left this homework for Little Z:\n\nH teacher gave an array $a$ of length $n$, whose array index starts from $1$, and all elements in the array are non-negative integers. Little Z needs to support $Q$ operations on the array $a$. There are two types of operations, with parameters as follows:\n\n$1\\ x\\ v$: This is the first type of operation, which will change the value of the $x$th element of $a$, namely $a_x$, to $v$. Ensure that $1 \\le x \\le n$ and $1 \\le v \\le 10^9$. **Note that this operation will change the elements in the array. The modified array will be retained and will affect subsequent operations.**\n\n$2\\ x$: This is the second type of operation. Assuming that H teacher sorts the $a$ array according to **the pseudocode above**, you need to tell H teacher the original position of the $x$th element of $a$, namely $a_x$, in the new sorted array. Ensure that $1 \\le x \\le n$. **Note that this operation will not change the elements in the array. The sorted array will not be retained and will not affect subsequent operations.**\n\nH teacher doesn't like too many modifications, so he guarantees that the number of type 1 operations will not exceed $5000$.\n\nLittle Z has not learned competitive programming, so he does not know how to solve this problem. He found you to help him.\n\ninput_format:\nThe first line contains two positive integers $n and Q$, indicating the array length and the number of operations.\n\nThe second line contains $n$space-separated non-negative integers, where the first non-negative integer represents $a_i$.\n\nNext $Q$line, each line $2 \\sim 3$positive integer, indicating an operation, operation format see [** Topic description **].\n\noutput_format:\nFor each query of type $2$, output a line with a positive integer representing the answer.\n*/\n\n#include<sstream>\n#include<stdlib.h>\n#include<algorithm>\n#include<math.h>\n#include<stdio.h>\n#include<vector>\n#include<string>\n#include<climits>\n#include<cstring>\n#include<iostream>\nusing namespace std;\n\n             \nstring solution(string std_in){\n    istringstream iss(std_in);\n             ", "constraints": "**【样例解释 #1】**\n\n在修改操作之前，假设 H 老师进行了一次插入排序，则原序列的三个元素在排序结束后所处的位置分别是 $3, 2, 1$。\n\n在修改操作之后，假设 H 老师进行了一次插入排序，则原序列的三个元素在排序结束后所处的位置分别是 $3, 1, 2$。\n\n注意虽然此时 $a_2 = a_3$，但是我们**不能将其视为相同的元素**。\n\n**【样例 #2】**\n\n见附件中的 `sort/sort2.in` 与 `sort/sort2.ans`。\n\n该测试点数据范围同测试点 $1 \\sim 2$。\n\n**【样例 #3】**\n\n见附件中的 `sort/sort3.in` 与 `sort/sort3.ans`。\n\n该测试点数据范围同测试点 $3 \\sim 7$。\n\n**【样例 #4】**\n\n见附件中的 `sort/sort4.in` 与 `sort/sort4.ans`。\n\n该测试点数据范围同测试点 $12 \\sim 14$。\n\n**【数据范围】**\n\n对于所有测试数据，满足 $1 \\le n \\le 8000$，$1 \\le Q \\le 2 \\times {10}^5$，$1 \\le x \\le n$，$1 \\le v,a_i \\le 10^9$。\n\n对于所有测试数据，保证在所有 $Q$ 次操作中，至多有 $5000$ 次操作属于类型一。\n\n各测试点的附加限制及分值如下表所示。\n\n| 测试点 | $n \\le$ | $Q \\le$ | 特殊性质 |\n|:-:|:-:|:-:|:-:|\n| $1 \\sim 4$ | $10$ | $10$ | 无 |\n| $5 \\sim 9$ | $300$ | $300$ | 无 |\n| $10 \\sim 13$ | $1500$ | $1500$ | 无 |\n| $14 \\sim 16$ | $8000$ | $8000$| 保证所有输入的 $a_i,v$ 互不相同 |\n| $17 \\sim 19$ | $8000$ | $8000$ | 无 |\n| $20 \\sim 22$ | $8000$ | $2 \\times 10^5$ | 保证所有输入的 $a_i,v$ 互不相同 |\n| $23 \\sim 25$ | $8000$ | $2 \\times 10^5$ | 无 |", "samples": [["3 4\n3 2 1\n2 3\n1 3 2\n2 2\n2 3\n", "1\n1\n2\n"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288]}}
{"task_id": "P2773", "title": "漂亮字串", "difficulty": "challenge", "nl": "Caima believes that O and X are the most beautiful letters, and a string composed of O and X is the most beautiful string. Among these beautiful strings, if any substring containing only X has a length not exceeding maxX, any substring containing only O has a length not exceeding maxO, and there are at most countO O's and countX X's in the entire string, then it is a super beautiful and invincible string. Now Caima wants to know the length of the longest super beautiful and invincible string, and he hopes you can tell him.", "code": "//这里 cx，mx，co，mo，分别代表 CountX，maxX，CountX，maxO。\n#include<bits/stdc++.h>\n#define int long long\nusing namespace std;\nint cx,co,mx,mo;\nsigned main(){\n\twhile(cin>>co>>cx>>mo>>mx){\n\t\tif(!(min(co,mo))) cout<<min(cx,mx)<<endl;\n\t\telse if(!(min(cx,mx))) cout<<min(co,mo)<<endl;\n\t\telse if(cx>mx*(co+1)) cout<<mx*(co+1)+co<<endl;\n\t\telse if(co>mo*(cx+1)) cout<<mo*(cx+1)+cx<<endl;\n\t\telse cout<<cx+co<<endl;\n\t}\n\treturn 0;\n}", "step": ["Take input for CountO, CountX, MaxO, MaxX.", "If CountX or MaxX is zero, then print 0 and continue to next line.", "If CountO or MaxO is zero, then print 0 and continue to next line.", "If MaxO*(CountX+1) is less than CountO, then print MaxO*(CountX+1)+CountX.", "If MaxX*(CountO+1) is less than CountX, then print MaxX*(CountO+1)+CountO.", "Else, print CountO+CountX."], "nl_cn": "Caima认为O和X是最优美的两个字母，由O、X组成的串是最优美的串。在这些最优美的串中，如果任意只包含X的字串，长度不超过maxX，任意只包含O的子串，长度不超过maxO，且整个串最多有countO个O，countX个X。那么这个就是超级优美无敌串。现在Caima想知道最长的超级优美无敌串有多长，希望你告诉他。\n", "test_cases": [{"input": "10 10 0 0\n3 5 1 1", "output": "0\n7"}, {"input": "10 10 0 0\n", "output": "0"}, {"input": "3 5 1 1\n", "output": "7"}, {"input": "4 4 1 3\n", "output": "8"}, {"input": "7 7 4 5\n", "output": "14"}, {"input": "2 3 0 0\n", "output": "0"}, {"input": "0 0 0 0\n", "output": "0"}, {"input": "1 1 1 1\n", "output": "2"}, {"input": "4 3 2 3\n", "output": "7"}, {"input": "5 0 0 3\n", "output": "0"}, {"input": "0 9 4 0\n", "output": "0"}, {"input": "2 2 1 2\n", "output": "4"}, {"input": "0 0 0 0\n0 0 0 0", "output": "0\n0"}, {"input": "3 3 2 2\n", "output": "6"}, {"input": "8 8 4 4\n", "output": "16"}, {"input": "7 7 3 3\n", "output": "14"}, {"input": "4 5 2 2\n", "output": "9"}, {"input": "1 3 1 2\n", "output": "4"}, {"input": "10 0 0 5\n", "output": "0"}, {"input": "5 6 2 3\n", "output": "11"}, {"input": "3 4 1 2\n", "output": "7"}, {"input": "5 5 3 2\n", "output": "10"}, {"input": "6 6 3 3\n", "output": "12"}, {"input": "2 2 1 1\n", "output": "4"}, {"input": "4 6 2 4\n", "output": "10"}, {"input": "7 8 4 4\n", "output": "15"}, {"input": "10 10 5 5\n", "output": "20"}, {"input": "5 5 5 5\n", "output": "10"}, {"input": "10 5 10 5\n", "output": "15"}, {"input": "5 10 5 10\n", "output": "15"}, {"input": "100 100 10 10\n", "output": "200"}, {"input": "30 40 3 4\n", "output": "70"}, {"input": "15 30 2 3\n", "output": "45"}, {"input": "0 0 2 3\n", "output": "0"}, {"input": "0 0 0 3\n", "output": "0"}, {"input": "100 100 100 100\n", "output": "200"}, {"input": "0 10 5 0\n", "output": "0"}, {"input": "10 5 5 5\n", "output": "15"}, {"input": "5 7 3 2\n", "output": "12"}, {"input": "7 5 2 3\n", "output": "12"}, {"input": "3 3 1 1\n", "output": "6"}, {"input": "4 4 2 2\n", "output": "8"}], "test": "#undef NDEBUG\n#include<assert.h>\nint main(){\n    assert(solution(\"10 10 0 0\\n3 5 1 1\") == \"0\\n7\");\n    assert(solution(\"10 10 0 0\\n\") == \"0\");\n    assert(solution(\"3 5 1 1\\n\") == \"7\");\n    assert(solution(\"4 4 1 3\\n\") == \"8\");\n    assert(solution(\"7 7 4 5\\n\") == \"14\");\n    assert(solution(\"2 3 0 0\\n\") == \"0\");\n    assert(solution(\"0 0 0 0\\n\") == \"0\");\n    assert(solution(\"1 1 1 1\\n\") == \"2\");\n    assert(solution(\"4 3 2 3\\n\") == \"7\");\n    assert(solution(\"5 0 0 3\\n\") == \"0\");\n    assert(solution(\"0 9 4 0\\n\") == \"0\");\n    assert(solution(\"2 2 1 2\\n\") == \"4\");\n    assert(solution(\"0 0 0 0\\n0 0 0 0\") == \"0\\n0\");\n    assert(solution(\"3 3 2 2\\n\") == \"6\");\n    assert(solution(\"8 8 4 4\\n\") == \"16\");\n    assert(solution(\"7 7 3 3\\n\") == \"14\");\n    assert(solution(\"4 5 2 2\\n\") == \"9\");\n    assert(solution(\"1 3 1 2\\n\") == \"4\");\n    assert(solution(\"10 0 0 5\\n\") == \"0\");\n    assert(solution(\"5 6 2 3\\n\") == \"11\");\n    assert(solution(\"3 4 1 2\\n\") == \"7\");\n    assert(solution(\"5 5 3 2\\n\") == \"10\");\n    assert(solution(\"6 6 3 3\\n\") == \"12\");\n    assert(solution(\"2 2 1 1\\n\") == \"4\");\n    assert(solution(\"4 6 2 4\\n\") == \"10\");\n    assert(solution(\"7 8 4 4\\n\") == \"15\");\n    assert(solution(\"10 10 5 5\\n\") == \"20\");\n    assert(solution(\"5 5 5 5\\n\") == \"10\");\n    assert(solution(\"10 5 10 5\\n\") == \"15\");\n    assert(solution(\"5 10 5 10\\n\") == \"15\");\n    assert(solution(\"100 100 10 10\\n\") == \"200\");\n    assert(solution(\"30 40 3 4\\n\") == \"70\");\n    assert(solution(\"15 30 2 3\\n\") == \"45\");\n    assert(solution(\"0 0 2 3\\n\") == \"0\");\n    assert(solution(\"0 0 0 3\\n\") == \"0\");\n    assert(solution(\"100 100 100 100\\n\") == \"200\");\n    assert(solution(\"0 10 5 0\\n\") == \"0\");\n    assert(solution(\"10 5 5 5\\n\") == \"15\");\n    assert(solution(\"5 7 3 2\\n\") == \"12\");\n    assert(solution(\"7 5 2 3\\n\") == \"12\");\n    assert(solution(\"3 3 1 1\\n\") == \"6\");\n    assert(solution(\"4 4 2 2\\n\") == \"8\");\n    return 0; \n}", "prompt": "/*Caima believes that O and X are the most beautiful letters, and a string composed of O and X is the most beautiful string. Among these beautiful strings, if any substring containing only X has a length not exceeding maxX, any substring containing only O has a length not exceeding maxO, and there are at most countO O's and countX X's in the entire string, then it is a super beautiful and invincible string. Now Caima wants to know the length of the longest super beautiful and invincible string, and he hopes you can tell him.\n\ninput_format:\nInput contains multiple lines, and it continues until the end of the file.\n\nEach line consists of four numbers, which are CountO, CountX, maxO, and maxX, respectively.\n\nCountO, CountX, maxO, and maxX are all greater than or equal to 0 and less than or equal to 1000000.\n\noutput_format:\nEach set of data output a line, a number representing the length of the longest super beautiful invincible string\n*/\n\n#include<sstream>\n#include<stdlib.h>\n#include<algorithm>\n#include<math.h>\n#include<stdio.h>\n#include<vector>\n#include<string>\n#include<climits>\n#include<cstring>\n#include<iostream>\nusing namespace std;\n\n             \nstring solution(string std_in){\n    istringstream iss(std_in);\n             ", "constraints": "", "samples": [["10 10 0 0\n3 5 1 1", "0\n7"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}}
{"task_id": "P2240", "title": "【深基12.例1】部分背包问题", "difficulty": "challenge", "nl": "Alibaba entered a treasure cave filled with treasures. There are $N(N \\le 100)$ piles of coins in the cave, and the total weight and value of the $i^{th}$ pile of coins are $m_i,v_i(1\\le m_i,v_i \\le 100)$ respectively. Alibaba has a backpack with a weight capacity of $T(T \\le 1000)$, but he may not be able to pack all the coins. He wants to take away as much valuable coins as possible. All coins can be split arbitrarily, and the weight-value ratio (i.e., unit price) of the split coins remains unchanged. What is the maximum value of coins that Alibaba can take away?", "code": "#include<cstdio>\n#include<algorithm>//用到sort\nusing namespace std;\nstruct Node{//金币结构体\n\tint w,v;//w表示重量，v表示价值\n}a[110];\nint read(){//普通的快读，不解释\n\tint x=0,f=1;\n\tchar c=getchar();\n\twhile(c<'0'||c>'9'){\n\t\tif(c=='-') f=-1;\n\t\tc=getchar();\n\t}\n\twhile(c>='0'&&c<='9'){\n\t\tx=x*10+c-'0';\n\t\tc=getchar();\n\t}\n\treturn x*f;\n}\nbool cmp(Node aa,Node bb){//定义排序方法\n\treturn aa.v*bb.w>aa.w*bb.v;//按性价比从高到低排序，为防止精度问题直接交叉相乘\n}\nint main(){//主函数\n\tint n=read(),m=read();\n\tdouble ans=0;//记录答案\n\tfor(int i=1;i<=n;i++) a[i].w=read(),a[i].v=read();\n\tsort(a+1,a+n+1,cmp);//排序\n\tfor(int i=1;i<=n;i++){//一次遍历\n\t\tif(a[i].w<=m) ans+=a[i].v,m-=a[i].w;//够就全拿\n\t\telse{//不够\n\t\t\tans+=a[i].v*m*1.0/(a[i].w*1.0);//拿上能拿的部分，注意强转double\n\t\t\tbreak;//直接退出循环\n\t\t}\n\t}\n\tprintf(\"%.2lf\",ans);//保留2位小数\n\treturn 0;//华丽结束\n}", "step": ["Define gold structure with weight and value attributes", "Define a method for comparing the worth of two sets of gold", "Define a read method to read integer inputs", "Read in the quantity of gold bars and maximum weight limit", "Read in each gold bar's weight and value", "Sort the gold bars by their worth", "Iterate through each gold bar, determining how many can fit in the weight limit and their worth", "Calculate the value of any left-over weight using the most valuable gold bar", "Print the value of all gold coins collected"], "nl_cn": "阿里巴巴走进了装满宝藏的藏宝洞。藏宝洞里面有 $N(N \\le 100)$ 堆金币，第 $i$ 堆金币的总重量和总价值分别是 $m_i,v_i(1\\le m_i,v_i \\le 100)$。阿里巴巴有一个承重量为 $T(T \\le 1000)$ 的背包，但并不一定有办法将全部的金币都装进去。他想装走尽可能多价值的金币。所有金币都可以随意分割，分割完的金币重量价值比（也就是单位价格）不变。请问阿里巴巴最多可以拿走多少价值的金币？", "test_cases": [{"input": "4 50\n10 60\n20 100\n30 120\n15 45\n", "output": "240.00"}, {"input": "1 10\n5 50\n", "output": "50.00"}, {"input": "5 200\n10 100\n20 200\n30 300\n40 400\n50 500\n", "output": "1500.00"}, {"input": "1 10\n5 20\n", "output": "20.00"}, {"input": "3 30\n5 25\n10 50\n15 75\n", "output": "150.00"}, {"input": "3 20\n10 50\n10 50\n10 50\n", "output": "100.00"}, {"input": "2 10\n5 10\n10 20\n", "output": "20.00"}, {"input": "2 15\n10 30\n5 15\n", "output": "45.00"}, {"input": "3 70\n10 50\n20 120\n30 100\n", "output": "270.00"}, {"input": "1 10\n10 100\n", "output": "100.00"}, {"input": "1 20\n10 200\n", "output": "200.00"}, {"input": "3 80\n20 150\n30 200\n10 50\n", "output": "400.00"}, {"input": "1 30\n30 300\n", "output": "300.00"}, {"input": "2 40\n15 50\n25 200\n", "output": "250.00"}, {"input": "3 100\n20 150\n30 200\n10 50\n", "output": "400.00"}, {"input": "1 40\n40 400\n", "output": "400.00"}, {"input": "4 70\n10 50\n15 80\n20 100\n25 150\n", "output": "380.00"}, {"input": "3 120\n20 150\n30 200\n10 50\n", "output": "400.00"}, {"input": "1 50\n50 500\n", "output": "500.00"}, {"input": "1 10\n2 20\n", "output": "20.00"}, {"input": "2 50\n10 100\n10 200\n", "output": "300.00"}, {"input": "3 200\n100 1000\n50 500\n30 300\n", "output": "1800.00"}, {"input": "4 100\n10 100\n20 200\n30 300\n40 400\n", "output": "1000.00"}, {"input": "2 1000\n100 500\n500 1000\n", "output": "1500.00"}, {"input": "1 100\n100 1000\n", "output": "1000.00"}, {"input": "3 60\n10 10\n20 20\n30 30\n", "output": "60.00"}, {"input": "5 100\n10 20\n20 40\n30 60\n40 80\n50 100\n", "output": "200.00"}, {"input": "1 5\n3 10\n", "output": "10.00"}, {"input": "2 20\n5 100\n10 50\n", "output": "150.00"}, {"input": "4 70\n10 40\n20 80\n30 120\n40 160\n", "output": "280.00"}, {"input": "2 5\n2 10\n1 5\n", "output": "15.00"}, {"input": "1 100\n100 200\n", "output": "200.00"}], "test": "#undef NDEBUG\n#include<assert.h>\nint main(){\n    assert(solution(\"4 50\\n10 60\\n20 100\\n30 120\\n15 45\\n\") == \"240.00\");\n    assert(solution(\"1 10\\n5 50\\n\") == \"50.00\");\n    assert(solution(\"5 200\\n10 100\\n20 200\\n30 300\\n40 400\\n50 500\\n\") == \"1500.00\");\n    assert(solution(\"1 10\\n5 20\\n\") == \"20.00\");\n    assert(solution(\"3 30\\n5 25\\n10 50\\n15 75\\n\") == \"150.00\");\n    assert(solution(\"3 20\\n10 50\\n10 50\\n10 50\\n\") == \"100.00\");\n    assert(solution(\"2 10\\n5 10\\n10 20\\n\") == \"20.00\");\n    assert(solution(\"2 15\\n10 30\\n5 15\\n\") == \"45.00\");\n    assert(solution(\"3 70\\n10 50\\n20 120\\n30 100\\n\") == \"270.00\");\n    assert(solution(\"1 10\\n10 100\\n\") == \"100.00\");\n    assert(solution(\"1 20\\n10 200\\n\") == \"200.00\");\n    assert(solution(\"3 80\\n20 150\\n30 200\\n10 50\\n\") == \"400.00\");\n    assert(solution(\"1 30\\n30 300\\n\") == \"300.00\");\n    assert(solution(\"2 40\\n15 50\\n25 200\\n\") == \"250.00\");\n    assert(solution(\"3 100\\n20 150\\n30 200\\n10 50\\n\") == \"400.00\");\n    assert(solution(\"1 40\\n40 400\\n\") == \"400.00\");\n    assert(solution(\"4 70\\n10 50\\n15 80\\n20 100\\n25 150\\n\") == \"380.00\");\n    assert(solution(\"3 120\\n20 150\\n30 200\\n10 50\\n\") == \"400.00\");\n    assert(solution(\"1 50\\n50 500\\n\") == \"500.00\");\n    assert(solution(\"1 10\\n2 20\\n\") == \"20.00\");\n    assert(solution(\"2 50\\n10 100\\n10 200\\n\") == \"300.00\");\n    assert(solution(\"3 200\\n100 1000\\n50 500\\n30 300\\n\") == \"1800.00\");\n    assert(solution(\"4 100\\n10 100\\n20 200\\n30 300\\n40 400\\n\") == \"1000.00\");\n    assert(solution(\"2 1000\\n100 500\\n500 1000\\n\") == \"1500.00\");\n    assert(solution(\"1 100\\n100 1000\\n\") == \"1000.00\");\n    assert(solution(\"3 60\\n10 10\\n20 20\\n30 30\\n\") == \"60.00\");\n    assert(solution(\"5 100\\n10 20\\n20 40\\n30 60\\n40 80\\n50 100\\n\") == \"200.00\");\n    assert(solution(\"1 5\\n3 10\\n\") == \"10.00\");\n    assert(solution(\"2 20\\n5 100\\n10 50\\n\") == \"150.00\");\n    assert(solution(\"4 70\\n10 40\\n20 80\\n30 120\\n40 160\\n\") == \"280.00\");\n    assert(solution(\"2 5\\n2 10\\n1 5\\n\") == \"15.00\");\n    assert(solution(\"1 100\\n100 200\\n\") == \"200.00\");\n    return 0; \n}", "prompt": "/*Alibaba entered a treasure cave filled with treasures. There are $N(N \\le 100)$ piles of coins in the cave, and the total weight and value of the $i^{th}$ pile of coins are $m_i,v_i(1\\le m_i,v_i \\le 100)$ respectively. Alibaba has a backpack with a weight capacity of $T(T \\le 1000)$, but he may not be able to pack all the coins. He wants to take away as much valuable coins as possible. All coins can be split arbitrarily, and the weight-value ratio (i.e., unit price) of the split coins remains unchanged. What is the maximum value of coins that Alibaba can take away?\n\ninput_format:\nThe first row has two integers $N,T$.\n\nNext, $N$lines, each with two integers $m_i,v_i$.\n\noutput_format:\nA real number represents the answer and outputs two decimals\n*/\n\n#include<sstream>\n#include<stdlib.h>\n#include<algorithm>\n#include<math.h>\n#include<stdio.h>\n#include<vector>\n#include<string>\n#include<climits>\n#include<cstring>\n#include<iostream>\nusing namespace std;\n\n             \nstring solution(string std_in){\n    istringstream iss(std_in);\n             ", "constraints": "", "samples": [["4 50\n10 60\n20 100\n30 120\n15 45\n", "240.00"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000]}}
{"task_id": "P2913", "title": "[USACO08OCT]Wheel Rotation G", "difficulty": "challenge", "nl": "Farmer John has an old-fashioned thresher (wheat harvester) that requires belts to be installed on various gears to drive the components. The engine drives pulley 1 clockwise, which is connected to pulley 2 by a belt. Pulley 2 is connected to pulley 3 by a belt, and so on, with a total of N (2 <= N <= 1,000) pulleys and N-1 belts.\n\nThe figure above describes two ways to install a belt between two gears. In this example, the belt from pulley 1 drives pulley 2 directly (a \"straight\" connection), so they will rotate in the same direction. Pulley 3 drives pulley 4 and reverses the direction through a \"crossed\" belt.\n\nGiven a list of belt connections between pulleys and the knowledge that the engine drives pulley 1 clockwise, determine the direction of pulley N. Each belt is described by three integers:\n\n```cpp\n• S_i - the driving (source) pulley\n• D_i - the driven (destination) pulley\n• C_i - the connection type (0 = straight connection, 1 = crossed connection)\n```\n\nUnfortunately, the order of the belts listed by FJ is random. For example, consider the figure above. N = 4, and pulley 1 is driven clockwise by the thresher engine. The straight belt drives pulleys 2 and 3, so they rotate clockwise. The crossed belt reverses the direction of rotation, so pulley 4 (pulley N) rotates counterclockwise.\n\nScore: 70", "code": "#include <bits/stdc++.h> //万能头是陋习 \nusing namespace std ;\nint n , a , b , c ;\nbool flag ; //flag为滑轮转动方向 \nint main()\n{\n\tcin >> n ;\n\tfor( int i = 1 ; i < n ; ++i ){\n\t\tcin >> a >> b >> c ;\n\t\tif( c == 1 ) flag = !flag ; //如果是交叉连接就转变方向 \n\t}\n\tcout << flag ? 0 : 1 ; //压行也是陋习\n\treturn 0 ; \n}", "step": ["Declare a structure.", "Define a compare function for structures.", "Define variables and take user input.", "Sort the array of structures.", "Count the number of 'true' values in the array.", "Output 0 if the count is even, 1 if it is odd."], "nl_cn": "Farmer John has an old-time thresher (wheat harvester) that requires belts to be installed on various gears to turn the parts. The engine drives pulley 1 in a clockwise direction which attaches via a belt to pulley 2. Pulley 2 attaches via a belt to pulley 3 and so on through a total of N (2 <= N <= 1,000) pulleys (and N-1 belts).\n\nThe diagram above depicts the two ways a belt can be installed between two gears. In this illustration, pulley 1's belt directly drives pulley 2 (a 'straight' connection) and thus they will rotate in the same direction. Pulley 3 drives pulley 4 via a 'crossed belt' that reverses the direction of the rotation.\n\nGiven a list of the belt types that connect the pulleys along with the fact that pulley 1 is driven in a clockwise direction by the engine, determine the drive direction of pulley N. Each belt is described by three integers:\n\n```cpp\n* S_i -- the driving (source) pulley \n* D_i -- the driven (destination) pulley \n* C_i -- the connection type (0=straight, 1=crossed) \nUnfortunately, FJ lists the belts in random order. \nBy way of example, consider the illustration below. N = 4, and pulley 1 is driven clockwise by the thresher engine. Straight \nbelts drive pulley 2 and then pulley 3, so they rotate clockwise. The crosswise belt reverses the rotation direction so pulley 4 (pulley N) rotates counterclockwise. \n```\nPOINTS: 70\n约翰有一个过时的收割机，需要在它的各种滑轮上装配皮带才能让收割机的各个部分运作起 来.引擎能够驱动滑轮1向顺时针方向转动，滑轮1通过一条皮带又连接到滑轮2.滑轮2又通过一 条皮带连接到滑轮3，等等，总共有N(2 <= N <= 1000)个滑轮和N - 1条皮带.\n\n皮带连接两个滑轮有两种方式：直接连接和交叉连接.直接连接的两个滑轮旋转方向相同， 即同为顺时针或同为逆时针.交叉连接的两个滑轮旋转方向相反.\n\n现在给出一个列表，里面列出所有皮带的连接方式.已经知道滑轮1被引擎驱动着向顺时针方 向转动.每一条皮带由下面三个数定义：\n\n•驱动滑轮S，输入驱动力的滑轮.\n\n•被驱动滑轮D;，被驱使转动的滑轮.\n\n•连接类型C，0表示直接连接，1表示交叉连接.\n\n不幸的是，约翰的这个列表中，皮带的顺序是混乱的.所以请你写一个程序来求出滑轮N的 转动方向.\n", "test_cases": [{"input": "4 \n2 3 0 \n3 4 1 \n1 2 0 \n", "output": "1"}, {"input": "2 \n1 2 0 \n", "output": "0"}, {"input": "3 \n1 2 0 \n2 3 0 \n", "output": "0"}, {"input": "6 \n1 2 1 \n2 3 1 \n3 4 0 \n4 5 1 \n5 6 0 \n", "output": "1"}, {"input": "7 \n1 2 0 \n2 3 0 \n3 4 0 \n4 5 0 \n5 6 0 \n6 7 0 \n", "output": "0"}, {"input": "11 \n1 2 1 \n2 3 1 \n3 4 1 \n4 5 0 \n5 6 0 \n6 7 1 \n7 8 0 \n8 9 0 \n9 10 1 \n10 11 0 \n", "output": "1"}, {"input": "12 \n1 2 0 \n2 3 1 \n3 4 0 \n4 5 0 \n5 6 1 \n6 7 0 \n7 8 1 \n8 9 0 \n9 10 1 \n10 11 0 \n11 12 1 \n", "output": "1"}, {"input": "13 \n1 2 0 \n2 3 1 \n3 4 0 \n4 5 0 \n5 6 0 \n6 7 0 \n7 8 1 \n8 9 0 \n9 10 1 \n10 11 0 \n11 12 1 \n12 13 0 \n", "output": "0"}, {"input": "16 \n1 2 1 \n2 3 0 \n3 4 1 \n4 5 1 \n5 6 0 \n6 7 0 \n7 8 0 \n8 9 0 \n9 10 0 \n10 11 1 \n11 12 1 \n12 13 0 \n13 14 0 \n14 15 1 \n15 16 1 \n", "output": "1"}, {"input": "18 \n1 2 0 \n2 3 0 \n3 4 1 \n4 5 0 \n5 6 1 \n6 7 0 \n7 8 1 \n8 9 1 \n9 10 0 \n10 11 0 \n11 12 0 \n12 13 0 \n13 14 0 \n14 15 0 \n15 16 0 \n16 17 0 \n17 18 1 \n", "output": "1"}, {"input": "20 \n1 2 1 \n2 3 0 \n3 4 1 \n4 5 0 \n5 6 0 \n6 7 0 \n7 8 1 \n8 9 1 \n9 10 0 \n10 11 1 \n11 12 0 \n12 13 1 \n13 14 1 \n14 15 1 \n15 16 0 \n16 17 1 \n17 18 0 \n18 19 1 \n19 20 1 \n", "output": "1"}, {"input": "6 \n1 2 1 \n2 3 0 \n3 4 1 \n4 5 0 \n5 6 1 \n", "output": "1"}, {"input": "7 \n1 2 0 \n2 3 0 \n3 4 0 \n4 5 1 \n5 6 1 \n6 7 0 \n", "output": "0"}, {"input": "6 \n1 2 0 \n2 3 0 \n3 4 1 \n4 5 1 \n5 6 0 \n", "output": "0"}, {"input": "8 \n1 2 0 \n2 3 1 \n3 4 0 \n4 5 0 \n5 6 1 \n6 7 1 \n7 8 0 \n", "output": "1"}, {"input": "9 \n1 2 1 \n2 3 0 \n3 4 0 \n4 5 0 \n5 6 0 \n6 7 0 \n7 8 1 \n8 9 1 \n", "output": "1"}, {"input": "10 \n1 2 0 \n2 3 1 \n3 4 1 \n4 5 1 \n5 6 1 \n6 7 0 \n7 8 0 \n8 9 0 \n9 10 0 \n", "output": "0"}, {"input": "15 \n1 2 1 \n2 3 1 \n3 4 0 \n4 5 0 \n5 6 1 \n6 7 1 \n7 8 1 \n8 9 0 \n9 10 1 \n10 11 0 \n11 12 1 \n12 13 1 \n13 14 0 \n14 15 1 \n", "output": "1"}, {"input": "5 \n1 2 1 \n2 3 0 \n3 4 1 \n4 5 0 \n", "output": "0"}, {"input": "3 \n1 2 0 \n2 3 1 \n", "output": "1"}, {"input": "5 \n1 2 1 \n2 3 0 \n3 4 0 \n4 5 1 \n", "output": "0"}, {"input": "4 \n1 2 0 \n2 3 0 \n3 4 1 \n", "output": "1"}, {"input": "6 \n1 2 1 \n2 3 0 \n3 4 1 \n4 5 1 \n5 6 0 \n", "output": "1"}, {"input": "2 \n1 2 1 \n", "output": "1"}, {"input": "7 \n1 2 0 \n2 3 0 \n3 4 1 \n4 5 0 \n5 6 1 \n6 7 1 \n", "output": "1"}, {"input": "5 \n1 2 0 \n2 3 1 \n3 4 0 \n4 5 0 \n", "output": "1"}, {"input": "4 \n1 2 1 \n2 3 0 \n3 4 1 \n", "output": "0"}, {"input": "5 \n1 2 1 \n2 3 1 \n3 4 1 \n4 5 1 \n", "output": "0"}, {"input": "6 \n1 2 1 \n1 3 1 \n2 4 1 \n3 4 0 \n4 5 0 \n", "output": "1"}, {"input": "7 \n1 2 1 \n2 3 0 \n3 4 1 \n4 5 0 \n5 6 0 \n6 7 1 \n", "output": "1"}, {"input": "5 \n1 3 1 \n3 5 1 \n5 2 1 \n2 4 0 \n", "output": "1"}, {"input": "5 \n3 1 1 \n4 1 1 \n5 2 1 \n3 4 1 \n", "output": "0"}, {"input": "5 \n3 5 1 \n4 2 0 \n5 2 0 \n1 3 1 \n", "output": "0"}, {"input": "7 \n7 1 1 \n1 2 1 \n2 3 0 \n4 2 1 \n5 3 0 \n6 4 1 \n", "output": "0"}], "test": "#undef NDEBUG\n#include<assert.h>\nint main(){\n    assert(solution(\"4 \\n2 3 0 \\n3 4 1 \\n1 2 0 \\n\") == \"1\");\n    assert(solution(\"2 \\n1 2 0 \\n\") == \"0\");\n    assert(solution(\"3 \\n1 2 0 \\n2 3 0 \\n\") == \"0\");\n    assert(solution(\"6 \\n1 2 1 \\n2 3 1 \\n3 4 0 \\n4 5 1 \\n5 6 0 \\n\") == \"1\");\n    assert(solution(\"7 \\n1 2 0 \\n2 3 0 \\n3 4 0 \\n4 5 0 \\n5 6 0 \\n6 7 0 \\n\") == \"0\");\n    assert(solution(\"11 \\n1 2 1 \\n2 3 1 \\n3 4 1 \\n4 5 0 \\n5 6 0 \\n6 7 1 \\n7 8 0 \\n8 9 0 \\n9 10 1 \\n10 11 0 \\n\") == \"1\");\n    assert(solution(\"12 \\n1 2 0 \\n2 3 1 \\n3 4 0 \\n4 5 0 \\n5 6 1 \\n6 7 0 \\n7 8 1 \\n8 9 0 \\n9 10 1 \\n10 11 0 \\n11 12 1 \\n\") == \"1\");\n    assert(solution(\"13 \\n1 2 0 \\n2 3 1 \\n3 4 0 \\n4 5 0 \\n5 6 0 \\n6 7 0 \\n7 8 1 \\n8 9 0 \\n9 10 1 \\n10 11 0 \\n11 12 1 \\n12 13 0 \\n\") == \"0\");\n    assert(solution(\"16 \\n1 2 1 \\n2 3 0 \\n3 4 1 \\n4 5 1 \\n5 6 0 \\n6 7 0 \\n7 8 0 \\n8 9 0 \\n9 10 0 \\n10 11 1 \\n11 12 1 \\n12 13 0 \\n13 14 0 \\n14 15 1 \\n15 16 1 \\n\") == \"1\");\n    assert(solution(\"18 \\n1 2 0 \\n2 3 0 \\n3 4 1 \\n4 5 0 \\n5 6 1 \\n6 7 0 \\n7 8 1 \\n8 9 1 \\n9 10 0 \\n10 11 0 \\n11 12 0 \\n12 13 0 \\n13 14 0 \\n14 15 0 \\n15 16 0 \\n16 17 0 \\n17 18 1 \\n\") == \"1\");\n    assert(solution(\"20 \\n1 2 1 \\n2 3 0 \\n3 4 1 \\n4 5 0 \\n5 6 0 \\n6 7 0 \\n7 8 1 \\n8 9 1 \\n9 10 0 \\n10 11 1 \\n11 12 0 \\n12 13 1 \\n13 14 1 \\n14 15 1 \\n15 16 0 \\n16 17 1 \\n17 18 0 \\n18 19 1 \\n19 20 1 \\n\") == \"1\");\n    assert(solution(\"6 \\n1 2 1 \\n2 3 0 \\n3 4 1 \\n4 5 0 \\n5 6 1 \\n\") == \"1\");\n    assert(solution(\"7 \\n1 2 0 \\n2 3 0 \\n3 4 0 \\n4 5 1 \\n5 6 1 \\n6 7 0 \\n\") == \"0\");\n    assert(solution(\"6 \\n1 2 0 \\n2 3 0 \\n3 4 1 \\n4 5 1 \\n5 6 0 \\n\") == \"0\");\n    assert(solution(\"8 \\n1 2 0 \\n2 3 1 \\n3 4 0 \\n4 5 0 \\n5 6 1 \\n6 7 1 \\n7 8 0 \\n\") == \"1\");\n    assert(solution(\"9 \\n1 2 1 \\n2 3 0 \\n3 4 0 \\n4 5 0 \\n5 6 0 \\n6 7 0 \\n7 8 1 \\n8 9 1 \\n\") == \"1\");\n    assert(solution(\"10 \\n1 2 0 \\n2 3 1 \\n3 4 1 \\n4 5 1 \\n5 6 1 \\n6 7 0 \\n7 8 0 \\n8 9 0 \\n9 10 0 \\n\") == \"0\");\n    assert(solution(\"15 \\n1 2 1 \\n2 3 1 \\n3 4 0 \\n4 5 0 \\n5 6 1 \\n6 7 1 \\n7 8 1 \\n8 9 0 \\n9 10 1 \\n10 11 0 \\n11 12 1 \\n12 13 1 \\n13 14 0 \\n14 15 1 \\n\") == \"1\");\n    assert(solution(\"5 \\n1 2 1 \\n2 3 0 \\n3 4 1 \\n4 5 0 \\n\") == \"0\");\n    assert(solution(\"3 \\n1 2 0 \\n2 3 1 \\n\") == \"1\");\n    assert(solution(\"5 \\n1 2 1 \\n2 3 0 \\n3 4 0 \\n4 5 1 \\n\") == \"0\");\n    assert(solution(\"4 \\n1 2 0 \\n2 3 0 \\n3 4 1 \\n\") == \"1\");\n    assert(solution(\"6 \\n1 2 1 \\n2 3 0 \\n3 4 1 \\n4 5 1 \\n5 6 0 \\n\") == \"1\");\n    assert(solution(\"2 \\n1 2 1 \\n\") == \"1\");\n    assert(solution(\"7 \\n1 2 0 \\n2 3 0 \\n3 4 1 \\n4 5 0 \\n5 6 1 \\n6 7 1 \\n\") == \"1\");\n    assert(solution(\"5 \\n1 2 0 \\n2 3 1 \\n3 4 0 \\n4 5 0 \\n\") == \"1\");\n    assert(solution(\"4 \\n1 2 1 \\n2 3 0 \\n3 4 1 \\n\") == \"0\");\n    assert(solution(\"5 \\n1 2 1 \\n2 3 1 \\n3 4 1 \\n4 5 1 \\n\") == \"0\");\n    assert(solution(\"6 \\n1 2 1 \\n1 3 1 \\n2 4 1 \\n3 4 0 \\n4 5 0 \\n\") == \"1\");\n    assert(solution(\"7 \\n1 2 1 \\n2 3 0 \\n3 4 1 \\n4 5 0 \\n5 6 0 \\n6 7 1 \\n\") == \"1\");\n    assert(solution(\"5 \\n1 3 1 \\n3 5 1 \\n5 2 1 \\n2 4 0 \\n\") == \"1\");\n    assert(solution(\"5 \\n3 1 1 \\n4 1 1 \\n5 2 1 \\n3 4 1 \\n\") == \"0\");\n    assert(solution(\"5 \\n3 5 1 \\n4 2 0 \\n5 2 0 \\n1 3 1 \\n\") == \"0\");\n    assert(solution(\"7 \\n7 1 1 \\n1 2 1 \\n2 3 0 \\n4 2 1 \\n5 3 0 \\n6 4 1 \\n\") == \"0\");\n    return 0; \n}", "prompt": "/*Farmer John has an old-fashioned thresher (wheat harvester) that requires belts to be installed on various gears to drive the components. The engine drives pulley 1 clockwise, which is connected to pulley 2 by a belt. Pulley 2 is connected to pulley 3 by a belt, and so on, with a total of N (2 <= N <= 1,000) pulleys and N-1 belts.\n\nThe figure above describes two ways to install a belt between two gears. In this example, the belt from pulley 1 drives pulley 2 directly (a \"straight\" connection), so they will rotate in the same direction. Pulley 3 drives pulley 4 and reverses the direction through a \"crossed\" belt.\n\nGiven a list of belt connections between pulleys and the knowledge that the engine drives pulley 1 clockwise, determine the direction of pulley N. Each belt is described by three integers:\n\n```cpp\n• S_i - the driving (source) pulley\n• D_i - the driven (destination) pulley\n• C_i - the connection type (0 = straight connection, 1 = crossed connection)\n```\n\nUnfortunately, the order of the belts listed by FJ is random. For example, consider the figure above. N = 4, and pulley 1 is driven clockwise by the thresher engine. The straight belt drives pulleys 2 and 3, so they rotate clockwise. The crossed belt reverses the direction of rotation, so pulley 4 (pulley N) rotates counterclockwise.\n\nScore: 70\n\ninput_format:\n\\* Line 1: A single integer: N\n\n\\* Lines 2..N: Each line describes a belt with three integers: S\\_i, D\\_i, and C\\_i\n\nTranslation:\n\n\\* Line 1: A single integer: N\n\n\\* Lines 2..N: Each line describes a belt with three integers: S\\_i, D\\_i, and C\\_i\n\noutput_format:\n\\* Line 1: A single integer that is the rotation direction for pulley N (0=clockwise, 1=counterclockwise)\n*/\n\n#include<sstream>\n#include<stdlib.h>\n#include<algorithm>\n#include<math.h>\n#include<stdio.h>\n#include<vector>\n#include<string>\n#include<climits>\n#include<cstring>\n#include<iostream>\nusing namespace std;\n\n             \nstring solution(string std_in){\n    istringstream iss(std_in);\n             ", "constraints": "As in the example illustration.\n", "samples": [["4 \n2 3 0 \n3 4 1 \n1 2 0 \n", "1 \n"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}}
{"task_id": "P8720", "title": "[蓝桥杯 2020 省 B2] 平面切分", "difficulty": "challenge", "nl": "There are $N$ straight lines on the plane, where the $i$-th line is $y=A_{i}\\cdot x+B_{i}$.\n\nPlease calculate how many parts the plane is divided into by these lines.", "code": "#include <iostream>\n#include <map>\n#include <set>\n#define IL inline\nusing namespace std;\nconst int N = 1e5 + 10;\n\nstruct node\n{\n    long double k, b;\n}a[N];\n\nint main()\n{\n    int n;\n    cin >> n;\n    int m = 0;\n    set<pair<long double, long double> > p;\n    for(int i = 1;i <= n;i++)\n    {\n        long double x, y;\n        cin >> x >> y; \n        p.insert({x, y});//set 去重。 \n    }\n    for(auto i = p.begin();i != p.end();i++) //遍历并存入结构体数组。 \n    {\n        a[++m] = {(*i).first, (*i).second};\n    }\n    int ans = 0;\n\t\n    for(int i = 1;i <= m;i++)\n    {\n\t\tset <pair<long double,long double> > o;\n        for(int j = 1;j < i;j++)\n        {\n            long double k1 = a[i].k;\n            long double k2 = a[j].k;\n            long double b1 = a[i].b;\n            long double b2 = a[j].b;\n            if(k1 == k2) continue; //斜率一致，平行，过掉。 \n            long double x1 = (b2 - b1)  / (k1 - k2);\n            long double y1 = k1 * x1 + b1;\n            //根据公式计算交点。\n            o.insert({x1, y1});\n            //加入 set 去重。\n        }\n        ans += (o.size() + 1);\n    }\n    cout << ans + 1 << endl; //初始有一部分，要加一。\n    return 0;\n}", "step": ["Read input value n", "Read input coordinates a and b for n points", "Using set data structure, count the number of distinct lines formed by each pair of points. If two points have the same coordinates, treat them as the same point. If two points have the same x coordinate, ignore them.", "For each point, check if it has already been counted in a previous line. If not, add count to the answer.", "Print the total count of distinct lines formed by the set of points."], "nl_cn": "平面上有 $N$ 条直线, 其中第 $i$ 条直线是 $y=A_{i} \\cdot x+B_{i}$ 。\n\n请计算这些直线将平面分成了几个部分。\n", "test_cases": [{"input": "3\n1 1\n2 2\n3 3", "output": "6"}, {"input": "2\n-2 -1\n2 1\n", "output": "4"}, {"input": "6\n1 1\n1 2\n1 3\n1 4\n1 5\n1 6\n", "output": "7"}, {"input": "2\n-1 0\n0 1\n", "output": "4"}, {"input": "4\n1 1\n-1 -1\n1 -1\n-1 1\n", "output": "9"}, {"input": "3\n1 1\n1 1\n1 1\n", "output": "2"}, {"input": "2\n0 0\n2 2\n", "output": "4"}, {"input": "3\n-2 -1\n2 1\n-2 -1\n", "output": "4"}, {"input": "5\n1 1\n1 1\n1 1\n1 1\n1 1\n", "output": "2"}, {"input": "5\n0 0\n0 1\n0 2\n0 3\n0 4", "output": "6"}, {"input": "3\n3 3\n1 1\n2 2", "output": "6"}, {"input": "2\n0 0\n0 0\n", "output": "2"}, {"input": "4\n0 0\n1 1\n2 2\n3 3\n", "output": "8"}, {"input": "3\n1 1\n1 2\n1 3\n", "output": "4"}, {"input": "4\n1 1\n1 2\n1 3\n1 4\n", "output": "5"}, {"input": "5\n1 1\n1 2\n1 3\n1 4\n1 5\n", "output": "6"}, {"input": "3\n1 1\n2 3\n3 2\n", "output": "7"}, {"input": "3\n2 1\n2 2\n2 3\n", "output": "4"}, {"input": "4\n2 1\n2 2\n2 3\n2 4\n", "output": "5"}, {"input": "5\n2 1\n2 2\n2 3\n2 4\n2 5\n", "output": "6"}], "test": "#undef NDEBUG\n#include<assert.h>\nint main(){\n    assert(solution(\"3\\n1 1\\n2 2\\n3 3\") == \"6\");\n    assert(solution(\"2\\n-2 -1\\n2 1\\n\") == \"4\");\n    assert(solution(\"6\\n1 1\\n1 2\\n1 3\\n1 4\\n1 5\\n1 6\\n\") == \"7\");\n    assert(solution(\"2\\n-1 0\\n0 1\\n\") == \"4\");\n    assert(solution(\"4\\n1 1\\n-1 -1\\n1 -1\\n-1 1\\n\") == \"9\");\n    assert(solution(\"3\\n1 1\\n1 1\\n1 1\\n\") == \"2\");\n    assert(solution(\"2\\n0 0\\n2 2\\n\") == \"4\");\n    assert(solution(\"3\\n-2 -1\\n2 1\\n-2 -1\\n\") == \"4\");\n    assert(solution(\"5\\n1 1\\n1 1\\n1 1\\n1 1\\n1 1\\n\") == \"2\");\n    assert(solution(\"5\\n0 0\\n0 1\\n0 2\\n0 3\\n0 4\") == \"6\");\n    assert(solution(\"3\\n3 3\\n1 1\\n2 2\") == \"6\");\n    assert(solution(\"2\\n0 0\\n0 0\\n\") == \"2\");\n    assert(solution(\"4\\n0 0\\n1 1\\n2 2\\n3 3\\n\") == \"8\");\n    assert(solution(\"3\\n1 1\\n1 2\\n1 3\\n\") == \"4\");\n    assert(solution(\"4\\n1 1\\n1 2\\n1 3\\n1 4\\n\") == \"5\");\n    assert(solution(\"5\\n1 1\\n1 2\\n1 3\\n1 4\\n1 5\\n\") == \"6\");\n    assert(solution(\"3\\n1 1\\n2 3\\n3 2\\n\") == \"7\");\n    assert(solution(\"3\\n2 1\\n2 2\\n2 3\\n\") == \"4\");\n    assert(solution(\"4\\n2 1\\n2 2\\n2 3\\n2 4\\n\") == \"5\");\n    assert(solution(\"5\\n2 1\\n2 2\\n2 3\\n2 4\\n2 5\\n\") == \"6\");\n    return 0; \n}", "prompt": "/*There are $N$ straight lines on the plane, where the $i$-th line is $y=A_{i}\\cdot x+B_{i}$.\n\nPlease calculate how many parts the plane is divided into by these lines.\n\ninput_format:\nThe first line contains an integer $N$.\n\nThe following $\\mathrm{N}$lines, each containing two integers $A_{i}, B_{i}$.\n\noutput_format:\nAn integer represents the answer.\n*/\n\n#include<sstream>\n#include<stdlib.h>\n#include<algorithm>\n#include<math.h>\n#include<stdio.h>\n#include<vector>\n#include<string>\n#include<climits>\n#include<cstring>\n#include<iostream>\nusing namespace std;\n\n             \nstring solution(string std_in){\n    istringstream iss(std_in);\n             ", "constraints": "对于 $50 \\%$ 的评测用例, $1 \\leq N \\leq 4,-10 \\leq A_{i}, B_{i} \\leq 10$。\n\n对于所有评测用例, $1 \\leq N \\leq 1000,-10^5 \\leq A_{i}, B_{i} \\leq 10^5$。\n\n蓝桥杯 2020 第二轮省赛 B 组 I 题", "samples": [["3\n1 1\n2 2\n3 3", "6"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072]}}
{"task_id": "P2415", "title": "集合求和", "difficulty": "challenge", "nl": "Given a set $s$ (number of elements in the set $\\le 30$), compute the sum of all the elements in all the subsets of this set.", "code": "#include<iostream>\n#include<cmath>\nusing namespace std;\nint a[31],i=0,j;\nlong long s=0;\nint main(){\n    //cout<<s;\n    while(cin>>a[i++]);//合写cin>>a[i];i++;\n    for(j=0;j<i;j++){\n        s+=a[j];\n    }\n    s*=pow(2,i-2);//注意，i-2!\n    cout<<s;\n    return 0;\n}", "step": ["initialize an array (a) and variables (i, j, s)", "accept input values for a until there are no more", "calculate the sum of all the values in a", "raise 2 to the power of (i-2)", "multiply the sum by the calculated value", "output the result"], "nl_cn": "给定一个集合 $s$（集合元素数量 $\\le 30$），求出此集合所有子集元素之和。\n", "test_cases": [{"input": "2 3\n", "output": "10"}, {"input": "1\n", "output": "1"}, {"input": "0 0 0 0 0\n", "output": "0"}, {"input": "1000000\n", "output": "1000000"}, {"input": "0\n", "output": "0"}, {"input": "0 0 0\n", "output": "0"}], "test": "#undef NDEBUG\n#include<assert.h>\nint main(){\n    assert(solution(\"2 3\\n\") == \"10\");\n    assert(solution(\"1\\n\") == \"1\");\n    assert(solution(\"0 0 0 0 0\\n\") == \"0\");\n    assert(solution(\"1000000\\n\") == \"1000000\");\n    assert(solution(\"0\\n\") == \"0\");\n    assert(solution(\"0 0 0\\n\") == \"0\");\n    return 0; \n}", "prompt": "/*Given a set $s$ (number of elements in the set $\\le 30$), compute the sum of all the elements in all the subsets of this set.\n\ninput_format:\nElements in the set (elements $\\le 1000$)\n\noutput_format:\n$s$Sum of all subset elements.\n*/\n\n#include<sstream>\n#include<stdlib.h>\n#include<algorithm>\n#include<math.h>\n#include<stdio.h>\n#include<vector>\n#include<string>\n#include<climits>\n#include<cstring>\n#include<iostream>\nusing namespace std;\n\n             \nstring solution(string std_in){\n    istringstream iss(std_in);\n             ", "constraints": "**【样例解释】**\n\n子集为：$\\varnothing, \\{ 2 \\}, \\{ 3 \\}, \\{ 2, 3 \\}$，和为 $2 + 3 + 2 + 3 = 10$。\n\n----\n\n**【数据范围】**\n\n对于 $100 \\%$ 的数据，$1 \\le \\lvert s \\rvert \\le 30$，$1 \\le s_i \\le 1000$，$s$ 所有子集元素之和 $\\le {10}^{18}$。", "samples": [["2 3\n", "10\n"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000], "memory": [131072, 131072, 131072, 131072, 131072]}}
{"task_id": "P5497", "title": "[LnOI2019SP]龟速单项式变换(SMT)", "difficulty": "challenge", "nl": "Given a sequence of positive integers $a$, it is called a \"multiple-of-$m$ sequence\" if there exist consecutive positive integers in $a$ whose sum is a multiple of $m$.\n\nGiven $n$ and $m$, determine whether any sequence $a$ of length $n$ consisting of positive integers is a multiple-of-$m$ sequence.", "code": "#include<cstdio>\nusing namespace std;\nint main()\n{\n\tlong long n,m;\n\tscanf(\"%lld%lld\",&n,&m);\n\tif(n>=m)\n\t\tprintf(\"YES\\n\");\n\telse\n\t\tprintf(\"NO\\n\");\n\treturn 0;\n}", "step": ["Declare two long long integers n and m", "Take input of two long long integers n and m", "Check if n is greater than or equal to m", "If true, print 'YES'", "If false, print 'NO'", "Return 0"], "nl_cn": "有如下定义：若正整数序列 $a$ 中存在连续若干个正整数的和为 $m$ 的倍数，则这个正整数序列 $a$ 被称为“司 $m$ 序列”。\n\n给定 $n$ 和 $m$，你需要知道长度为 $n$ 的任意正整数序列 $a$ 是否都是“司 $m$ 序列”。", "test_cases": [{"input": "2 4\n", "output": "NO"}, {"input": "5 3\n", "output": "YES"}, {"input": "10 5\n", "output": "YES"}, {"input": "12 5\n", "output": "YES"}, {"input": "8 6\n", "output": "YES"}, {"input": "15 6\n", "output": "YES"}, {"input": "14 3\n", "output": "YES"}, {"input": "9 9\n", "output": "YES"}, {"input": "7 7\n", "output": "YES"}, {"input": "11 11\n", "output": "YES"}, {"input": "20 5\n", "output": "YES"}, {"input": "13 4\n", "output": "YES"}, {"input": "16 2\n", "output": "YES"}, {"input": "18 3\n", "output": "YES"}, {"input": "22 7\n", "output": "YES"}, {"input": "25 5\n", "output": "YES"}, {"input": "27 3\n", "output": "YES"}, {"input": "10 10\n", "output": "YES"}, {"input": "3 5\n", "output": "NO"}, {"input": "7 2\n", "output": "YES"}, {"input": "8 4\n", "output": "YES"}, {"input": "4 1\n", "output": "YES"}, {"input": "6 6\n", "output": "YES"}, {"input": "9 3\n", "output": "YES"}, {"input": "11 7\n", "output": "YES"}, {"input": "15 2\n", "output": "YES"}, {"input": "13 9\n", "output": "YES"}, {"input": "16 8\n", "output": "YES"}, {"input": "20 10\n", "output": "YES"}, {"input": "18 6\n", "output": "YES"}, {"input": "21 11\n", "output": "YES"}, {"input": "14 4\n", "output": "YES"}, {"input": "17 13\n", "output": "YES"}, {"input": "19 17\n", "output": "YES"}, {"input": "1 3\n", "output": "NO"}, {"input": "5 5\n", "output": "YES"}, {"input": "3 6\n", "output": "NO"}, {"input": "10 2\n", "output": "YES"}, {"input": "2 2\n", "output": "YES"}, {"input": "6 3\n", "output": "YES"}, {"input": "4 4\n", "output": "YES"}, {"input": "15 9\n", "output": "YES"}, {"input": "9 5\n", "output": "YES"}, {"input": "12 6\n", "output": "YES"}, {"input": "13 8\n", "output": "YES"}, {"input": "17 1\n", "output": "YES"}, {"input": "19 7\n", "output": "YES"}, {"input": "14 13\n", "output": "YES"}, {"input": "23 15\n", "output": "YES"}], "test": "#undef NDEBUG\n#include<assert.h>\nint main(){\n    assert(solution(\"2 4\\n\") == \"NO\");\n    assert(solution(\"5 3\\n\") == \"YES\");\n    assert(solution(\"10 5\\n\") == \"YES\");\n    assert(solution(\"12 5\\n\") == \"YES\");\n    assert(solution(\"8 6\\n\") == \"YES\");\n    assert(solution(\"15 6\\n\") == \"YES\");\n    assert(solution(\"14 3\\n\") == \"YES\");\n    assert(solution(\"9 9\\n\") == \"YES\");\n    assert(solution(\"7 7\\n\") == \"YES\");\n    assert(solution(\"11 11\\n\") == \"YES\");\n    assert(solution(\"20 5\\n\") == \"YES\");\n    assert(solution(\"13 4\\n\") == \"YES\");\n    assert(solution(\"16 2\\n\") == \"YES\");\n    assert(solution(\"18 3\\n\") == \"YES\");\n    assert(solution(\"22 7\\n\") == \"YES\");\n    assert(solution(\"25 5\\n\") == \"YES\");\n    assert(solution(\"27 3\\n\") == \"YES\");\n    assert(solution(\"10 10\\n\") == \"YES\");\n    assert(solution(\"3 5\\n\") == \"NO\");\n    assert(solution(\"7 2\\n\") == \"YES\");\n    assert(solution(\"8 4\\n\") == \"YES\");\n    assert(solution(\"4 1\\n\") == \"YES\");\n    assert(solution(\"6 6\\n\") == \"YES\");\n    assert(solution(\"9 3\\n\") == \"YES\");\n    assert(solution(\"11 7\\n\") == \"YES\");\n    assert(solution(\"15 2\\n\") == \"YES\");\n    assert(solution(\"13 9\\n\") == \"YES\");\n    assert(solution(\"16 8\\n\") == \"YES\");\n    assert(solution(\"20 10\\n\") == \"YES\");\n    assert(solution(\"18 6\\n\") == \"YES\");\n    assert(solution(\"21 11\\n\") == \"YES\");\n    assert(solution(\"14 4\\n\") == \"YES\");\n    assert(solution(\"17 13\\n\") == \"YES\");\n    assert(solution(\"19 17\\n\") == \"YES\");\n    assert(solution(\"1 3\\n\") == \"NO\");\n    assert(solution(\"5 5\\n\") == \"YES\");\n    assert(solution(\"3 6\\n\") == \"NO\");\n    assert(solution(\"10 2\\n\") == \"YES\");\n    assert(solution(\"2 2\\n\") == \"YES\");\n    assert(solution(\"6 3\\n\") == \"YES\");\n    assert(solution(\"4 4\\n\") == \"YES\");\n    assert(solution(\"15 9\\n\") == \"YES\");\n    assert(solution(\"9 5\\n\") == \"YES\");\n    assert(solution(\"12 6\\n\") == \"YES\");\n    assert(solution(\"13 8\\n\") == \"YES\");\n    assert(solution(\"17 1\\n\") == \"YES\");\n    assert(solution(\"19 7\\n\") == \"YES\");\n    assert(solution(\"14 13\\n\") == \"YES\");\n    assert(solution(\"23 15\\n\") == \"YES\");\n    return 0; \n}", "prompt": "/*Given a sequence of positive integers $a$, it is called a \"multiple-of-$m$ sequence\" if there exist consecutive positive integers in $a$ whose sum is a multiple of $m$.\n\nGiven $n$ and $m$, determine whether any sequence $a$ of length $n$ consisting of positive integers is a multiple-of-$m$ sequence.\n\ninput_format:\nTwo numbers, $n$and $m$.\n\noutput_format:\nIf YES output 'yes' otherwise output' NO '.\n*/\n\n#include<sstream>\n#include<stdlib.h>\n#include<algorithm>\n#include<math.h>\n#include<stdio.h>\n#include<vector>\n#include<string>\n#include<climits>\n#include<cstring>\n#include<iostream>\nusing namespace std;\n\n             \nstring solution(string std_in){\n    istringstream iss(std_in);\n             ", "constraints": "样例解释：存在反例 $[1, 2]$。\n\nSubtask 1 (50 pts)：$1 \\le n, m \\le 5$。\n\nSubtask 2 (50 pts)：$1 \\le n, m \\le {10}^{18}$。", "samples": [["2 4\n", "NO\n"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072]}}
{"task_id": "P7488", "title": "「Stoi2031」黑色毛衣", "difficulty": "advanced", "nl": "Reminds me of the time with Rain. Because Rain is a playful girl, they have a lot of toys, including a toy that looks like a \"white dragonfly\", which now stays with Let, with a total of $n$ of them. The wingspan of each \"white dragonfly\" ranges from $1$ to $n$, and can be opened to any angle between $(0,\\pi)$. Let believes that the scene where $m$ \"white dragonflies\" open their wings to make the distance between the ends of the wings integers and different from each other is \"weaving\" a \"memory\". He believes that two \"memories\" are the same if and only if the $m$ \"white dragonflies\" can be rearranged in a certain way to make the corresponding wingspan length and wing distance equal. He wants you to tell him how many different \"memories\" can be weaved. You only need to find the value of $ans\\bmod{p}$ of the answer.", "code": "#include<map>\n#include<list>\n#include<cmath>\n#include<cstdio>\n#include<cstring>\n#include<iostream>\n#include<algorithm>\n#define LL long long\nusing namespace std;\nLL n,m,p,ans;\ninline LL exgcd(LL a,LL b,LL &x,LL &y)\n{\n\tif(!b)\n\t{\n\t\tx=1;y=0;\n\t\treturn a;\n\t}\n\tLL r=exgcd(b,a%b,y,x);\n\ty-=(a/b)*x;\n\treturn r;\n}\ninline LL mul(LL a,LL b,LL n)\n{\n\treturn a*b%n;\n}\ninline LL qpw(LL n,LL k,LL m)\n{\n\tLL res=1;\n\twhile(k)\n\t{\n\t\tif(k&1)res=mul(res,n,m);\n\t\tn=mul(n,n,m);\n\t\tk>>=1;\n\t}\n\treturn res;\n}\ninline LL fac(LL n,LL pi,LL pk)\n{\n\tif(!n)return 1;\n\tLL res=1;\n\tfor(LL i=2;i<=pk;++i)\n\t{\n\t\tif(i%pi)res=mul(res,i,pk);\n\t}\n\tres=qpw(res,n/pk,pk);\n\tfor(LL i=2;i<=n%pk;++i)\n\t{\n\t\tif(i%pi)res=mul(res,i,pk);\n\t}\n\treturn mul(res,fac(n/pi,pi,pk),pk);\n}\ninline LL inv(LL n,LL m)\n{\n\tLL x,y;\n\texgcd(n,m,x,y);\n\treturn (x+m)%m;\n}\ninline LL crt(LL b,LL m)\n{\n\treturn mul(mul(b,inv(p/m,m),p),p/m,p);\n}\ninline LL C(LL n,LL m,LL pi,LL pk)\n{\n    LL so=fac(n,pi,pk),fa=fac(m,pi,pk),mo=fac(n-m,pi,pk);\n    LL k=0;\n    for(LL i=n;i;i/=pi)k+=i/pi;\n    for(LL i=m;i;i/=pi)k-=i/pi;\n    for(LL i=n-m;i;i/=pi)k-=i/pi;\n    return mul(mul(mul(so,inv(fa,pk),pk),inv(mo,pk),pk),qpw(pi,k,pk),pk);\n}\ninline LL exlucas(LL n,LL m)\n{\n\tLL res=0,k=p,pk;\n\tLL maxx=sqrt(p)+6;\n\tfor(LL i=2;i<maxx;++i)\n\t{\n\t\tif(k%i)continue;\n\t\tpk=1;while(k%i==0)pk*=i,k/=i;\n\t\tres=(res+crt(C(n,m,i,pk),pk))%p;\n\t}\n\tif(k>1)res=(res+crt(C(n,m,k,k),k))%p;\n\treturn res;\n}\nint main()\n{\n    scanf(\" %lld %lld %lld\",&n,&m,&p);\n    if(m>=p)return 0&puts(\"0\");\n    ans=exlucas(n,m);\n    ans=ans*ans%p;\n    for(int i=1;i<=m;++i)ans=ans*i%p;\n    printf(\"%lld\\n\",ans);\n    return 0;\n}", "step": ["1. Read input long long integers n, m, and p from stdin. ", " 2. Pass the input numbers to exlucas() defined below. ", " 3. Calculate (n choose m) using C(). ", " 4. Calculate the Chinese Remainder Theorem (CRT) of (n choose m) % p and keep track of the sum. ", " 5. Calculate (the sum obtained in step 4) * (the sum obtained in step 4) % p. ", " 6. Calculate m! % p and multiply it with the value obtained in step 5. Print the result."], "nl_cn": "让想起了和雨在一起的时候。由于雨是一个爱玩的女孩子，所以他们有很多玩具，其中就有一种像 **白色蜻蜓** 一样的玩具，现在留在了让的身边，共有 $n$ 只。每只 **白色蜻蜓** 的翅膀长度分别是 $1,2,\\dots,n$，并且可以张开成 $(0,\\pi)$ 之间的任意角度。让认为使其中 $m$ 只 **白色蜻蜓** 分别张开翅膀使双翅末端的距离都为整数且互不相同的场景是在 **编织** 一份 **记忆**。他认为两份 **记忆** 相同当且仅当可以将 $m$ 只 **白色蜻蜓** 按某种方式重排后一一对应使对应的蜻蜓翅膀长度和双翅距离都相等。他想请你告诉他能编织出多少份不同的记忆。你只需要求出答案 $ans\\bmod{p}$ 的值。", "test_cases": [{"input": "32 2 47\n", "output": "36"}, {"input": "233 223 1926817\n", "output": "620162"}, {"input": "3 1 7", "output": "2"}, {"input": "50 0 11\n", "output": "1"}, {"input": "1000 0 2\n", "output": "1"}, {"input": "1 1 100\n", "output": "1"}, {"input": "5 3 10\n", "output": "0"}, {"input": "12 6 15\n", "output": "0"}, {"input": "50 25 100\n", "output": "0"}, {"input": "16 8 40\n", "output": "0"}, {"input": "40 25 60\n", "output": "0"}, {"input": "20 10 23\n", "output": "5"}], "test": "#undef NDEBUG\n#include<assert.h>\nint main(){\n    assert(solution(\"32 2 47\\n\") == \"36\");\n    assert(solution(\"233 223 1926817\\n\") == \"620162\");\n    assert(solution(\"3 1 7\") == \"2\");\n    assert(solution(\"50 0 11\\n\") == \"1\");\n    assert(solution(\"1000 0 2\\n\") == \"1\");\n    assert(solution(\"1 1 100\\n\") == \"1\");\n    assert(solution(\"5 3 10\\n\") == \"0\");\n    assert(solution(\"12 6 15\\n\") == \"0\");\n    assert(solution(\"50 25 100\\n\") == \"0\");\n    assert(solution(\"16 8 40\\n\") == \"0\");\n    assert(solution(\"40 25 60\\n\") == \"0\");\n    assert(solution(\"20 10 23\\n\") == \"5\");\n    return 0; \n}", "prompt": "/*Reminds me of the time with Rain. Because Rain is a playful girl, they have a lot of toys, including a toy that looks like a \"white dragonfly\", which now stays with Let, with a total of $n$ of them. The wingspan of each \"white dragonfly\" ranges from $1$ to $n$, and can be opened to any angle between $(0,\\pi)$. Let believes that the scene where $m$ \"white dragonflies\" open their wings to make the distance between the ends of the wings integers and different from each other is \"weaving\" a \"memory\". He believes that two \"memories\" are the same if and only if the $m$ \"white dragonflies\" can be rearranged in a certain way to make the corresponding wingspan length and wing distance equal. He wants you to tell him how many different \"memories\" can be weaved. You only need to find the value of $ans\\bmod{p}$ of the answer.\n\ninput_format:\nA row of three positive integers $n,m,p$.\n\noutput_format:\nOne line, one number, represents the answer.\n*/\n\n#include<sstream>\n#include<stdlib.h>\n#include<algorithm>\n#include<math.h>\n#include<stdio.h>\n#include<vector>\n#include<string>\n#include<climits>\n#include<cstring>\n#include<iostream>\nusing namespace std;\n\n             \nstring solution(string std_in){\n    istringstream iss(std_in);\n             ", "constraints": "#### 简述版题意\n\n求不同的腰长 $1 \\le a \\le n$，底长 $1 \\le b \\le 2a-1$ 且都为整数，腰长互不相同，底长也互不相同的 $m$ 个等腰三角形构成的不同组数。两组相同当且仅当可以使 $m$ 个三角形按某种方式重排后一一对应全等。\n\n#### 样例解释：\n\n限于篇幅，只对样例 $3$ 作解释。\n\n可以 **编织** 出 $1,1,1$，$2,2,1$，$2,2,2$，$2,2,3$，$3,3,1$，$3,3,2$，$3,3,3$，$3,3,4$，$3,3,5$ 共 $9$ 种 **记忆**，取模 $7$ 后为 $2$。\n\n**本题采用捆绑测试，每个 Subtask 的分数与限制如下。**\n\n| Subtask No. | $m \\le n \\le$ | 特殊限制 | 分值 |\n| :-----------: | :-----------: | :-----------: | :-----------: |\n| $1$ | $10^3$ | 无 | $13$ |\n| $2$ | $10^6$ | 无 | $37$ |\n| $3$ | $10^{18}$ | 无 | $37$ |\n| $4$ | $10^{18}$ | $p$是质数 | $13$ |\n\n对于所有数据， $1 \\le m \\le n \\le 10^{18},1 \\le p \\le 10^5$，不保证 $p$ 是质数。", "samples": [["32 2 47\n", "36\n"], ["233 223 1926817\n", "620162\n"], ["3 1 7", "2"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072]}}
{"task_id": "P7774", "title": "[COCI2009-2010#2] KUTEVI", "difficulty": "challenge", "nl": "Given $N$ angles (denoted by $a_i$), as the initial angle, and $M$ angles (denoted by $b_i$), as the target angle.\n\nRequest for each $b_i$, whether it can be obtained by adding or subtracting between several $a_i$.\n\nNote that the same $a_i$ can be used multiple times or not at all.", "code": "#include<bits/stdc++.h>\nusing namespace std;\nint n,m,a[15],b[15],f[1005];\nint main()\n{\n    cin>>n>>m;\n    for(int i=1;i<=n;i++)cin>>a[i];\n    for(int i=1;i<=m;i++)cin>>b[i];\n    f[0]=1;\n    for(int i=1;i<=n;i++)\n        for(int j=0;j<=1000;j++)\n        {\n            if(j>=a[i])\n            f[j%360]|=f[(j-a[i])%360];\n            f[j%360]|=f[(j+a[i])%360];\n        }\n    for(int i=1;i<=m;i++)\n    {\n        if(f[b[i]]==1)cout<<\"YES\"<<endl;\n        else cout<<\"NO\"<<endl;\n    }\n    return 0;\n}", "step": ["Take input values for n and m.", "Take input for the array 'a'.", "Take input for the array 'b'.", "Create an array 'f' of size 1005.", "The first index of 'f' is assigned a value of 1.", "Loop through the values of 'a' and the range of 0 to 1000.", "If j is greater than or equal to the current value of 'a', check whether the index j%360 is true or equal to the 'f' index (j-a[i])%360 or (j+a[i])%360.", "If either condition is met, set the index j%360 to true.", "Loop through the values of 'b'.", "If the index b[i] in the 'f' array is true, output 'YES', otherwise output 'NO'."], "nl_cn": "给定 $N$ 个角（第 $i$ 个角记作 $a_i$），作为初始角，另给定 $M$ 个角（第 $i$ 个角记作 $b_i$），作为目标角。\n\n请求出对于每个 $b_i$，它是否能被若干个 $a_i$ 之间的加、减运算得到。\n\n注意同一个 $a_i$ 可以用多次，也可以不用。", "test_cases": [{"input": "2 1\n30 70\n40", "output": "YES"}, {"input": "1 1\n100\n60", "output": "YES"}, {"input": "3 2\n10 20 30\n5 70", "output": "NO\nYES"}, {"input": "0 1\n\n45\n", "output": "NO"}, {"input": "4 3\n45 90 180 270\n180 90 270\n", "output": "YES\nYES\nYES"}, {"input": "2 3\n45 90\n30 90 180\n", "output": "NO\nYES\nYES"}, {"input": "1 1\n0\n0\n", "output": "YES"}, {"input": "2 2\n90 270\n0 180\n", "output": "YES\nYES"}, {"input": "3 2\n20 40 60\n40 80\n", "output": "YES\nYES"}, {"input": "2 3\n15 30\n45 90 180\n", "output": "YES\nYES\nYES"}, {"input": "2 1\n180 90\n270\n", "output": "YES"}, {"input": "5 4\n30 60 90 120 150\n180 270 0 90\n", "output": "YES\nYES\nYES\nYES"}, {"input": "0 0\n\n\n", "output": ""}, {"input": "2 2\n45 315\n0 180\n", "output": "YES\nYES"}, {"input": "5 2\n15 30 45 60 75\n15 75\n", "output": "YES\nYES"}, {"input": "2 2\n270 90\n90 270\n", "output": "YES\nYES"}, {"input": "4 1\n180 270 360 45\n45\n", "output": "YES"}, {"input": "3 2\n90 180 270\n0 270\n", "output": "YES\nYES"}, {"input": "1 1\n0\n270\n", "output": "NO"}, {"input": "2 1\n120 240\n270\n", "output": "NO"}, {"input": "1 1\n180\n90\n", "output": "NO"}, {"input": "5 2\n60 120 180 240 300\n100 180\n", "output": "NO\nYES"}, {"input": "2 3\n45 135\n45 135 270\n", "output": "YES\nYES\nYES"}, {"input": "2 2\n90 270\n180 0\n", "output": "YES\nYES"}, {"input": "3 1\n10 20 30\n60\n", "output": "YES"}, {"input": "3 3\n90 180 270\n90 180 270\n", "output": "YES\nYES\nYES"}, {"input": "5 2\n60 120 180 240 300\n100 200\n", "output": "NO\nNO"}, {"input": "2 2\n45 90\n60 90\n", "output": "NO\nYES"}, {"input": "1 1\n10\n0\n", "output": "YES"}, {"input": "4 2\n10 30 80 100\n10 100\n", "output": "YES\nYES"}, {"input": "3 2\n30 60 90\n100 180\n", "output": "NO\nYES"}, {"input": "5 3\n0 45 90 135 180\n0 180 270\n", "output": "YES\nYES\nYES"}, {"input": "2 2\n45 135\n90 270\n", "output": "YES\nYES"}, {"input": "2 1\n45 135\n180\n", "output": "YES"}, {"input": "3 2\n10 20 30\n40 50\n", "output": "YES\nYES"}, {"input": "2 2\n60 120\n240 300\n", "output": "YES\nYES"}, {"input": "3 2\n45 135 225\n90 180\n", "output": "YES\nYES"}, {"input": "4 4\n15 45 75 105\n180 270 360 450\n", "output": "YES\nYES\nNO\nNO"}], "test": "#undef NDEBUG\n#include<assert.h>\nint main(){\n    assert(solution(\"2 1\\n30 70\\n40\") == \"YES\");\n    assert(solution(\"1 1\\n100\\n60\") == \"YES\");\n    assert(solution(\"3 2\\n10 20 30\\n5 70\") == \"NO\\nYES\");\n    assert(solution(\"0 1\\n\\n45\\n\") == \"NO\");\n    assert(solution(\"4 3\\n45 90 180 270\\n180 90 270\\n\") == \"YES\\nYES\\nYES\");\n    assert(solution(\"2 3\\n45 90\\n30 90 180\\n\") == \"NO\\nYES\\nYES\");\n    assert(solution(\"1 1\\n0\\n0\\n\") == \"YES\");\n    assert(solution(\"2 2\\n90 270\\n0 180\\n\") == \"YES\\nYES\");\n    assert(solution(\"3 2\\n20 40 60\\n40 80\\n\") == \"YES\\nYES\");\n    assert(solution(\"2 3\\n15 30\\n45 90 180\\n\") == \"YES\\nYES\\nYES\");\n    assert(solution(\"2 1\\n180 90\\n270\\n\") == \"YES\");\n    assert(solution(\"5 4\\n30 60 90 120 150\\n180 270 0 90\\n\") == \"YES\\nYES\\nYES\\nYES\");\n    assert(solution(\"0 0\\n\\n\\n\") == \"\");\n    assert(solution(\"2 2\\n45 315\\n0 180\\n\") == \"YES\\nYES\");\n    assert(solution(\"5 2\\n15 30 45 60 75\\n15 75\\n\") == \"YES\\nYES\");\n    assert(solution(\"2 2\\n270 90\\n90 270\\n\") == \"YES\\nYES\");\n    assert(solution(\"4 1\\n180 270 360 45\\n45\\n\") == \"YES\");\n    assert(solution(\"3 2\\n90 180 270\\n0 270\\n\") == \"YES\\nYES\");\n    assert(solution(\"1 1\\n0\\n270\\n\") == \"NO\");\n    assert(solution(\"2 1\\n120 240\\n270\\n\") == \"NO\");\n    assert(solution(\"1 1\\n180\\n90\\n\") == \"NO\");\n    assert(solution(\"5 2\\n60 120 180 240 300\\n100 180\\n\") == \"NO\\nYES\");\n    assert(solution(\"2 3\\n45 135\\n45 135 270\\n\") == \"YES\\nYES\\nYES\");\n    assert(solution(\"2 2\\n90 270\\n180 0\\n\") == \"YES\\nYES\");\n    assert(solution(\"3 1\\n10 20 30\\n60\\n\") == \"YES\");\n    assert(solution(\"3 3\\n90 180 270\\n90 180 270\\n\") == \"YES\\nYES\\nYES\");\n    assert(solution(\"5 2\\n60 120 180 240 300\\n100 200\\n\") == \"NO\\nNO\");\n    assert(solution(\"2 2\\n45 90\\n60 90\\n\") == \"NO\\nYES\");\n    assert(solution(\"1 1\\n10\\n0\\n\") == \"YES\");\n    assert(solution(\"4 2\\n10 30 80 100\\n10 100\\n\") == \"YES\\nYES\");\n    assert(solution(\"3 2\\n30 60 90\\n100 180\\n\") == \"NO\\nYES\");\n    assert(solution(\"5 3\\n0 45 90 135 180\\n0 180 270\\n\") == \"YES\\nYES\\nYES\");\n    assert(solution(\"2 2\\n45 135\\n90 270\\n\") == \"YES\\nYES\");\n    assert(solution(\"2 1\\n45 135\\n180\\n\") == \"YES\");\n    assert(solution(\"3 2\\n10 20 30\\n40 50\\n\") == \"YES\\nYES\");\n    assert(solution(\"2 2\\n60 120\\n240 300\\n\") == \"YES\\nYES\");\n    assert(solution(\"3 2\\n45 135 225\\n90 180\\n\") == \"YES\\nYES\");\n    assert(solution(\"4 4\\n15 45 75 105\\n180 270 360 450\\n\") == \"YES\\nYES\\nNO\\nNO\");\n    return 0; \n}", "prompt": "/*Given $N$ angles (denoted by $a_i$), as the initial angle, and $M$ angles (denoted by $b_i$), as the target angle.\n\nRequest for each $b_i$, whether it can be obtained by adding or subtracting between several $a_i$.\n\nNote that the same $a_i$ can be used multiple times or not at all.\n\ninput_format:\nThe first row has two positive integers $N,M$.\n\nThe second row has $N$positive integers, and the number of $i$is $a_i$.\n\nThe third line is $M$, and the number of $i$is $b_i$.\n\noutput_format:\nIn line $M$, on line $i$, if $b_i$can be obtained by adding and subtracting several $a_i$, output 'YES', otherwise output 'NO'.\n*/\n\n#include<sstream>\n#include<stdlib.h>\n#include<algorithm>\n#include<math.h>\n#include<stdio.h>\n#include<vector>\n#include<string>\n#include<climits>\n#include<cstring>\n#include<iostream>\nusing namespace std;\n\n             \nstring solution(string std_in){\n    istringstream iss(std_in);\n             ", "constraints": "### 样例解释\n\n样例 $1$ 解释：\n\n$70^\\circ-30^\\circ=40^\\circ$。\n\n样例 $2$ 解释：\n\n$15\\times100^\\circ=1500^\\circ=60^\\circ$。\n\n### 数据范围与约定\n\n$1\\leq N,M\\leq10$，$0<a_i,b_i< 360$。", "samples": [["2 1\n30 70\n40", "YES"], ["1 1\n100\n60", "YES"], ["3 2\n10 20 30\n5 70", "NO\nYES"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [32768, 32768, 32768, 32768, 32768, 32768, 32768, 32768, 32768, 32768, 32768, 32768]}}
{"task_id": "P8012", "title": "[COCI2013-2014#4] NASLJEDSTVO", "difficulty": "basic", "nl": "There are several coins and a person tries to divide them into $N$ equally-sized parts as much as possible, and takes one part, leaving $O$ coins behind.\n\nHere, \"trying to divide them into $N$ equally-sized parts as much as possible\" means dividing the coins into $N$ parts, where each part contains an integer number of coins, and the difference in the number of coins between any two parts does not exceed $1$.\n\nIt is agreed that the part taken by the person is the one with the least number of coins.\n\nPlease find the minimum and maximum numbers of coins originally in the pile.", "code": "#include <iostream>\n#include <cstdio>\n//这些不用说吧\nint n,o;//见题意\nint Max,Min;//Max为最大金币数，Min为最小金币数\nint main() {\n    scanf(\"%d%d\",&n,&o);\n    Max=o/(n-1.0)*n;//根据如上公式算出最大金币数\n    if(Max%n==0) Min=Max-1; \n    //如果n能被Max整除，则Min是Max-1\n    else Min=Max;//否则为Max\n    printf(\"%d %d\",Min,Max);//华丽输出\n    return 0;//完美结束\n}", "step": ["Read the input values n and o", "Calculate the Maximum value using o and n", "Check if the Maximum value is divisible by n, if it is, then assign Max-1 to Min. If not, assign Max to Min.", "Print the values of Min and Max.", "Exit"], "nl_cn": "有若干个金币，一个人将这堆金币尽量 $N$ 等分并拿走了一份，剩下 $O$ 个金币。\n\n所谓『尽量 $N$ 等分』，是指将这堆金币分成 $N$ 堆，每堆所含的金币数是整数，且每两对金币的数量相差不超过 $1$。\n\n我们约定这个人拿走的那一份金币是比较少的一份。\n\n请你分别求出这堆金币原来最少有多少个和最多有多少个。", "test_cases": [{"input": "2\n5", "output": "9 10"}, {"input": "3\n5", "output": "7 7"}, {"input": "5\n10 ", "output": "12 12"}, {"input": "6\n12 ", "output": "14 14"}, {"input": "8\n18 ", "output": "20 20"}, {"input": "10\n23 ", "output": "25 25"}, {"input": "12\n29 ", "output": "31 31"}, {"input": "14\n35 ", "output": "37 37"}, {"input": "18\n47 ", "output": "49 49"}, {"input": "20\n53 ", "output": "55 55"}], "test": "#undef NDEBUG\n#include<assert.h>\nint main(){\n    assert(solution(\"2\\n5\") == \"9 10\");\n    assert(solution(\"3\\n5\") == \"7 7\");\n    assert(solution(\"5\\n10 \") == \"12 12\");\n    assert(solution(\"6\\n12 \") == \"14 14\");\n    assert(solution(\"8\\n18 \") == \"20 20\");\n    assert(solution(\"10\\n23 \") == \"25 25\");\n    assert(solution(\"12\\n29 \") == \"31 31\");\n    assert(solution(\"14\\n35 \") == \"37 37\");\n    assert(solution(\"18\\n47 \") == \"49 49\");\n    assert(solution(\"20\\n53 \") == \"55 55\");\n    return 0; \n}", "prompt": "/*There are several coins and a person tries to divide them into $N$ equally-sized parts as much as possible, and takes one part, leaving $O$ coins behind.\n\nHere, \"trying to divide them into $N$ equally-sized parts as much as possible\" means dividing the coins into $N$ parts, where each part contains an integer number of coins, and the difference in the number of coins between any two parts does not exceed $1$.\n\nIt is agreed that the part taken by the person is the one with the least number of coins.\n\nPlease find the minimum and maximum numbers of coins originally in the pile.\n\ninput_format:\nThe first line, a positive integer $N$, indicates that it is divided into equal parts of $N$;\n\nThe second line, a positive integer $O$, indicates that $O$gold is left after $1 of $N$is taken away.\n\noutput_format:\nOne line, two positive integers, represents the minimum and maximum number of gold coins in the pile.\n*/\n\n#include<sstream>\n#include<stdlib.h>\n#include<algorithm>\n#include<math.h>\n#include<stdio.h>\n#include<vector>\n#include<string>\n#include<climits>\n#include<cstring>\n#include<iostream>\nusing namespace std;\n\n             \nstring solution(string std_in){\n    istringstream iss(std_in);\n             ", "constraints": "**【样例解释 #1】**\n\n这堆金币可能原来有 $9$ 个，这个人可能将其分成 $4+5$ 个，自己拿走 $4$ 个；\n\n这堆金币可能原来有 $10$ 个，这个人可能将其分成 $5+5$ 个，自己拿走 $5$ 个。\n\n**【数据范围】**\n\n对于 $100\\%$ 的数据，$2\\le N\\le 15$，$N\\le O\\le 100$。\n\n**【来源】**\n\n本题分值按 COCI 原题设置，满分 $50$。\n\n题目译自 [COCI2013-2014 CONTEST #4](https://hsin.hr/coci/archive/2013_2014/contest4_tasks.pdf) _**T1 NASLJEDSTVO**_。", "samples": [["2\n5", "9 10"], ["3\n5", "7 7"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [32768, 32768, 32768, 32768, 32768, 32768, 32768, 32768, 32768, 32768, 32768, 32768]}}
{"task_id": "P8072", "title": "[COCI2009-2010#7] COKOLADA", "difficulty": "basic", "nl": "The customer urgently needs a chocolate bar with a size of $K$ units, but you can **only choose one** chocolate bar with a size of $2$ according to a non-negative integer power (i.e. $1,2,4,8,16,\\cdots$) for purchase.\n\nTo meet the customer's needs, you can cut a chocolate bar with a size of $D$ units into two smaller bars with a size of $\\dfrac{D}{2}$ units each.\n\nIn order to reduce costs, you need to determine the minimum size of the required chocolate bar and the minimum number of cuts needed.", "code": "#include <cstdio>\n\nint main() {\n  int n, k, d;\n  scanf(\"%d\", &n);\n  k = n & -n;\n  for( d = 0; k < n; k <<= 1 ) ++d;\n  printf(\"%d %d\\n\", k, d);\n  return 0;\n}", "step": ["Take input 'n'.", "Calculate ans1 by dividing n repeatedly by 2 and multiplying ans1 by 2.", "If ans1 is equal to 2 times the value of n, divide ans1 by 2 and print ans1 and 0 then exit the loop.", "Divide tmp (which has the value of n) by 2 until tmp is no longer divisible by 2.", "Calculate ans2 by dividing tmp repeatedly by 2 and increasing ans2 by 1.", "Print ans1 and ans2."], "nl_cn": "顾客急需大小为 $K$ 个单位的巧克力，但现在你**只能选择一块**大小为 $2$ 的非负整数幂（即 $1,2,4,8,16,\\cdots$）的巧克力进行购买。\n\n为了满足顾客需求，可以采取切割的方式，将一块大小为 $D$ 个单位的巧克力切成两块大小为 $\\dfrac{D}{2}$ 个单位的巧克力。\n\n为了降低成本，你需要求出所需的巧克力大小的最小值和最小切割次数。", "test_cases": [{"input": "6", "output": "8 2"}, {"input": "7", "output": "8 3"}, {"input": "5", "output": "8 3"}, {"input": "2\n", "output": "2 0"}, {"input": "4\n", "output": "4 0"}, {"input": "8\n", "output": "8 0"}, {"input": "16\n", "output": "16 0"}, {"input": "32\n", "output": "32 0"}, {"input": "64\n", "output": "64 0"}, {"input": "256\n", "output": "256 0"}, {"input": "512\n", "output": "512 0"}, {"input": "1024\n", "output": "1024 0"}, {"input": "2048\n", "output": "2048 0"}, {"input": "4096\n", "output": "4096 0"}, {"input": "8192\n", "output": "8192 0"}, {"input": "16384\n", "output": "16384 0"}, {"input": "32768\n", "output": "32768 0"}, {"input": "65536\n", "output": "65536 0"}, {"input": "131072\n", "output": "131072 0"}, {"input": "262144\n", "output": "262144 0"}], "test": "#undef NDEBUG\n#include<assert.h>\nint main(){\n    assert(solution(\"6\") == \"8 2\");\n    assert(solution(\"7\") == \"8 3\");\n    assert(solution(\"5\") == \"8 3\");\n    assert(solution(\"2\\n\") == \"2 0\");\n    assert(solution(\"4\\n\") == \"4 0\");\n    assert(solution(\"8\\n\") == \"8 0\");\n    assert(solution(\"16\\n\") == \"16 0\");\n    assert(solution(\"32\\n\") == \"32 0\");\n    assert(solution(\"64\\n\") == \"64 0\");\n    assert(solution(\"256\\n\") == \"256 0\");\n    assert(solution(\"512\\n\") == \"512 0\");\n    assert(solution(\"1024\\n\") == \"1024 0\");\n    assert(solution(\"2048\\n\") == \"2048 0\");\n    assert(solution(\"4096\\n\") == \"4096 0\");\n    assert(solution(\"8192\\n\") == \"8192 0\");\n    assert(solution(\"16384\\n\") == \"16384 0\");\n    assert(solution(\"32768\\n\") == \"32768 0\");\n    assert(solution(\"65536\\n\") == \"65536 0\");\n    assert(solution(\"131072\\n\") == \"131072 0\");\n    assert(solution(\"262144\\n\") == \"262144 0\");\n    return 0; \n}", "prompt": "/*The customer urgently needs a chocolate bar with a size of $K$ units, but you can **only choose one** chocolate bar with a size of $2$ according to a non-negative integer power (i.e. $1,2,4,8,16,\\cdots$) for purchase.\n\nTo meet the customer's needs, you can cut a chocolate bar with a size of $D$ units into two smaller bars with a size of $\\dfrac{D}{2}$ units each.\n\nIn order to reduce costs, you need to determine the minimum size of the required chocolate bar and the minimum number of cuts needed.\n\ninput_format:\nThe first line, a positive integer $K$, indicates the size of the chocolate required by the customer.\n\noutput_format:\nOutput two integers representing the minimum size of the chocolate and the minimum number of cuts tied.\n*/\n\n#include<sstream>\n#include<stdlib.h>\n#include<algorithm>\n#include<math.h>\n#include<stdio.h>\n#include<vector>\n#include<string>\n#include<climits>\n#include<cstring>\n#include<iostream>\nusing namespace std;\n\n             \nstring solution(string std_in){\n    istringstream iss(std_in);\n             ", "constraints": "**【数据规模与约定】**\n\n- 对于 $100\\%$ 的数据，$1 \\le K \\le 10^6$。\n\n**【提示与说明】**\n\n**题目译自 [COCI 2009-2010](https://hsin.hr/coci/archive/2009_2010/) [CONTEST #7](https://hsin.hr/coci/archive/2009_2010/contest7_tasks.pdf) _Task 2 COKOLADA_。**\n\n**本题分值按 COCI 原题设置，满分 $50$。**", "samples": [["6", "8 2"], ["7", "8 3"], ["5", "8 3"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [32768, 32768, 32768, 32768, 32768, 32768, 32768, 32768, 32768, 32768]}}
{"task_id": "P8082", "title": "[COCI2011-2012#4] KEKS", "difficulty": "challenge", "nl": "Given positive integers $N$ and $K$, and an $N$-digit number, find the maximum value of the remaining number after deleting $K$ digits from the $N$-digit number.", "code": "#include<bits/stdc++.h>\n#define MAXN 500005\nusing namespace std;\nchar s[MAXN];\nint st[MAXN],top;//栈 \nint main(){\n\tint n,k;\n\tscanf(\"%d%d%s\",&n,&k,s+1);\n\tfor(int i=1;i<=n;i++){\n\t\tint x=s[i]-'0';\n\t\twhile(k&&top&&st[top]<x)k--,st[top--]=0;//弹出操作 \n\t\tst[++top]=x;//加入操作 \n\t}\n\tfor(int i=1;i<=top-k;i++)//遍历栈 不遍历后面剩余的 k 个数\n\t\tprintf(\"%d\",st[i]);//输出答案 \n\treturn 0;\n}", "step": ["Declare variables n, k and an array s[]", "Take inputs n, k, and s[]", "Initialize an integer variable x and a stack array st[] with top = 0", "For each element in s[]", "If k is not 0 and stack top is smaller than the current element, keep popping elements from stack until k becomes 0 or stack top becomes greater than the current element. Then push the current element in the stack.", "Print the remaining numbers in the stack"], "nl_cn": "给定正整数 $N,K$ 和一个 $N$ 位数，求在 $N$ 位数中删除 $K$ 位后剩下的数的最大值。", "test_cases": [{"input": "4 2\n1924", "output": "94"}, {"input": "7 3\n1231234", "output": "3234"}, {"input": "10 4\n4177252841", "output": "775841"}, {"input": "3 1\n101", "output": "11"}, {"input": "2 1\n12", "output": "2"}, {"input": "5 2\n12345", "output": "345"}, {"input": "9 2\n567890123", "output": "7890123"}, {"input": "6 2\n543216", "output": "5436"}, {"input": "2 1\n46", "output": "6"}, {"input": "5 2\n15243", "output": "543"}, {"input": "5 3\n84193", "output": "93"}, {"input": "6 3\n153726", "output": "726"}, {"input": "2 1\n34", "output": "4"}, {"input": "1 0\n9", "output": "9"}, {"input": "5 1\n56789", "output": "6789"}, {"input": "8 3\n24681357", "output": "81357"}, {"input": "2 0\n69", "output": "69"}, {"input": "4 1\n9898", "output": "998"}], "test": "#undef NDEBUG\n#include<assert.h>\nint main(){\n    assert(solution(\"4 2\\n1924\") == \"94\");\n    assert(solution(\"7 3\\n1231234\") == \"3234\");\n    assert(solution(\"10 4\\n4177252841\") == \"775841\");\n    assert(solution(\"3 1\\n101\") == \"11\");\n    assert(solution(\"2 1\\n12\") == \"2\");\n    assert(solution(\"5 2\\n12345\") == \"345\");\n    assert(solution(\"9 2\\n567890123\") == \"7890123\");\n    assert(solution(\"6 2\\n543216\") == \"5436\");\n    assert(solution(\"2 1\\n46\") == \"6\");\n    assert(solution(\"5 2\\n15243\") == \"543\");\n    assert(solution(\"5 3\\n84193\") == \"93\");\n    assert(solution(\"6 3\\n153726\") == \"726\");\n    assert(solution(\"2 1\\n34\") == \"4\");\n    assert(solution(\"1 0\\n9\") == \"9\");\n    assert(solution(\"5 1\\n56789\") == \"6789\");\n    assert(solution(\"8 3\\n24681357\") == \"81357\");\n    assert(solution(\"2 0\\n69\") == \"69\");\n    assert(solution(\"4 1\\n9898\") == \"998\");\n    return 0; \n}", "prompt": "/*Given positive integers $N$ and $K$, and an $N$-digit number, find the maximum value of the remaining number after deleting $K$ digits from the $N$-digit number.\n\ninput_format:\nFirst line, two integers $N,K$.\n\nThe second line, a $N$digit integer. Guaranteed no lead $0$.\n\noutput_format:\nOutput the maximum value of the remaining number.\n*/\n\n#include<sstream>\n#include<stdlib.h>\n#include<algorithm>\n#include<math.h>\n#include<stdio.h>\n#include<vector>\n#include<string>\n#include<climits>\n#include<cstring>\n#include<iostream>\nusing namespace std;\n\n             \nstring solution(string std_in){\n    istringstream iss(std_in);\n             ", "constraints": "**【数据规模与约定】**\n\n- 对于 $50\\%$ 的数据，$N \\le 1000$。\n- 对于 $100\\%$ 的数据，$1 \\le K \\lt N \\le 5 \\times 10^5$。\n\n**【提示与说明】**\n\n**题目译自 [COCI 2011-2012](https://hsin.hr/coci/archive/2011_2012/) [CONTEST #4](https://hsin.hr/coci/archive/2011_2012/contest4_tasks.pdf) _Task 3 KEKS_。**\n\n**本题分值按 COCI 原题设置，满分 $100$。**", "samples": [["4 2\n1924", "94"], ["7 3\n1231234", "3234"], ["10 4\n4177252841", "775841"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [32768, 32768, 32768, 32768, 32768, 32768, 32768, 32768, 32768, 32768]}}
{"task_id": "P4194", "title": "矩阵", "difficulty": "advanced", "nl": "Given an integer matrix $A[n\\times m]$, find a matrix $B[n\\times m]$ such that $\\forall 1\\le i\\le n,1\\le j\\le m,B_{i,j}\\in[L,R]$, and the following equation is minimized:\n\n$$\\max\\begin{cases}\\displaystyle\\max_{1\\le j\\le m}\\left\\{\\left|\\sum_{i=1}^n\\left(A_{i,j}-B_{i,j}\\right)\\right|\\right\\}\\\\\\displaystyle\\max_{1\\le i\\le n}\\left\\{\\left|\\sum_{j=1}^m\\left(A_{i,j}-B_{i,j}\\right)\\right|\\right\\}\\end{cases}$$", "code": "#include<bits/stdc++.h>\n#define int long long\n#define ffor(i,a,b) for(int i=(a);i<=(b);i++)\n#define roff(i,a,b) for(int i=(a);i>=(b);i--)\nusing namespace std;\nconst int MAXN=200+10,MAXV=MAXN*2,MAXE=MAXV*MAXV*2;\nstruct Edge {\n\tint to,nxt,w;\t\n}edge[MAXE];\nint n,m,l,r,a[MAXN][MAXN],ot[MAXV],s,t,tot=1,tval[MAXV],hd[MAXV],cur[MAXV],dis[MAXV];\nvoid add_edge(int u,int v,int w) {\n\tedge[++tot]={v,hd[u],w},hd[u]=tot;\n\tedge[++tot]={u,hd[v],0},hd[v]=tot;\n\treturn ;\n}\nint bfs(void) {\n\tmemset(dis,-1,sizeof(dis));\n\tdis[s]=0; queue<int> q; q.push(s);\n\twhile(!q.empty()) {\n\t\tint u=q.front();\n\t\tq.pop(),cur[u]=hd[u];\n\t\tfor(int i=hd[u];i;i=edge[i].nxt) {\n\t\t\tint to=edge[i].to,w=edge[i].w;\n\t\t\tif(!w||dis[to]!=-1) continue ;\n\t\t\tdis[to]=dis[u]+1,q.push(to);\n\t\t}\n\t}\n\treturn dis[t]!=-1;\n}\nint dinic(int u,int mx) {\n\tif(u==t) return mx;\n\tint ans=0;\n\tfor(int i=cur[u];i;i=edge[i].nxt) {\n\t\tint to=edge[i].to,w=edge[i].w;\n\t\tcur[u]=i;\n\t\tif(!w||dis[to]!=dis[u]+1) continue ;\n\t\tint tmp=dinic(to,min(mx,w));\n\t\tif(tmp) {\n\t\t\tedge[i].w-=tmp,edge[i^1].w+=tmp,ans+=tmp,mx-=tmp;\n\t\t\tif(mx==0) break ;\t\n\t\t}\n\t}\n\treturn ans;\n}\nint check(int lim) {\n\ts=n+m+2,t=n+m+3;\n\ttot=1,memset(hd,0,sizeof(hd)),memset(ot,0,sizeof(ot));\n\tffor(i,1,n) ffor(j,1,m) ot[i]+=l,ot[j+n]-=l,add_edge(i,j+n,r-l);\t\n\tffor(i,1,n) {\n\t\tint sum=0;\n\t\tffor(j,1,m) sum+=a[i][j];\n\t\tint L=max(0ll,sum-lim),R=sum+lim;\n\t\tot[0]+=L,ot[i]-=L,add_edge(0,i,R-L);\n\t}\n\tffor(j,1,m) {\n\t\tint sum=0;\n\t\tffor(i,1,n) sum+=a[i][j];\n\t\tint L=max(0ll,sum-lim),R=sum+lim;\n\t\tot[n+m+1]-=L,ot[j+n]+=L,add_edge(j+n,n+m+1,R-L);\n\t}\n\tadd_edge(n+m+1,0,200000000);\n\tint ans=0,tmp=0;\n\tffor(i,0,n+m+1) if(ot[i]>=0) add_edge(i,t,ot[i]); else add_edge(s,i,-ot[i]),ans-=ot[i];\n\twhile(bfs()) while(tmp=dinic(s,200000000)) ans-=tmp;\n\treturn ans==0;\n}\nint bfind(int l,int r) {\n\tint ans=-1,mid;\n\twhile(l<=r) {\n\t\tmid=l+r>>1;\n\t\tif(check(mid)) ans=mid,r=mid-1;\n\t\telse l=mid+1;\n\t}\n\treturn ans;\n}\nsigned main() {\n\tios::sync_with_stdio(false),cin.tie(0),cout.tie(0);\n\tcin>>n>>m; ffor(i,1,n) ffor(j,1,m) cin>>a[i][j]; cin>>l>>r;\n\tcout<<bfind(0,200000);\n\treturn 0;\n}", "step": ["Initialize variables and arrays.", "Create a graph to solve the problem using Max-Flow algorithm.", "Create edges between every row and column.", "Create edges from source to rows and from columns to sink.", "Add super source and sink.", "Apply binary search to find the maximum value."], "nl_cn": "给定一个整数矩阵 $A[n\\times m]$，求一个矩阵 $B[n\\times m]$，满足 $\\forall 1\\le i\\le n,1\\le j\\le m,B_{i,j}\\in[L,R]$，且使下式值最小：\n\n$$\\max\\begin{cases}\\displaystyle\\max_{1\\le j\\le m}\\left\\{\\left|\\sum_{i=1}^n\\left(A_{i,j}-B_{i,j}\\right)\\right|\\right\\}\\\\\\displaystyle\\max_{1\\le i\\le n}\\left\\{\\left|\\sum_{j=1}^m\\left(A_{i,j}-B_{i,j}\\right)\\right|\\right\\}\\end{cases}$$", "test_cases": [{"input": "2 2\n0 1\n2 1\n0 1", "output": "1"}, {"input": "1 1\n7\n-10 10", "output": "0"}, {"input": "2 2\n0 0\n0 0\n0 1", "output": "0"}, {"input": "4 4\n0 0 0 0\n0 0 0 0\n0 0 0 0\n0 0 0 0\n0 0", "output": "0"}, {"input": "1 1\n-1000000000\n-1000000000 1000000000", "output": "0"}, {"input": "2 2\n1 -1\n-1 1\n-10 10", "output": "0"}], "test": "#undef NDEBUG\n#include<assert.h>\nint main(){\n    assert(solution(\"2 2\\n0 1\\n2 1\\n0 1\") == \"1\");\n    assert(solution(\"1 1\\n7\\n-10 10\") == \"0\");\n    assert(solution(\"2 2\\n0 0\\n0 0\\n0 1\") == \"0\");\n    assert(solution(\"4 4\\n0 0 0 0\\n0 0 0 0\\n0 0 0 0\\n0 0 0 0\\n0 0\") == \"0\");\n    assert(solution(\"1 1\\n-1000000000\\n-1000000000 1000000000\") == \"0\");\n    assert(solution(\"2 2\\n1 -1\\n-1 1\\n-10 10\") == \"0\");\n    return 0; \n}", "prompt": "/*Given an integer matrix $A[n\\times m]$, find a matrix $B[n\\times m]$ such that $\\forall 1\\le i\\le n,1\\le j\\le m,B_{i,j}\\in[L,R]$, and the following equation is minimized:\n\n$$\\max\\begin{cases}\\displaystyle\\max_{1\\le j\\le m}\\left\\{\\left|\\sum_{i=1}^n\\left(A_{i,j}-B_{i,j}\\right)\\right|\\right\\}\\\\\\displaystyle\\max_{1\\le i\\le n}\\left\\{\\left|\\sum_{j=1}^m\\left(A_{i,j}-B_{i,j}\\right)\\right|\\right\\}\\end{cases}$$\n\ninput_format:\nThe first row of two integers $n$, $m$, indicates the size of the matrix.\n\nThe next $n$row, each $m$integer, describes the matrix $A$.\n\nThe last line has two integers $L$, $R$.\n\noutput_format:\nOutput a line with an integer representing the answer.\n*/\n\n#include<sstream>\n#include<stdlib.h>\n#include<algorithm>\n#include<math.h>\n#include<stdio.h>\n#include<vector>\n#include<string>\n#include<climits>\n#include<cstring>\n#include<iostream>\nusing namespace std;\n\n             \nstring solution(string std_in){\n    istringstream iss(std_in);\n             ", "constraints": "对于 $100\\%$ 的数据满足 $n,m\\le200$，$0\\le L\\le R\\le1000$，$0\\le A_{i,j}\\le1000$。", "samples": [["2 2\n0 1\n2 1\n0 1", "1"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}}
{"task_id": "P1321", "title": "单词覆盖还原", "difficulty": "basic", "nl": "A string of length $l$ has been repeatedly pasted with the words `boy` and `girl`, where the later pasted may cover the previous ones (dots represent uncovered characters). In the end, each word has at least one uncovered character. What is the number of `boy` and `girl` in the string?", "code": "#include<bits/stdc++.h>//c++万能头文件 \nusing namespace std;//命名空间~ \nint main() {//主函数 \n\tint boy=0,girl=0;//boy和girl用来记下各自的个数 \n\tstring st;//定义题目给出的字符串 \n\tcin>>st;//这个我们校长都能看得懂的输入~ \n\tfor(int i=0;i<=st.length();i++){//开始发挥计算机的强大功能！\n//st.length()为读取字符串长度的函数，c++中最好用string头文件，这里我就直接用万能头文件了~ \n\t\tif (st[i]=='b'||st[i+1]=='o'||st[i+2]=='y')//判断连着的三个字母是否为b、o、y \n\t\t\tboy++;//boy计数器加一 \n\t\tif (st[i]=='g'||st[i+1]=='i'||st[i+2]=='r'||st[i+3]=='l')//判断连着的三个字母是否为g、i、r、l \n\t\t\tgirl++;//girl计数器加一 \n\t}\n\tcout<<boy<<endl;//输出boy的个数  换行~ \n\tcout<<girl<<endl;//输出girl的个数 \n\treturn 0;//愉快地结束程序~~~~ \n}", "step": ["Initialize variables including two arrays of 'boy' and 'girl'", "Read characters from input stream, if the character exists in 'boy' or 'girl', count it and continue the loop", "Print the number of occurrences of 'boy' and 'girl' after finishing input", "Return 0 to exit the program"], "nl_cn": "一个长度为 $l$ 的字符串中被反复贴有 `boy` 和 `girl` 两单词，后贴上的可能覆盖已贴上的单词（没有被覆盖的用句点表示），最终每个单词至少有一个字符没有被覆盖。问贴有几个 `boy` 几个 `girl`？", "test_cases": [{"input": "......boyogirlyy......girl.......\n", "output": "4\n2"}, {"input": "..........\n", "output": "0\n0"}, {"input": "...........\n", "output": "0\n0"}, {"input": "boyboygirlgirlboygirlgirl\n", "output": "3\n4"}, {"input": "boyboyboygirl\n", "output": "3\n1"}, {"input": "boygirl\n", "output": "1\n1"}, {"input": "girlboy\n", "output": "1\n1"}, {"input": "boygirlboygirl\n", "output": "2\n2"}, {"input": "boygirlboygirlboygirl\n", "output": "3\n3"}, {"input": "boys\n", "output": "1\n0"}, {"input": "girls\n", "output": "0\n1"}, {"input": "girlgirlgirlgirlgirl\n", "output": "0\n5"}, {"input": "girlgirlgirlgirl\n", "output": "0\n4"}, {"input": "girboyboygirlgirlgirl\n", "output": "2\n4"}, {"input": "...boy....girl...\n", "output": "1\n1"}, {"input": "boygirlboygirlboygirlboygirl\n", "output": "4\n4"}, {"input": "......boy......girl......boy......girl...\n", "output": "2\n2"}, {"input": ".........................................\n", "output": "0\n0"}, {"input": "......boy....girl.....boy...girl....\n", "output": "2\n2"}, {"input": "...............\n", "output": "0\n0"}, {"input": "......boy........girl.....boy.........girl....\n", "output": "2\n2"}, {"input": "......boy....girl....boygirl....girlboy....\n", "output": "3\n3"}, {"input": "............................\n", "output": "0\n0"}, {"input": "......boy....girl.....boy........girl......\n", "output": "2\n2"}, {"input": ".........\n", "output": "0\n0"}, {"input": "boy....girl.....boy...girl\n", "output": "2\n2"}, {"input": "........boy.........girl....\n", "output": "1\n1"}, {"input": "boy..girl..boy....girl\n", "output": "2\n2"}], "test": "#undef NDEBUG\n#include<assert.h>\nint main(){\n    assert(solution(\"......boyogirlyy......girl.......\\n\") == \"4\\n2\");\n    assert(solution(\"..........\\n\") == \"0\\n0\");\n    assert(solution(\"...........\\n\") == \"0\\n0\");\n    assert(solution(\"boyboygirlgirlboygirlgirl\\n\") == \"3\\n4\");\n    assert(solution(\"boyboyboygirl\\n\") == \"3\\n1\");\n    assert(solution(\"boygirl\\n\") == \"1\\n1\");\n    assert(solution(\"girlboy\\n\") == \"1\\n1\");\n    assert(solution(\"boygirlboygirl\\n\") == \"2\\n2\");\n    assert(solution(\"boygirlboygirlboygirl\\n\") == \"3\\n3\");\n    assert(solution(\"boys\\n\") == \"1\\n0\");\n    assert(solution(\"girls\\n\") == \"0\\n1\");\n    assert(solution(\"girlgirlgirlgirlgirl\\n\") == \"0\\n5\");\n    assert(solution(\"girlgirlgirlgirl\\n\") == \"0\\n4\");\n    assert(solution(\"girboyboygirlgirlgirl\\n\") == \"2\\n4\");\n    assert(solution(\"...boy....girl...\\n\") == \"1\\n1\");\n    assert(solution(\"boygirlboygirlboygirlboygirl\\n\") == \"4\\n4\");\n    assert(solution(\"......boy......girl......boy......girl...\\n\") == \"2\\n2\");\n    assert(solution(\".........................................\\n\") == \"0\\n0\");\n    assert(solution(\"......boy....girl.....boy...girl....\\n\") == \"2\\n2\");\n    assert(solution(\"...............\\n\") == \"0\\n0\");\n    assert(solution(\"......boy........girl.....boy.........girl....\\n\") == \"2\\n2\");\n    assert(solution(\"......boy....girl....boygirl....girlboy....\\n\") == \"3\\n3\");\n    assert(solution(\"............................\\n\") == \"0\\n0\");\n    assert(solution(\"......boy....girl.....boy........girl......\\n\") == \"2\\n2\");\n    assert(solution(\".........\\n\") == \"0\\n0\");\n    assert(solution(\"boy....girl.....boy...girl\\n\") == \"2\\n2\");\n    assert(solution(\"........boy.........girl....\\n\") == \"1\\n1\");\n    assert(solution(\"boy..girl..boy....girl\\n\") == \"2\\n2\");\n    return 0; \n}", "prompt": "/*A string of length $l$ has been repeatedly pasted with the words `boy` and `girl`, where the later pasted may cover the previous ones (dots represent uncovered characters). In the end, each word has at least one uncovered character. What is the number of `boy` and `girl` in the string?\n\ninput_format:\nA string with the words' boy 'and' girl 'repeatedly attached to it.\n\noutput_format:\nTwo lines, two integers. The number of the first act 'boy' and the number of the second act 'girl'.\n*/\n\n#include<sstream>\n#include<stdlib.h>\n#include<algorithm>\n#include<math.h>\n#include<stdio.h>\n#include<vector>\n#include<string>\n#include<climits>\n#include<cstring>\n#include<iostream>\nusing namespace std;\n\n             \nstring solution(string std_in){\n    istringstream iss(std_in);\n             ", "constraints": "数据保证，$3\\le l\\le255$，字符串仅仅包含如下字符：$\\texttt{.bgilory}$。", "samples": [["......boyogirlyy......girl.......\n", "4\n2\n"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072]}}
{"task_id": "P1146", "title": "硬币翻转", "difficulty": "challenge", "nl": "There are $N$ coins on the table, all facing up. Now we need to flip all the coins so that they are facing down. The rule is that we can flip any $N-1$ coins at a time (those facing up will face down, and vice versa). Find the shortest sequence of operations needed.", "code": "#include<iostream>\nusing namespace std;\nconst int maxn=101;\nbool a[maxn];//a数组负责存储硬币的状态\nint n;//n枚硬币\nint main()\n{\n    cin>>n;\n    cout<<n<<endl;//因为相当于只翻一枚，所以翻n次即可\n    for(int i=1;i<=n;i++){//i表示这是第几次翻\n        for(int j=1;j<=n;j++){//表示当前翻得是第几枚硬币\n            if(j!=i){//如果不为第i枚\n                if(a[j])a[j]=0;//1变成0\n                else a[j]=1;//0变成1\n            }\n            cout<<a[j];//输出当前状态\n        }\n        cout<<endl;//别忘了换行\n    }\n    return 0;\n}", "step": ["Take input integer value from the user.", "Print the integer value.", "Loop through rows from 1 to n (input integer value)", "Loop through columns from 1 to n", "Toggle the boolean value for column if it is not equal to the row value", "Print the boolean matrix"], "nl_cn": "在桌面上有一排硬币，共$N$枚，每一枚硬币均为正面朝上。现在要把所有的硬币翻转成反面朝上，规则是每次可翻转任意$N-1$枚硬币（正面向上的被翻转为反面向上，反之亦然）。求一个最短的操作序列（将每次翻转N-1枚硬币成为一次操作）。\n", "test_cases": [{"input": "4", "output": "4\n0111\n1100\n0001\n1111"}, {"input": "1\n", "output": "1\n0"}, {"input": "3", "output": "3\n011\n110\n000"}], "test": "#undef NDEBUG\n#include<assert.h>\nint main(){\n    assert(solution(\"4\") == \"4\\n0111\\n1100\\n0001\\n1111\");\n    assert(solution(\"1\\n\") == \"1\\n0\");\n    assert(solution(\"3\") == \"3\\n011\\n110\\n000\");\n    return 0; \n}", "prompt": "/*There are $N$ coins on the table, all facing up. Now we need to flip all the coins so that they are facing down. The rule is that we can flip any $N-1$ coins at a time (those facing up will face down, and vice versa). Find the shortest sequence of operations needed.\n\ninput_format:\nA natural number $N$ ($N$ is an even number not greater than $100$).\n\noutput_format:\nThe first line contains an integer $S$, representing the minimum number of operations required. The next $S$line each represents the state of the coin on the table after each operation (a line containing $N$integers ($0$or $1$) represents the state of each coin: $0$- heads up, and $1$- tails up, with no extra Spaces allowed).\n\nIn cases where there are multiple operation options, only the lexicographic order of the operation needs to output a minimum of one.\n\nNote: Lexicographic order of operations: For a single operation, 1 means flip and 0 means no inversion.\n\nBut what you need to output is the state after each operation, 0 means heads up, 1 means tails up.\n*/\n\n#include<sstream>\n#include<stdlib.h>\n#include<algorithm>\n#include<math.h>\n#include<stdio.h>\n#include<vector>\n#include<string>\n#include<climits>\n#include<cstring>\n#include<iostream>\nusing namespace std;\n\n             \nstring solution(string std_in){\n    istringstream iss(std_in);\n             ", "constraints": "", "samples": [["4", "4\n0111\n1100\n0001\n1111\n"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000]}}
{"task_id": "P6421", "title": "[COCI2008-2009#2] RESETO", "difficulty": "basic", "nl": "The Sieve of Eratosthenes is a famous prime number sieve algorithm that can find all prime numbers up to $n$. The steps of this algorithm are:\n1. Write down all integers between $2$ and $n$, inclusive (including $2$ and $n$).\n2. Find the smallest number not yet crossed out and name it $p$; then $p$ is a prime number.\n3. Cross out $p$ and all its uncrossed multiples.\n4. If there are still numbers left that have not been crossed out, go back to step 2.\n\nWrite a program that, given $n$ and $k$, finds the $k$-th deleted integer.", "code": "#include <bits/stdc++.h>\nusing namespace std;\nint main()\n{\n\tbool s[1001];//来存下这些数\n\tint n,k,w=0;//w记录划掉了几个数\n\tcin>>n>>k;//输入\n\tmemset(s,true,sizeof(s));//写下所有数\n\tfor(int i=2;i<=n;i++)//找没有划掉的数\n\t{\n\t\tif(s[i]==true)//如果没有被划掉\n\t\t{\n\t\t\tfor(int j=i;j<=n;j+=i)//找它的倍数\n\t\t\t{\n\t\t\t\tif(s[j]==true)//如果它的倍数没被划掉\n\t\t\t\t{\n\t\t\t\t\tw++;//又划掉一个数\n\t\t\t\t\ts[j]=false;//现在它被划掉了\n\t\t\t\t\tif(w==k)//如果已经划掉k个数\n\t\t\t\t\t{\n\t\t\t\t\t\tcout<<j;//输出答案\n\t\t\t\t\t\treturn 0;//结束\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\treturn 0;//别忘了\n}", "step": ["Initialize boolean array s with all values as true.", "Accept the value of n and k from the user.", "Loop through the array from 2 to n.", "If the element at i is true, loop through the array from i to n with i as the increment factor. If the element at j is true, mark it as composite and increment w by 1.", "If w equals k, print the value of j and exit the program.", "If the loop completes without finding the kth composite, exit the program."], "nl_cn": "埃拉托色尼筛法是一种著名的素数筛法，可以查找所有直至 $n$ 的素数。该算法的步骤是：\n1. 写下 $2$ 到 $n$ 之间的所有整数（包括 $2$ 和 $n$）。\n2. 找到尚未删除的最小数，并将其命名为 $p$； 则 $p$ 是素数。\n3. 划掉 $p$ 及其所有尚未划掉的倍数。\n4. 如果尚有数未被划掉，请转到步骤 $2$。\n\n编写一个程序，给定 $n$ 和 $k$，找出第 $k$ 个被删除的整数。", "test_cases": [{"input": "7 3", "output": "6"}, {"input": "15 12", "output": "7"}, {"input": "10 7", "output": "9"}, {"input": "30 10\n", "output": "20"}, {"input": "2 1", "output": "2"}, {"input": "4 2", "output": "4"}, {"input": "5 1\n", "output": "2"}, {"input": "30 1\n", "output": "2"}, {"input": "12 10\n", "output": "7"}, {"input": "18 6\n", "output": "12"}, {"input": "16 1\n", "output": "2"}], "test": "#undef NDEBUG\n#include<assert.h>\nint main(){\n    assert(solution(\"7 3\") == \"6\");\n    assert(solution(\"15 12\") == \"7\");\n    assert(solution(\"10 7\") == \"9\");\n    assert(solution(\"30 10\\n\") == \"20\");\n    assert(solution(\"2 1\") == \"2\");\n    assert(solution(\"4 2\") == \"4\");\n    assert(solution(\"5 1\\n\") == \"2\");\n    assert(solution(\"30 1\\n\") == \"2\");\n    assert(solution(\"12 10\\n\") == \"7\");\n    assert(solution(\"18 6\\n\") == \"12\");\n    assert(solution(\"16 1\\n\") == \"2\");\n    return 0; \n}", "prompt": "/*The Sieve of Eratosthenes is a famous prime number sieve algorithm that can find all prime numbers up to $n$. The steps of this algorithm are:\n1. Write down all integers between $2$ and $n$, inclusive (including $2$ and $n$).\n2. Find the smallest number not yet crossed out and name it $p$; then $p$ is a prime number.\n3. Cross out $p$ and all its uncrossed multiples.\n4. If there are still numbers left that have not been crossed out, go back to step 2.\n\nWrite a program that, given $n$ and $k$, finds the $k$-th deleted integer.\n\ninput_format:\nA row of two integers $n$and $k$, the specific meaning of which is described in the topic.\n\noutput_format:\nA row of an integer, representing the $k$integer that has been crossed out.\n*/\n\n#include<sstream>\n#include<stdlib.h>\n#include<algorithm>\n#include<math.h>\n#include<stdio.h>\n#include<vector>\n#include<string>\n#include<climits>\n#include<cstring>\n#include<iostream>\nusing namespace std;\n\n             \nstring solution(string std_in){\n    istringstream iss(std_in);\n             ", "constraints": "#### 数据规模与约定\n对于 $100\\%$ 的数据，有 $2 \\leq k < n \\leq 1000$。\n#### 说明\n#### 题目译自 [COCI2008-2009](https://hsin.hr/coci/archive/2008_2009/) [CONTEST #2](https://hsin.hr/coci/archive/2008_2009/contest2_tasks.pdf) RESETO，译者 @[mnesia](https://www.luogu.com.cn/user/115711)。", "samples": [["7 3", "6"], ["15 12", "7"], ["10 7", "9"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [32768, 32768, 32768, 32768, 32768, 32768, 32768, 32768]}}
{"task_id": "P2008", "title": "大朋友的数字", "difficulty": "challenge", "nl": "There is a group of adults (over 15 years old), each holding a number between 0 and 9. Each adult's score is the sum of all the numbers in the longest non-decreasing subsequence before him (the sequence must end with his number!). If there are multiple longest non-decreasing subsequences, choose the one with the smallest lexicographic index. Now, given n adults and their respective numbers, you are asked to calculate each person's score.", "code": "#include<iostream>\n#include<cstring>\nusing namespace std;\nint n,a[10010],b[10010],c[10010];\nbool vis[10010];\nint main(){\n    cin>>n;\n    for(int i=1;i<=n;i++)cin>>a[i];\n    for(int i=1;i<=n;i++){\n        b[i]=1;\n        for(int j=1;j<=i-1;j++)\n            if(a[i]>=a[j])\n                if(b[i]<b[j]+1){\n                    b[i]=b[j]+1;\n                    c[i]=c[j];//c[i]等于离它最近的一个数c[j]因为要求字典序最小 \n                }\n        c[i]+=a[i];//自身也是序列的一个数 \n    }\n    for(int i=1;i<=n;i++)cout<<c[i]<<\" \";\n    return 0;\n}", "step": ["Read integer n from user.", "Read input sequence a of size n from user.", "For each element in the input sequence:", "  If an element is greater than or equal to any previous element:", "      update the length of the maximum increasing subsequence,", "      and update the maximum sum of an increasing subsequence."], "nl_cn": "有一批大朋友（年龄 $15$ 岁以上），他们每人手上拿着一个数字，当然这个数字只有 $1$ 位，也就是 $0$ 到 $9$ 之间。每个大朋友的分数为在他之前的最长不下降子序列中所有数之和。（这个序列必须以它作为结尾！）如有多个最长不下降子序列，那么取编号字典序最小的。现在告诉你有 $n$ 个大朋友，以及他们各自的数字，请你求出他们每个人的分数。", "test_cases": [{"input": "5\n1 2 5 3 4\n", "output": "1 3 8 6 10"}, {"input": "5\n1 7 5 9 6\n", "output": "1 8 6 17 12"}, {"input": "5\n8 6 4 2 0\n", "output": "8 6 4 2 0"}, {"input": "2\n9 1\n", "output": "9 1"}, {"input": "1\n5\n", "output": "5"}, {"input": "3\n7 4 3\n", "output": "7 4 3"}, {"input": "5\n5 2 4 7 10\n", "output": "5 2 6 13 23"}, {"input": "3\n4 1 7\n", "output": "4 1 11"}, {"input": "6\n10 8 6 4 2 0\n", "output": "10 8 6 4 2 0"}, {"input": "1\n0\n", "output": "0"}, {"input": "3\n3 2 1\n", "output": "3 2 1"}, {"input": "6\n9 8 7 6 5 4\n", "output": "9 8 7 6 5 4"}, {"input": "3\n1 2 3\n", "output": "1 3 6"}, {"input": "10\n1 2 3 4 5 6 7 8 9 10\n", "output": "1 3 6 10 15 21 28 36 45 55"}, {"input": "2\n5 2\n", "output": "5 2"}, {"input": "1\n9\n", "output": "9"}, {"input": "1\n1\n", "output": "1"}, {"input": "6\n5 6 7 8 9 10\n", "output": "5 11 18 26 35 45"}, {"input": "5\n5 4 3 2 1\n", "output": "5 4 3 2 1"}, {"input": "3\n0 0 0\n", "output": "0 0 0"}, {"input": "4\n2 2 2 2\n", "output": "2 4 6 8"}, {"input": "6\n1 2 3 4 5 6\n", "output": "1 3 6 10 15 21"}, {"input": "2\n9 9\n", "output": "9 18"}, {"input": "3\n1 1 1\n", "output": "1 2 3"}, {"input": "4\n2 2 2 3\n", "output": "2 4 6 9"}, {"input": "3\n9 8 7\n", "output": "9 8 7"}, {"input": "3\n5 2 7\n", "output": "5 2 12"}, {"input": "2\n9 2\n", "output": "9 2"}, {"input": "5\n5 4 5 4 5\n", "output": "5 4 10 8 15"}], "test": "#undef NDEBUG\n#include<assert.h>\nint main(){\n    assert(solution(\"5\\n1 2 5 3 4\\n\") == \"1 3 8 6 10\");\n    assert(solution(\"5\\n1 7 5 9 6\\n\") == \"1 8 6 17 12\");\n    assert(solution(\"5\\n8 6 4 2 0\\n\") == \"8 6 4 2 0\");\n    assert(solution(\"2\\n9 1\\n\") == \"9 1\");\n    assert(solution(\"1\\n5\\n\") == \"5\");\n    assert(solution(\"3\\n7 4 3\\n\") == \"7 4 3\");\n    assert(solution(\"5\\n5 2 4 7 10\\n\") == \"5 2 6 13 23\");\n    assert(solution(\"3\\n4 1 7\\n\") == \"4 1 11\");\n    assert(solution(\"6\\n10 8 6 4 2 0\\n\") == \"10 8 6 4 2 0\");\n    assert(solution(\"1\\n0\\n\") == \"0\");\n    assert(solution(\"3\\n3 2 1\\n\") == \"3 2 1\");\n    assert(solution(\"6\\n9 8 7 6 5 4\\n\") == \"9 8 7 6 5 4\");\n    assert(solution(\"3\\n1 2 3\\n\") == \"1 3 6\");\n    assert(solution(\"10\\n1 2 3 4 5 6 7 8 9 10\\n\") == \"1 3 6 10 15 21 28 36 45 55\");\n    assert(solution(\"2\\n5 2\\n\") == \"5 2\");\n    assert(solution(\"1\\n9\\n\") == \"9\");\n    assert(solution(\"1\\n1\\n\") == \"1\");\n    assert(solution(\"6\\n5 6 7 8 9 10\\n\") == \"5 11 18 26 35 45\");\n    assert(solution(\"5\\n5 4 3 2 1\\n\") == \"5 4 3 2 1\");\n    assert(solution(\"3\\n0 0 0\\n\") == \"0 0 0\");\n    assert(solution(\"4\\n2 2 2 2\\n\") == \"2 4 6 8\");\n    assert(solution(\"6\\n1 2 3 4 5 6\\n\") == \"1 3 6 10 15 21\");\n    assert(solution(\"2\\n9 9\\n\") == \"9 18\");\n    assert(solution(\"3\\n1 1 1\\n\") == \"1 2 3\");\n    assert(solution(\"4\\n2 2 2 3\\n\") == \"2 4 6 9\");\n    assert(solution(\"3\\n9 8 7\\n\") == \"9 8 7\");\n    assert(solution(\"3\\n5 2 7\\n\") == \"5 2 12\");\n    assert(solution(\"2\\n9 2\\n\") == \"9 2\");\n    assert(solution(\"5\\n5 4 5 4 5\\n\") == \"5 4 10 8 15\");\n    return 0; \n}", "prompt": "/*There is a group of adults (over 15 years old), each holding a number between 0 and 9. Each adult's score is the sum of all the numbers in the longest non-decreasing subsequence before him (the sequence must end with his number!). If there are multiple longest non-decreasing subsequences, choose the one with the smallest lexicographic index. Now, given n adults and their respective numbers, you are asked to calculate each person's score.\n\ninput_format:\nIn the first row, $1 has a number of $n$.\n\nThe second line, $n$number, represents each person's number.\n\noutput_format:\nOne line, $n$number, represents each person's score.\n*/\n\n#include<sstream>\n#include<stdlib.h>\n#include<algorithm>\n#include<math.h>\n#include<stdio.h>\n#include<vector>\n#include<string>\n#include<climits>\n#include<cstring>\n#include<iostream>\nusing namespace std;\n\n             \nstring solution(string std_in){\n    istringstream iss(std_in);\n             ", "constraints": "【样例解释 $1$】\n\n五个人分数分别为 $(1),(1+2),(1+2+5),(1+2+3),(1+2+3+4)$。\n\n【样例解释 $2$】\n\n五个人分数分别为 $(1),(1+7),(1+5),(1+7+9)$ （还有一个 $(1,5,9)$），$(1+5+6)$。\n\n【数据规模】\n\n对于 $50\\%$ 的数据，$1\\le n\\le 500$；\n\n对于 $80\\%$ 的数据，$1\\le n\\le 10^3$；\n\n对于 $100\\%$ 的数据，$1\\le n\\le 10^4$。", "samples": [["5\n1 2 5 3 4\n", "1 3 8 6 10\n"], ["5\n1 7 5 9 6\n", "1 8 6 17 12\n"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}}
{"task_id": "P6745", "title": "『MdOI R3』Number", "difficulty": "basic", "nl": "In our daily life, we often encounter some special numbers. These numbers can be expressed in a special way to make them easier to remember and use. For example, $10^9+7$ is a very common number, which is easier for contestants to read without counting the 0s, and it has no loss of precision in scientific notation. \n\nNow, you are given a number of the form $10^k+x$. Please convert it to the usual form.", "code": "#include <iostream>\n#include <cstdio>\n#include <cstring>\n#include <algorithm>\n#include <cmath>\n#include <cctype>\n#include <queue>\n#include <vector>\n\nusing namespace std;\n\ninline long long read()\n{\n\tlong long x=0,f=1;char ch=getchar();\n\twhile (!isdigit(ch)){if (ch=='-') f=-1;ch=getchar();}\n\twhile (isdigit(ch)){x=x*10+ch-48;ch=getchar();}\n\treturn x*f;\n}\n\nlong long k,x;\n\nint main()\n{\n\tk=read(),x=read();\n\tif (k<=18)\n\t{\n\t\tlong long ans=1;\n\t\tfor (int i=1;i<=k;i++)\n\t\t\tans=ans*10;\n\t\tcout << ans+x << endl;\n\t}\n\telse\n\t{\n\t\tputchar('1');\n\t\tlong long x1=x,digit=0;\n\t\twhile (x1>0)\n\t\t{\n\t\t\tdigit++;\n\t\t\tx1/=10;\n\t\t}\n\t\tfor (int i=1;i<=k-digit;i++)\n\t\t\tputchar('0');\n\t\tif (x!=0)\n\t\t\tcout << x << endl;//注意这里的特判，x=0 的话没必要再输出一个 0。\n\t}\n\treturn 0;\n}", "step": ["Read in k and x", "If k <= 18, compute (10^k)+x and output it", "If k > 18, output 1", "Find the number of digits in x and call it digit", "Output k-digit zeroes", "If x is not 0, output x"], "nl_cn": "生活中我们会碰到一些特殊数字，这些数字使用一些特殊表达方式后会方便记忆和使用。比如说，$10^9+7$ 就非常常见——它相比于 $1000000007$，更方便选手看清数字而不必数 $0$，而且没有科学计数法的精度损失。\n\n你现在有一个形如 $10^{k}+x$ 的数字，请还原成一般写法。", "test_cases": [{"input": "9 7", "output": "1000000007"}, {"input": "5 0\n", "output": "100000"}, {"input": "2 9\n", "output": "109"}, {"input": "4 6\n", "output": "10006"}, {"input": "7 8\n", "output": "10000008"}, {"input": "6 2\n", "output": "1000002"}, {"input": "10 1\n", "output": "10000000001"}, {"input": "8 4\n", "output": "100000004"}, {"input": "1 3\n", "output": "13"}, {"input": "11 7\n", "output": "100000000007"}, {"input": "20 1\n", "output": "100000000000000000001"}, {"input": "19 3\n", "output": "10000000000000000003"}, {"input": "6 9", "output": "1000009"}, {"input": "8 1", "output": "100000001"}, {"input": "2 5\n", "output": "105"}, {"input": "10 3\n", "output": "10000000003"}, {"input": "13 9\n", "output": "10000000000009"}, {"input": "20 17\n", "output": "100000000000000000017"}, {"input": "8 6\n", "output": "100000006"}, {"input": "3 1\n", "output": "1001"}, {"input": "4 0\n", "output": "10000"}, {"input": "5 2\n", "output": "100002"}, {"input": "14 4\n", "output": "100000000000004"}, {"input": "16 15\n", "output": "10000000000000015"}, {"input": "11 10\n", "output": "100000000010"}, {"input": "1 9\n", "output": "19"}, {"input": "5 3\n", "output": "100003"}, {"input": "10 0\n", "output": "10000000000"}, {"input": "18 5\n", "output": "1000000000000000005"}, {"input": "7 6\n", "output": "10000006"}, {"input": "6 1\n", "output": "1000001"}, {"input": "12 8\n", "output": "1000000000008"}, {"input": "4 2\n", "output": "10002"}, {"input": "8 9\n", "output": "100000009"}, {"input": "17 6\n", "output": "100000000000000006"}, {"input": "1 1\n", "output": "11"}, {"input": "16 5\n", "output": "10000000000000005"}, {"input": "0 0\n", "output": "1"}, {"input": "1 0\n", "output": "10"}, {"input": "2 0\n", "output": "100"}, {"input": "3 0\n", "output": "1000"}, {"input": "6 0\n", "output": "1000000"}, {"input": "7 0\n", "output": "10000000"}, {"input": "8 0\n", "output": "100000000"}, {"input": "9 0\n", "output": "1000000000"}, {"input": "11 0\n", "output": "100000000000"}, {"input": "12 0\n", "output": "1000000000000"}, {"input": "13 0\n", "output": "10000000000000"}, {"input": "14 0\n", "output": "100000000000000"}, {"input": "15 0\n", "output": "1000000000000000"}, {"input": "16 0\n", "output": "10000000000000000"}, {"input": "17 0\n", "output": "100000000000000000"}, {"input": "18 0\n", "output": "1000000000000000000"}, {"input": "19 0\n", "output": "10000000000000000000"}], "test": "#undef NDEBUG\n#include<assert.h>\nint main(){\n    assert(solution(\"9 7\") == \"1000000007\");\n    assert(solution(\"5 0\\n\") == \"100000\");\n    assert(solution(\"2 9\\n\") == \"109\");\n    assert(solution(\"4 6\\n\") == \"10006\");\n    assert(solution(\"7 8\\n\") == \"10000008\");\n    assert(solution(\"6 2\\n\") == \"1000002\");\n    assert(solution(\"10 1\\n\") == \"10000000001\");\n    assert(solution(\"8 4\\n\") == \"100000004\");\n    assert(solution(\"1 3\\n\") == \"13\");\n    assert(solution(\"11 7\\n\") == \"100000000007\");\n    assert(solution(\"20 1\\n\") == \"100000000000000000001\");\n    assert(solution(\"19 3\\n\") == \"10000000000000000003\");\n    assert(solution(\"6 9\") == \"1000009\");\n    assert(solution(\"8 1\") == \"100000001\");\n    assert(solution(\"2 5\\n\") == \"105\");\n    assert(solution(\"10 3\\n\") == \"10000000003\");\n    assert(solution(\"13 9\\n\") == \"10000000000009\");\n    assert(solution(\"20 17\\n\") == \"100000000000000000017\");\n    assert(solution(\"8 6\\n\") == \"100000006\");\n    assert(solution(\"3 1\\n\") == \"1001\");\n    assert(solution(\"4 0\\n\") == \"10000\");\n    assert(solution(\"5 2\\n\") == \"100002\");\n    assert(solution(\"14 4\\n\") == \"100000000000004\");\n    assert(solution(\"16 15\\n\") == \"10000000000000015\");\n    assert(solution(\"11 10\\n\") == \"100000000010\");\n    assert(solution(\"1 9\\n\") == \"19\");\n    assert(solution(\"5 3\\n\") == \"100003\");\n    assert(solution(\"10 0\\n\") == \"10000000000\");\n    assert(solution(\"18 5\\n\") == \"1000000000000000005\");\n    assert(solution(\"7 6\\n\") == \"10000006\");\n    assert(solution(\"6 1\\n\") == \"1000001\");\n    assert(solution(\"12 8\\n\") == \"1000000000008\");\n    assert(solution(\"4 2\\n\") == \"10002\");\n    assert(solution(\"8 9\\n\") == \"100000009\");\n    assert(solution(\"17 6\\n\") == \"100000000000000006\");\n    assert(solution(\"1 1\\n\") == \"11\");\n    assert(solution(\"16 5\\n\") == \"10000000000000005\");\n    assert(solution(\"0 0\\n\") == \"1\");\n    assert(solution(\"1 0\\n\") == \"10\");\n    assert(solution(\"2 0\\n\") == \"100\");\n    assert(solution(\"3 0\\n\") == \"1000\");\n    assert(solution(\"6 0\\n\") == \"1000000\");\n    assert(solution(\"7 0\\n\") == \"10000000\");\n    assert(solution(\"8 0\\n\") == \"100000000\");\n    assert(solution(\"9 0\\n\") == \"1000000000\");\n    assert(solution(\"11 0\\n\") == \"100000000000\");\n    assert(solution(\"12 0\\n\") == \"1000000000000\");\n    assert(solution(\"13 0\\n\") == \"10000000000000\");\n    assert(solution(\"14 0\\n\") == \"100000000000000\");\n    assert(solution(\"15 0\\n\") == \"1000000000000000\");\n    assert(solution(\"16 0\\n\") == \"10000000000000000\");\n    assert(solution(\"17 0\\n\") == \"100000000000000000\");\n    assert(solution(\"18 0\\n\") == \"1000000000000000000\");\n    assert(solution(\"19 0\\n\") == \"10000000000000000000\");\n    return 0; \n}", "prompt": "/*In our daily life, we often encounter some special numbers. These numbers can be expressed in a special way to make them easier to remember and use. For example, $10^9+7$ is a very common number, which is easier for contestants to read without counting the 0s, and it has no loss of precision in scientific notation. \n\nNow, you are given a number of the form $10^k+x$. Please convert it to the usual form.\n\ninput_format:\nA row of two integers $k,x$.\n\noutput_format:\nA row of integers represents $10^k+x$.\n*/\n\n#include<sstream>\n#include<stdlib.h>\n#include<algorithm>\n#include<math.h>\n#include<stdio.h>\n#include<vector>\n#include<string>\n#include<climits>\n#include<cstring>\n#include<iostream>\nusing namespace std;\n\n             \nstring solution(string std_in){\n    istringstream iss(std_in);\n             ", "constraints": "【样例解释】   \n\n$10^9+7=1000000007$。\n\n更多样例请[到这里](https://www.luogu.com.cn/paste/8lbtjwuk)领取。\n\n【数据范围】   \n\n**本题采用捆绑测试**，换言之，你只有通过一个子任务的所有测试点，才可以拿到该子任务对应分数。\n|子任务编号|$x<$|$k\\le$|特殊性质|分值|\n|:-:|:-:|:-:|:-:|:-:|\n|1|$10$|$9$||12|\n|2|$10$|$500$||15|\n|3|$10^{18}$|$18$||8|\n|4|$10^{18}$|$500$|$k\\ge18$|25|\n|5|$10^{18}$|$500$||40|\n\n对于所有数据，$0\\le x<10^{18}$，$0\\leq k\\leq 500$。", "samples": [["9 7", "1000000007"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072]}}
{"task_id": "P2547", "title": "[AHOI2004]DNA变异", "difficulty": "advanced", "nl": "\n\nTranslate the Chinese description of the programming problem on the website, separated by ````` into English. Please follow the following requirements:\n1. The content of the formula format cannot be deleted or modified.\n2. Return the translated English result directly, and do not return any other content.", "code": "#include \"iostream\"\n#include \"cstring\"\nusing namespace std;\nint t, num1, num2, cnt;\nstring input[8005];\nbool vis[65536], book[65536];\nint hash_(string h_){\n    int id=0;\n    for(int i=0;i<8;i++){\n        id*=4;\n        switch(h_[i]){\n            case 'G': id+=1; break;\n            case 'T': id+=2; break;\n            case 'C': id+=3; break;\n            default: break;\n        }\n    }\n    return id;\n}\nint main(){\n    cin >> t;\n    for(int i=1;i<=t;i++){\n        cin >> input[i];\n        book[hash_(input[i])]=1; // 这个哈希值在序列中出现过\n    }\n    for(int c=1;c<=t;c++){\n        memset(vis, false, sizeof(vis)); // 去重数组\n        for(int i=0;i<8;i++)\n            for(int j=i+1;j<8;j++)\n                for(int k=i+1;k<8;k++){\n                    if(k==j) continue;\n                    for(int l=k+1;l<8;l++){\n                        if(l==j) continue;\n                        num1=hash_(input[c]);\n                        swap(input[c][i], input[c][j]);\n                        swap(input[c][k], input[c][l]);\n                        num2=hash_(input[c]); // 新DNA的哈希值\n                        if(book[num2] && !vis[num2] && num2!=num1) cnt++, vis[num2]=true;\n                        //注意，除了判断重复以外，还需要判断 num2!=num1，如果变异得到的和原来一样，就不能算一对。\n                        swap(input[c][i], input[c][j]);\n                        swap(input[c][k], input[c][l]); // 换回来\n                    }\n                }\n    }\n    printf(\"%d\", cnt/2);\n}", "step": ["Read in the DNA sequences and represent them as integers using a mapping.", "Generate all possible tuples of 4 distinct numbers between 0 and 7 (to represent the four positions to swap).", "For each tuple, check for transpositions between all pairs of DNA sequences.", "Output the number of possible transpositions (divided by 2, since each transposition is counted twice)."], "nl_cn": "\n", "test_cases": [{"input": "3\nATCTACTG\nCTATACTG\nCTATGATC", "output": "1"}, {"input": "5\nAAGTACGT\nCGTAGTCC\nCCGATGTA\nACCTCGCG\nCGTACGTA\n", "output": "0"}, {"input": "2\nACGTCGTA\nCGTACGTA\n", "output": "0"}, {"input": "1\nACGTACGT\n", "output": "0"}, {"input": "2\nAAATTTTT\nGGGCCCCC\n", "output": "0"}, {"input": "1\nAGTAAGTA\n", "output": "0"}, {"input": "0\n\n", "output": "0"}, {"input": "4\nAAAAAATG\nATGCATCG\nCTACACAA\nGCTGCTAG\n", "output": "0"}, {"input": "2\nAGTCAGTC\nGTCAGTCA\n", "output": "0"}, {"input": "3\nCTAATGCT\nAACTGCTA\nGCATGCAT\n", "output": "0"}, {"input": "1\nAGTACATC\n", "output": "0"}, {"input": "2\nCACGCATC\nACGCACGT\n", "output": "0"}, {"input": "3\nAGTAGCTG\nCGATATAC\nACGCTGCT\n", "output": "0"}, {"input": "1\nTCATGTCA\n", "output": "0"}], "test": "#undef NDEBUG\n#include<assert.h>\nint main(){\n    assert(solution(\"3\\nATCTACTG\\nCTATACTG\\nCTATGATC\") == \"1\");\n    assert(solution(\"5\\nAAGTACGT\\nCGTAGTCC\\nCCGATGTA\\nACCTCGCG\\nCGTACGTA\\n\") == \"0\");\n    assert(solution(\"2\\nACGTCGTA\\nCGTACGTA\\n\") == \"0\");\n    assert(solution(\"1\\nACGTACGT\\n\") == \"0\");\n    assert(solution(\"2\\nAAATTTTT\\nGGGCCCCC\\n\") == \"0\");\n    assert(solution(\"1\\nAGTAAGTA\\n\") == \"0\");\n    assert(solution(\"0\\n\\n\") == \"0\");\n    assert(solution(\"4\\nAAAAAATG\\nATGCATCG\\nCTACACAA\\nGCTGCTAG\\n\") == \"0\");\n    assert(solution(\"2\\nAGTCAGTC\\nGTCAGTCA\\n\") == \"0\");\n    assert(solution(\"3\\nCTAATGCT\\nAACTGCTA\\nGCATGCAT\\n\") == \"0\");\n    assert(solution(\"1\\nAGTACATC\\n\") == \"0\");\n    assert(solution(\"2\\nCACGCATC\\nACGCACGT\\n\") == \"0\");\n    assert(solution(\"3\\nAGTAGCTG\\nCGATATAC\\nACGCTGCT\\n\") == \"0\");\n    assert(solution(\"1\\nTCATGTCA\\n\") == \"0\");\n    return 0; \n}", "prompt": "/*\n\nTranslate the Chinese description of the programming problem on the website, separated by ````` into English. Please follow the following requirements:\n1. The content of the formula format cannot be deleted or modified.\n2. Return the translated English result directly, and do not return any other content.\n\ninput_format:\n\n\n\n\noutput_format:\nA single line of numbers represents the total number of blood sequence pairs in a DNA sequence.\n*/\n\n#include<sstream>\n#include<stdlib.h>\n#include<algorithm>\n#include<math.h>\n#include<stdio.h>\n#include<vector>\n#include<string>\n#include<climits>\n#include<cstring>\n#include<iostream>\nusing namespace std;\n\n             \nstring solution(string std_in){\n    istringstream iss(std_in);\n             ", "constraints": "", "samples": [["3\nATCTACTG\nCTATACTG\nCTATGATC", "1"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}}
{"task_id": "P1239", "title": "计数器", "difficulty": "challenge", "nl": "A book has $n$ pages, numbered from $1$ to $n$. Please determine how many times each digit $0$ to $9$ is used in the page numbers. Note that leading zeros are not allowed in page numbers, so for example, the 5th page of a book with $n=1234$ is labeled as 5, not 0005.", "code": "#include<cstdio>\n#include<cstring>\n#define N 10000\n#define For(i,j,k) for(int i=j;i<=k;i++)\nusing namespace std;\nint a[10];\nvoid f(int y){ //计算一个数中每个数码出现次数\n    while(y>0) a[y%10]++,y=y/10;\n}\nint main(){\n    int n,x,b[10]={0},y; scanf(\"%d\",&n); x=n/N;\n    if (n<10000) For(i,1,n) f(i); //特判n<10000\n    else {\n        For(i,1,N-1) f(i); //算出前面的1-9999\n        For(i,1,x-1){ //算中间一段，方法如上面所述\n            memset(b,0,sizeof(b)); y=i;\n            while(y>0) b[y%10]++,y=y/10;\n            For(j,0,9) a[j]+=b[j]*N;\n        }\n        For(i,0,9) a[i]+=4000*(x-1); //后4位的贡献值一次性加上，不用一个一个加\n        For(i,x*N,n) f(i); //算最后的一些数\n    }\n    For(i,0,9) printf(\"%d\\n\",a[i]); //输出\n    return 0;\n}", "step": ["Read input integer n", "If n is less than 10,000, count the frequency of each digit for each number from 1 to n", "Otherwise, process the first 10,000 numbers by counting the frequency of each digit for each number", "For the remaining numbers, process them in chunks of 10,000, and add the digit frequency counts of each chunk to a running total", "Multiply the digit frequency counts of each 10,000 chunk by 10,000 and add them to the running total", "Count the frequency of each digit for the remaining numbers that didn't fit into a complete 10,000 chunk", "Output the digit frequency counts for each digit"], "nl_cn": "一本书的页数为 $n$，页码从 $1$ 开始编起，请你求出全部页码中，用了多少个 $0,1,2\\cdots 9$。每个页码不含前导 $0$，如 $n=1234$ 时第 $5$ 页不是 $0005$，只是 $5$。\n", "test_cases": [{"input": "11", "output": "1\n4\n1\n1\n1\n1\n1\n1\n1\n1"}, {"input": "1\n", "output": "0\n1\n0\n0\n0\n0\n0\n0\n0\n0"}], "test": "#undef NDEBUG\n#include<assert.h>\nint main(){\n    assert(solution(\"11\") == \"1\\n4\\n1\\n1\\n1\\n1\\n1\\n1\\n1\\n1\");\n    assert(solution(\"1\\n\") == \"0\\n1\\n0\\n0\\n0\\n0\\n0\\n0\\n0\\n0\");\n    return 0; \n}", "prompt": "/*A book has $n$ pages, numbered from $1$ to $n$. Please determine how many times each digit $0$ to $9$ is used in the page numbers. Note that leading zeros are not allowed in page numbers, so for example, the 5th page of a book with $n=1234$ is labeled as 5, not 0005.\n\ninput_format:\nA positive integer $n$represents the total page number.\n\noutput_format:\nOutput a total of ten lines, where the number of $k$behavior digits $k-1$.\n*/\n\n#include<sstream>\n#include<stdlib.h>\n#include<algorithm>\n#include<math.h>\n#include<stdio.h>\n#include<vector>\n#include<string>\n#include<climits>\n#include<cstring>\n#include<iostream>\nusing namespace std;\n\n             \nstring solution(string std_in){\n    istringstream iss(std_in);\n             ", "constraints": "对于 $100\\%$ 数据，满足 $1\\le n\\le 10^9$。\n\n---\n\n$2022.7.4$：新添加三组 $\\text{Hack}$ 数据。", "samples": [["11", "1\n4\n1\n1\n1\n1\n1\n1\n1\n1"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072]}}
{"task_id": "P6272", "title": "[湖北省队互测2014]没有人的算术", "difficulty": "advanced", "nl": "Before the beginning of everything, the universe was an endless chaotic darkness, through which only the Spirit of God passed.\n\nGod was displeased with the endless darkness, and waved His hand, saying, \"Let there be light.\" And so there was light. From this day on, there was the alternation of day and night in the world. This was the first day of God's creation.\n\nOn the second day, God was still dissatisfied with the empty scenery before Him, and He waved His hand, saying, \"Let there be zero.\" And so the first number appeared in the world: $0$.\n\nOn the third day, God was unhappy with there being only $0$, so He waved His hand, saying, \"Let there be non-zero numbers.\" And so God began to create new numbers, each new number represented by an ordered pair of a number that had already been created, that is:\n\n$$\nx = (x_L, x_R)\n$$\n\nAnd so $(0, 0), (0, (0, 0)), ((0, 0), 0), ((0, 0), (0, 0)), ...$ appeared. At night, all kinds of strange numbers galloped on the earth.\n(Note: This \"number\" that God created is different from ordinary natural numbers, rational numbers, etc. This type of number is recursively defined as described above and always has a pair of numbers in the pair, which, when broken down to the end, will result in an unbreakable $0$.)\n\nOn the fourth day, God saw that the various numbers were indistinguishable, so He waved His hand and said, \"Let there be distinction.\" And so, in order to distinguish each number, God defined equivalence as follows:\n\n1. $0 = 0$.\n\n2. For any $x_L, x_R, y_L, y_R$, if $x_L = y_L$ and $x_R = y_R$, then $(x_L, x_R) = (y_L, y_R)$.\n\n3. For any $x, y$, $x = y$ if and only if one of the above conditions is satisfied. Conversely, we write $x \\not = y$.\n\nOn the fifth day, God saw that the various numbers were in chaos, so He waved His hand and said, \"Let there be order.\" And so, in order to compare each number, God defined less than as follows:\n\n1. For any $x$, if $x\\not = 0$, then $0 < x$.\n2. For any $x_L, x_R, y_L, y_R$, if $x_L < y_L$, then $(x_L, x_R) < (y_L, y_R)$.\n3. For any $x_L, x_R, y_L, y_R$, if $x_L = y_L$ and $x_R < y_R$, then $(x_L, x_R) < (y_L, y_R)$.\n4. For any $x, y$, $x < y$ if and only if one of the above conditions is satisfied. Conversely, we write $x\\not < y$.\n\nOn the basis of this, we define less than or equal to: $x ≤ y ⇐⇒ x < y$ or $x = y$. It is easy to find that:\n\n1. $x ≤ y, y ≤ x ⇒ x = y$.\n2. $x ≤ y, y ≤ z ⇒ x ≤ z$.\n3. $x ≤ y$ or $y ≤ x$.\n\nAnd then define:\n\n1. $x > y \\Longleftrightarrow  y < x$ .\n2. $x ≥ y \\Longleftrightarrow   x\\not < y$.\n\nEverything is flourishing now, harmoniously together.\n\nOn the sixth day, due to previous indulgence in arithmetic and forgetting to create nucleic acids and proteins, God could not create humans. But God was not satisfied and waved His hand, saying, \"Let there be fleas,\" and so He made the magical creature flea out of mud.\n\nGod created everything in the world in five days, and in the sixth day, He created the only life - the flea. God saw that everything was orderly and thriving, and the flea He made was happily playing with mathematics, so God was pleased and decided to make the seventh day a day of rest.\n\nThe flea's daily life is very simple. At the beginning of each day, he takes an array of length $n$, $a[1], a[2], ..., a[n]$, all initially set to $0$.\n\nThen he continues to do one of the following two things:\n\n1. He generates three positive integers $l$, $r$, and $k$ in his mind, and then reassigns $a[k]$ to $(a[l], a[r])$. Specifically, if $l=k$ or $r=k$, it is also legal, because the flea always calculates $(a[l], a[r])$ silently before assigning it to $a[k]$.\n\n    It is guaranteed that $1 \\leq l, r, k \\leq n$.\n\n2. He generates two positive integers $l$ and $r$ in his mind and then calculates the maximum value of $a[l], a[l+1], ..., a[r−1], a[r]$.\n\n    It is guaranteed that $1 \\leq l \\leq r \\leq n$.\n\nOf course, the flea knows what to do! But he wants to test you...", "code": "#include<cstdio>\n#include<algorithm>\n#include<iostream>\n#include<cmath>\n#include<map>\n#include<iomanip>\n#include<cstring>\n#define reg register\n#define EN std::puts(\"\")\n#define LL long long\ninline int read(){\n\tregister int x=0;register int y=1;\n\tregister char c=std::getchar();\n\twhile(c<'0'||c>'9'){if(c=='-') y=0;c=std::getchar();}\n\twhile(c>='0'&&c<='9'){x=x*10+(c^48);c=std::getchar();}\n\treturn y?x:-x;\n}\n#define N 500005\nint n,m;\nstruct GOAT{\n\t#define alpha 0.7\n\tstruct tr;\n\tstruct data{\n\t\ttr *l,*r;\n\t\tinline int operator <(const data &x){\n\t\t\treturn l->a==x.l->a?r->a<x.r->a:l->a<x.l->a;\n\t\t}\n\t\tinline int operator==(const data &x){\n\t\t\treturn l->a==x.l->a&&r->a==x.r->a;\n\t\t}\n\t};\n\tstruct tr{\n\t\ttr *ls,*rs;\n\t\tint size;\n\t\tdata val;\n\t\tdouble a;\n\t}*root,*null,**badtag,dizhi[N],*nodes[N],*pos[N];\n\tdouble badtagL,badtagR;\n\tint tot,node;\n\tinline void init(){\n\t\tnull=&dizhi[0];\n\t\tnull->val=(data){0,0};\n\t\tnull->size=0;\n\t\troot=null;\n\t}\n\tinline int isbad(tr *tree){\n\t\treturn tree->ls->size>tree->size*alpha+5||tree->rs->size>tree->size*alpha+5;\n\t}\n\tvoid dfs(tr *tree){\n\t\tif(tree->ls!=null) dfs(tree->ls);\n\t\tnodes[++node]=tree;\n\t\tif(tree->rs!=null) dfs(tree->rs);\n\t}\n\ttr* build(int l,int r,double L,double R){\n\t\tif(l>r) return null;\n\t\tdouble MID=(L+R)/2;\n\t\tif(l==r){\n\t\t\tnodes[l]->ls=nodes[l]->rs=null;\n\t\t\tnodes[l]->size=1;\n\t\t\tnodes[l]->a=MID;\n\t\t\treturn nodes[l];\n\t\t}\n\t\tint mid=(l+r)>>1;\n\t\tnodes[mid]->ls=build(l,mid-1,L,MID);nodes[mid]->rs=build(mid+1,r,MID,R);\n\t\tnodes[mid]->size=1+nodes[mid]->ls->size+nodes[mid]->rs->size;\n\t\tnodes[mid]->a=MID;\n\t\treturn nodes[mid];\n\t}\n\tinline void rebuild(tr *&tree){\n\t\tnode=0;dfs(tree);\n\t\ttree=build(1,node,badtagL,badtagR);\n\t}\n\ttr* insert(tr *&tree,double l,double r,data k){\n\t\tdouble mid=(l+r)/2;\n\t\tif(tree==null){\n\t\t\ttree=&dizhi[++tot];\n\t\t\ttree->ls=tree->rs=null;\n\t\t\ttree->val=k;\n\t\t\ttree->a=mid;\n\t\t\ttree->size=1;\n\t\t\treturn tree;\n\t\t}\n\t\tif(k==tree->val) return tree;\n\t\ttree->size++;\n\t\ttr* ret;\n\t\tif(k<tree->val) ret=insert(tree->ls,l,mid,k);\n\t\telse ret=insert(tree->rs,mid,r,k);\n\t\tif(isbad(tree)) badtag=&tree,badtagL=l,badtagR=r;\n\t\treturn ret;\n\t}\n\tinline tr* Insert(data k){\n\t\tbadtag=NULL;\n\t\ttr *ret=insert(root,1,1e9,k);\n\t\tif(badtag) rebuild(*badtag);\n\t\treturn ret;\n\t}\n\t#undef alpha\n}B;\nstruct SEG{\n\tstruct tr{\n\t\ttr *ls,*rs;\n\t\tint pos;\n\t}dizhi[N],*root=&dizhi[0];\n\tint tot;\n\tvoid build(tr *tree,int l,int r){\n\t\tif(l==r) return tree->pos=l,void();\n\t\ttree->ls=&dizhi[++tot];tree->rs=&dizhi[++tot];\n\t\tint mid=(l+r)>>1;\n\t\tbuild(tree->ls,l,mid);build(tree->rs,mid+1,r);\n\t\ttree->pos=l;\n\t}\n\tvoid change(tr *tree,int l,int r,int pos){\n\t\tif(l==r) return;\n\t\tint mid=(l+r)>>1;\n\t\tif(pos<=mid) change(tree->ls,l,mid,pos);\n\t\telse change(tree->rs,mid+1,r,pos);\n\t\ttree->pos=B.pos[tree->ls->pos]->a>=B.pos[tree->rs->pos]->a?tree->ls->pos:tree->rs->pos;\n\t}\n\tint get(tr *tree,int l,int r,int ql,int qr){\n\t\tif(ql<=l&&r<=qr) return tree->pos;\n\t\tint mid=(l+r)>>1;\n\t\tif(qr<=mid) return get(tree->ls,l,mid,ql,qr);\n\t\tif(ql>mid) return get(tree->rs,mid+1,r,ql,qr);\n\t\tint L=get(tree->ls,l,mid,ql,qr),R=get(tree->rs,mid+1,r,ql,qr);\n\t\treturn B.pos[L]->a>=B.pos[R]->a?L:R;\n\t}\n}A;\nint main(){\n\tn=read();m=read();\n\tB.init();\n\tB.Insert((GOAT::data){B.null,B.null});\n\tA.build(A.root,1,n);\n\tfor(reg int i=1;i<=n;i++) B.pos[i]=B.root;\n\treg int l,r,k;char c;\n\twhile(m--){\n\t\tc=getchar();\n\t\twhile(c!='Q'&&c!='C') c=getchar();\n\t\tl=read();r=read();\n\t\tif(c=='C'){\n\t\t\tk=read();\n\t\t\tB.pos[k]=B.Insert((GOAT::data){B.pos[l],B.pos[r]});\n\t\t\tA.change(A.root,1,n,k);\n\t\t}\n\t\telse printf(\"%d\\n\",A.get(A.root,1,n,l,r));\n\t}\n\treturn 0;\n}", "step": ["Initialize values of variables and create structure for data.", "Build values of segment tree.", "Rebuild the structure according to alpha if necessary.", "Insert values into data structure.", "Update segment tree.", "Query the structure and output the results."], "nl_cn": "万物初始之前，宇宙是无边无际混沌的黑暗，只有上帝之灵穿行其间。\n\n上帝对这无边的黑暗十分不满，就一挥手说:“要有光”，于是世间就有了光。从此，世间 就有了昼与夜的交替。这是上帝创世的第一天。\n\n第二天，上帝仍不满意眼前空洞的景象，就一挥手说：“要有零”。于是世间出现了第一个数：$0$。\n\n第三天，上帝对只有 $0$ 很不满意，就一挥手说：“要有非零数”。于是上帝开始创造新数，每个新数用一个已经创造出来的数的有序对表示，即：\n\n$$\nx = (x_L, x_R)\n$$\n\n于是世间出现了 $(0, 0), (0, (0, 0)), ((0, 0), 0), ((0, 0), (0, 0)), ...$。到了晚上，各种各样千奇百怪的数在大地上奔腾。\n（注：上帝造的这个 “数” 与普通的自然数、有理数之类的不同，这种数是以如上所述的方式递归定义的，总是数对里面是数对，拆分到最后会得到不可再拆的 $0$）\n\n第四天，上帝看到各个数不分彼此，就一挥手说：“要有区别”。于是为了区分每个数，上帝定义等于：\n\n1.  $0 = 0$ 。\n\n2.  对于任意 $x_L, x_R, y_L, y_R$，若 $x_L = y_L$ 且 $x_R = y_R$，则 $(x_L, x_R) = (y_L, y_R)$。\n\n3.  对于任意 $x, y$，$x = y$ 当且仅当满足以上条件之一。反之记作 $x \\not = y$。\n\n第五天，上帝看到各个数乱成一团，就一挥手说：“要有序”。于是为了比较每个数，上帝定义小于：\n\n1. 对于任意 $x$，若 $x\\not = 0$，则 $0 < x$。\n2. 对于任意 $x_L, x_R, y_L, y_R$，若 $x_L < y_L$，则 $(x_L, x_R) < (y_L, y_R)$ 。\n3. 对于任意 $x_L, x_R, y_L, y_R$，若 $x_L = y_L$ 且 $x_R < y_R$，则 $(x_L, x_R) < (y_L, y_R)$。\n4. 对于任意 $x, y$，$x < y$ 当且仅当满足以上条件之一。反之记作 $x\\not < y$。\n\n在此基础上定义小于等于：$x ≤ y ⇐⇒ x < y$ 或 $x = y$ 。容易发现：\n\n1. $x ≤ y, y ≤ x ⇒ x = y$ 。\n2. $x ≤ y, y ≤ z ⇒ x ≤ z$ 。\n3. $x ≤ y$ 或 $y ≤ x$ 。\n\n进而定义：\n\n1. $x > y \\Longleftrightarrow  y < x$ 。\n2. $x ≥ y \\Longleftrightarrow   x\\not < y$。\n\n\f至此万物欣欣向荣，和睦一堂。\n\n第六天，由于之前沉迷与算术而忘记去造核酸和蛋白质，所以上帝没办法造人。但是上帝不甘心，就一挥手说：“要有跳蚤”，于是用泥巴捏出了神奇生物跳蚤。\n\n上帝用五天的时间造出天地万物，又在第六天造出了唯一的生命——跳蚤。上帝看到天地万物井然有序、生生不息，自己造的跳蚤正在开心地和数学玩耍，很高兴，便决定把第七天作为休息的日子。\n\n跳蚤每天的生活很简单。一天开始时，他会取一个长度为 $n$ 的数组 $a[1], a[2], ..., a[n]$，初始时均为 $0$。\n\n接着他会不断地做下列两件事之一：\n\n1. 在头脑中产生三个正整数 $l, r, k$，然后把 $a[k]$ 重新赋值为 $(a[l], a[r])$ 。特别地，如果 $l = k$ 或 $r = k$ 也是合法的，这不会导致错误，因为跳蚤总是先默默算出 $(a[l], a[r])$ 再给 $a[k]$ 赋值。\n\n    保证 $1 ≤ l, r, k ≤ n$。\n\n2. 在头脑中产生两个正整数 $l, r$，然后计算 $a[l], a[l + 1], ..., a[r − 1], a[r]$ 中的最大值。\n\n     保证 $1 ≤ l ≤ r ≤ n$。\n\n跳蚤当然知道怎么做啦！但是他想考考你……", "test_cases": [{"input": "5 10 \nC 1 1 1 \nC 2 1 2 \nQ 1 2 \nC 4 4 4 \nC 5 5 5 \nQ 4 5 \nQ 3 3 \nC 4 2 3 \nC 4 4 4 \nQ 3 4", "output": "2\n4\n3\n3"}, {"input": "2 4 \nC 1 1 1 \nC 2 1 2 \nQ 1 2 \nQ 2 2", "output": "2\n2"}, {"input": "1 3 \nC 1 1 1 \nQ 1 1 \nQ 1 1", "output": "1\n1"}, {"input": "3 5 \nC 1 1 1 \nC 2 1 2 \nC 3 2 3 \nQ 1 3 \nQ 2 2", "output": "3\n2"}, {"input": "5 10\nC 1 1 1\nC 2 1 2\nQ 1 2\nC 4 4 4\nC 5 5 5\nQ 4 5\nQ 3 3\nC 4 2 3\nC 4 4 4\nQ 3 4", "output": "2\n4\n3\n3"}, {"input": "1 2\nC 1 1 1\nQ 1 1", "output": "1"}, {"input": "2 2\nC 1 1 1\nQ 1 2", "output": "1"}], "test": "#undef NDEBUG\n#include<assert.h>\nint main(){\n    assert(solution(\"5 10 \\nC 1 1 1 \\nC 2 1 2 \\nQ 1 2 \\nC 4 4 4 \\nC 5 5 5 \\nQ 4 5 \\nQ 3 3 \\nC 4 2 3 \\nC 4 4 4 \\nQ 3 4\") == \"2\\n4\\n3\\n3\");\n    assert(solution(\"2 4 \\nC 1 1 1 \\nC 2 1 2 \\nQ 1 2 \\nQ 2 2\") == \"2\\n2\");\n    assert(solution(\"1 3 \\nC 1 1 1 \\nQ 1 1 \\nQ 1 1\") == \"1\\n1\");\n    assert(solution(\"3 5 \\nC 1 1 1 \\nC 2 1 2 \\nC 3 2 3 \\nQ 1 3 \\nQ 2 2\") == \"3\\n2\");\n    assert(solution(\"5 10\\nC 1 1 1\\nC 2 1 2\\nQ 1 2\\nC 4 4 4\\nC 5 5 5\\nQ 4 5\\nQ 3 3\\nC 4 2 3\\nC 4 4 4\\nQ 3 4\") == \"2\\n4\\n3\\n3\");\n    assert(solution(\"1 2\\nC 1 1 1\\nQ 1 1\") == \"1\");\n    assert(solution(\"2 2\\nC 1 1 1\\nQ 1 2\") == \"1\");\n    return 0; \n}", "prompt": "/*Before the beginning of everything, the universe was an endless chaotic darkness, through which only the Spirit of God passed.\n\nGod was displeased with the endless darkness, and waved His hand, saying, \"Let there be light.\" And so there was light. From this day on, there was the alternation of day and night in the world. This was the first day of God's creation.\n\nOn the second day, God was still dissatisfied with the empty scenery before Him, and He waved His hand, saying, \"Let there be zero.\" And so the first number appeared in the world: $0$.\n\nOn the third day, God was unhappy with there being only $0$, so He waved His hand, saying, \"Let there be non-zero numbers.\" And so God began to create new numbers, each new number represented by an ordered pair of a number that had already been created, that is:\n\n$$\nx = (x_L, x_R)\n$$\n\nAnd so $(0, 0), (0, (0, 0)), ((0, 0), 0), ((0, 0), (0, 0)), ...$ appeared. At night, all kinds of strange numbers galloped on the earth.\n(Note: This \"number\" that God created is different from ordinary natural numbers, rational numbers, etc. This type of number is recursively defined as described above and always has a pair of numbers in the pair, which, when broken down to the end, will result in an unbreakable $0$.)\n\nOn the fourth day, God saw that the various numbers were indistinguishable, so He waved His hand and said, \"Let there be distinction.\" And so, in order to distinguish each number, God defined equivalence as follows:\n\n1. $0 = 0$.\n\n2. For any $x_L, x_R, y_L, y_R$, if $x_L = y_L$ and $x_R = y_R$, then $(x_L, x_R) = (y_L, y_R)$.\n\n3. For any $x, y$, $x = y$ if and only if one of the above conditions is satisfied. Conversely, we write $x \\not = y$.\n\nOn the fifth day, God saw that the various numbers were in chaos, so He waved His hand and said, \"Let there be order.\" And so, in order to compare each number, God defined less than as follows:\n\n1. For any $x$, if $x\\not = 0$, then $0 < x$.\n2. For any $x_L, x_R, y_L, y_R$, if $x_L < y_L$, then $(x_L, x_R) < (y_L, y_R)$.\n3. For any $x_L, x_R, y_L, y_R$, if $x_L = y_L$ and $x_R < y_R$, then $(x_L, x_R) < (y_L, y_R)$.\n4. For any $x, y$, $x < y$ if and only if one of the above conditions is satisfied. Conversely, we write $x\\not < y$.\n\nOn the basis of this, we define less than or equal to: $x ≤ y ⇐⇒ x < y$ or $x = y$. It is easy to find that:\n\n1. $x ≤ y, y ≤ x ⇒ x = y$.\n2. $x ≤ y, y ≤ z ⇒ x ≤ z$.\n3. $x ≤ y$ or $y ≤ x$.\n\nAnd then define:\n\n1. $x > y \\Longleftrightarrow  y < x$ .\n2. $x ≥ y \\Longleftrightarrow   x\\not < y$.\n\nEverything is flourishing now, harmoniously together.\n\nOn the sixth day, due to previous indulgence in arithmetic and forgetting to create nucleic acids and proteins, God could not create humans. But God was not satisfied and waved His hand, saying, \"Let there be fleas,\" and so He made the magical creature flea out of mud.\n\nGod created everything in the world in five days, and in the sixth day, He created the only life - the flea. God saw that everything was orderly and thriving, and the flea He made was happily playing with mathematics, so God was pleased and decided to make the seventh day a day of rest.\n\nThe flea's daily life is very simple. At the beginning of each day, he takes an array of length $n$, $a[1], a[2], ..., a[n]$, all initially set to $0$.\n\nThen he continues to do one of the following two things:\n\n1. He generates three positive integers $l$, $r$, and $k$ in his mind, and then reassigns $a[k]$ to $(a[l], a[r])$. Specifically, if $l=k$ or $r=k$, it is also legal, because the flea always calculates $(a[l], a[r])$ silently before assigning it to $a[k]$.\n\n    It is guaranteed that $1 \\leq l, r, k \\leq n$.\n\n2. He generates two positive integers $l$ and $r$ in his mind and then calculates the maximum value of $a[l], a[l+1], ..., a[r−1], a[r]$.\n\n    It is guaranteed that $1 \\leq l \\leq r \\leq n$.\n\nOf course, the flea knows what to do! But he wants to test you...\n\ninput_format:\nThe first line has two positive integers $n, m$, representing an array of length $n$, with a total of $m$operations. Next $m$lines each represent an action:\n\n1. 'C l r k' : The assignment operation, $a[k] = (a[l], a[r])$.\n\n2. 'Q l r' : query operation, calculate $a[l], a[l + 1],... , a[r − 1], the maximum value of a[r]$. Output the subscript corresponding to the maximum value. If there are multiple maximum values then take the one with the smallest subscript.\n\noutput_format:\nThe output line for each query operation represents the corresponding result.\n*/\n\n#include<sstream>\n#include<stdlib.h>\n#include<algorithm>\n#include<math.h>\n#include<stdio.h>\n#include<vector>\n#include<string>\n#include<climits>\n#include<cstring>\n#include<iostream>\nusing namespace std;\n\n             \nstring solution(string std_in){\n    istringstream iss(std_in);\n             ", "constraints": "$$\n\\def\\arraystretch{1.5}\n\\begin{array}{c|l|l}\n\\hline\\hline \\rm Task~Id & n & m \\\\\n\\hline\\hline 1 & =10 & =50 \\\\\n\\hline 2 & =5\\times 10^4 & \\leq 2\\times 10^5 \\\\\n\\hline 3 & =5\\times 10^4 & \\leq 2\\times 10^5 \\\\\n\\hline 4 & =6\\times 10^4 & \\leq 5\\times 10^5 \\\\\n\\hline 5 & =6\\times 10^4 & \\leq 5\\times 10^5 \\\\\n\\hline 6 & =8\\times 10^4 & \\leq 2\\times 10^5 \\\\\n\\hline 7 & =8\\times 10^4 & \\leq 2\\times 10^5 \\\\\n\\hline 8 & =10^5 & \\leq 5\\times 10^5 \\\\\n\\hline 9 & =10^5 & \\leq 5\\times 10^5 \\\\\n\\hline 10 & =10^5 & \\leq 5\\times 10^5 \\\\\n\\hline\\hline\n\\end{array}\n$$", "samples": [["5 10 \nC 1 1 1 \nC 2 1 2 \nQ 1 2 \nC 4 4 4 \nC 5 5 5 \nQ 4 5 \nQ 3 3 \nC 4 2 3 \nC 4 4 4 \nQ 3 4", "2\n4\n3\n3"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}}
{"task_id": "P7281", "title": "[COCI2020-2021#4] Vepar", "difficulty": "advanced", "nl": "Given two sets of positive integers $\\{a,a+1,\\cdots,b\\}$ and $\\{c,c+1,\\cdots,d\\}$, determine whether $c \\cdot (c+1)\\cdots d$ is divisible by $a \\cdot (a+1)\\cdots b$.", "code": "#include <cstdio>\n#include <cstring>\n#include <algorithm>\n\nusing namespace std;\n\nconst int N = 2e7 + 10;\n\nint p[N], cnt;\nbool st[N];\n\nvoid prime(int n)\n{\n\tfor(int i = 2; i <= n; i++)\n\t{\n\t\tif(!st[i]) p[++cnt] = i;\n\t\tfor(int j = 1; p[j] * i <= n; j++)\n\t\t{\n\t\t\tst[i * p[j]] = true;\n\t\t\tif(i % p[j] == 0) break;\n\t\t}\n\t}\n}\n\nint count(int x, int a)\n{\n\tint ans = 0;\n\twhile(x)\n\t{\n\t\tans += x / a;\n\t\tx /= a;\n\t}\n\treturn ans;\n}//计算a在1~x中出现了几次\n\nint main()\n{\n\tprime(2e7);//筛质数\n\t\n\tint T;\n\tscanf(\"%d\", &T);\n\twhile(T--)\n\t{\n\t\tint a, b, c, d;\n\t\tscanf(\"%d%d%d%d\", &a, &b, &c, &d);\n\t\t\n\t\tbool f = true;\n\t\tfor(int i = 1; p[i] <= b; i++)\n\t\t{\n\t\t\tint cnt1 = count(b, p[i]) - count(a - 1, p[i]), cnt2 = count(d, p[i]) - count(c - 1, p[i]);\n\t\t\tif(cnt1 > cnt2)//判断能否整除\n\t\t\t{\n\t\t\t\tputs(\"NE\");\n\t\t\t\tf = false;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\t\n\t\tif(f) puts(\"DA\");\n\t}\n}", "step": ["Read integer values for T, a, b, c, and d.", "Generate prime numbers using the Miller Rabin primality test.", "Iterate over prime numbers and count their occurrences in prime factorization of a - 1, b - 1, c - 1, and d - 1.", "Compute S and P as per the instructions.", "If S is greater than P, return NE, else return DA.", "Print the result."], "nl_cn": "给定两组正整数 $\\{a,a+1,\\cdots,b\\}$ 和 $\\{c,c+1,\\cdots,d\\}$。判断 $c \\cdot (c+1)\\cdots d$ 能否被 $a \\cdot (a+1)\\cdots b$ 整除。", "test_cases": [{"input": "2\n9 10 3 6\n2 5 7 9", "output": "DA\nNE"}, {"input": "6\n1 2 3 4\n1 4 2 3\n2 3 1 4\n1 3 2 4\n19 22 55 57\n55 57 19 22", "output": "DA\nNE\nDA\nDA\nDA\nDA"}, {"input": "1\n1 10 1 10\n", "output": "DA"}, {"input": "1\n4 4 4 4\n", "output": "DA"}, {"input": "2\n10 15 25 30\n5 10 3 8\n", "output": "NE\nNE"}, {"input": "1\n50 60 100 200\n", "output": "DA"}, {"input": "2\n10 20 30 40\n40 50 60 70\n", "output": "DA\nNE"}, {"input": "2\n1 1 2 2\n2 2 3 3\n", "output": "DA\nNE"}, {"input": "1\n5 10 10 15\n", "output": "NE"}, {"input": "1\n2 7 2 6", "output": "NE"}, {"input": "1\n4 5 1 4\n", "output": "NE"}, {"input": "2\n2 5 1 3\n5 6 2 4\n", "output": "NE\nNE"}, {"input": "1\n8 12 1 7\n", "output": "NE"}, {"input": "2\n2 4 1 3\n3 5 2 4\n", "output": "NE\nNE"}, {"input": "3\n1 4 3 4\n2 4 1 3\n4 5 2 3\n", "output": "NE\nNE\nNE"}, {"input": "1\n10 15 3 9\n", "output": "NE"}, {"input": "3\n6 10 5 9\n8 12 2 10\n3 7 1 8\n", "output": "NE\nNE\nDA"}, {"input": "2\n1 6 5 8\n4 9 2 7\n", "output": "NE\nNE"}, {"input": "2\n1 6 2 8\n3 7 1 9\n", "output": "DA\nDA"}, {"input": "1\n2 7 4 5\n", "output": "NE"}], "test": "#undef NDEBUG\n#include<assert.h>\nint main(){\n    assert(solution(\"2\\n9 10 3 6\\n2 5 7 9\") == \"DA\\nNE\");\n    assert(solution(\"6\\n1 2 3 4\\n1 4 2 3\\n2 3 1 4\\n1 3 2 4\\n19 22 55 57\\n55 57 19 22\") == \"DA\\nNE\\nDA\\nDA\\nDA\\nDA\");\n    assert(solution(\"1\\n1 10 1 10\\n\") == \"DA\");\n    assert(solution(\"1\\n4 4 4 4\\n\") == \"DA\");\n    assert(solution(\"2\\n10 15 25 30\\n5 10 3 8\\n\") == \"NE\\nNE\");\n    assert(solution(\"1\\n50 60 100 200\\n\") == \"DA\");\n    assert(solution(\"2\\n10 20 30 40\\n40 50 60 70\\n\") == \"DA\\nNE\");\n    assert(solution(\"2\\n1 1 2 2\\n2 2 3 3\\n\") == \"DA\\nNE\");\n    assert(solution(\"1\\n5 10 10 15\\n\") == \"NE\");\n    assert(solution(\"1\\n2 7 2 6\") == \"NE\");\n    assert(solution(\"1\\n4 5 1 4\\n\") == \"NE\");\n    assert(solution(\"2\\n2 5 1 3\\n5 6 2 4\\n\") == \"NE\\nNE\");\n    assert(solution(\"1\\n8 12 1 7\\n\") == \"NE\");\n    assert(solution(\"2\\n2 4 1 3\\n3 5 2 4\\n\") == \"NE\\nNE\");\n    assert(solution(\"3\\n1 4 3 4\\n2 4 1 3\\n4 5 2 3\\n\") == \"NE\\nNE\\nNE\");\n    assert(solution(\"1\\n10 15 3 9\\n\") == \"NE\");\n    assert(solution(\"3\\n6 10 5 9\\n8 12 2 10\\n3 7 1 8\\n\") == \"NE\\nNE\\nDA\");\n    assert(solution(\"2\\n1 6 5 8\\n4 9 2 7\\n\") == \"NE\\nNE\");\n    assert(solution(\"2\\n1 6 2 8\\n3 7 1 9\\n\") == \"DA\\nDA\");\n    assert(solution(\"1\\n2 7 4 5\\n\") == \"NE\");\n    return 0; \n}", "prompt": "/*Given two sets of positive integers $\\{a,a+1,\\cdots,b\\}$ and $\\{c,c+1,\\cdots,d\\}$, determine whether $c \\cdot (c+1)\\cdots d$ is divisible by $a \\cdot (a+1)\\cdots b$.\n\ninput_format:\nEnter an integer $t$on the first line to represent the number of data sets.\n\nIn the next $t$line, enter four integers $a_i,b_i,c_i,d_i$.\n\noutput_format:\nOutput a total of $t$rows. For the $i$line, if $c_i \\cdot (c_i+1)\\cdots d_i$can be evenly divided by $a_i \\cdot (a_i+1)\\cdots b_i$, output 'DA', otherwise output 'NE'.\n*/\n\n#include<sstream>\n#include<stdlib.h>\n#include<algorithm>\n#include<math.h>\n#include<stdio.h>\n#include<vector>\n#include<string>\n#include<climits>\n#include<cstring>\n#include<iostream>\nusing namespace std;\n\n             \nstring solution(string std_in){\n    istringstream iss(std_in);\n             ", "constraints": "#### 样例 1 解释\n\n按照题意分别相乘得到 $9 \\times 10=90$ 和 $3 \\times 4 \\times 5 \\times 6=360$。由于 $90$ 能被 $360$ 整除，因此输出 `DA`。\n\n我们得到 $2 \\times 3 \\times 4 \\times 5=120$ 和 $7 \\times 8 \\times 9=504$。而 $120$ 不能被 $504$ 整除，因此输出 `NE`。\n\n#### 数据规模与约定\n\n本题**不采用捆绑评测**，通过对应测试点就可以拿到对应的分数，但有若干个约束。\n\n| 约束编号 | 分值 | 数据范围及约定 |\n| :----------: | :----------: | :----------: |\n| $1$ | $10$ | $a_i,b_i,c_i,d_i \\le 50$ |\n| $2$ | $20$ | $a_i,b_i,c_i,d_i \\le 1000$ |\n| $3$ | $10$ | $a_i=1$ |\n| $4$ | $30$ | 无 |\n\n对于 $100\\%$ 的数据，$1 \\le t \\le 10$，$1 \\le a_i \\le b_i \\le 10^7$，$1 \\le c_i \\le d_i \\le 10^7$。\n\n#### 说明\n\n**本题分值按 COCI 原题设置，满分 $70$。**\n\n**题目译自 [COCI2020-2021](https://hsin.hr/coci/) [CONTEST #4](https://hsin.hr/coci/contest4_tasks.pdf)  _T2 Vepar_。**", "samples": [["2\n9 10 3 6\n2 5 7 9", "DA\nNE"], ["6\n1 2 3 4\n1 4 2 3\n2 3 1 4\n1 3 2 4\n19 22 55 57\n55 57 19 22", "DA\nNE\nDA\nDA\nDA\nDA"]], "limits": {"time": [1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500], "memory": [512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000]}}
{"task_id": "P9121", "title": "[USACO23FEB] Hungry Cow B", "difficulty": "challenge", "nl": "Bessie is a hungry cow. Every night, she will eat a stack of hay if there is one in the barn. Farmer John doesn't want Bessie to go hungry, so on some days he will deliver a shipment of hay that arrives before dinner. On day $d_i$, Farmer John will deliver $b_i$ stacks of hay $(1 \\le d_i \\le 10^{14}, 1\\le b_i\\le 10^9)$.\n\nCalculate how many stacks of hay Bessie will eat in total during the first $T$ days.", "code": "#include<bits/stdc++.h>\nusing namespace std;\nlong long n,t,sum,ans,pos,d[100010],b[100010];\nint main(){\n\tscanf(\"%lld%lld\",&n,&t);\n\tfor(long long i=1;i<=n;i++){\n\t\tscanf(\"%lld%lld\",&d[i],&b[i]);\n\t\tpos=min(sum,d[i]-d[i-1]);\n\t\tsum-=pos,ans+=pos,sum+=b[i];\n\t}\n\tprintf(\"%lld\",ans+min(sum,t-d[n]+1));\n\treturn 0;\n}", "step": ["Read in n and t", "Read in arrays d and b of size n", "Calculate the amount of food Lola will need along her route", "Output the result"], "nl_cn": "Bessie is a hungry cow. Each day, for dinner, if there is a haybale in the barn, she will eat one haybale. Farmer John does not want Bessie to starve, so some days he sends a delivery of haybales, which arrive in the morning (before dinner). In particular, on day $d_i$, Farmer John sends a delivery of $b_i$ haybales $(1 \\le d_i \\le 10^{14}, 1 \\le b_i \\le 10^9)$.\n\nCompute the total number of haybales Bessie will eat during the first $T$ days.", "test_cases": [{"input": "1 5\n1 2", "output": "2"}, {"input": "2 5\n1 2\n5 10", "output": "3"}, {"input": "2 5\n1 10\n5 10", "output": "5"}, {"input": "3 7\n1 3\n4 1\n6 4", "output": "6"}, {"input": "2 6\n1 2\n5 4", "output": "4"}, {"input": "1 3\n1 2", "output": "2"}, {"input": "2 5\n1 2\n4 4", "output": "4"}, {"input": "2 7\n2 4\n6 1", "output": "5"}, {"input": "2 5\n1 2\n3 4", "output": "5"}, {"input": "1 1\n1 1\n", "output": "1"}, {"input": "5 5\n1 1\n2 1\n3 1\n4 1\n5 1\n", "output": "5"}, {"input": "5 20\n1 10\n2 5\n3 2\n4 1\n5 1\n", "output": "19"}, {"input": "3 10\n1 5\n2 3\n5 4\n", "output": "10"}, {"input": "3 15\n1 10\n5 5\n10 20\n", "output": "15"}, {"input": "3 10\n1 3\n4 4\n8 2\n", "output": "9"}, {"input": "4 10\n1 1\n2 2\n3 3\n4 4\n", "output": "10"}, {"input": "4 10\n1 1\n2 2\n3 2\n4 2\n", "output": "7"}, {"input": "5 10\n1 10\n2 10\n3 10\n4 10\n5 10\n", "output": "10"}, {"input": "5 15\n1 5\n3 2\n5 3\n7 4\n10 1\n", "output": "15"}, {"input": "1 100000\n1 1000000000\n", "output": "100000"}, {"input": "5 20\n1 5\n2 10\n3 1\n4 3\n5 1\n", "output": "20"}, {"input": "10 50\n1 1\n2 1\n3 1\n4 1\n5 1\n6 1\n7 1\n8 1\n9 1\n10 1\n", "output": "10"}, {"input": "4 5\n1 1\n2 2\n3 3\n4 4\n", "output": "5"}, {"input": "2 100\n1 50\n2 50\n", "output": "100"}, {"input": "1 10000\n1 1\n", "output": "1"}, {"input": "2 5\n1 9\n4 3\n", "output": "5"}, {"input": "1 1000\n1 1\n", "output": "1"}, {"input": "5 10\n1 1\n2 2\n3 3\n4 4\n5 5\n", "output": "10"}, {"input": "1 100000\n1 10\n", "output": "10"}], "test": "#undef NDEBUG\n#include<assert.h>\nint main(){\n    assert(solution(\"1 5\\n1 2\") == \"2\");\n    assert(solution(\"2 5\\n1 2\\n5 10\") == \"3\");\n    assert(solution(\"2 5\\n1 10\\n5 10\") == \"5\");\n    assert(solution(\"3 7\\n1 3\\n4 1\\n6 4\") == \"6\");\n    assert(solution(\"2 6\\n1 2\\n5 4\") == \"4\");\n    assert(solution(\"1 3\\n1 2\") == \"2\");\n    assert(solution(\"2 5\\n1 2\\n4 4\") == \"4\");\n    assert(solution(\"2 7\\n2 4\\n6 1\") == \"5\");\n    assert(solution(\"2 5\\n1 2\\n3 4\") == \"5\");\n    assert(solution(\"1 1\\n1 1\\n\") == \"1\");\n    assert(solution(\"5 5\\n1 1\\n2 1\\n3 1\\n4 1\\n5 1\\n\") == \"5\");\n    assert(solution(\"5 20\\n1 10\\n2 5\\n3 2\\n4 1\\n5 1\\n\") == \"19\");\n    assert(solution(\"3 10\\n1 5\\n2 3\\n5 4\\n\") == \"10\");\n    assert(solution(\"3 15\\n1 10\\n5 5\\n10 20\\n\") == \"15\");\n    assert(solution(\"3 10\\n1 3\\n4 4\\n8 2\\n\") == \"9\");\n    assert(solution(\"4 10\\n1 1\\n2 2\\n3 3\\n4 4\\n\") == \"10\");\n    assert(solution(\"4 10\\n1 1\\n2 2\\n3 2\\n4 2\\n\") == \"7\");\n    assert(solution(\"5 10\\n1 10\\n2 10\\n3 10\\n4 10\\n5 10\\n\") == \"10\");\n    assert(solution(\"5 15\\n1 5\\n3 2\\n5 3\\n7 4\\n10 1\\n\") == \"15\");\n    assert(solution(\"1 100000\\n1 1000000000\\n\") == \"100000\");\n    assert(solution(\"5 20\\n1 5\\n2 10\\n3 1\\n4 3\\n5 1\\n\") == \"20\");\n    assert(solution(\"10 50\\n1 1\\n2 1\\n3 1\\n4 1\\n5 1\\n6 1\\n7 1\\n8 1\\n9 1\\n10 1\\n\") == \"10\");\n    assert(solution(\"4 5\\n1 1\\n2 2\\n3 3\\n4 4\\n\") == \"5\");\n    assert(solution(\"2 100\\n1 50\\n2 50\\n\") == \"100\");\n    assert(solution(\"1 10000\\n1 1\\n\") == \"1\");\n    assert(solution(\"2 5\\n1 9\\n4 3\\n\") == \"5\");\n    assert(solution(\"1 1000\\n1 1\\n\") == \"1\");\n    assert(solution(\"5 10\\n1 1\\n2 2\\n3 3\\n4 4\\n5 5\\n\") == \"10\");\n    assert(solution(\"1 100000\\n1 10\\n\") == \"10\");\n    return 0; \n}", "prompt": "/*Bessie is a hungry cow. Every night, she will eat a stack of hay if there is one in the barn. Farmer John doesn't want Bessie to go hungry, so on some days he will deliver a shipment of hay that arrives before dinner. On day $d_i$, Farmer John will deliver $b_i$ stacks of hay $(1 \\le d_i \\le 10^{14}, 1\\le b_i\\le 10^9)$.\n\nCalculate how many stacks of hay Bessie will eat in total during the first $T$ days.\n\ninput_format:\nThe first line contains $N$ and $T$ $(1 \\le N \\le 10^5, 1 \\le T \\le 10^{14})$.\n\nThe next $N$ lines each contain $d_i$ and $b_i$. It is additionally guaranteed that $1 \\le d_1<d_2<\\cdots <d_N \\le T$.\n\noutput_format:\nOutput the number of haybales that Bessie will eat during the first $T$ days.\n\nNote that the large size of integers involved in this problem may require the use of 64-bit integer data types (e.g., a \"long long\" in C/C++).\n*/\n\n#include<sstream>\n#include<stdlib.h>\n#include<algorithm>\n#include<math.h>\n#include<stdio.h>\n#include<vector>\n#include<string>\n#include<climits>\n#include<cstring>\n#include<iostream>\nusing namespace std;\n\n             \nstring solution(string std_in){\n    istringstream iss(std_in);\n             ", "constraints": "### Explanation for Sample 1\n\nTwo haybales arrive on the morning of day $1$. Bessie eats one haybale for dinner on day $1$ and another haybale on day $2$. On days $3 \\cdots 5$, there are no more haybales for Bessie to eat. In total, Bessie eats $2$ haybales during the first $5$ days. \n\n### Explanation for Sample 2\n\nTwo haybales arrive on the morning of day $1$. Bessie eats one haybale on days $1$ and $2$. There are no haybales for Bessie to eat on days $3$ and $4$. On the morning of day $5$, $10$ haybales arrive. Bessie eats one haybale for dinner on day $5$. In total, Bessie eats $3$ haybales during the first $5$ days.\n\n### Explanation for Sample 3\n\n10 haybales arrive on the morning of day $1$. Bessie eats one haybale on days $1 \\cdots 4$. On the morning of day $5$, another $10$ haybales arrive, meaning there are $16$ haybales in the barn. For dinner on day $5$, Bessie eats another haybale. In total, Bessie eats $5$ haybales during the first $5$ days. \n\n### SCORING\n\n - Inputs $4-7$: $T \\le 10^5$\n - Inputs $8-13$: No additional constraints.", "samples": [["1 5\n1 2", "2"], ["2 5\n1 2\n5 10", "3"], ["2 5\n1 10\n5 10", "5"]], "limits": {"time": [2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000], "memory": [262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144]}}
{"task_id": "P1150", "title": "Peter 的烟", "difficulty": "basic", "nl": "Peter has $n$ cigarettes, and after he finishes smoking one, he saves the butt. He can exchange $k$ ($k>1$) butts for a new cigarette. How many cigarettes can Peter end up smoking?\n\nSmoking is harmful to health.", "code": "#include <bits/stdc++.h>\n     using namespace std;\n     int main(){\n         int n,k;\n         cin>>n>>k;\n         cout<<n+(n-1)/(k-1);\n         return 0;\n     }", "step": ["Import necessary libraries", "Declare integer variables 'n' and 'k'", "Accept user input for 'n' and 'k'", "Apply mathematical equation to calculate the result", "Print the result", "End the program"], "nl_cn": "Peter 有 $n$ 根烟，他每吸完一根烟就把烟蒂保存起来，$k$（$k>1$）个烟蒂可以换一个新的烟，那么 Peter 最终能吸到多少根烟呢？\n\n吸烟有害健康。", "test_cases": [{"input": "4 3\n", "output": "5"}, {"input": "10 3", "output": "14"}, {"input": "1 2\n", "output": "1"}, {"input": "12 2\n", "output": "23"}, {"input": "25 5\n", "output": "31"}, {"input": "2 3\n", "output": "2"}, {"input": "6 4\n", "output": "7"}, {"input": "30 5\n", "output": "37"}, {"input": "9 2\n", "output": "17"}, {"input": "50 10\n", "output": "55"}, {"input": "5 4\n", "output": "6"}, {"input": "7 5\n", "output": "8"}, {"input": "20 3\n", "output": "29"}, {"input": "13 2\n", "output": "25"}, {"input": "2 2\n", "output": "3"}, {"input": "6 5\n", "output": "7"}, {"input": "12 5\n", "output": "14"}, {"input": "25 7\n", "output": "29"}, {"input": "7 2\n", "output": "13"}, {"input": "1 10\n", "output": "1"}, {"input": "20 4\n", "output": "26"}, {"input": "100 10\n", "output": "111"}, {"input": "3 4\n", "output": "3"}, {"input": "100 2\n", "output": "199"}, {"input": "50 7\n", "output": "58"}, {"input": "100 3\n", "output": "149"}, {"input": "60 7\n", "output": "69"}, {"input": "500 3\n", "output": "749"}, {"input": "100 5\n", "output": "124"}, {"input": "25 6\n", "output": "29"}, {"input": "5 3\n", "output": "7"}], "test": "#undef NDEBUG\n#include<assert.h>\nint main(){\n    assert(solution(\"4 3\\n\") == \"5\");\n    assert(solution(\"10 3\") == \"14\");\n    assert(solution(\"1 2\\n\") == \"1\");\n    assert(solution(\"12 2\\n\") == \"23\");\n    assert(solution(\"25 5\\n\") == \"31\");\n    assert(solution(\"2 3\\n\") == \"2\");\n    assert(solution(\"6 4\\n\") == \"7\");\n    assert(solution(\"30 5\\n\") == \"37\");\n    assert(solution(\"9 2\\n\") == \"17\");\n    assert(solution(\"50 10\\n\") == \"55\");\n    assert(solution(\"5 4\\n\") == \"6\");\n    assert(solution(\"7 5\\n\") == \"8\");\n    assert(solution(\"20 3\\n\") == \"29\");\n    assert(solution(\"13 2\\n\") == \"25\");\n    assert(solution(\"2 2\\n\") == \"3\");\n    assert(solution(\"6 5\\n\") == \"7\");\n    assert(solution(\"12 5\\n\") == \"14\");\n    assert(solution(\"25 7\\n\") == \"29\");\n    assert(solution(\"7 2\\n\") == \"13\");\n    assert(solution(\"1 10\\n\") == \"1\");\n    assert(solution(\"20 4\\n\") == \"26\");\n    assert(solution(\"100 10\\n\") == \"111\");\n    assert(solution(\"3 4\\n\") == \"3\");\n    assert(solution(\"100 2\\n\") == \"199\");\n    assert(solution(\"50 7\\n\") == \"58\");\n    assert(solution(\"100 3\\n\") == \"149\");\n    assert(solution(\"60 7\\n\") == \"69\");\n    assert(solution(\"500 3\\n\") == \"749\");\n    assert(solution(\"100 5\\n\") == \"124\");\n    assert(solution(\"25 6\\n\") == \"29\");\n    assert(solution(\"5 3\\n\") == \"7\");\n    return 0; \n}", "prompt": "/*Peter has $n$ cigarettes, and after he finishes smoking one, he saves the butt. He can exchange $k$ ($k>1$) butts for a new cigarette. How many cigarettes can Peter end up smoking?\n\nSmoking is harmful to health.\n\ninput_format:\nEach line of test data includes two integers $n, k$ ($1 < n, k \\le 10^8$).\n\noutput_format:\nFor each set of test data, the output line includes an integer representing the number of final smoke.\n*/\n\n#include<sstream>\n#include<stdlib.h>\n#include<algorithm>\n#include<math.h>\n#include<stdio.h>\n#include<vector>\n#include<string>\n#include<climits>\n#include<cstring>\n#include<iostream>\nusing namespace std;\n\n             \nstring solution(string std_in){\n    istringstream iss(std_in);\n             ", "constraints": "对于 $100\\%$ 的数据，$1<n, k \\le 10^8$。\n", "samples": [["4 3\n", "5"], ["10 3", "14"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}}
{"task_id": "P1234", "title": "小 A 的口头禅", "difficulty": "challenge", "nl": "Little A has a catchphrase \"hehe\" recently, so he gave you a rectangle and asked you to calculate how many \"hehe\"s are inside it (the direction does not matter).", "code": "#include<bits/stdc++.h>\nusing namespace std;\nchar a[1005][1005];\nint i,j,cnt=0,m,n;\nint main(){\n\tcin>>n>>m;\n\tmemset(a,' ',sizeof(a)); //初始化（不过不这么做似乎问题不大）\n\tfor(i=1;i<=n;i++){\n\t\tfor(j=1;j<=m;j++)\n\t\t\tcin>>a[i][j];  //读入char数组\n\t}\n      for(i=1;i<=n;i++){\n\t\tfor(j=1;j<=m;j++){\n\t\t\tif(a[i][j]=='h'){ //判断有没有hehe\n\t\t\t\tif(a[i+1][j]=='e'&&a[i+2][j]=='h'&&a[i+3][j]=='e')cnt++;  //横行有没有\n\t\t\t\tif(a[i][j+1]=='e'&&a[i][j+2]=='h'&&a[i][j+3]=='e')cnt++;  //竖列有没有\n\t\t\t}\n           \tif(a[i][j]=='e'){  //判断有没有eheh\n\t\t\t\tif(a[i+1][j]=='h'&&a[i+2][j]=='e'&&a[i+3][j]=='h')cnt++;  //横行有没有\n\t\t\t\tif(a[i][j+1]=='h'&&a[i][j+2]=='e'&&a[i][j+3]=='h')cnt++;  //竖列有没有\n\t\t\t}\n\t\t}\n\t}\n    \tcout<<cnt<<endl;\n\treturn 0;\n}", "step": ["Take input n and m for matrix dimensions", "Initialize ans, n, and m variables", "For each element in the matrix, check if it's 'h'", "If it's 'h', check the elements around it for 'ehe' pattern horizontally and vertically", "If found, increment the count of ans", "Output the count of ans"], "nl_cn": "小 A 最近有了一个口头禅 “呵呵”，于是他给出了一个矩形，让你求出里面有几个 “hehe”（方向无所谓）。\n", "test_cases": [{"input": "5 5\nheheh\nheheh\nheheh\nheheh\nheheh\n", "output": "10"}, {"input": "3 4\nhhhh\neeee\nhehe\n", "output": "1"}, {"input": "1 1\nh\n", "output": "0"}, {"input": "2 2\nhe\neh\n", "output": "0"}, {"input": "2 3\nheh\nhee\n", "output": "0"}, {"input": "3 2\nhh\neh\nhe\n", "output": "0"}, {"input": "5 4\nhhhh\neheh\neheh\nhehe\neheh\n", "output": "4"}, {"input": "3 4\nhehe\nhhhh\nhhhh\n", "output": "1"}, {"input": "2 3\nhhhh\nehhe\n", "output": "0"}, {"input": "3 2\nhh\nehh\nhhe\n", "output": "0"}, {"input": "2 2\nhh\nhh\n", "output": "0"}, {"input": "5 5\nhehhe\neehee\nhhhhh\nhehhe\nhhhhh\n", "output": "2"}, {"input": "4 5\nheheh\nhhhhh\nheheh\nhhhhh\n", "output": "6"}, {"input": "3 4\nhehh\nhhww\neheh\n", "output": "1"}, {"input": "1 2\nhh\n", "output": "0"}, {"input": "2 4\nhhhp\nehhb\n", "output": "0"}, {"input": "3 4\nhhhe\nhhbh\neehb\n", "output": "0"}, {"input": "5 3\ngeh\nehh\nhhg\nhhh\nhhh\n", "output": "0"}, {"input": "2 2\nhh\neh\n", "output": "0"}], "test": "#undef NDEBUG\n#include<assert.h>\nint main(){\n    assert(solution(\"5 5\\nheheh\\nheheh\\nheheh\\nheheh\\nheheh\\n\") == \"10\");\n    assert(solution(\"3 4\\nhhhh\\neeee\\nhehe\\n\") == \"1\");\n    assert(solution(\"1 1\\nh\\n\") == \"0\");\n    assert(solution(\"2 2\\nhe\\neh\\n\") == \"0\");\n    assert(solution(\"2 3\\nheh\\nhee\\n\") == \"0\");\n    assert(solution(\"3 2\\nhh\\neh\\nhe\\n\") == \"0\");\n    assert(solution(\"5 4\\nhhhh\\neheh\\neheh\\nhehe\\neheh\\n\") == \"4\");\n    assert(solution(\"3 4\\nhehe\\nhhhh\\nhhhh\\n\") == \"1\");\n    assert(solution(\"2 3\\nhhhh\\nehhe\\n\") == \"0\");\n    assert(solution(\"3 2\\nhh\\nehh\\nhhe\\n\") == \"0\");\n    assert(solution(\"2 2\\nhh\\nhh\\n\") == \"0\");\n    assert(solution(\"5 5\\nhehhe\\neehee\\nhhhhh\\nhehhe\\nhhhhh\\n\") == \"2\");\n    assert(solution(\"4 5\\nheheh\\nhhhhh\\nheheh\\nhhhhh\\n\") == \"6\");\n    assert(solution(\"3 4\\nhehh\\nhhww\\neheh\\n\") == \"1\");\n    assert(solution(\"1 2\\nhh\\n\") == \"0\");\n    assert(solution(\"2 4\\nhhhp\\nehhb\\n\") == \"0\");\n    assert(solution(\"3 4\\nhhhe\\nhhbh\\neehb\\n\") == \"0\");\n    assert(solution(\"5 3\\ngeh\\nehh\\nhhg\\nhhh\\nhhh\\n\") == \"0\");\n    assert(solution(\"2 2\\nhh\\neh\\n\") == \"0\");\n    return 0; \n}", "prompt": "/*Little A has a catchphrase \"hehe\" recently, so he gave you a rectangle and asked you to calculate how many \"hehe\"s are inside it (the direction does not matter).\n\ninput_format:\nThe first line has two numbers, $n and $m, representing the size of the rectangle.\n\nThe next $n$line, with $m$characters per line, represents the rectangle.\n\noutput_format:\nA line with a number indicates how many \"hehe\" there are.\n*/\n\n#include<sstream>\n#include<stdlib.h>\n#include<algorithm>\n#include<math.h>\n#include<stdio.h>\n#include<vector>\n#include<string>\n#include<climits>\n#include<cstring>\n#include<iostream>\nusing namespace std;\n\n             \nstring solution(string std_in){\n    istringstream iss(std_in);\n             ", "constraints": "$1 \\leq n,m \\leq1000$。\n\n", "samples": [["5 5\nheheh\nheheh\nheheh\nheheh\nheheh\n", "10\n"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}}
{"task_id": "P1652", "title": "圆", "difficulty": "basic", "nl": "Given $n$ circles, ensuring that any two circles do not intersect and do not touch each other. \n\nThen given two points $(x_1,y_1),(x_2,y_2)$, ensuring that neither of them is on any circle. Now draw a curve from $(x_1,y_1)$ to $(x_2,y_2)$, and ask how many times the curve crosses the boundary of a circle at least?", "code": "#include<cstdio>\n#include<cmath>//用到sqrt，即开根\nusing namespace std;\nint x[60],y[60],r[60];//读入的三个数组\ndouble dist(int x1,int y1,int x2,int y2){//求距离的函数\n\treturn sqrt((x1-x2)*(x1-x2)+(y1-y2)*(y1-y2));//公式\n}\nint main(){\n\tint n,x1,y1,x2,y2,ans=0;\n\tscanf(\"%d\",&n);\n\tfor(int i=1;i<=n;i++) scanf(\"%d\",&x[i]);\n\tfor(int i=1;i<=n;i++) scanf(\"%d\",&y[i]);\n\tfor(int i=1;i<=n;i++) scanf(\"%d\",&r[i]);\n\tscanf(\"%d%d%d%d\",&x1,&y1,&x2,&y2);\n\tfor(int i=1;i<=n;i++)//每个圆都搜一遍\n\t\tif((dist(x1,y1,x[i],y[i])<r[i])^(dist(x2,y2,x[i],y[i]))<r[i]) ans++;//如果两个点恰有一个在圆内，就累加上\n\tprintf(\"%d\",ans);//输出总和\n\treturn 0;//华丽结束\n}", "step": ["Define a function named dis that takes in four integers and returns a double.", "Initialize variables x1, y1, x2, y2, and ans to 0.", "Create a 2D array y with dimensions 105x3 and a variable n.", "Take input for n and fill the 2D array y with n rows and 3 columns.", "Take input for x1, y1, x2, and y2.", "For each circle in y, if the distance between the center and (x1,y1) is less than the radius but the distance between the center and (x2,y2) is not less than the radius, increment ans.", "Print the value of ans.", "End the program."], "nl_cn": "给出 $n$ 个圆，保证任意两个圆都不相交且不相切。  \n\n然后给出两个点 $(x_1,y_1),(x_2,y_2)$，保证均不在某个圆上。现在要从 $(x_1,y_1) \\to (x_2,y_2)$ 画条曲线，问这条曲线最少穿过多少次圆的边界？\n\n", "test_cases": [{"input": "7\n1 -3 2 5 -4 12 12\n1 -1 2 5 5 1 1\n8 1 2 1 1 1 2\n-5 1 12 1", "output": "3"}, {"input": "3\n-1 -1 -1\n2 2 2\n3 3 3\n-2 -2 -2", "output": "0"}, {"input": "1\n100 100 100\n1 2 3 4", "output": "0"}, {"input": "4\n-5 -4 0 0\n-1 -1 -1 -1\n1 1 1 1\n2 2 2 2", "output": "0"}, {"input": "2\n-3 3 -3 3\n-3 -3 -3 -3", "output": "0"}, {"input": "1\n0 0 0\n2 2 2 2", "output": "0"}, {"input": "3\n-1 -1 -1 1 1 1\n2 2 2 2 2 2\n3 3 3 3 3 3\n-1 -1 -1 -1", "output": "0"}, {"input": "4\n1 2 2 1\n5 5 5 5\n0 0 0 0\n-1 -1 -1 -1\n2 2 2 2", "output": "0"}, {"input": "3\n-1 -1 1 1 1 1\n2 2 2 2 2 2\n3 3 3 3 3 3\n-1 -1 -1 -1", "output": "1"}, {"input": "3\n1 2 3 4 5 6 7\n1 2 3 4 5 6 7\n1 2 3 4 5 6 7\n1 2 3\n", "output": "0"}, {"input": "2\n1 1 1 1 1 1 1\n2 2 2 2 2 2 2\n", "output": "0"}, {"input": "4\n-1 -1 -1 -1 1 1 1\n-1 -1 -1 -1 -1 -1 -1\n1 1 1 1 1 1 1\n1 1 1 1 -1 -1 -1\n", "output": "0"}, {"input": "8\n1 1 1 1 1 1 1\n1 1 1 1 1 1 1\n1 1 1 1 1 1 1\n1 1 1 1 1 1 1\n1 1 1 1 1 1 1\n1 1 1 1 1 1 1\n1 1 1 1 1 1 1\n1 1 1 1 1 1 1\n", "output": "0"}, {"input": "1\n1 2 3 4 5 6 7\n", "output": "0"}, {"input": "3\n-1 -1 -1 -1 -1 -1 -1\n-1 -1 -1 -1 -1 -1 -1\n-1 -1 -1 -1 -1 -1 -1\n", "output": "0"}, {"input": "2\n2 1 4 7 2 3 1\n-1 2 3 6 5 2 4\n5 2 3 6\n", "output": "1"}, {"input": "4\n2 4 5 2 3 1 7\n1 2 3 6 -1 2 3\n-1 2 3 6 5 2 4\n3 1 2 6 5 4 7\n2 1 4 7\n", "output": "3"}, {"input": "2\n3 1 2 6 5 4 7\n1 2 3 6 -1 2 3\n5 2 4 7\n", "output": "1"}, {"input": "5\n1 2 3 4 5 6 7 8 9 10 11\n3 4 5 6 7 8 6 4 3 2 1\n12 34 56 78 90 12 24 36 48 60\n23 34 45 56 67 78 89 90 91 92\n-1 -2 -3 -4 -5 -6 -7 -8 -9 -10\n", "output": "2"}, {"input": "2\n1 2 3 4 5 6\n7 8 9 10 11 12\n", "output": "0"}, {"input": "4\n1 2 3 4 5 6\n7 8 9 10 11 12\n1 2 3 4 5 6\n7 8 9 10 11 12\n", "output": "0"}, {"input": "3\n1 2 3 4 5 6\n1 2 3 4 5 6\n1 2 3 4 5 6\n", "output": "1"}, {"input": "1\n1 2 3\n4 5 6\n", "output": "0"}, {"input": "2\n0 0 0 0 0 0\n1 1 1 1 1 1\n", "output": "0"}], "test": "#undef NDEBUG\n#include<assert.h>\nint main(){\n    assert(solution(\"7\\n1 -3 2 5 -4 12 12\\n1 -1 2 5 5 1 1\\n8 1 2 1 1 1 2\\n-5 1 12 1\") == \"3\");\n    assert(solution(\"3\\n-1 -1 -1\\n2 2 2\\n3 3 3\\n-2 -2 -2\") == \"0\");\n    assert(solution(\"1\\n100 100 100\\n1 2 3 4\") == \"0\");\n    assert(solution(\"4\\n-5 -4 0 0\\n-1 -1 -1 -1\\n1 1 1 1\\n2 2 2 2\") == \"0\");\n    assert(solution(\"2\\n-3 3 -3 3\\n-3 -3 -3 -3\") == \"0\");\n    assert(solution(\"1\\n0 0 0\\n2 2 2 2\") == \"0\");\n    assert(solution(\"3\\n-1 -1 -1 1 1 1\\n2 2 2 2 2 2\\n3 3 3 3 3 3\\n-1 -1 -1 -1\") == \"0\");\n    assert(solution(\"4\\n1 2 2 1\\n5 5 5 5\\n0 0 0 0\\n-1 -1 -1 -1\\n2 2 2 2\") == \"0\");\n    assert(solution(\"3\\n-1 -1 1 1 1 1\\n2 2 2 2 2 2\\n3 3 3 3 3 3\\n-1 -1 -1 -1\") == \"1\");\n    assert(solution(\"3\\n1 2 3 4 5 6 7\\n1 2 3 4 5 6 7\\n1 2 3 4 5 6 7\\n1 2 3\\n\") == \"0\");\n    assert(solution(\"2\\n1 1 1 1 1 1 1\\n2 2 2 2 2 2 2\\n\") == \"0\");\n    assert(solution(\"4\\n-1 -1 -1 -1 1 1 1\\n-1 -1 -1 -1 -1 -1 -1\\n1 1 1 1 1 1 1\\n1 1 1 1 -1 -1 -1\\n\") == \"0\");\n    assert(solution(\"8\\n1 1 1 1 1 1 1\\n1 1 1 1 1 1 1\\n1 1 1 1 1 1 1\\n1 1 1 1 1 1 1\\n1 1 1 1 1 1 1\\n1 1 1 1 1 1 1\\n1 1 1 1 1 1 1\\n1 1 1 1 1 1 1\\n\") == \"0\");\n    assert(solution(\"1\\n1 2 3 4 5 6 7\\n\") == \"0\");\n    assert(solution(\"3\\n-1 -1 -1 -1 -1 -1 -1\\n-1 -1 -1 -1 -1 -1 -1\\n-1 -1 -1 -1 -1 -1 -1\\n\") == \"0\");\n    assert(solution(\"2\\n2 1 4 7 2 3 1\\n-1 2 3 6 5 2 4\\n5 2 3 6\\n\") == \"1\");\n    assert(solution(\"4\\n2 4 5 2 3 1 7\\n1 2 3 6 -1 2 3\\n-1 2 3 6 5 2 4\\n3 1 2 6 5 4 7\\n2 1 4 7\\n\") == \"3\");\n    assert(solution(\"2\\n3 1 2 6 5 4 7\\n1 2 3 6 -1 2 3\\n5 2 4 7\\n\") == \"1\");\n    assert(solution(\"5\\n1 2 3 4 5 6 7 8 9 10 11\\n3 4 5 6 7 8 6 4 3 2 1\\n12 34 56 78 90 12 24 36 48 60\\n23 34 45 56 67 78 89 90 91 92\\n-1 -2 -3 -4 -5 -6 -7 -8 -9 -10\\n\") == \"2\");\n    assert(solution(\"2\\n1 2 3 4 5 6\\n7 8 9 10 11 12\\n\") == \"0\");\n    assert(solution(\"4\\n1 2 3 4 5 6\\n7 8 9 10 11 12\\n1 2 3 4 5 6\\n7 8 9 10 11 12\\n\") == \"0\");\n    assert(solution(\"3\\n1 2 3 4 5 6\\n1 2 3 4 5 6\\n1 2 3 4 5 6\\n\") == \"1\");\n    assert(solution(\"1\\n1 2 3\\n4 5 6\\n\") == \"0\");\n    assert(solution(\"2\\n0 0 0 0 0 0\\n1 1 1 1 1 1\\n\") == \"0\");\n    return 0; \n}", "prompt": "/*Given $n$ circles, ensuring that any two circles do not intersect and do not touch each other. \n\nThen given two points $(x_1,y_1),(x_2,y_2)$, ensuring that neither of them is on any circle. Now draw a curve from $(x_1,y_1)$ to $(x_2,y_2)$, and ask how many times the curve crosses the boundary of a circle at least?\n\ninput_format:\n- The first act is an integer $n$, representing the number of circles;\n- The second line contains $n$integers, representing the $x$coordinates of $n$circles;\n- The third line contains $n$integers, representing the $y$coordinates of $n$circles;\n- The fourth line is $n$integer, representing the radius of $n$circle $r$;\n- The fifth line is four integers $x_1,y_1,x_2,y_2$.\n\noutput_format:\nOnly one integer, indicating the minimum number of times to cross the boundary of the circle.\n*/\n\n#include<sstream>\n#include<stdlib.h>\n#include<algorithm>\n#include<math.h>\n#include<stdio.h>\n#include<vector>\n#include<string>\n#include<climits>\n#include<cstring>\n#include<iostream>\nusing namespace std;\n\n             \nstring solution(string std_in){\n    istringstream iss(std_in);\n             ", "constraints": "【数据范围】  \n\n对于 $100\\%$ 的数据，$1\\le n \\le 50$，$|x|,|y| \\le 1000$，$1 \\le r \\le 1000$。\n\n保证圆之间没有公共点。", "samples": [["7\n1 -3 2 5 -4 12 12\n1 -1 2 5 5 1 1\n8 1 2 1 1 1 2\n-5 1 12 1", "3"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}}
{"task_id": "P2307", "title": "迷宫", "difficulty": "advanced", "nl": "Xiao Xi loves to play maze games very much. Now she has designed a maze game by herself. In the maze she designed, first of all, she thinks that all passages should be bidirectional. That is to say, if there is a passage connecting room A and B, it can be used to go from room A to room B and vice versa. In order to increase the difficulty, Xiao Xi wants any two rooms to have only one path that can be connected (unless you walk back). Xiao Xi now gives you her design and asks for your help to determine whether her design meets her design ideas. For example, the first two examples meet the conditions, but the last one has two ways to reach 8 from 5.", "code": "#include<iostream>\n#include<cstdio>\n#include<cstring>\nusing namespace std;\n\ninline int read(){//普通快读优化，萌新可换成cin\n\tint x=0,fh=1;\n\tchar ch=getchar();\n\twhile(!isdigit(ch)){\n\t\tif(ch=='-') fh=-1;\n\t\tch=getchar();\n\t}\n\twhile(isdigit(ch)){\n\t\tx=(x<<1)+(x<<3)+ch-'0';\n\t\tch=getchar();\n\t}\n\treturn x*fh;\n}\n\nconst int maxn=100010;//定义数组大小\nint a[maxn]; //a数组是并查集\nbool flag;//flag用来记录是否出现-1,-1\n\nint fin(int x){//查找祖先&路径压缩\n\tif(a[x]==0) return x;\n\telse return a[x]=fin(a[x]);\n}\n\ninline void check(){//判断每组数据是否是树并输出相应的答案\n\tmemset(a,0,sizeof(a));//先清零并查集\n\tbool f=0;//f用来记录图中是否出现了环\n\tint b[maxn]={0},cnt1=0,cnt2=0,x,y,xx,yy;\n\t//b数组是桶，cnt1是点数，cnt2是边数 \n    //x和y是连边的两点，xx和yy是两点的祖先\n\twhile(1){//循环输入\n\t\tx=read();y=read();\n\t\tif(x==0&&y==0) break;//0,0表明输入结束\n\t\tif(x==-1&&y==-1){//-1,-1表明所有数据都已输入完\n\t\t\tflag=1;//flag记录一下\n\t\t\treturn;//直接返回主函数\n\t\t}\n\t\tif(f) continue;\n        //已经有环了，那就不用再进行操作了\n        //这里是为了节省空间，因为还得把剩下的数据输入\n        //如果不用f标记的话必须得用数组存储\n\t\txx=fin(x);yy=fin(y);//查找祖先\n\t\tif(xx!=yy){//祖先不同，不在同一集合中\n\t\t\ta[xx]=yy;//连边\n\t\t\tif(!b[x]){//x这个点之前没出现过\n\t\t\t\tb[x]=1;//修改桶\n\t\t\t\tcnt1++;//点数+1\n\t\t\t}\n\t\t\tif(!b[y]){//同上\n\t\t\t\tb[y]=1;\n\t\t\t\tcnt1++;\n\t\t\t}\n\t\t\tcnt2++;//又连了一条边，因此边数要+1\n\t\t}else{//祖先相同，在同一集合中\n\t\t\tf=1;//出现了环，更改f标记\n\t\t}\n\t}\n\tif(cnt2==cnt1-1&&!f) printf(\"1\\n\");\n    //边数是点数-1且无环，是树，输出1\n\telse printf(\"0\\n\");\n    //否则不是树，输出0\n\treturn;\n} \n\nint main(){\n\twhile(1){\n\t\tcheck();\n\t\tif(flag) break;\n        //出现了-1，-1，所有数据已输入完毕，跳出循环\n\t}\n\treturn 0;\n}", "step": ["Read input edges and create disjoint sets.", "Check if two vertices are already in the same set or not.", "If same set, there is a cycle.", "If all the vertices form a single connected component and there is no cycle, then it is a tree.", "Print 1 if the given set of edges form a tree else print 0.", "Repeat for multiple test cases."], "nl_cn": "小希非常喜欢玩迷宫游戏，现在她自己设计了一个迷宫游戏。在她设计的迷宫中，首先她认为所有的通道都应该是双向连通的，就是说如果有一个通道连通了房间A和B，那么既可以通过它从房间A走到房间B，也可以通过它从房间B走到房间A，为了提高难度，小希希望任意两个房间有且仅有一条路径可以相通（除非走了回头路）。小希现在把她的设计图给你，让你帮忙判断她的设计图是否符合她的设计思路。比如下面的例子，前两个是符合条件的，但是最后一个却有两种方法从5到达8。\n", "test_cases": [{"input": "6 8  5 3  5 2  6 4\n5 6  0 0\n\n8 1  7 3  6 2  8 9  7 5\n7 4  7 8  7 6  0 0\n\n3 8  6 8  6 4\n5 3  5 6  5 2  0 0\n\n-1 -1\n", "output": "1\n1\n0"}], "test": "#undef NDEBUG\n#include<assert.h>\nint main(){\n    assert(solution(\"6 8  5 3  5 2  6 4\\n5 6  0 0\\n\\n8 1  7 3  6 2  8 9  7 5\\n7 4  7 8  7 6  0 0\\n\\n3 8  6 8  6 4\\n5 3  5 6  5 2  0 0\\n\\n-1 -1\\n\") == \"1\\n1\\n0\");\n    return 0; \n}", "prompt": "/*Xiao Xi loves to play maze games very much. Now she has designed a maze game by herself. In the maze she designed, first of all, she thinks that all passages should be bidirectional. That is to say, if there is a passage connecting room A and B, it can be used to go from room A to room B and vice versa. In order to increase the difficulty, Xiao Xi wants any two rooms to have only one path that can be connected (unless you walk back). Xiao Xi now gives you her design and asks for your help to determine whether her design meets her design ideas. For example, the first two examples meet the conditions, but the last one has two ways to reach 8 from 5.\n\ninput_format:\nThere are multiple sets of data as input, and each set consists of a list of integer pairs ending with 0 0. Each pair represents the numbers of two rooms connected by a channel. The room numbers are at least 1 and not exceeding 100,000. There is a blank line between each set of data.\n\nThe entire file ends with two -1s.\n\noutput_format:\nFor each set of input data, the output contains only one line. Output \"1\" if the maze matches Hiss's idea, otherwise output \"0\".\n*/\n\n#include<sstream>\n#include<stdlib.h>\n#include<algorithm>\n#include<math.h>\n#include<stdio.h>\n#include<vector>\n#include<string>\n#include<climits>\n#include<cstring>\n#include<iostream>\nusing namespace std;\n\n             \nstring solution(string std_in){\n    istringstream iss(std_in);\n             ", "constraints": "无", "samples": [["6 8  5 3  5 2  6 4\n5 6  0 0\n\n8 1  7 3  6 2  8 9  7 5\n7 4  7 8  7 6  0 0\n\n3 8  6 8  6 4\n5 3  5 6  5 2  0 0\n\n-1 -1\n", "1\n1\n0\n"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}}
{"task_id": "P3984", "title": "高兴的津津", "difficulty": "challenge", "nl": "Jinjin has started high school. Under the devil's training of her mother, she has become a master and always triumphs in OI competitions. She is happy every time she gets an Au. Assuming that Jinjin will not be happy for any other reason and her happiness will last for $T$ days (including the day of winning the prize), even if she gets an Au again during the happy period, her happiness will only be extended for another $T$ days from the day of the second winning instead of adding another $T$ days, unless she wins another prize later. Please help check Jinjin's schedule for the next $n$ competitions and see how many days she will be happy in total.", "code": "#include<cmath>\n#include<cstdio>\n#include<iostream>\n#include<cstring>\n#include<algorithm>\nusing namespace std;\n\nint n,t,ans;//ans是答案，answer，显得我英语很好（划掉）\nint a[200005];\n\nint main(){\n\tscanf(\"%d%d\",&n,&t);//读入不解释\n\tscanf(\"%d\",&a[1]);//先读入第一个数据\n\tfor(int i=2;i<=n;i++){//从第二个数开始读，并加上判断\n\t\tscanf(\"%d\",&a[i]);\n\t\tif(a[i]-a[i-1]<t){//如果前一次与这次时间间隔不大于t天，加上相隔的时间\n\t\t    ans+=a[i]-a[i-1];\n\t\t}\n\t\telse{//如果大于t天，因为快乐只能持续t天，所以答案加一\n\t\t    ans+=t;\n\t\t}\n\t}\n\tprintf(\"%d\\n\",ans+t);//因为最后一天的快乐肯定能持续t天，所以直接输出ans+t就好\n\treturn 0;\n}", "step": ["Take input values of total tasks and time needed for each task.", "Take input values of time needed to complete each task.", "If time needed to complete task is less than given time, add it to the answer.", "If time needed is greater than given time, add the given time to the answer.", "Print the final answer.", "Exit the program."], "nl_cn": "津津上高中了。她在自己的妈妈的魔鬼训练下，成为了一个神犇，每次参加一次 OI 比赛必拿 Au 虐全场。每次她拿到一个 Au 后就很高兴。假设津津不会因为其它事高兴，并且她的高兴会持续 $T$ 天（包含获奖当天。就算在高兴的时候再次拿到 Au，他的高兴也只能维持包括这次拿奖之日起 $T$ 天，而不是额外增加 $T$ 天的高兴时间，除非之后再拿奖）。请你帮忙检查一下津津接下来的的日程安排，要参加 $n$ 场比赛，看看接下来的几天，津津会累计开心多久？", "test_cases": [{"input": "3 5\n1 2 10", "output": "11"}, {"input": "4 7\n3 4 11 14\n", "output": "18"}, {"input": "2 2\n1 1\n", "output": "2"}, {"input": "0 1\n\n", "output": "1"}, {"input": "6 5\n10 15 20 25 30 35\n", "output": "30"}, {"input": "2 7\n5 12\n", "output": "14"}, {"input": "2 4\n2 6\n", "output": "8"}, {"input": "2 3\n8 10\n", "output": "5"}, {"input": "3 1\n3 4 5\n", "output": "3"}, {"input": "2 1\n1 3\n", "output": "2"}, {"input": "4 6\n5 11 13 17\n", "output": "18"}, {"input": "4 3\n1 2 3 4\n", "output": "6"}, {"input": "0 5\n", "output": "5"}, {"input": "2 8\n3 12\n", "output": "16"}, {"input": "2 3\n20 22\n", "output": "5"}, {"input": "2 4\n8 12\n", "output": "8"}, {"input": "3 4\n2 6 10\n", "output": "12"}, {"input": "2 1\n1 2\n", "output": "2"}, {"input": "5 4\n1 8 11 15 19\n", "output": "19"}, {"input": "3 8\n3 7 11\n", "output": "16"}], "test": "#undef NDEBUG\n#include<assert.h>\nint main(){\n    assert(solution(\"3 5\\n1 2 10\") == \"11\");\n    assert(solution(\"4 7\\n3 4 11 14\\n\") == \"18\");\n    assert(solution(\"2 2\\n1 1\\n\") == \"2\");\n    assert(solution(\"0 1\\n\\n\") == \"1\");\n    assert(solution(\"6 5\\n10 15 20 25 30 35\\n\") == \"30\");\n    assert(solution(\"2 7\\n5 12\\n\") == \"14\");\n    assert(solution(\"2 4\\n2 6\\n\") == \"8\");\n    assert(solution(\"2 3\\n8 10\\n\") == \"5\");\n    assert(solution(\"3 1\\n3 4 5\\n\") == \"3\");\n    assert(solution(\"2 1\\n1 3\\n\") == \"2\");\n    assert(solution(\"4 6\\n5 11 13 17\\n\") == \"18\");\n    assert(solution(\"4 3\\n1 2 3 4\\n\") == \"6\");\n    assert(solution(\"0 5\\n\") == \"5\");\n    assert(solution(\"2 8\\n3 12\\n\") == \"16\");\n    assert(solution(\"2 3\\n20 22\\n\") == \"5\");\n    assert(solution(\"2 4\\n8 12\\n\") == \"8\");\n    assert(solution(\"3 4\\n2 6 10\\n\") == \"12\");\n    assert(solution(\"2 1\\n1 2\\n\") == \"2\");\n    assert(solution(\"5 4\\n1 8 11 15 19\\n\") == \"19\");\n    assert(solution(\"3 8\\n3 7 11\\n\") == \"16\");\n    return 0; \n}", "prompt": "/*Jinjin has started high school. Under the devil's training of her mother, she has become a master and always triumphs in OI competitions. She is happy every time she gets an Au. Assuming that Jinjin will not be happy for any other reason and her happiness will last for $T$ days (including the day of winning the prize), even if she gets an Au again during the happy period, her happiness will only be extended for another $T$ days from the day of the second winning instead of adding another $T$ days, unless she wins another prize later. Please help check Jinjin's schedule for the next $n$ competitions and see how many days she will be happy in total.\n\ninput_format:\nThe first line has two integers $n$and $T$.\n\nOn the next line, $n$is a monotonically increasing integer $t_i$, indicating that she took an Au on day t_i$.\n\noutput_format:\nAn integer indicates how long the relish accumulatively happy.\n*/\n\n#include<sstream>\n#include<stdlib.h>\n#include<algorithm>\n#include<math.h>\n#include<stdio.h>\n#include<vector>\n#include<string>\n#include<climits>\n#include<cstring>\n#include<iostream>\nusing namespace std;\n\n             \nstring solution(string std_in){\n    istringstream iss(std_in);\n             ", "constraints": "#### 数据规模与约定\n\n对于 $100\\%$ 的数据，保证：\n\n- $1\\le n\\le2\\times10^5$。\n- $1\\le T\\le10^9$。\n- $1\\le t_i\\le 10^9$，$t_i$ 单调递增。", "samples": [["3 5\n1 2 10", "11"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}}
{"task_id": "P3287", "title": "[SCOI2014]方伯伯的玉米田", "difficulty": "advanced", "nl": "Uncle Fang was taking a walk by his farmland when he suddenly noticed that one row of corn was quite unsightly. There were a total of $N$ corn plants in this row, and their heights were uneven. Uncle Fang believed that a monotonically non-decreasing sequence was beautiful, so he decided to first raise some corn plants and then remove the ones that destroyed the aesthetics, leaving behind a row of corn with non-decreasing heights. Uncle Fang can choose an interval and raise the heights of all the corn plants in that interval by $1$ unit. He can perform this operation for at most $K$ times. He can also remove any subset of corn plants. What is the maximum number of corn plants that can remain so that they form a beautiful row of corn?", "code": "#include<iostream>\n#include<cstdio>\n#include<cstdlib>\n#define N 10005\n#define re register\nusing namespace std;\nint n,K,X,Y,h[N],M[505][5505],ans=0;\ninline int max(int a,int b){ return a>b?a:b; }\ninline int L(int x){ return x&(-x); }\nvoid Add(int x,int y,int C){ for(re int i=x;i<=X;i+=L(i)) for(re int j=y;j<=Y;j+=L(j)) M[i][j]=max(M[i][j],C); }\nint Query(int x,int y){ int ans=0; for(re int i=x;i;i-=L(i)) for(re int j=y;j;j-=L(j)) ans=max(ans,M[i][j]); return ans; }\nint main(){\n\tscanf(\"%d%d\",&n,&K);\n\tfor(re int i=1;i<=n;++i) scanf(\"%d\",&h[i]),Y=max(Y,h[i]);\n\tX=K+1; Y=Y+K;\n\tfor(re int i=1;i<=n;++i){\n\t\tfor(re int j=K;~j;--j){\n\t\t\tint x=Query(j+1,h[i]+j)+1;\n\t\t\tans=max(ans,x);\n\t\t\tAdd(j+1,h[i]+j,x);\n\t\t}\n\t}\n\tprintf(\"%d\\n\",ans);\n\treturn 0;\n}", "step": ["Read in the values of n and k.", "Read the heights of all triangles and find the maximum height.", "For each triangle, iterate through possible heights the tower can be built up until it and update the maximum number of triangles that can be stacked for each.", "For each triangle across all possible heights, keep track of the maximum number of triangles that can be stacked for the entire tower.", "Output the maximum number of triangles that can be stacked."], "nl_cn": "方伯伯在自己的农田边散步，他突然发现田里的一排玉米非常的不美。这排玉米一共有 $N$ 株，它们的高度参差不齐。方伯伯认为单调不下降序列很美，所以他决定先把一些玉米拔高，再把破坏美感的玉米拔除掉，使得剩下的玉米的高度构成一个单调不下降序列。方伯伯可以选择一个区间，把这个区间的玉米全部拔高 $1$ 单位高度，他可以进行最多 $K$ 次这样的操作。拔玉米则可以随意选择一个集合的玉米拔掉。问能最多剩多少株玉米，来构成一排美丽的玉米。", "test_cases": [{"input": "3 1\n2 1 3", "output": "3"}, {"input": "5 2\n1 2 3 4 5 ", "output": "5"}, {"input": "4 1\n4 3 2 1 ", "output": "2"}, {"input": "6 3\n1 2 3 4 5 6 ", "output": "6"}, {"input": "5 2\n5 4 3 2 1 ", "output": "3"}, {"input": "3 1\n3 2 1 ", "output": "2"}, {"input": "4 1\n2 4 3 1 ", "output": "3"}, {"input": "4 1\n3 1 2 4 ", "output": "3"}, {"input": "5 2\n4 2 1 5 3 ", "output": "3"}, {"input": "3 1\n3 1 2 ", "output": "2"}, {"input": "4 1\n1 4 3 2 ", "output": "3"}, {"input": "6 3\n3 4 5 6 2 1 ", "output": "4"}, {"input": "4 3\n1 2 3 4", "output": "4"}, {"input": "5 3\n9 6 8 7 5", "output": "4"}, {"input": "2 1\n1 2", "output": "2"}, {"input": "3 1\n1 3 2", "output": "3"}, {"input": "5 3\n5 4 3 2 1", "output": "4"}, {"input": "4 3\n5 4 3 2\n", "output": "4"}, {"input": "2 1\n10 10\n", "output": "2"}, {"input": "10 5\n1 2 3 4 5 6 7 8 9 10\n", "output": "10"}, {"input": "6 2\n6 2 4 5 1 3\n", "output": "4"}, {"input": "9 3\n3 8 2 1 9 7 4 5 6\n", "output": "6"}, {"input": "2 1\n1 1\n", "output": "2"}, {"input": "4 2\n2 3 4 1\n", "output": "3"}, {"input": "5 2\n1 2 3 5 4\n", "output": "5"}, {"input": "6 2\n6 1 5 3 4 2\n", "output": "4"}, {"input": "5 1\n2 3 5 1 4\n", "output": "4"}], "test": "#undef NDEBUG\n#include<assert.h>\nint main(){\n    assert(solution(\"3 1\\n2 1 3\") == \"3\");\n    assert(solution(\"5 2\\n1 2 3 4 5 \") == \"5\");\n    assert(solution(\"4 1\\n4 3 2 1 \") == \"2\");\n    assert(solution(\"6 3\\n1 2 3 4 5 6 \") == \"6\");\n    assert(solution(\"5 2\\n5 4 3 2 1 \") == \"3\");\n    assert(solution(\"3 1\\n3 2 1 \") == \"2\");\n    assert(solution(\"4 1\\n2 4 3 1 \") == \"3\");\n    assert(solution(\"4 1\\n3 1 2 4 \") == \"3\");\n    assert(solution(\"5 2\\n4 2 1 5 3 \") == \"3\");\n    assert(solution(\"3 1\\n3 1 2 \") == \"2\");\n    assert(solution(\"4 1\\n1 4 3 2 \") == \"3\");\n    assert(solution(\"6 3\\n3 4 5 6 2 1 \") == \"4\");\n    assert(solution(\"4 3\\n1 2 3 4\") == \"4\");\n    assert(solution(\"5 3\\n9 6 8 7 5\") == \"4\");\n    assert(solution(\"2 1\\n1 2\") == \"2\");\n    assert(solution(\"3 1\\n1 3 2\") == \"3\");\n    assert(solution(\"5 3\\n5 4 3 2 1\") == \"4\");\n    assert(solution(\"4 3\\n5 4 3 2\\n\") == \"4\");\n    assert(solution(\"2 1\\n10 10\\n\") == \"2\");\n    assert(solution(\"10 5\\n1 2 3 4 5 6 7 8 9 10\\n\") == \"10\");\n    assert(solution(\"6 2\\n6 2 4 5 1 3\\n\") == \"4\");\n    assert(solution(\"9 3\\n3 8 2 1 9 7 4 5 6\\n\") == \"6\");\n    assert(solution(\"2 1\\n1 1\\n\") == \"2\");\n    assert(solution(\"4 2\\n2 3 4 1\\n\") == \"3\");\n    assert(solution(\"5 2\\n1 2 3 5 4\\n\") == \"5\");\n    assert(solution(\"6 2\\n6 1 5 3 4 2\\n\") == \"4\");\n    assert(solution(\"5 1\\n2 3 5 1 4\\n\") == \"4\");\n    return 0; \n}", "prompt": "/*Uncle Fang was taking a walk by his farmland when he suddenly noticed that one row of corn was quite unsightly. There were a total of $N$ corn plants in this row, and their heights were uneven. Uncle Fang believed that a monotonically non-decreasing sequence was beautiful, so he decided to first raise some corn plants and then remove the ones that destroyed the aesthetics, leaving behind a row of corn with non-decreasing heights. Uncle Fang can choose an interval and raise the heights of all the corn plants in that interval by $1$ unit. He can perform this operation for at most $K$ times. He can also remove any subset of corn plants. What is the maximum number of corn plants that can remain so that they form a beautiful row of corn?\n\ninput_format:\nThe first row contains two integers $n and K$, which indicate the number of corn rows and the maximum number of operations that can be performed. The second row contains $n$integers, and the number of $i$indicates the height of the row of corn, from left to right, at $a_i$.\n\noutput_format:\nOutput an integer, up to the number of corn left.\n*/\n\n#include<sstream>\n#include<stdlib.h>\n#include<algorithm>\n#include<math.h>\n#include<stdio.h>\n#include<vector>\n#include<string>\n#include<climits>\n#include<cstring>\n#include<iostream>\nusing namespace std;\n\n             \nstring solution(string std_in){\n    istringstream iss(std_in);\n             ", "constraints": "$100\\%$ 的数据满足：$2 \\le N \\lt 10^4 $，$2 \\le K \\le 500$，$1 \\leq a_i \\leq 5000$。", "samples": [["3 1\n2 1 3", "3"]], "limits": {"time": [3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000, 3000], "memory": [524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288]}}
{"task_id": "P2037", "title": "电话号码", "difficulty": "advanced", "nl": "A phone number consisting of a long string of numbers is usually difficult to remember. To facilitate memory, a method is to use words for convenience. For example, \"Three Tens\" is used to remember the phone number 3-10-10-10.\n\nThe standard form of a phone number is seven digits, separated by a hyphen into the first three and last four numbers (for example: 888-1200). Phone numbers can be represented by letters. The correspondences between letters and numbers are:\n\nA, B, and C correspond to 2\n\nD, E, and F correspond to 3\n\nG, H, and I correspond to 4\n\nJ, K, and L correspond to 5\n\nM, N, and O correspond to 6\n\nP, R, and S correspond to 7\n\nT, U, and V correspond to 8\n\nW, X, and Y correspond to 9\n\nYou will notice that there are no letters Q and Z. The hyphen in the phone number can be ignored. For example, the standard form of TUT-GLOP is 888-4567, the standard form of 310-GINO is 310-4466, and the standard form of 3-10-10-10 is 310-1010.\n\nIf two phone numbers have the same standard form, then these two numbers are the same.\n\nNow there is a phone book, please find out which phone numbers are duplicates.", "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nint n;\nchar cmap[128];\nmap<string, int> phone;\nbool flag;\n\nvoid print(string s)\n{\n    for (int i = 0; i < s.size(); ++i)\n    {\n        if (i == 3) cout << '-';\n        cout << s[i];\n    }\n}\n\nint main()\n{\n    ios::sync_with_stdio(0);\n    for (char c = '0'; c <= '9'; ++c) cmap[c] = c;\n    cmap['A'] = cmap['B'] = cmap['C'] = '2';\n    cmap['D'] = cmap['E'] = cmap['F'] = '3';\n    cmap['G'] = cmap['H'] = cmap['I'] = '4';\n    cmap['J'] = cmap['K'] = cmap['L'] = '5';\n    cmap['M'] = cmap['N'] = cmap['O'] = '6';\n    cmap['P'] = cmap['R'] = cmap['S'] = '7';\n    cmap['T'] = cmap['U'] = cmap['V'] = '8';\n    cmap['W'] = cmap['X'] = cmap['Y'] = '9';\n    cin >> n;\n    for (int i = 0; i < n; ++i)\n    {\n        string num, newnum = \"\";\n        cin >> num;\n        for (int i = 0; i < num.size(); ++i)\n            if (num[i] != '-') newnum += cmap[num[i]];\n        ++phone[newnum];\n    }\n    for (map<string, int>::iterator it = phone.begin(); it != phone.end(); ++it)\n    {\n        if (it->second > 1)\n        {\n            print(it->first);\n            cout << ' ' << it->second << '\\n';\n            flag = 1;\n        }\n    }\n    if (!flag) cout << \"No duplicates.\\n\";\n    return 0;\n}", "step": ["Read the number of test cases 'n'", "For each test case, read input as string 'cnt'", "Convert the input string to phone number by taking numeric equivalent of each character or using pre-defined map 'f'", "Sort the phone numbers", "Count the frequency of each phone number and print numbers with frequency greater than one"], "nl_cn": "一串由长长的数字组成的电话号码通常很难记忆。为了方便记忆，有种方法是用单词来方便记忆。例如用“Three Tens”来记忆电话3-10-10-10。\n\n电话号码的标准形式是七位数字，中间用连字号分成前三个和后四个数字（例如：888-1200）。电话号码可以用字母来表示。以下是字母与数字的对应：\n\nA，B和C对应2\n\nD，E和F对应3\n\nG，H和I对应4\n\nJ，K和L对应5\n\nM，N和O对应6\n\nP，R和S对应7\n\nT，U和V对应8\n\nW，X和Y对应9\n\n你会发现其中没有字母Q和Z。电话中的连字号是可以忽略。例如TUT-GLOP的标准形式是888-4567，310-GINO的标准形式是310-4466，3-10-10-10的标准形式是310-1010。\n\n如果两个电话号码的标准形式是一样的，那么这两个电话号码就是一样的。\n\n现在有一本电话簿，请从中找出哪些电话号码是重复的。\n", "test_cases": [{"input": "3\r\nTUT-GLOP\r\n3-10-10-10\r\n310-1010\r\n", "output": "310-1010 2"}, {"input": "4\nTUT-GLOP\n3-10-10-10\n310-1010\n333-3333\n", "output": "310-1010 2"}], "test": "#undef NDEBUG\n#include<assert.h>\nint main(){\n    assert(solution(\"3\\r\\nTUT-GLOP\\r\\n3-10-10-10\\r\\n310-1010\\r\\n\") == \"310-1010 2\");\n    assert(solution(\"4\\nTUT-GLOP\\n3-10-10-10\\n310-1010\\n333-3333\\n\") == \"310-1010 2\");\n    return 0; \n}", "prompt": "/*A phone number consisting of a long string of numbers is usually difficult to remember. To facilitate memory, a method is to use words for convenience. For example, \"Three Tens\" is used to remember the phone number 3-10-10-10.\n\nThe standard form of a phone number is seven digits, separated by a hyphen into the first three and last four numbers (for example: 888-1200). Phone numbers can be represented by letters. The correspondences between letters and numbers are:\n\nA, B, and C correspond to 2\n\nD, E, and F correspond to 3\n\nG, H, and I correspond to 4\n\nJ, K, and L correspond to 5\n\nM, N, and O correspond to 6\n\nP, R, and S correspond to 7\n\nT, U, and V correspond to 8\n\nW, X, and Y correspond to 9\n\nYou will notice that there are no letters Q and Z. The hyphen in the phone number can be ignored. For example, the standard form of TUT-GLOP is 888-4567, the standard form of 310-GINO is 310-4466, and the standard form of 3-10-10-10 is 310-1010.\n\nIf two phone numbers have the same standard form, then these two numbers are the same.\n\nNow there is a phone book, please find out which phone numbers are duplicates.\n\ninput_format:\nThe first line is a positive integer N, indicating how many phone numbers there are.\n\nThe following N lines are one phone number per line. The phone number consists of digits, uppercase letters (except Q and Z), and hyphens. The length of the phone number will not exceed 1000. All phone numbers are legitimate.\n\noutput_format:\nAll repeated phone numbers are printed in standard form in lexicographical order. Each phone number is followed by an integer to indicate how many times the phone number has appeared. The phone number and integer are separated by a space. Do not output extra empty lines.\n\nIf there are No duplicate phone numbers, output: No duplicates.\n*/\n\n#include<sstream>\n#include<stdlib.h>\n#include<algorithm>\n#include<math.h>\n#include<stdio.h>\n#include<vector>\n#include<string>\n#include<climits>\n#include<cstring>\n#include<iostream>\nusing namespace std;\n\n             \nstring solution(string std_in){\n    istringstream iss(std_in);\n             ", "constraints": "【数据范围】\n\n对于 $30\\%$ 的数据，$N\\le20$。\n\n对于 $50\\%$ 的数据，$N\\le10000$。\n\n对于 $100\\%$ 的数据，$N\\le10^5$。\n", "samples": [["3\r\nTUT-GLOP\r\n3-10-10-10\r\n310-1010\r\n", "310-1010 2"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}}
{"task_id": "P7659", "title": "[COCI2014-2015#5] FUNGHI", "difficulty": "basic", "nl": "Hansel and Gretel got a pizza divided into 8 slices, each with a different number of mushrooms represented by $S_1, S_2,..., S_8$. Gretel loves mushrooms and wants to find a consecutive set of four slices with the highest total number of mushrooms.", "code": "#include<bits/stdc++.h>\nusing namespace std;\nint dat[20],ans,now;\nint main(){\n    for(int i=0;i<8;i++){cin>>dat[i];}\n    for(int i=0;i<8;i++){\n        now=0;\n        for(int j=i,k=0;k<4;j=(j+1)%8,k++)now+=dat[j];\n        if(now>ans)ans=now;\n    }\n    cout<<ans;\n}", "step": ["Read in an array of 8 integers.", "Loop through the array from index 0 to index 7.", "Create a sum variable 'now' and initialize it to 0.", "Loop through the array from current index to 4 positions ahead, adding each element to 'now'.", "If 'now' is greater than the current maximum 'ans', update 'ans' to be 'now'.", "Output 'ans'."], "nl_cn": "Hansel 和 Gretel 得到了一块分成 $8$ 片的披萨，每片上面有不同数量的蘑菇，表示为 $S_1,S_2,...,S_8$。Gretel 很喜欢蘑菇，她想要找到连续的四片披萨使得上面的蘑菇最多。", "test_cases": [{"input": "5\n2\n1\n4\n5\n1\n2\n3", "output": "12"}, {"input": "2\n6\n5\n3\n3\n7\n2\n6", "output": "19"}, {"input": "5 2 1 4 5 1 2 3\n", "output": "12"}, {"input": "2 6 5 3 3 7 2 6\n", "output": "19"}, {"input": "1 2 3 4 5 6 7 8\n", "output": "26"}, {"input": "8 7 6 5 4 3 2 1\n", "output": "26"}, {"input": "1 1 1 1 1 1 1 1\n", "output": "4"}, {"input": "10 20 30 40 50 60 70 80\n", "output": "260"}, {"input": "100 200 300 400 500 600 700 800\n", "output": "2600"}, {"input": "5 5 5 5 5 5 5 5\n", "output": "20"}, {"input": "4 4 4 2 2 2 1 1\n", "output": "14"}, {"input": "0 0 0 0 0 3 3 3\n", "output": "9"}, {"input": "1 3 5 2 4 7 6 2", "output": "19"}, {"input": "4 6 8 1 3 5 7 9", "output": "27"}, {"input": "9 9 9 9 1 2 3 4", "output": "36"}, {"input": "2 2 5 5 6 6 1 1", "output": "22"}, {"input": "0\n0\n0\n0\n0\n0\n0\n0\n", "output": "0"}, {"input": "1\n1\n1\n1\n1\n1\n1\n1\n", "output": "4"}, {"input": "5\n5\n5\n5\n5\n5\n5\n5\n", "output": "20"}, {"input": "1\n2\n3\n4\n5\n6\n7\n8\n", "output": "26"}, {"input": "-1\n-2\n-3\n-4\n-5\n-6\n-7\n-8\n", "output": "0"}, {"input": "100\n100\n100\n100\n0\n0\n0\n0\n", "output": "400"}, {"input": "99\n99\n99\n99\n1\n1\n1\n1\n", "output": "396"}, {"input": "0\n0\n0\n0\n1\n2\n3\n4\n", "output": "10"}, {"input": "5 2 1 4\n5 1 2 3\n", "output": "12"}, {"input": "2 6 5 3\n3 7 2 6\n", "output": "19"}, {"input": "8 8 8 8\n8 8 8 8\n", "output": "32"}, {"input": "1 2 3 4\n5 6 7 8\n", "output": "26"}, {"input": "4 3 2 1\n0 0 0 0\n", "output": "10"}, {"input": "4 2 1 1\n4 2 1 1\n", "output": "8"}, {"input": "3 3 3 3\n3 3 3 3\n", "output": "12"}, {"input": "1 1 1 2\n2 1 1 1\n", "output": "6"}, {"input": "0 0 0 0\n0 0 0 0\n", "output": "0"}, {"input": "1 2 3 4\n0 0 0 0\n", "output": "10"}, {"input": "8 8 8 8\n4 4 4 4\n", "output": "32"}, {"input": "7 6 5 4\n3 2 1 0\n", "output": "22"}, {"input": "5 0 5 0\n0 5 0 5\n", "output": "15"}, {"input": "10 10 10 10\n15 15 15 15\n", "output": "60"}, {"input": "9\n8\n7\n6\n5\n4\n3\n2\n", "output": "30"}, {"input": "3\n3\n3\n3\n3\n3\n3\n3\n", "output": "12"}, {"input": "4\n4\n4\n4\n4\n4\n4\n4\n", "output": "16"}, {"input": "20\n20\n20\n20\n20\n20\n20\n20\n", "output": "80"}, {"input": "12\n34\n56\n78\n90\n12\n34\n56\n", "output": "258"}, {"input": "11\n22\n33\n44\n55\n66\n77\n88\n", "output": "286"}, {"input": "7\n33\n99\n66\n99\n33\n66\n99\n", "output": "297"}], "test": "#undef NDEBUG\n#include<assert.h>\nint main(){\n    assert(solution(\"5\\n2\\n1\\n4\\n5\\n1\\n2\\n3\") == \"12\");\n    assert(solution(\"2\\n6\\n5\\n3\\n3\\n7\\n2\\n6\") == \"19\");\n    assert(solution(\"5 2 1 4 5 1 2 3\\n\") == \"12\");\n    assert(solution(\"2 6 5 3 3 7 2 6\\n\") == \"19\");\n    assert(solution(\"1 2 3 4 5 6 7 8\\n\") == \"26\");\n    assert(solution(\"8 7 6 5 4 3 2 1\\n\") == \"26\");\n    assert(solution(\"1 1 1 1 1 1 1 1\\n\") == \"4\");\n    assert(solution(\"10 20 30 40 50 60 70 80\\n\") == \"260\");\n    assert(solution(\"100 200 300 400 500 600 700 800\\n\") == \"2600\");\n    assert(solution(\"5 5 5 5 5 5 5 5\\n\") == \"20\");\n    assert(solution(\"4 4 4 2 2 2 1 1\\n\") == \"14\");\n    assert(solution(\"0 0 0 0 0 3 3 3\\n\") == \"9\");\n    assert(solution(\"1 3 5 2 4 7 6 2\") == \"19\");\n    assert(solution(\"4 6 8 1 3 5 7 9\") == \"27\");\n    assert(solution(\"9 9 9 9 1 2 3 4\") == \"36\");\n    assert(solution(\"2 2 5 5 6 6 1 1\") == \"22\");\n    assert(solution(\"0\\n0\\n0\\n0\\n0\\n0\\n0\\n0\\n\") == \"0\");\n    assert(solution(\"1\\n1\\n1\\n1\\n1\\n1\\n1\\n1\\n\") == \"4\");\n    assert(solution(\"5\\n5\\n5\\n5\\n5\\n5\\n5\\n5\\n\") == \"20\");\n    assert(solution(\"1\\n2\\n3\\n4\\n5\\n6\\n7\\n8\\n\") == \"26\");\n    assert(solution(\"-1\\n-2\\n-3\\n-4\\n-5\\n-6\\n-7\\n-8\\n\") == \"0\");\n    assert(solution(\"100\\n100\\n100\\n100\\n0\\n0\\n0\\n0\\n\") == \"400\");\n    assert(solution(\"99\\n99\\n99\\n99\\n1\\n1\\n1\\n1\\n\") == \"396\");\n    assert(solution(\"0\\n0\\n0\\n0\\n1\\n2\\n3\\n4\\n\") == \"10\");\n    assert(solution(\"5 2 1 4\\n5 1 2 3\\n\") == \"12\");\n    assert(solution(\"2 6 5 3\\n3 7 2 6\\n\") == \"19\");\n    assert(solution(\"8 8 8 8\\n8 8 8 8\\n\") == \"32\");\n    assert(solution(\"1 2 3 4\\n5 6 7 8\\n\") == \"26\");\n    assert(solution(\"4 3 2 1\\n0 0 0 0\\n\") == \"10\");\n    assert(solution(\"4 2 1 1\\n4 2 1 1\\n\") == \"8\");\n    assert(solution(\"3 3 3 3\\n3 3 3 3\\n\") == \"12\");\n    assert(solution(\"1 1 1 2\\n2 1 1 1\\n\") == \"6\");\n    assert(solution(\"0 0 0 0\\n0 0 0 0\\n\") == \"0\");\n    assert(solution(\"1 2 3 4\\n0 0 0 0\\n\") == \"10\");\n    assert(solution(\"8 8 8 8\\n4 4 4 4\\n\") == \"32\");\n    assert(solution(\"7 6 5 4\\n3 2 1 0\\n\") == \"22\");\n    assert(solution(\"5 0 5 0\\n0 5 0 5\\n\") == \"15\");\n    assert(solution(\"10 10 10 10\\n15 15 15 15\\n\") == \"60\");\n    assert(solution(\"9\\n8\\n7\\n6\\n5\\n4\\n3\\n2\\n\") == \"30\");\n    assert(solution(\"3\\n3\\n3\\n3\\n3\\n3\\n3\\n3\\n\") == \"12\");\n    assert(solution(\"4\\n4\\n4\\n4\\n4\\n4\\n4\\n4\\n\") == \"16\");\n    assert(solution(\"20\\n20\\n20\\n20\\n20\\n20\\n20\\n20\\n\") == \"80\");\n    assert(solution(\"12\\n34\\n56\\n78\\n90\\n12\\n34\\n56\\n\") == \"258\");\n    assert(solution(\"11\\n22\\n33\\n44\\n55\\n66\\n77\\n88\\n\") == \"286\");\n    assert(solution(\"7\\n33\\n99\\n66\\n99\\n33\\n66\\n99\\n\") == \"297\");\n    return 0; \n}", "prompt": "/*Hansel and Gretel got a pizza divided into 8 slices, each with a different number of mushrooms represented by $S_1, S_2,..., S_8$. Gretel loves mushrooms and wants to find a consecutive set of four slices with the highest total number of mushrooms.\n\ninput_format:\nThere are a total of $8$lines, each line has a positive integer $S_i$($i$is the number of rows), indicating the number of mushrooms on the pizza slice.\n\noutput_format:\nA line of a positive integer indicates that there are at most a few mushrooms on four slices of pizza in a row.\n*/\n\n#include<sstream>\n#include<stdlib.h>\n#include<algorithm>\n#include<math.h>\n#include<stdio.h>\n#include<vector>\n#include<string>\n#include<climits>\n#include<cstring>\n#include<iostream>\nusing namespace std;\n\n             \nstring solution(string std_in){\n    istringstream iss(std_in);\n             ", "constraints": "对于 $100\\%$ 的数据，$0 \\leq S_i \\leq 50$。\n\n译自 [COCI 2014/2015 CONTEST #5](https://hsin.hr/coci/archive/2014_2015/contest5_tasks.pdf)。", "samples": [["5\n2\n1\n4\n5\n1\n2\n3", "12"], ["2\n6\n5\n3\n3\n7\n2\n6", "19"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [32768, 32768, 32768, 32768, 32768, 32768, 32768, 32768, 32768, 32768]}}
{"task_id": "P6367", "title": "[COCI2006-2007#6] PRASE", "difficulty": "basic", "nl": "The children are having lunch at the table with n portions of food. The children will take away these n portions of food in order from 1 to n.\n\nWhen a child takes away a portion of food, if the number of portions of food he has taken away before (excluding the current one) is more than the sum of portions of food taken away by other children, his mother will remind him of his impolite behavior. Note that although the mother reminds him, he will still take away this portion of food. In other words, the mother's reminder has no effect on the child's behavior.\n\nGiven which child took away the n portions of food, please determine how many times the mothers have reminded their children.", "code": "#include <map>\n#include <string>\n#include <iostream>\n\nint n;\nstd::map<std::string, int> mp;\n\nint main() {\n  std::cin >> n;\n  int ans = 0;\n  std::string tmp;\n  for (int i = 0; i < n; ++i) {\n    std::cin >> tmp;\n    int k = i - mp[tmp];\n    if (mp[tmp]++ > k) ++ans;\n  }\n  std::cout << ans << std::endl;\n  return 0;\n}", "step": ["Read in an integer n.", "Initialize a map to hold strings and their frequency.", "Initialize a counter to count the frequency of repeated strings.", "For i from 0 to n, read in a string.", "Calculate the difference between the current index and the last occurrence of the string using the map.", "If the string has been seen before and the difference is less than its last occurrence, increment the counter.", "Print out the counter value.", "Exit the program."], "nl_cn": "孩子们正在餐桌旁吃午餐，共有 $n$ 份食物，孩子们会按照从 $1$ 至 $n$ 的顺序依次取走这 $n$ 份食物。\n\n当某个孩子取走了一份食物时，如果这个他之前已经取走的食物份数（不包括当前这一份）比其他人取走的食物份数之和还要多，那么他的妈妈就会提醒他注意自己不礼貌的行为。注意，虽然被妈妈提醒了，但是他仍然会取走这份食物。换句话说，妈妈的提醒对孩子的行为没有任何影响。\n\n给定 $n$ 份食物分别被哪个孩子取走了，请求出妈妈们一共提醒了多少次。", "test_cases": [{"input": "4\nmirko\nstanko\nstanko\nstanko\n", "output": "1"}, {"input": "17\na\nb\nb\na\na\na\nc\na\nb\nb\nc\nb\nb\nb\nb\nb\nb\n", "output": "4"}, {"input": "0\n", "output": "0"}, {"input": "1\na\n", "output": "0"}, {"input": "2\nx\nx\n", "output": "1"}, {"input": "3\na\na\nb\n", "output": "1"}, {"input": "6\na\nb\nc\nd\ne\nf\n", "output": "0"}, {"input": "5\na\nb\nc\nd\ne\n", "output": "0"}, {"input": "8\na\nb\nc\nd\ne\nf\ng\nh\n", "output": "0"}, {"input": "15\na\na\na\nb\nb\nc\nd\nd\nd\nd\nd\nd\nd\nd\n", "output": "4"}, {"input": "7\na\nb\nc\nd\ne\nf\ng\n", "output": "0"}, {"input": "9\na\na\na\nb\nc\nd\nd\nd\nd\n", "output": "2"}, {"input": "2\na\na\n", "output": "1"}, {"input": "7\na\na\na\na\na\na\na\n", "output": "6"}, {"input": "8\na\nb\nc\nd\ne\ne\ne\n", "output": "0"}, {"input": "11\na\na\na\na\na\na\na\na\na\na\n", "output": "10"}, {"input": "19\na\nb\nb\na\na\na\nc\na\nb\nb\nc\nb\nb\nb\nb\nb\nb\nb\na\n", "output": "5"}, {"input": "20\na\nb\nb\na\na\na\nc\na\nb\nb\nc\nb\nb\nb\nb\nb\nb\nb\na\na\n", "output": "5"}, {"input": "6\na\na\na\na\na\na\n", "output": "5"}, {"input": "4\na\nb\nc\nd\n", "output": "0"}, {"input": "3\na\nb\nc\n", "output": "0"}, {"input": "2\na\nb\n", "output": "0"}, {"input": "4\na\na\nb\nc\n", "output": "1"}], "test": "#undef NDEBUG\n#include<assert.h>\nint main(){\n    assert(solution(\"4\\nmirko\\nstanko\\nstanko\\nstanko\\n\") == \"1\");\n    assert(solution(\"17\\na\\nb\\nb\\na\\na\\na\\nc\\na\\nb\\nb\\nc\\nb\\nb\\nb\\nb\\nb\\nb\\n\") == \"4\");\n    assert(solution(\"0\\n\") == \"0\");\n    assert(solution(\"1\\na\\n\") == \"0\");\n    assert(solution(\"2\\nx\\nx\\n\") == \"1\");\n    assert(solution(\"3\\na\\na\\nb\\n\") == \"1\");\n    assert(solution(\"6\\na\\nb\\nc\\nd\\ne\\nf\\n\") == \"0\");\n    assert(solution(\"5\\na\\nb\\nc\\nd\\ne\\n\") == \"0\");\n    assert(solution(\"8\\na\\nb\\nc\\nd\\ne\\nf\\ng\\nh\\n\") == \"0\");\n    assert(solution(\"15\\na\\na\\na\\nb\\nb\\nc\\nd\\nd\\nd\\nd\\nd\\nd\\nd\\nd\\n\") == \"4\");\n    assert(solution(\"7\\na\\nb\\nc\\nd\\ne\\nf\\ng\\n\") == \"0\");\n    assert(solution(\"9\\na\\na\\na\\nb\\nc\\nd\\nd\\nd\\nd\\n\") == \"2\");\n    assert(solution(\"2\\na\\na\\n\") == \"1\");\n    assert(solution(\"7\\na\\na\\na\\na\\na\\na\\na\\n\") == \"6\");\n    assert(solution(\"8\\na\\nb\\nc\\nd\\ne\\ne\\ne\\n\") == \"0\");\n    assert(solution(\"11\\na\\na\\na\\na\\na\\na\\na\\na\\na\\na\\n\") == \"10\");\n    assert(solution(\"19\\na\\nb\\nb\\na\\na\\na\\nc\\na\\nb\\nb\\nc\\nb\\nb\\nb\\nb\\nb\\nb\\nb\\na\\n\") == \"5\");\n    assert(solution(\"20\\na\\nb\\nb\\na\\na\\na\\nc\\na\\nb\\nb\\nc\\nb\\nb\\nb\\nb\\nb\\nb\\nb\\na\\na\\n\") == \"5\");\n    assert(solution(\"6\\na\\na\\na\\na\\na\\na\\n\") == \"5\");\n    assert(solution(\"4\\na\\nb\\nc\\nd\\n\") == \"0\");\n    assert(solution(\"3\\na\\nb\\nc\\n\") == \"0\");\n    assert(solution(\"2\\na\\nb\\n\") == \"0\");\n    assert(solution(\"4\\na\\na\\nb\\nc\\n\") == \"1\");\n    return 0; \n}", "prompt": "/*The children are having lunch at the table with n portions of food. The children will take away these n portions of food in order from 1 to n.\n\nWhen a child takes away a portion of food, if the number of portions of food he has taken away before (excluding the current one) is more than the sum of portions of food taken away by other children, his mother will remind him of his impolite behavior. Note that although the mother reminds him, he will still take away this portion of food. In other words, the mother's reminder has no effect on the child's behavior.\n\nGiven which child took away the n portions of food, please determine how many times the mothers have reminded their children.\n\ninput_format:\nThe first line is an integer representing the number of servings of food $n$.\n\nLines $2 through $(n + 1)$have one string per line, and the string $s_i$in line $(i + 1) represents the name of the child who took the $i$portion.\n\noutput_format:\nOutput a line with an integer representing the answer.\n*/\n\n#include<sstream>\n#include<stdlib.h>\n#include<algorithm>\n#include<math.h>\n#include<stdio.h>\n#include<vector>\n#include<string>\n#include<climits>\n#include<cstring>\n#include<iostream>\nusing namespace std;\n\n             \nstring solution(string std_in){\n    istringstream iss(std_in);\n             ", "constraints": "#### 样例 1 解释\n\n当取到第 $3$ 份食物时，stanko 已取走的食物（不包括当前这份）的份数是一份，而其他人也总共取走了一份，所以 stanko 的妈妈不会提醒他注意礼貌。\n\n当取到第 $4$ 份食物时，stanko 已经取走两份食物，其他人总共取走了一份食物，因此妈妈会提醒他。\n\n---\n\n#### 数据规模与约定\n\n对于全部的测试点，保证：\n\n- $1 \\leq n \\leq 100$\n- $1 \\leq |s_i| \\leq 20$，$s_i$ 中只含小写英文字母。$|s_i|$ 表示字符串 $s_i$ 的长度。\n\n---\n\n#### 说明\n\n**题目译自 [COCI2006-2007](https://hsin.hr/coci/archive/2006_2007/) [CONTEST #6](https://hsin.hr/coci/archive/2006_2007/contest6_tasks.pdf) *T1  PRASE***。", "samples": [["4\nmirko\nstanko\nstanko\nstanko\n", "1"], ["17\na\nb\nb\na\na\na\nc\na\nb\nb\nc\nb\nb\nb\nb\nb\nb\n", "4"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000], "memory": [32000, 32000, 32000, 32000, 32000]}}
{"task_id": "P5831", "title": "[USACO19DEC]Cow Gymnastics B", "difficulty": "basic", "nl": "To improve their health level, cows have started doing gymnastics training! Farmer John chooses his favorite cow Bessie to teach the other N cows and evaluate their progress in learning different gymnastic techniques.\n\nDuring each of the K training sessions, Bessie ranks the N cows based on their performance. Afterwards, she becomes curious about the consistency of these rankings. Two distinct cows are considered **consistent** if one cow performs better than the other in every training session.\n\nHelp Bessie calculate the number of consistent pairs of cows.", "code": "#include <bits/stdc++.h>//不解释了\nusing namespace std;\nint n,k;//输入数据\nint zjl=0;//计数器———同学名字（呵呵）\nint a[11][21],c[11][21];//a输入数据，c存排名\nint main()\n{\n//读入部分\n    scanf(\"%d%d\",&k,&n);//输入k和n\n    for(int i=1;i<=k;i++)//双层循环读入\n    {\n        for(int j=1;j<=n;j++)\n        {\n            scanf(\"%d\",&a[i][j]);//输入a数组\n            c[i][a[i][j]]=j;//这里存储第i天第j头奶牛的排名               \n        }\n    }\n    //以下为暴力阶段\n    for(int i=1;i<=n;i++)//三层暴力\n    {\n        for(int j=1;j<=n;j++)\n        {\n            int cnt=0;//内部计数器\n            for(int x=1;x<=k;x++)//枚举每一天\n            {\n                if(c[x][i]>c[x][j])//如果排名是大于\n                {\n                    cnt++;\n                }\n            }\n            if(cnt==k)//cnt等于k说明是每一天排名都一致，可以算作是一致的一对\n            {\n                zjl++;//于是乎，计数器自增\n            }\n        }\n    }\n    printf(\"%d\",zjl);//输出“一致的”对数\n    return 0;//结束\n}", "step": ["Take inputs", "Count pairs where i appears before j", "Count how many times the pair i and j appears in k groups", "If found in all k groups, count it", "Print the count"], "nl_cn": "为了提高健康水平，奶牛们开始进行体操训练了！Farmer John 选定了他最喜爱的奶牛 Bessie 来执教其他 $N$ 头奶牛，同时评估她们学习不同的体操技术的进度。\n\n$K$ 次训练课的每一次，Bessie 都会根据 $N$ 头奶牛的表现给她们进行排名。之后，她对这些排名的一致性产生了好奇。称一对不同的奶牛是**一致的**，如果其中一头奶牛在每次训练课中都表现得都比另一头要好。\n\n请帮助 Bessie 计算一致的奶牛的对数。", "test_cases": [{"input": "3 4\n4 1 2 3\n4 1 3 2\n4 2 1 3", "output": "4"}, {"input": "2 3\n1 2 3\n2 1 3\n", "output": "2"}, {"input": "1 1\n1\n", "output": "0"}, {"input": "3 3\n1 3 2\n3 1 2\n2 1 3\n", "output": "0"}, {"input": "3 2\n2 1\n2 1\n", "output": "0"}, {"input": "1 2\n2 1", "output": "1"}, {"input": "3 2\n2 1\n2 1\n2 2", "output": "0"}, {"input": "1 4\n4 1 2 3", "output": "6"}, {"input": "4 5\n3 2 1 5 4\n4 5 1 2 3\n1 3 5 2 4\n3 2 1 5 4\n", "output": "0"}, {"input": "2 2\n1 2\n2 1\n", "output": "0"}, {"input": "4 4\n1 2 3 4\n2 1 3 4\n3 4 1 2\n4 3 2 1\n", "output": "0"}, {"input": "1 3\n1 2 3\n3 2 1\n", "output": "3"}, {"input": "3 5\n1 2 3 4 5\n5 4 3 2 1\n2 1 3 4 5\n", "output": "0"}, {"input": "2 2\n1 1\n2 2\n", "output": "0"}, {"input": "4 6\n6 5 4 3 2 1\n6 5 4 3 2 1\n6 5 4 3 2 1\n6 5 4 3 2 1\n", "output": "15"}], "test": "#undef NDEBUG\n#include<assert.h>\nint main(){\n    assert(solution(\"3 4\\n4 1 2 3\\n4 1 3 2\\n4 2 1 3\") == \"4\");\n    assert(solution(\"2 3\\n1 2 3\\n2 1 3\\n\") == \"2\");\n    assert(solution(\"1 1\\n1\\n\") == \"0\");\n    assert(solution(\"3 3\\n1 3 2\\n3 1 2\\n2 1 3\\n\") == \"0\");\n    assert(solution(\"3 2\\n2 1\\n2 1\\n\") == \"0\");\n    assert(solution(\"1 2\\n2 1\") == \"1\");\n    assert(solution(\"3 2\\n2 1\\n2 1\\n2 2\") == \"0\");\n    assert(solution(\"1 4\\n4 1 2 3\") == \"6\");\n    assert(solution(\"4 5\\n3 2 1 5 4\\n4 5 1 2 3\\n1 3 5 2 4\\n3 2 1 5 4\\n\") == \"0\");\n    assert(solution(\"2 2\\n1 2\\n2 1\\n\") == \"0\");\n    assert(solution(\"4 4\\n1 2 3 4\\n2 1 3 4\\n3 4 1 2\\n4 3 2 1\\n\") == \"0\");\n    assert(solution(\"1 3\\n1 2 3\\n3 2 1\\n\") == \"3\");\n    assert(solution(\"3 5\\n1 2 3 4 5\\n5 4 3 2 1\\n2 1 3 4 5\\n\") == \"0\");\n    assert(solution(\"2 2\\n1 1\\n2 2\\n\") == \"0\");\n    assert(solution(\"4 6\\n6 5 4 3 2 1\\n6 5 4 3 2 1\\n6 5 4 3 2 1\\n6 5 4 3 2 1\\n\") == \"15\");\n    return 0; \n}", "prompt": "/*To improve their health level, cows have started doing gymnastics training! Farmer John chooses his favorite cow Bessie to teach the other N cows and evaluate their progress in learning different gymnastic techniques.\n\nDuring each of the K training sessions, Bessie ranks the N cows based on their performance. Afterwards, she becomes curious about the consistency of these rankings. Two distinct cows are considered **consistent** if one cow performs better than the other in every training session.\n\nHelp Bessie calculate the number of consistent pairs of cows.\n\ninput_format:\nThe first line of input contains two positive integers $K$and $N$. Each of the following $K$rows contains some arrangement of the integers $1 \\ldots N$, representing the rank of the cows (cows are distinguished by the number $1 \\ldots N$). If $A$comes before $B$in A line, it means that the cow $A$performed better than the cow $B$.\n\noutput_format:\nOutput a line containing the consistent logarithm of the cows.\n*/\n\n#include<sstream>\n#include<stdlib.h>\n#include<algorithm>\n#include<math.h>\n#include<stdio.h>\n#include<vector>\n#include<string>\n#include<climits>\n#include<cstring>\n#include<iostream>\nusing namespace std;\n\n             \nstring solution(string std_in){\n    istringstream iss(std_in);\n             ", "constraints": "一致的奶牛对为 $(1,4)$、$(2,4)$、$(3,4)$ 和 $(1,3)$。\n\n$1 \\leq K \\leq 10$，$1 \\leq N \\leq 20$。\n\n供题：Nick Wu", "samples": [["3 4\n4 1 2 3\n4 1 3 2\n4 2 1 3", "4"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}}
{"task_id": "P5560", "title": "[Celeste-B]Golden Feather", "difficulty": "advanced", "nl": "\"Your breath keeps the feather floating.\"\n\n\"Take a deep breath in, and let it out slowly.\"\n\n\"See? It's always so easy.\"\n\nAs Madeline breathes, the feather moves up and down.\n\nThrough Madeline's observation, she finds that the feather follows a magical pattern of movement.\n\nIn each breath cycle, the feather will stop at specific places, which are all magical. Specifically, the magic of the $i$-th stopping place is $(i+1)^2-1$.\n\nMoreover, at the end of each breath cycle, the feather exudes some energy. As long as Madeline can use this energy to connect these stopping places, she can harness the power of the feather and fly. More specifically, as like charges repel, the higher the similarity between the magic of two places, the more difficult it is to connect them, and the energy needed to connect two places is their greatest common divisor (GCD).\n\nBreath after breath, Madeline has become too occupied to calculate the minimum energy required. Due to the limited energy exuded by the feather, could you help her calculate the minimum energy needed to connect these stopping places?", "code": "#include <cstdio>\n#define ll long long\n\nusing namespace std;\n\nll t, n;\n\nint main(){\n\tscanf(\"%lld\",&t);\n\twhile(t--){\n\t\tscanf(\"%lld\",&n);\n\t\tif(n == 4) printf(\"5\\n\");\n\t\telse if(n == 10) printf(\"11\\n\");\n\t\telse printf(\"%lld\\n\",n - 1);\n\t}\n\treturn 0;\n}", "step": ["Read integer t from the input.", "Loop t times:", "\tRead integer n from the input.", "\tIf n is equal to 4, print 5.", "\tIf n is equal to 10, print 11.", "\tOtherwise, print n-1."], "nl_cn": "“你的呼吸让那片羽毛一直飘着。”\n\n“平稳缓慢地呼吸，吸气，吐气。”\n\n“看吧，每次都是这么轻松。”\n\n随着 Madeline 的呼吸，羽毛上下移动着。\n\n通过 Madeline 的观察，她还发现，羽毛似乎遵循这一种神奇的运动轨迹。\n\n在每一轮呼吸中，羽毛会在特定的地方停止，这些地方都是有魔力的，具体来说，第 $i$ 个停留处的魔力是 $(i+1)^2-1$。\n\n并且，在一轮呼吸停止时，羽毛会渗透出一些能量，只要能用这些能量沟通这些停止的地方，Madeline 就能运用羽毛的力量飞翔。更具体的，由于同性相斥，两个地方魔力的相似程度越高就越难被沟通，沟通两个地方所需要的能量为这两个地方魔力的 $gcd$。\n\n在一轮一轮的呼吸中，Madeline 已经无暇算出最少需要的能量，由于羽毛渗透出的能量不多，你能帮帮她算出最少需要多少能量来沟通这些羽毛停止的地方吗？", "test_cases": [{"input": "4\n1\n2\n3\n9\n", "output": "0\n1\n2\n8"}, {"input": "1\n1\n", "output": "0"}, {"input": "1\n2\n", "output": "1"}, {"input": "1\n3\n", "output": "2"}, {"input": "1\n9\n", "output": "8"}, {"input": "2\n1\n2\n", "output": "0\n1"}, {"input": "2\n3\n9\n", "output": "2\n8"}, {"input": "3\n1\n2\n3\n", "output": "0\n1\n2"}], "test": "#undef NDEBUG\n#include<assert.h>\nint main(){\n    assert(solution(\"4\\n1\\n2\\n3\\n9\\n\") == \"0\\n1\\n2\\n8\");\n    assert(solution(\"1\\n1\\n\") == \"0\");\n    assert(solution(\"1\\n2\\n\") == \"1\");\n    assert(solution(\"1\\n3\\n\") == \"2\");\n    assert(solution(\"1\\n9\\n\") == \"8\");\n    assert(solution(\"2\\n1\\n2\\n\") == \"0\\n1\");\n    assert(solution(\"2\\n3\\n9\\n\") == \"2\\n8\");\n    assert(solution(\"3\\n1\\n2\\n3\\n\") == \"0\\n1\\n2\");\n    return 0; \n}", "prompt": "/*\"Your breath keeps the feather floating.\"\n\n\"Take a deep breath in, and let it out slowly.\"\n\n\"See? It's always so easy.\"\n\nAs Madeline breathes, the feather moves up and down.\n\nThrough Madeline's observation, she finds that the feather follows a magical pattern of movement.\n\nIn each breath cycle, the feather will stop at specific places, which are all magical. Specifically, the magic of the $i$-th stopping place is $(i+1)^2-1$.\n\nMoreover, at the end of each breath cycle, the feather exudes some energy. As long as Madeline can use this energy to connect these stopping places, she can harness the power of the feather and fly. More specifically, as like charges repel, the higher the similarity between the magic of two places, the more difficult it is to connect them, and the energy needed to connect two places is their greatest common divisor (GCD).\n\nBreath after breath, Madeline has become too occupied to calculate the minimum energy required. Due to the limited energy exuded by the feather, could you help her calculate the minimum energy needed to connect these stopping places?\n\ninput_format:\nThe first line has a positive integer $T$, indicating the number of breathing rounds.\n\nThe next $T$line is a positive integer $n$, indicating the number of places the feather stops in that round of breathing.\n\noutput_format:\nOutput $T$rows, rows of one integer, the minimum amount of energy required.\n*/\n\n#include<sstream>\n#include<stdlib.h>\n#include<algorithm>\n#include<math.h>\n#include<stdio.h>\n#include<vector>\n#include<string>\n#include<climits>\n#include<cstring>\n#include<iostream>\nusing namespace std;\n\n             \nstring solution(string std_in){\n    istringstream iss(std_in);\n             ", "constraints": "n=3 的样例解释如下图\n\n![T1_2.png](https://i.loli.net/2019/09/14/PtflkNCE8b3iKzB.png)\n![T1.png](https://i.loli.net/2019/09/14/AIYlMZgonL7thfu.png)\n\n对于 $5\\%$ 的数据，$n \\leq 3$\n\n对于 $10\\%$ 的数据，$n \\leq 1000$\n\n对于 $50\\%$ 的数据，$n \\leq 10^6$,$T \\leq 10$\n\n对于 $100\\%$ 的数据，$n \\leq 10^{18}$,$T \\leq 100$", "samples": [["4\n1\n2\n3\n9\n", "0\n1\n2\n8"]], "limits": {"time": [500, 500, 500, 500], "memory": [128000, 128000, 128000, 128000]}}
{"task_id": "P5742", "title": "【深基7.例11】评等级", "difficulty": "challenge", "nl": "There are N students, each of whom needs to design a struct to record the following information: student ID, academic score, quality development score, and comprehensive score (real number). Read in each student's name, academic score, and quality development score, and calculate the comprehensive score (accumulated by weights of 70% and 30% respectively), and store it in the struct. You also need to define a member function in the struct to return the total score of academic score and quality development score of the struct object.\n\nThen, design a function whose parameter is a student struct object to determine whether the student is \"excellent\". The definition of \"excellent\" is that the total score of academic and quality development scores is **greater than** 140 and the comprehensive score is **not less than** 80.\n\n> Of course, it's easy to pass this question. This question is just to help you practice the use of structs.\n\nThere is a precision error issue in this question. Please compare `a * 0.3 + b * 0.7` with 80 by converting it to `a * 3 + b * 7` and comparing it with 800.", "code": "#include <iostream>\n#include <cstdio>\n#include <cstring>\nusing namespace std;\nstruct node {\n    int id;//学号\n    double sc1, sc2;//学业成绩和素质拓展成绩\n    int score;//学业成绩和素质拓展成绩的和\n    double final_score;//综合分数\n}a[1000];//结构体定义，由于本人习惯（懒），sc1和sc2定义成了double。\nint main() {\n    int n;\n    cin >> n;\n    for(int i=0; i<n; i++) {\n        cin >> a[i].id >> a[i].sc1 >> a[i].sc2;\n        a[i].score = a[i].sc1 + a[i].sc2;\n        a[i].final_score = a[i].sc1 * 0.7 + a[i].sc2 * 0.3;//计算综合分数\n    }\n    for(int i=0; i<n; i++) {\n        if(a[i].score > 140 && a[i].final_score >= 80) {//一定看清题\n            cout << \"Excellent\" << endl;\n        }\n        else {\n            cout << \"Not excellent\" << endl;\n        }\n    }\n    return 0;\n}", "step": ["Read input for number of students.", "Loop through each student and read their id, score 1 and score 2. Calculate the total score by adding the two scores and calculate the final score using a weighted average formula.", "Loop through each student and check if their total score is greater than 140 and their final score is greater than or equal to 80. If so, print 'Excellent'. Otherwise, print 'Not excellent'.", "Return 0 to end the program."], "nl_cn": "现有 $N$ 名同学，每名同学需要设计一个结构体记录以下信息：学号、学业成绩和素质拓展成绩、综合分数（实数）。每行读入同学的姓名、学业成绩和素质拓展成绩，并且计算综合分数（分别按照 $70\\%$ 和 $30\\%$ 权重累加），存入结构体中。还需要在结构体中定义一个成员函数，返回该结构体对象的学业成绩和素质拓展成绩的总分。\n\n然后需要设计一个函数，其参数是一个学生结构体对象，判断该学生是否“优秀”。优秀的定义是学业和素质拓展成绩总分**大于** $140$ 分，且综合分数**不小于** $80$ 分。\n\n> 当然通过本题很容易啦，本题只是为了帮助你训练结构体的使用方法。\n\n本题存在精度误差问题，请将 `a * 0.3 + b * 0.7` 与 80 比较 转化为 `a * 3 + b * 7` 与 800 比较。", "test_cases": [{"input": "4\n1223 95 59\n1224 50 7\n1473 32 45\n1556 86 99", "output": "Excellent\nNot excellent\nNot excellent\nExcellent"}, {"input": "5\n1111 95 85\n2222 75 70\n3333 80 90\n4444 60 60\n5555 100 95", "output": "Excellent\nNot excellent\nExcellent\nNot excellent\nExcellent"}, {"input": "1\n6666 70 80", "output": "Not excellent"}, {"input": "2\n2222 80 70\n3333 70 80", "output": "Not excellent\nNot excellent"}, {"input": "1\n4444 70 80", "output": "Not excellent"}, {"input": "3\n7777 60 90\n8888 70 80\n9999 80 70", "output": "Not excellent\nNot excellent\nNot excellent"}, {"input": "2\n3333 80 70\n4444 70 80", "output": "Not excellent\nNot excellent"}, {"input": "1\n5555 70 80", "output": "Not excellent"}], "test": "#undef NDEBUG\n#include<assert.h>\nint main(){\n    assert(solution(\"4\\n1223 95 59\\n1224 50 7\\n1473 32 45\\n1556 86 99\") == \"Excellent\\nNot excellent\\nNot excellent\\nExcellent\");\n    assert(solution(\"5\\n1111 95 85\\n2222 75 70\\n3333 80 90\\n4444 60 60\\n5555 100 95\") == \"Excellent\\nNot excellent\\nExcellent\\nNot excellent\\nExcellent\");\n    assert(solution(\"1\\n6666 70 80\") == \"Not excellent\");\n    assert(solution(\"2\\n2222 80 70\\n3333 70 80\") == \"Not excellent\\nNot excellent\");\n    assert(solution(\"1\\n4444 70 80\") == \"Not excellent\");\n    assert(solution(\"3\\n7777 60 90\\n8888 70 80\\n9999 80 70\") == \"Not excellent\\nNot excellent\\nNot excellent\");\n    assert(solution(\"2\\n3333 80 70\\n4444 70 80\") == \"Not excellent\\nNot excellent\");\n    assert(solution(\"1\\n5555 70 80\") == \"Not excellent\");\n    return 0; \n}", "prompt": "/*There are N students, each of whom needs to design a struct to record the following information: student ID, academic score, quality development score, and comprehensive score (real number). Read in each student's name, academic score, and quality development score, and calculate the comprehensive score (accumulated by weights of 70% and 30% respectively), and store it in the struct. You also need to define a member function in the struct to return the total score of academic score and quality development score of the struct object.\n\nThen, design a function whose parameter is a student struct object to determine whether the student is \"excellent\". The definition of \"excellent\" is that the total score of academic and quality development scores is **greater than** 140 and the comprehensive score is **not less than** 80.\n\n> Of course, it's easy to pass this question. This question is just to help you practice the use of structs.\n\nThere is a precision error issue in this question. Please compare `a * 0.3 + b * 0.7` with 80 by converting it to `a * 3 + b * 7` and comparing it with 800.\n\ninput_format:\nThe first line is an integer $N$.\n\nThe next $N$line, each $3$integer, in order to represent the student number, academic achievement and quality development achievement.\n\noutput_format:\nIn the $N$line, if the first $i$student is outstanding, the output is' Excellent ', otherwise the output is' Not excellent '.\n*/\n\n#include<sstream>\n#include<stdlib.h>\n#include<algorithm>\n#include<math.h>\n#include<stdio.h>\n#include<vector>\n#include<string>\n#include<climits>\n#include<cstring>\n#include<iostream>\nusing namespace std;\n\n             \nstring solution(string std_in){\n    istringstream iss(std_in);\n             ", "constraints": "数据保证，$1 \\le N\\le 1000$，学号为不超过 $100000$ 的正整数，学业成绩和素质拓展成绩为 $0 \\sim 100$ 之间的正整数。", "samples": [["4\n1223 95 59\n1224 50 7\n1473 32 45\n1556 86 99", "Excellent\nNot excellent\nNot excellent\nExcellent"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000], "memory": [131072, 131072, 131072, 131072, 131072]}}
{"task_id": "P1094", "title": "[NOIP2007 普及组] 纪念品分组", "difficulty": "challenge", "nl": "New Year's Day is coming soon, and the student union of the school has asked Lele to be in charge of distributing souvenirs for the New Year's party. In order to ensure that the souvenirs obtained by the students who attend the party are relatively evenly valued, he wants to group the purchased souvenirs according to their prices. However, each group can include at most two souvenirs, and the sum of the prices of each group of souvenirs cannot exceed a given integer. In order to ensure that all souvenirs are distributed as quickly as possible, Lele hopes to minimize the number of groups.\n\nYour task is to write a program to find the minimum number of groups among all grouping schemes and output the minimum number of groups.", "code": "#include<bits/stdc++.h>\nusing namespace std;\nint W,ans=0;\nint n,a[30001];\nint l,r,i;\nint main()\n{\n    scanf(\"%d%d\",&W,&n);\n    for(i=1;i<=n;i++)\n      scanf(\"%d\",&a[i]);\n    sort(a+1,a+n+1);\n    l=1;  r=n;\n    while(l<=r)//一定要有等号。\n    {\n        if(a[l]+a[r]<=W)   //一定要有等号。\n          l++,r--,ans++;\n        else\n          r--,ans++;   //贪心过程\n    }\n    printf(\"%d\",ans);\n    return 0;\n}", "step": ["Take input of W and n", "Take input of array a of size n", "Sort array a in ascending order", "Initialize l=1 and r=n", "Loop until l<=r", "If sum of a[l] and a[r] is less than or equal to W, increment l, decrement r and increment ans. Otherwise, decrement r and increment ans."], "nl_cn": "元旦快到了，校学生会让乐乐负责新年晚会的纪念品发放工作。为使得参加晚会的同学所获得 的纪念品价值相对均衡，他要把购来的纪念品根据价格进行分组，但每组最多只能包括两件纪念品， 并且每组纪念品的价格之和不能超过一个给定的整数。为了保证在尽量短的时间内发完所有纪念品，乐乐希望分组的数目最少。\n\n你的任务是写一个程序，找出所有分组方案中分组数最少的一种，输出最少的分组数目。\n", "test_cases": [{"input": "100 \n9 \n90 \n20 \n20 \n30 \n50 \n60 \n70 \n80 \n90\n", "output": "6"}, {"input": "200 \n6 \n50 \n50 \n50 \n40 \n70 \n80\n", "output": "3"}, {"input": "80 \n7 \n30 \n35 \n35 \n25 \n45 \n40 \n26\n", "output": "4"}, {"input": "250 \n8 \n60 \n70 \n80 \n90 \n100 \n110 \n120 \n130\n", "output": "4"}, {"input": "80 \n6 \n25 \n30 \n20 \n15 \n10 \n5\n", "output": "3"}, {"input": "180 \n5 \n60 \n50 \n80 \n75 \n10\n", "output": "3"}, {"input": "100 \n5 \n70 \n20 \n30 \n40 \n50\n", "output": "3"}, {"input": "90 \n4 \n20 \n30 \n45 \n25\n", "output": "2"}, {"input": "150 \n7 \n40 \n50 \n60 \n70 \n80 \n90 \n100\n", "output": "4"}, {"input": "80 \n5 \n25 \n30 \n20 \n15 \n10\n", "output": "3"}, {"input": "200 \n6 \n75 \n50 \n55 \n60 \n80 \n95\n", "output": "3"}, {"input": "160 \n5 \n60 \n50 \n80 \n75 \n10\n", "output": "3"}, {"input": "90 \n4 \n30 \n40 \n45 \n25\n", "output": "2"}, {"input": "170 \n7 \n40 \n50 \n60 \n70 \n80 \n90 \n100\n", "output": "4"}, {"input": "200 \n10 \n40 \n60 \n70 \n80 \n90 \n100 \n110 \n120 \n130 \n140\n", "output": "5"}, {"input": "150 \n8 \n40 \n30 \n20 \n60 \n80 \n90 \n100 \n110\n", "output": "4"}, {"input": "80 \n6 \n10 \n20 \n30 \n40 \n50 \n60\n", "output": "3"}, {"input": "100 \n5 \n10 \n20 \n30 \n40 \n50\n", "output": "3"}, {"input": "70 \n6 \n10 \n20 \n30 \n40 \n50 \n60\n", "output": "3"}, {"input": "120 \n7 \n10 \n20 \n30 \n40 \n50 \n60 \n70\n", "output": "4"}, {"input": "90 \n6 \n10 \n20 \n30 \n40 \n50 \n60\n", "output": "3"}, {"input": "70 \n6 \n20 \n10 \n30 \n50 \n40 \n60\n", "output": "3"}, {"input": "70 \n6 \n30 \n40 \n20 \n50 \n10 \n60\n", "output": "3"}, {"input": "90 \n6 \n30 \n10 \n20 \n50 \n40 \n60\n", "output": "3"}, {"input": "80 \n6 \n30 \n40 \n20 \n50 \n10 \n60\n", "output": "3"}, {"input": "50 \n5 \n10 \n20 \n30 \n40 \n50\n", "output": "3"}, {"input": "150 \n6 \n30 \n40 \n50 \n60 \n70 \n80\n", "output": "3"}, {"input": "80 \n8 \n10 \n10 \n10 \n10 \n10 \n10 \n10 \n10\n", "output": "4"}, {"input": "300 \n10 \n50 \n80 \n120 \n200 \n250 \n300 \n100 \n150 \n180 \n220\n", "output": "6"}, {"input": "70 \n7 \n10 \n20 \n30 \n40 \n50 \n60 \n70\n", "output": "4"}, {"input": "110 \n9 \n10 \n20 \n30 \n40 \n50 \n60 \n70 \n80 \n90\n", "output": "5"}, {"input": "90 \n5 \n10 \n20 \n30 \n40 \n50\n", "output": "3"}, {"input": "100 \n4 \n10 \n20 \n30 \n40\n", "output": "2"}, {"input": "80 \n6 \n10 \n10 \n10 \n10 \n10 \n10\n", "output": "3"}, {"input": "70 \n6 \n10 \n10 \n10 \n10 \n10 \n10\n", "output": "3"}, {"input": "110 \n7 \n10 \n10 \n10 \n10 \n10 \n10 \n10\n", "output": "4"}, {"input": "90 \n9 \n10 \n10 \n10 \n10 \n10 \n10 \n10 \n10 \n10\n", "output": "5"}, {"input": "150 \n4 \n20 \n30 \n40 \n50\n", "output": "2"}], "test": "#undef NDEBUG\n#include<assert.h>\nint main(){\n    assert(solution(\"100 \\n9 \\n90 \\n20 \\n20 \\n30 \\n50 \\n60 \\n70 \\n80 \\n90\\n\") == \"6\");\n    assert(solution(\"200 \\n6 \\n50 \\n50 \\n50 \\n40 \\n70 \\n80\\n\") == \"3\");\n    assert(solution(\"80 \\n7 \\n30 \\n35 \\n35 \\n25 \\n45 \\n40 \\n26\\n\") == \"4\");\n    assert(solution(\"250 \\n8 \\n60 \\n70 \\n80 \\n90 \\n100 \\n110 \\n120 \\n130\\n\") == \"4\");\n    assert(solution(\"80 \\n6 \\n25 \\n30 \\n20 \\n15 \\n10 \\n5\\n\") == \"3\");\n    assert(solution(\"180 \\n5 \\n60 \\n50 \\n80 \\n75 \\n10\\n\") == \"3\");\n    assert(solution(\"100 \\n5 \\n70 \\n20 \\n30 \\n40 \\n50\\n\") == \"3\");\n    assert(solution(\"90 \\n4 \\n20 \\n30 \\n45 \\n25\\n\") == \"2\");\n    assert(solution(\"150 \\n7 \\n40 \\n50 \\n60 \\n70 \\n80 \\n90 \\n100\\n\") == \"4\");\n    assert(solution(\"80 \\n5 \\n25 \\n30 \\n20 \\n15 \\n10\\n\") == \"3\");\n    assert(solution(\"200 \\n6 \\n75 \\n50 \\n55 \\n60 \\n80 \\n95\\n\") == \"3\");\n    assert(solution(\"160 \\n5 \\n60 \\n50 \\n80 \\n75 \\n10\\n\") == \"3\");\n    assert(solution(\"90 \\n4 \\n30 \\n40 \\n45 \\n25\\n\") == \"2\");\n    assert(solution(\"170 \\n7 \\n40 \\n50 \\n60 \\n70 \\n80 \\n90 \\n100\\n\") == \"4\");\n    assert(solution(\"200 \\n10 \\n40 \\n60 \\n70 \\n80 \\n90 \\n100 \\n110 \\n120 \\n130 \\n140\\n\") == \"5\");\n    assert(solution(\"150 \\n8 \\n40 \\n30 \\n20 \\n60 \\n80 \\n90 \\n100 \\n110\\n\") == \"4\");\n    assert(solution(\"80 \\n6 \\n10 \\n20 \\n30 \\n40 \\n50 \\n60\\n\") == \"3\");\n    assert(solution(\"100 \\n5 \\n10 \\n20 \\n30 \\n40 \\n50\\n\") == \"3\");\n    assert(solution(\"70 \\n6 \\n10 \\n20 \\n30 \\n40 \\n50 \\n60\\n\") == \"3\");\n    assert(solution(\"120 \\n7 \\n10 \\n20 \\n30 \\n40 \\n50 \\n60 \\n70\\n\") == \"4\");\n    assert(solution(\"90 \\n6 \\n10 \\n20 \\n30 \\n40 \\n50 \\n60\\n\") == \"3\");\n    assert(solution(\"70 \\n6 \\n20 \\n10 \\n30 \\n50 \\n40 \\n60\\n\") == \"3\");\n    assert(solution(\"70 \\n6 \\n30 \\n40 \\n20 \\n50 \\n10 \\n60\\n\") == \"3\");\n    assert(solution(\"90 \\n6 \\n30 \\n10 \\n20 \\n50 \\n40 \\n60\\n\") == \"3\");\n    assert(solution(\"80 \\n6 \\n30 \\n40 \\n20 \\n50 \\n10 \\n60\\n\") == \"3\");\n    assert(solution(\"50 \\n5 \\n10 \\n20 \\n30 \\n40 \\n50\\n\") == \"3\");\n    assert(solution(\"150 \\n6 \\n30 \\n40 \\n50 \\n60 \\n70 \\n80\\n\") == \"3\");\n    assert(solution(\"80 \\n8 \\n10 \\n10 \\n10 \\n10 \\n10 \\n10 \\n10 \\n10\\n\") == \"4\");\n    assert(solution(\"300 \\n10 \\n50 \\n80 \\n120 \\n200 \\n250 \\n300 \\n100 \\n150 \\n180 \\n220\\n\") == \"6\");\n    assert(solution(\"70 \\n7 \\n10 \\n20 \\n30 \\n40 \\n50 \\n60 \\n70\\n\") == \"4\");\n    assert(solution(\"110 \\n9 \\n10 \\n20 \\n30 \\n40 \\n50 \\n60 \\n70 \\n80 \\n90\\n\") == \"5\");\n    assert(solution(\"90 \\n5 \\n10 \\n20 \\n30 \\n40 \\n50\\n\") == \"3\");\n    assert(solution(\"100 \\n4 \\n10 \\n20 \\n30 \\n40\\n\") == \"2\");\n    assert(solution(\"80 \\n6 \\n10 \\n10 \\n10 \\n10 \\n10 \\n10\\n\") == \"3\");\n    assert(solution(\"70 \\n6 \\n10 \\n10 \\n10 \\n10 \\n10 \\n10\\n\") == \"3\");\n    assert(solution(\"110 \\n7 \\n10 \\n10 \\n10 \\n10 \\n10 \\n10 \\n10\\n\") == \"4\");\n    assert(solution(\"90 \\n9 \\n10 \\n10 \\n10 \\n10 \\n10 \\n10 \\n10 \\n10 \\n10\\n\") == \"5\");\n    assert(solution(\"150 \\n4 \\n20 \\n30 \\n40 \\n50\\n\") == \"2\");\n    return 0; \n}", "prompt": "/*New Year's Day is coming soon, and the student union of the school has asked Lele to be in charge of distributing souvenirs for the New Year's party. In order to ensure that the souvenirs obtained by the students who attend the party are relatively evenly valued, he wants to group the purchased souvenirs according to their prices. However, each group can include at most two souvenirs, and the sum of the prices of each group of souvenirs cannot exceed a given integer. In order to ensure that all souvenirs are distributed as quickly as possible, Lele hopes to minimize the number of groups.\n\nYour task is to write a program to find the minimum number of groups among all grouping schemes and output the minimum number of groups.\n\ninput_format:\n$n+2$ lines in total:\n\nThe first line contains an integer $w$, which represents the upper limit of the sum of prices of all the purchased souvenirs.\n\nThe second line contains an integer $n$, which represents the total number of purchased souvenirs, $G$.\n\nLines $3$ to $n+2$ each contain a positive integer $P_i$, representing the price of the corresponding souvenir.\n\noutput_format:\nAn integer, that is, the minimum number of groups.\n*/\n\n#include<sstream>\n#include<stdlib.h>\n#include<algorithm>\n#include<math.h>\n#include<stdio.h>\n#include<vector>\n#include<string>\n#include<climits>\n#include<cstring>\n#include<iostream>\nusing namespace std;\n\n             \nstring solution(string std_in){\n    istringstream iss(std_in);\n             ", "constraints": "$50\\%$ 的数据满足：$1\\le n\\le15$。\n\n$100\\%$ 的数据满足：$1\\le n\\le3\\times10^4$，$80\\le w\\le200$，$5 \\le  P_i  \\le  w$。", "samples": [["100 \n9 \n90 \n20 \n20 \n30 \n50 \n60 \n70 \n80 \n90\n", "6\n"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}}
{"task_id": "P3560", "title": "[POI2013]LAN-Colorful Chain", "difficulty": "advanced", "nl": "Little Bytie likes to play with a colorful chain.\n\nHe has quite a collection, but some of them are more special than others.\n\nEach chain is made up of a certain number of colorful links.\n\nByteasar has noticed that Bytie has a very precise aesthetic sense.\n\nIn fact, if a contiguous segment of the chain contains exactly , and does not contain any links of other colors, then Bytie considers that segment to be very pretty.\n\nThe attractiveness of a chain is the number of (contiguous) pretty segments that it contains.\n\nThrough trial and error, Byteasar has determined the values of .\n\nNow he wants to buy a new chain, so he asks you to write a program to help him shop.\n\nGiven a sequence, determine how many contiguous subsequences contain exactly , and no other colors.", "code": "#include<bits/stdc++.h>\n#define int long long\nusing namespace std;\nconst int mod = 1e9 + 7 , base = 13331;\nint n , m , hsh[1000010] , sum[1000010] , l[1000010] , c[1000010] , a[1000010] , len , ans , res;\nsigned main()\n{\n    scanf(\"%lld%lld\" , &n , &m);\n    hsh[0] = 1;\n    for(int i = 1 ; i <= n ; i ++) hsh[i] = hsh[i - 1] * base % mod;\n    for(int i = 1 ; i <= m ; i ++) scanf(\"%lld\" , &l[i]) , len += l[i];\n    for(int i = 1 , x ; i <= m ; i ++) scanf(\"%lld\" , &x) , res += hsh[x] * l[i] % mod , res %= mod;\n    for(int i = 1 , x ; i <= n ; i ++) scanf(\"%lld\" , &x) , sum[i] = (sum[i - 1] + hsh[x]) % mod;\n    for(int i = 1 ; i + len - 1 <= n ; i ++) ans += ((sum[i + len - 1] - sum[i - 1] + mod) % mod == res);\n    printf(\"%lld\" , ans);\n    return 0;\n}", "step": ["Initialize variables and read input values", "Calculate hash values for the given input", "Calculate the hash value of the given sequence", "Check matching subsequences by sliding window technique", "Return the number of matching subsequences"], "nl_cn": "Little Bytie loves to play with colorful chains.\n\nHe already has quite an impressive collection, and some of them he likes    more than the others.\n\nEach chain consists of a certain number of colorful links.\n\nByteasar has noticed that Bytie's sense of aesthetics is very precise.\n\nIt turns out that Bytie finds a contiguous fragment of a chain nice if    it contains exactly    ,    and moreover it contains no links of other colors.\n\nA chain's appeal is its number of (contiguous) fragments that are nice.\n\nBy trial and error, Byteasar has determined the values .\n\nNow he would like to buy a new chain, and therefore asks you to write a program to aid him in shopping.\n\n给定一个序列,求有多少个子序列使得c\\_i这个数在这个序列中出现了l\\_i次,且不存在其它的数。\n", "test_cases": [{"input": "7 3\n2 1 1\n1 2 3\n4 2 1 3 1 2 5\n", "output": "2"}, {"input": "9 3\n1 2 1\n2 4 1\n2 4 6 1 2 3 4 5 6\n", "output": "0"}, {"input": "4 2\n1 2\n3 4 1 2\n", "output": "0"}, {"input": "10 3\n2 2 2\n1 3 5\n1 2 3 4 5 6 7 8 9 10\n", "output": "0"}, {"input": "8 3\n2 2 1\n1 3 5\n1 2 3 4 5 6 7 8\n", "output": "0"}, {"input": "10 4\n1 2 3 4\n1 1 1 1\n1 1 1 1 1 2 2 2 2 2\n", "output": "0"}, {"input": "6 2\n2 1\n1 2 1 2 1 2\n", "output": "1"}, {"input": "8 3\n2 2 2\n5 4 3\n1 2 3 4 5 6 7 1\n", "output": "0"}, {"input": "9 2\n2 2\n1 1 1 1 1 1 1 2 1\n", "output": "2"}, {"input": "6 3\n1 1 1\n1 2 3\n1 1 2 2 1 1\n", "output": "0"}, {"input": "8 4\n1 1 1 1\n3 2 1 1\n1 2 3 4 5 6 7 8\n", "output": "0"}, {"input": "9 4\n2 2 2 2\n2 3 1 4\n1 2 3 4 5 6 7 8 9\n", "output": "0"}, {"input": "6 2\n3 1 1\n2 2 3\n1 2 2 2 2\n", "output": "0"}, {"input": "5 1\n1 1\n2 2 2\n", "output": "0"}, {"input": "9 3\n2 2 2\n1 1 1\n3 2 1 3 1 2 5 6 7\n", "output": "0"}, {"input": "8 3\n2 3 1\n1 3 2\n1 2 1 3 1 2 5 6\n", "output": "0"}, {"input": "7 2\n1 1 1\n1 2 3\n5 1 2 3 4 5\n", "output": "0"}, {"input": "8 3\n2 3 1\n1 3 2\n1 2 1 1 1 2 5 6\n", "output": "0"}, {"input": "5 2\n1 1\n1 1\n3 3 3 3\n", "output": "0"}, {"input": "6 3\n1 1 1\n1 2 3\n1 1 1 1 1 1\n", "output": "0"}, {"input": "7 3\n1 1 1\n1 2 3\n1 1 1 1 1 1 1\n", "output": "0"}, {"input": "6 2\n1 2\n3 1 2 1\n1 1 2\n", "output": "0"}, {"input": "4 2\n2 1\n1 2 3\n3 3 2 1\n", "output": "0"}, {"input": "7 2\n2 2\n2 1 2\n1 1\n", "output": "0"}, {"input": "5 2\n1 1\n1 1 2 3 4\n3 4 5\n", "output": "0"}, {"input": "8 2\n2 1\n4 1 2 3 4\n1 2\n", "output": "0"}, {"input": "9 3\n1 2 1\n5 1 1 1 1 1\n1 1 1\n", "output": "0"}], "test": "#undef NDEBUG\n#include<assert.h>\nint main(){\n    assert(solution(\"7 3\\n2 1 1\\n1 2 3\\n4 2 1 3 1 2 5\\n\") == \"2\");\n    assert(solution(\"9 3\\n1 2 1\\n2 4 1\\n2 4 6 1 2 3 4 5 6\\n\") == \"0\");\n    assert(solution(\"4 2\\n1 2\\n3 4 1 2\\n\") == \"0\");\n    assert(solution(\"10 3\\n2 2 2\\n1 3 5\\n1 2 3 4 5 6 7 8 9 10\\n\") == \"0\");\n    assert(solution(\"8 3\\n2 2 1\\n1 3 5\\n1 2 3 4 5 6 7 8\\n\") == \"0\");\n    assert(solution(\"10 4\\n1 2 3 4\\n1 1 1 1\\n1 1 1 1 1 2 2 2 2 2\\n\") == \"0\");\n    assert(solution(\"6 2\\n2 1\\n1 2 1 2 1 2\\n\") == \"1\");\n    assert(solution(\"8 3\\n2 2 2\\n5 4 3\\n1 2 3 4 5 6 7 1\\n\") == \"0\");\n    assert(solution(\"9 2\\n2 2\\n1 1 1 1 1 1 1 2 1\\n\") == \"2\");\n    assert(solution(\"6 3\\n1 1 1\\n1 2 3\\n1 1 2 2 1 1\\n\") == \"0\");\n    assert(solution(\"8 4\\n1 1 1 1\\n3 2 1 1\\n1 2 3 4 5 6 7 8\\n\") == \"0\");\n    assert(solution(\"9 4\\n2 2 2 2\\n2 3 1 4\\n1 2 3 4 5 6 7 8 9\\n\") == \"0\");\n    assert(solution(\"6 2\\n3 1 1\\n2 2 3\\n1 2 2 2 2\\n\") == \"0\");\n    assert(solution(\"5 1\\n1 1\\n2 2 2\\n\") == \"0\");\n    assert(solution(\"9 3\\n2 2 2\\n1 1 1\\n3 2 1 3 1 2 5 6 7\\n\") == \"0\");\n    assert(solution(\"8 3\\n2 3 1\\n1 3 2\\n1 2 1 3 1 2 5 6\\n\") == \"0\");\n    assert(solution(\"7 2\\n1 1 1\\n1 2 3\\n5 1 2 3 4 5\\n\") == \"0\");\n    assert(solution(\"8 3\\n2 3 1\\n1 3 2\\n1 2 1 1 1 2 5 6\\n\") == \"0\");\n    assert(solution(\"5 2\\n1 1\\n1 1\\n3 3 3 3\\n\") == \"0\");\n    assert(solution(\"6 3\\n1 1 1\\n1 2 3\\n1 1 1 1 1 1\\n\") == \"0\");\n    assert(solution(\"7 3\\n1 1 1\\n1 2 3\\n1 1 1 1 1 1 1\\n\") == \"0\");\n    assert(solution(\"6 2\\n1 2\\n3 1 2 1\\n1 1 2\\n\") == \"0\");\n    assert(solution(\"4 2\\n2 1\\n1 2 3\\n3 3 2 1\\n\") == \"0\");\n    assert(solution(\"7 2\\n2 2\\n2 1 2\\n1 1\\n\") == \"0\");\n    assert(solution(\"5 2\\n1 1\\n1 1 2 3 4\\n3 4 5\\n\") == \"0\");\n    assert(solution(\"8 2\\n2 1\\n4 1 2 3 4\\n1 2\\n\") == \"0\");\n    assert(solution(\"9 3\\n1 2 1\\n5 1 1 1 1 1\\n1 1 1\\n\") == \"0\");\n    return 0; \n}", "prompt": "/*Little Bytie likes to play with a colorful chain.\n\nHe has quite a collection, but some of them are more special than others.\n\nEach chain is made up of a certain number of colorful links.\n\nByteasar has noticed that Bytie has a very precise aesthetic sense.\n\nIn fact, if a contiguous segment of the chain contains exactly , and does not contain any links of other colors, then Bytie considers that segment to be very pretty.\n\nThe attractiveness of a chain is the number of (contiguous) pretty segments that it contains.\n\nThrough trial and error, Byteasar has determined the values of .\n\nNow he wants to buy a new chain, so he asks you to write a program to help him shop.\n\nGiven a sequence, determine how many contiguous subsequences contain exactly , and no other colors.\n\ninput_format:\nThe first line of the standard input gives two integers, , separated by a single space.\n\nThese are the length of the chain and the length of a nice fragment's description.\n\nThe second line gives ,      separated by single spaces.\n\nThe third line gives , also separated by single spaces.\n\nThe sequences .\n\nThe fourth line gives ,      separated by single spaces, that are the colors of successive links of      the chain.\n\nIn tests worth 50% of total points the constraint  holds in addition.\n\noutput_format:\nYour program is to print a single integer, the number of nice contiguous    fragments in the chain, to the first and only line of the standard output.\n*/\n\n#include<sstream>\n#include<stdlib.h>\n#include<algorithm>\n#include<math.h>\n#include<stdio.h>\n#include<vector>\n#include<string>\n#include<climits>\n#include<cstring>\n#include<iostream>\nusing namespace std;\n\n             \nstring solution(string std_in){\n    istringstream iss(std_in);\n             ", "constraints": "\n\n### 数据范围：\n\n对于 $100\\%$ 的数据，$1\\leq m\\leq n \\leq 10^6$，$1\\leq a_i,b_i,c_i\\leq n$。", "samples": [["7 3\n2 1 1\n1 2 3\n4 2 1 3 1 2 5\n", "2\n"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}}
{"task_id": "P3407", "title": "散步", "difficulty": "advanced", "nl": "On a road, the integer A represents the position of a point.\n\nWhen A=0, there is a palace. When A>0, it means there are A meters to the east of the palace, and when A<0, it means there are |A| meters to the west of the palace.\n\nOn this road, there are N residences numbered from 1 to N, from west to east. Each residence has one person, and they only exist on even integers.\n\nThe king of the country believes that the health of the citizens has declined, and they must exercise more. Therefore, he orders everyone to go out for a walk. Each citizen can walk 1 meter per second, and each citizen will walk either to the east or to the west. You know the directions. After the order is given, everyone leaves their homes at the same time and starts walking.\n\nHowever, the citizens of this country are all very talkative. If two people meet while walking, they will stop and talk. If a person who is walking meets someone who has already stopped (even if they're walking at the same position), they will also stop and talk. Once they stop, they will chat incessantly and forget about exercising.\n\nNow, T seconds have passed since the order was given. The king hopes to locate Q important figures in the country. Can you help him?", "code": "#include<iostream>\n#define maxn 100010\nusing namespace std;\nint n,Q,q[maxn];\nlong long loc[maxn],p[maxn][2],t;//loc记录第i个人的位置 \nint main()\n{\n    ios::sync_with_stdio(false);\n    cin>>n>>t>>Q;\n    for(int i=1;i<=n;i++)\n        cin>>p[i][0]>>p[i][1];    \n    for(int i=1;i<=Q;i++)\n        cin>>q[i];\n    for(int i=1;i<=n;i++)\n        if(p[i][1]==2)\n        {\n            if(i==1)\n                loc[i]=p[i][0]-t;\n            else if(p[i-1][1]==2)\n                loc[i]=max(loc[i-1],p[i][0]-t);\n            else loc[i]=max(p[i][0]/2+p[i-1][0]/2,p[i][0]-t);\n        }\n    for(int i=n;i>=1;i--)\n        if(p[i][1]==1)\n        {\n            if(i==n)\n                loc[i]=p[i][0]+t;\n            else if(p[i+1][1]==1)\n                loc[i]=min(loc[i+1],p[i][0]+t);\n            else loc[i]=min(p[i][0]/2+p[i+1][0]/2,p[i][0]+t);\n        }\n    for(int i=1;i<=Q;i++)\n        cout<<loc[q[i]]<<endl;\n    return 0;\n}", "step": ["Read input values of n, t, and Q.", "Read input values for array p", "Calculates the location of an object based on the given parameters and values for array p", "Displays the calculated location of the object"], "nl_cn": "一条道路上，位置点用整数A表示。\n\n当A=0时，有一个王宫。当A>0，就是离王宫的东边有A米，当A<0，就是离王宫的西边有A米。\n\n道路上，有N个住宅从西向东用1-N来标号。每个住宅有一个人。住宅只会存在于偶数整数点。\n\n\n该国国王认为，国民体质下降，必须要多运动，于是下命令所有人都必须出门散步。所有的国民，一秒钟可以走1米。每个国民各自向东或者向西走。这些方向你是知道的。命令发出后所有人同时离开家门开始散步。\n\n\n然而该国的国民个都很健谈，如果在散步途中两个人相遇，就会停下来交谈。正在走路的人碰到已经停下来的人（重合）也会停下来交谈。一但停下来，就会聊到天昏地暗，忘记了散步。\n\n\n现在命令已经发出了T秒，该国有Q个重要人物，国王希望能够把握他们的位置。你能帮他解答吗？\n", "test_cases": [{"input": "6 6 4\n-10 1\n-6 2\n-4 1\n2 1\n6 2\n18 2\n2\n3\n4\n6", "output": "-8\n2\n4\n12"}, {"input": "2 0 2\n-4 1\n4 2\n1\n2", "output": "-4\n4"}, {"input": "0 10 1\n0 2\n1", "output": "0"}, {"input": "2 1 2\n0 1\n2 1\n1\n2", "output": "1\n3"}, {"input": "1 5 1\n12 2\n1", "output": "7"}, {"input": "2 2 2\n-2 1\n2 1\n1\n2", "output": "0\n4"}, {"input": "1 1 1\n0 1\n1\n", "output": "1"}], "test": "#undef NDEBUG\n#include<assert.h>\nint main(){\n    assert(solution(\"6 6 4\\n-10 1\\n-6 2\\n-4 1\\n2 1\\n6 2\\n18 2\\n2\\n3\\n4\\n6\") == \"-8\\n2\\n4\\n12\");\n    assert(solution(\"2 0 2\\n-4 1\\n4 2\\n1\\n2\") == \"-4\\n4\");\n    assert(solution(\"0 10 1\\n0 2\\n1\") == \"0\");\n    assert(solution(\"2 1 2\\n0 1\\n2 1\\n1\\n2\") == \"1\\n3\");\n    assert(solution(\"1 5 1\\n12 2\\n1\") == \"7\");\n    assert(solution(\"2 2 2\\n-2 1\\n2 1\\n1\\n2\") == \"0\\n4\");\n    assert(solution(\"1 1 1\\n0 1\\n1\\n\") == \"1\");\n    return 0; \n}", "prompt": "/*On a road, the integer A represents the position of a point.\n\nWhen A=0, there is a palace. When A>0, it means there are A meters to the east of the palace, and when A<0, it means there are |A| meters to the west of the palace.\n\nOn this road, there are N residences numbered from 1 to N, from west to east. Each residence has one person, and they only exist on even integers.\n\nThe king of the country believes that the health of the citizens has declined, and they must exercise more. Therefore, he orders everyone to go out for a walk. Each citizen can walk 1 meter per second, and each citizen will walk either to the east or to the west. You know the directions. After the order is given, everyone leaves their homes at the same time and starts walking.\n\nHowever, the citizens of this country are all very talkative. If two people meet while walking, they will stop and talk. If a person who is walking meets someone who has already stopped (even if they're walking at the same position), they will also stop and talk. Once they stop, they will chat incessantly and forget about exercising.\n\nNow, T seconds have passed since the order was given. The king hopes to locate Q important figures in the country. Can you help him?\n\ninput_format:\nThe first row is three integers, N,T,Q\n\nNext N lines, two integers each Ai,Ri. Ai is the coordinate of home, if Ri is 1, then it goes east, if RI is 2, it goes west. The data ensures that the Ai is sorted in ascending order, and that no two people start out in the same position.\n\nThis is followed by Q lines, each with an integer indicating the important people the king cares about.\n\noutput_format:\nQ lines, one integer per line, represent the person's coordinates.\n*/\n\n#include<sstream>\n#include<stdlib.h>\n#include<algorithm>\n#include<math.h>\n#include<stdio.h>\n#include<vector>\n#include<string>\n#include<climits>\n#include<cstring>\n#include<iostream>\nusing namespace std;\n\n             \nstring solution(string std_in){\n    istringstream iss(std_in);\n             ", "constraints": "$20\\%$ 数据，$N\\le 100,T\\le 10000$。\n\n另外 $20\\%$ 数据，$N\\le 5000$。\n\n另外 $20\\%$ 数据，从最西边数起连续的若干国民全部往东，剩下的全部往西。\n\n$100\\%$ 数据 $A_i$ 为偶数，$|A_i|\\le 10^{18},|T|\\le 10^{18},1\\le Q\\le N\\le 100000$。\n", "samples": [["6 6 4\n-10 1\n-6 2\n-4 1\n2 1\n6 2\n18 2\n2\n3\n4\n6", "-8\n2\n4\n12"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000]}}
{"task_id": "P1357", "title": "花园", "difficulty": "advanced", "nl": "Little L has a circular garden with flower beds numbered from $1$ to $n$ in a clockwise direction. Flower beds $1$ and $n$ are adjacent.\n\nEvery day, the garden will be decorated with a new flower pattern, but all patterns follow a rule: in any $m$ adjacent flower beds, there are no more than $k$ C-shaped flower beds, and the rest are all P-shaped.\n\nFor example, if $n=10$, $m=5$, and $k=3$, then:\n\n- `CCPCPPPPCC` is not a valid flower pattern.\n- `CCPPPPCPCP` is a valid flower pattern.\n\nPlease help Little L count the number of valid flower patterns modulo $10^9+7$.", "code": "#include<iostream>\n#include<cstdio>\n#include<cstring>\n#include<algorithm>\nusing namespace std;\n#define LL long long\nLL n,m,k,lim,mod=1000000007,ans;\nstruct node{LL t[64][64];}re,x;\nint ok[64],bin[6];//ok：是否是合法状态\nvoid work(int zt,int num) {//计算初始合法转移\n    ok[zt]=1;int kl=zt>>1;\n    x.t[kl][zt]=1;\n    if(num==k&&!(zt&1)) return;\n    x.t[kl+bin[m]][zt]=1;\n}\nvoid dfs(int x,int num,int zt) {\n    if(x==m+1) {work(zt,num);return;}\n    dfs(x+1,num,zt);\n    if(num<k) dfs(x+1,num+1,zt|bin[x]);\n}\nnode operator * (node a,node b) {\n    int i,j,k;node c;\n    for(i=0;i<=lim;++i)\n        for(j=0;j<=lim;++j) {\n        c.t[i][j]=0;\n        for(k=0;k<=lim;++k)\n            c.t[i][j]+=a.t[i][k]*b.t[k][j]%mod,c.t[i][j]%=mod;\n    }\n    return c;\n}\nvoid ksm() {//快速幂\n    int bj=0;\n    while(n) {\n        if(n&1) {\n            if(!bj) re=x,bj=1;\n            else re=re*x;\n        }\n        x=x*x;n>>=1;\n    }\n}\nint main()\n{\n    bin[1]=1;for(int i=2;i<=5;++i) bin[i]=bin[i-1]<<1;\n    scanf(\"%lld%lld%lld\",&n,&m,&k);\n    lim=(1<<m)-1;dfs(1,0,0);ksm();\n    for(int i=0;i<=lim;++i) if(ok[i]) ans+=re.t[i][i],ans%=mod;//答案统计\n    printf(\"%lld\",ans);\n    return 0;\n}", "step": ["Read the input values of n, m, and K.", "Initialize the value of t.", "Construct a binary matrix based on the input values.", "Raise the binary matrix to the power of n.", "Calculate the sum of the diagonals of the resulting matrix.", "Output the answer."], "nl_cn": "小 L 有一座环形花园，沿花园的顺时针方向，他把各个花圃编号为 $1 \\sim n$。花园 $1$ 和 $n$ 是相邻的。\n\n他的环形花园每天都会换一个新花样，但他的花园都不外乎一个规则：任意相邻 $m$ 个花圃中都只有不超过 $k$ 个 C 形的花圃，其余花圃均为 P 形的花圃。\n\n例如，若 $n=10$ , $m=5$ , $k=3$ ，则\n\n- `CCPCPPPPCC` 是一种不符合规则的花圃。\n- `CCPPPPCPCP` 是一种符合规则的花圃。\n\n请帮小 L 求出符合规则的花园种数对 $10^9+7$ 取模的结果。", "test_cases": [{"input": "10 5 3\n", "output": "458"}, {"input": "6 2 1\n", "output": "18"}, {"input": "1 1 0\n", "output": "1"}], "test": "#undef NDEBUG\n#include<assert.h>\nint main(){\n    assert(solution(\"10 5 3\\n\") == \"458\");\n    assert(solution(\"6 2 1\\n\") == \"18\");\n    assert(solution(\"1 1 0\\n\") == \"1\");\n    return 0; \n}", "prompt": "/*Little L has a circular garden with flower beds numbered from $1$ to $n$ in a clockwise direction. Flower beds $1$ and $n$ are adjacent.\n\nEvery day, the garden will be decorated with a new flower pattern, but all patterns follow a rule: in any $m$ adjacent flower beds, there are no more than $k$ C-shaped flower beds, and the rest are all P-shaped.\n\nFor example, if $n=10$, $m=5$, and $k=3$, then:\n\n- `CCPCPPPPCC` is not a valid flower pattern.\n- `CCPPPPCPCP` is a valid flower pattern.\n\nPlease help Little L count the number of valid flower patterns modulo $10^9+7$.\n\ninput_format:\nThere is only one row of three integers representing $n, m, and k$.\n\noutput_format:\nOutput a line with an integer representing the answer.\n*/\n\n#include<sstream>\n#include<stdlib.h>\n#include<algorithm>\n#include<math.h>\n#include<stdio.h>\n#include<vector>\n#include<string>\n#include<climits>\n#include<cstring>\n#include<iostream>\nusing namespace std;\n\n             \nstring solution(string std_in){\n    istringstream iss(std_in);\n             ", "constraints": "#### 数据规模与约定\n\n- 对于 $40\\%$ 的数据，保证 $n \\le 20$。\n- 对于 $60\\%$ 的数据，保证 $m=2$。\n- 对于 $80\\%$ 的数据，保证 $n \\le 10^5$；\n- 对于 $100\\%$ 的数据，保证 $2 \\leq n \\le 10^{15}$，$2 \\leq m \\leq \\min(n, 5)$，$1 \\leq k \\lt m$。", "samples": [["10 5 3\n", "458"], ["6 2 1\n", "18"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}}
{"task_id": "P3682", "title": "[CERC2016]自由的套娃 Free Figurines", "difficulty": "advanced", "nl": "Russian nesting dolls are wooden sculptures of increasing size that can be nested inside one another. Each doll can be placed into a larger doll, or be placed into a smaller doll. Each doll can only directly nest one doll inside it, but the nested doll can continue to nest inside.\n\nGiven n nesting dolls with sizes that are all different, they are numbered from 1 to n according to size in ascending order. If doll a is directly nested inside doll b, we call b the father of a. If a doll has no father, we call it free. A set of nesting solutions can be represented by the father of each doll.\n\nWe can take one of the following two actions at each step:\n1. Nest a free doll directly into a larger doll that has not yet been filled.\n2. Choose a non-free doll and remove it from its father.\n\nGiven an initial configuration, please calculate the minimum number of steps required to reach the target configuration.", "code": "#include <cstdio>\n\nint a[100005], b[100005];\nbool ntail[100005]; //表示i不是链的结尾\n\nint main(){\n    int n, ans = 0;\n    scanf(\"%d\", &n);\n    for(int i=1; i<=n; i++){\n\t\tscanf(\"%d\", &a[i]);\n\t\tntail[a[i]] = true; //已经不是链的结尾（最小的套娃）了\n\t\tif(a[i] != 0) ans++; //原始做法\n\t}\n    for(int i=1; i<=n; i++){ //同上\n    \tscanf(\"%d\", &b[i]);\n    \tntail[b[i]] = true;\n    \tif(b[i] != 0) ans++;\n\t}\n\tint p;\n\tfor(int i=1; i<=n; i++){\n\t\tif(!ntail[i]){ //是链尾\n\t\t\tp = i;\n\t\t\twhile(a[p] == b[p] && a[p] != 0 && b[p] != 0){ //一直找相同（可以不拆开的）\n\t\t\t\tans -= 2; //避免2次操作\n\t\t\t\tp = a[p];\n\t\t\t}\n\t\t}\n\t}\n    printf(\"%d\\n\", ans);\n    return 0;\n}", "step": ["Declare and initialize the necessary variables and arrays.", "Scan the first array and populate the 'ntail' buffer with true at the position of each element.", "If the element of the array is not zero, increment the 'ans' variable.", "Scan the second array and repeat step 2 and 3.", "Loop through the 'ntail' array to find the first position where it is false.", "Starting from that index, loop through both arrays simultaneously and keep incrementing 'ans' until their matching element is zero. If a previously stored non-zero element is matched, decrement 'ans' by 2 each time."], "nl_cn": "俄罗斯套娃是一些尺寸递增的木制雕像，它们可以嵌套在一起。每个套娃可以放进一个更大的套娃，也可以被放入一个更小的套娃。每个套娃内部最多只能直接嵌套一个套娃，但是那个套娃内部还可以继续嵌套。\n\n\n给定n个尺寸互不相同的套娃，按尺寸从小到大依次编号为1到n。如果套娃a被直接嵌入套娃b，那么我们称b是a的父亲，如果一个套娃没有父亲，那么我们称它是自由的。一组镶嵌方案可以用每个套娃的父亲来表示。\n\n\n我们可以每步可以做以下两种操作中的任意一种：\n\n\n1.把一个自由的套娃直接嵌入一个更大的没有被放入东西的套娃。\n\n\n2.选择一个不自由的套娃，将其从其父亲中取出。\n\n\n给定初始局面，请计算达到目标局面的最小的操作步数。\n", "test_cases": [{"input": "7\n3 5 4 0 7 0 0\n3 5 0 6 7 0 0\n", "output": "2"}], "test": "#undef NDEBUG\n#include<assert.h>\nint main(){\n    assert(solution(\"7\\n3 5 4 0 7 0 0\\n3 5 0 6 7 0 0\\n\") == \"2\");\n    return 0; \n}", "prompt": "/*Russian nesting dolls are wooden sculptures of increasing size that can be nested inside one another. Each doll can be placed into a larger doll, or be placed into a smaller doll. Each doll can only directly nest one doll inside it, but the nested doll can continue to nest inside.\n\nGiven n nesting dolls with sizes that are all different, they are numbered from 1 to n according to size in ascending order. If doll a is directly nested inside doll b, we call b the father of a. If a doll has no father, we call it free. A set of nesting solutions can be represented by the father of each doll.\n\nWe can take one of the following two actions at each step:\n1. Nest a free doll directly into a larger doll that has not yet been filled.\n2. Choose a non-free doll and remove it from its father.\n\nGiven an initial configuration, please calculate the minimum number of steps required to reach the target configuration.\n\ninput_format:\nThe first line contains a positive integer n(1<=n<=100000), representing the number of nesting dolls.\n\nThe second row contains n integers p\\_1,p\\_2,... p\\_n(0<=p\\_i<=n), in turn, represents the father of each nesting doll in the initial situation, and 0 represents the free nesting doll.\n\nThe third line contains n integers q\\_1,q\\_2,... ,q\\_n(0<=q\\_i<=n), which in turn represents the father of each nesting doll in the target situation, and 0 represents the free nesting doll.\n\nInput data to ensure that both the initial and target situations are legitimate.\n\noutput_format:\nOutput a line of an integer, that is, the minimum number of operation steps.\n*/\n\n#include<sstream>\n#include<stdlib.h>\n#include<algorithm>\n#include<math.h>\n#include<stdio.h>\n#include<vector>\n#include<string>\n#include<climits>\n#include<cstring>\n#include<iostream>\nusing namespace std;\n\n             \nstring solution(string std_in){\n    istringstream iss(std_in);\n             ", "constraints": "", "samples": [["7\n3 5 4 0 7 0 0\n3 5 0 6 7 0 0\n", "2"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}}
{"task_id": "P4285", "title": "[SHOI2008]汉诺塔", "difficulty": "advanced", "nl": "The Tower of Hanoi consists of three poles (represented by A, B, and C) and n rings of different sizes. At the beginning, all n rings are stacked on pole A, with larger rings on the bottom and smaller ones on top, forming a tower in the shape of a cone. \n\nA legitimate operation on the Tower of Hanoi is defined as moving the top ring from one pole to another pole, while ensuring that the ring being moved is placed on top of a larger ring (this requirement does not apply when moving to an empty pole). We can use two letters to describe an operation: the first letter represents the starting pole, and the second letter represents the target pole. For example, AB means moving the top ring from pole A to pole B. The goal of the Tower of Hanoi game is to move all rings from pole A to pole B or pole C.\n\nThere is a simple and classic strategy that can help us complete the game. First, before any operation is performed, we assign different priorities to the six operations (AB, AC, BA, BC, CA, and CB) in any order. Then, we always choose the operation that meets the following two conditions to move the ring until all the rings are moved from pole A to another pole: (1) this operation has the highest priority among all legitimate operations; (2) the ring being moved by this operation is not the same as the ring being moved in the last operation.\n\nIt can be proven that the above strategy can always complete the Tower of Hanoi game. Now your task is to calculate the number of steps required to move the Tower of Hanoi according to the above strategy, given the priorities of each operation.", "code": "#include<bits/stdc++.h>\n#define For(i,a,b) for(int (i)=(a);(i)<=(b);(i)++)\n#define il inline\n#define ll long long\nusing namespace std;\nconst int N=35;\nint n;\nll d[N];\nint stk[5][5],cnt[4];\nstruct node{\n    int fr,to;\n}a[N];\nbool vis[4];\nchar s[4];\nil void dfs(int p,int c,int lst){\n    if(cnt[1]==c||cnt[2]==c){d[c]=p;return;}\n    For(i,1,6){\n        int j=a[i].fr,k=a[i].to;\n        if(cnt[j]&&j!=lst){\n            if(stk[j][cnt[j]]<stk[k][cnt[k]]||!stk[k][cnt[k]]){\n                stk[k][++cnt[k]]=stk[j][cnt[j]];\n                cnt[j]--;\n                dfs(p+1,c,k);\n                break;\n            }\n        }\n    }\n}\nint main(){\n    scanf(\"%d\",&n);\n    For(i,1,6){\n        scanf(\"%s\",s);\n        a[i].fr=s[0]-'A',a[i].to=s[1]-'A';\n    }\n    stk[0][++cnt[0]]=1;\n    dfs(0,1,-1);\n    cnt[1]=cnt[2]=cnt[0]=0;\n    For(i,1,2)stk[0][++cnt[0]]=3-i;\n    dfs(0,2,-1);\n    cnt[1]=cnt[2]=cnt[0]=0;\n    For(i,1,3)stk[0][++cnt[0]]=4-i;\n    dfs(0,3,-1);\n    if(n<=3)cout<<d[n];\n    else {\n        ll k=(d[3]-d[2])/(d[2]-d[1]),q=d[3]-k*d[2];\n        For(i,4,n)d[i]=1ll*k*(d[i-1])+q;\n        cout<<d[n];\n    }\n    return 0;\n}", "step": ["Set up necessary variables and constants", "Read the input values", "Solve the puzzle for 1, 2 and 3 disks", "If the input is greater than 3 disks, generate the answer using a linear recurrence relation", "Return the answer"], "nl_cn": "汉诺塔由三根柱子（分别用A、B、C表示）和n个大小互不相同的空心盘子组成。一开始n个盘子都摞在柱子A上，大的在下面，小的在上面，形成了一个塔状的锥形体。\n    对汉诺塔的一次合法的操作是指：从一根柱子的最上层拿一个盘子放到另一根柱子的最上层，同时要保证被移动的盘子一定放在比它更大的盘子上面（如果移动到空柱子上就不需要满足这个要求）。我们可以用两个字母来描述一次操作：第一个字母代表起始柱子，第二个字母代表目标柱子。例如，AB就是把柱子A最上面的那个盘子移到柱子B。汉诺塔的游戏目标是将所有的盘子从柱子A移动到柱子B或柱子C上面。\n有一种非常简洁而经典的策略可以帮助我们完成这个游戏。首先，在任何操作执行之前，我们以任意的次序为六种操作（AB、AC、BA、BC、CA和CB）赋予不同的优先级，然后，我们总是选择符合以下两个条件的操作来移动盘子，直到所有的盘子都从柱子A移动到另一根柱子：\n（1）这种操作是所有合法操作中优先级最高的；\n（2）这种操作所要移动的盘子不是上一次操作所移动的那个盘子。\n可以证明，上述策略一定能完成汉诺塔游戏。现在你的任务就是假设给定了每种操作的优先级，计算按照上述策略操作汉诺塔移动所需要的步骤数。\n\n\n", "test_cases": [{"input": "3\nAB BC CA BA CB AC", "output": "7"}, {"input": "2\nAB BA CA BC CB AC", "output": "5"}, {"input": "1\nAB AC BC CA CB BA", "output": "1"}, {"input": "1\nAB AC BC CA BA CB\n", "output": "1"}], "test": "#undef NDEBUG\n#include<assert.h>\nint main(){\n    assert(solution(\"3\\nAB BC CA BA CB AC\") == \"7\");\n    assert(solution(\"2\\nAB BA CA BC CB AC\") == \"5\");\n    assert(solution(\"1\\nAB AC BC CA CB BA\") == \"1\");\n    assert(solution(\"1\\nAB AC BC CA BA CB\\n\") == \"1\");\n    return 0; \n}", "prompt": "/*The Tower of Hanoi consists of three poles (represented by A, B, and C) and n rings of different sizes. At the beginning, all n rings are stacked on pole A, with larger rings on the bottom and smaller ones on top, forming a tower in the shape of a cone. \n\nA legitimate operation on the Tower of Hanoi is defined as moving the top ring from one pole to another pole, while ensuring that the ring being moved is placed on top of a larger ring (this requirement does not apply when moving to an empty pole). We can use two letters to describe an operation: the first letter represents the starting pole, and the second letter represents the target pole. For example, AB means moving the top ring from pole A to pole B. The goal of the Tower of Hanoi game is to move all rings from pole A to pole B or pole C.\n\nThere is a simple and classic strategy that can help us complete the game. First, before any operation is performed, we assign different priorities to the six operations (AB, AC, BA, BC, CA, and CB) in any order. Then, we always choose the operation that meets the following two conditions to move the ring until all the rings are moved from pole A to another pole: (1) this operation has the highest priority among all legitimate operations; (2) the ring being moved by this operation is not the same as the ring being moved in the last operation.\n\nIt can be proven that the above strategy can always complete the Tower of Hanoi game. Now your task is to calculate the number of steps required to move the Tower of Hanoi according to the above strategy, given the priorities of each operation.\n\ninput_format:\nThe input has two lines. The first is an integer n (1≤n≤30), which represents the number of plates. The second line is a string of uppercase ABC characters, representing the priority of the six operations, with the first operation having a higher priority. Each operation is separated by a space.\n\noutput_format:\nJust output a number that represents the number of moves. We guarantee that the answer will not exceed 10 to the 18th power.\n*/\n\n#include<sstream>\n#include<stdlib.h>\n#include<algorithm>\n#include<math.h>\n#include<stdio.h>\n#include<vector>\n#include<string>\n#include<climits>\n#include<cstring>\n#include<iostream>\nusing namespace std;\n\n             \nstring solution(string std_in){\n    istringstream iss(std_in);\n             ", "constraints": "对于20%的数据，n ≤ 10。\n对于100%的数据，n ≤ 30。", "samples": [["3\nAB BC CA BA CB AC", "7"], ["2\nAB BA CA BC CB AC", "5"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}}
{"task_id": "P2095", "title": "营养膳食", "difficulty": "challenge", "nl": "Mr.L is working on his weight gain plan.\n\nIn order to gain weight, Mr.L wants to eat more fat. However, he cannot just eat high-fat foods, otherwise he will lack other nutrients.\n\nMr.L found through research that a true nutritional diet stipulates that a certain type of food should not be eaten more than a certain amount at one time. For example, for a meal, meat should not be eaten more than 1 portion, fish should not be eaten more than 1 portion, eggs should not be eaten more than 1 portion, and vegetables should not be eaten more than 2 portions.\n\nMr.L wants to eat more fat while still following a nutritional diet, but of course, Mr.L's appetite is also limited.", "code": "#include<bits/stdc++.h>\nusing namespace std;\nint n,m,k,ans=0;\nstruct bzyq{\n    int a,b;\n}\ns[470];//用结构体排序好排\nint x[470];\nbool cmp(bzyq i,bzyq j)\n{\n    return i.a>j.a;//根据脂肪值排序\n}\nint main()\n{\n    cin>>n>>m>>k;\n    for(int i=1;i<=k;i++)\n     cin>>x[i];\n    for(int i=1;i<=n;i++)\n     cin>>s[i].a>>s[i].b;\n    sort(s+1,s+n+1,cmp);\n    int i=1;\n    while(m&&i<=n)//m得>0\n    {\n        if(x[s[i].b]>0)\n        {\n          ans+=s[i].a;//累计脂肪值\n          m--;//m去掉1，吃的分数－1\n          x[s[i].b]--;//x数组表示能吃的第s[i].b种食品分数减一\n        }\n        i++;\n    }\n    cout<<ans;\n    return 0;\n    //~~华丽的结束~~\n}", "step": ["Read the values of n, m, and k", "Read an array b of k integers", "Read an array of n node structures", "Perform quicksort on the array 'a' based on the first attribute of the node structure", "Select the first m elements of the sorted array 'a' using the indices of the second attribute of the node structure to index array 'b'. Decrement the indexed value of array 'b' when an element of 'a' is selected", "Calculate and output the sum of the selected elements of array 'a'"], "nl_cn": "Mr.L 正在完成自己的增肥计划。\n\n为了增肥，Mr.L 希望吃到更多的脂肪。然而也不能只吃高脂肪食品，那样的话就会导致缺少其他营养。\n\nMr.L 通过研究发现：真正的营养膳食规定某类食品不宜一次性吃超过若干份。比如就一顿饭来说，肉类不宜吃超过 $1$ 份，鱼类不宜吃超过 $1$ 份，蛋类不宜吃超过 $1$ 份，蔬菜类不宜吃超过 $2$ 份。\n\nMr.L 想要在营养膳食的情况下吃到更多的脂肪，当然 Mr.L 的食量也是有限的。\n", "test_cases": [{"input": "6 6 3\n3 3 2\n15 1\n15 2\n10 2\n15 2\n10 2\n5 3", "output": "60"}, {"input": "2 2 2\n1 1 1\n1 2\n1 2\n", "output": "2"}, {"input": "1 1 1\n1 1 1\n1 1", "output": "1"}], "test": "#undef NDEBUG\n#include<assert.h>\nint main(){\n    assert(solution(\"6 6 3\\n3 3 2\\n15 1\\n15 2\\n10 2\\n15 2\\n10 2\\n5 3\") == \"60\");\n    assert(solution(\"2 2 2\\n1 1 1\\n1 2\\n1 2\\n\") == \"2\");\n    assert(solution(\"1 1 1\\n1 1 1\\n1 1\") == \"1\");\n    return 0; \n}", "prompt": "/*Mr.L is working on his weight gain plan.\n\nIn order to gain weight, Mr.L wants to eat more fat. However, he cannot just eat high-fat foods, otherwise he will lack other nutrients.\n\nMr.L found through research that a true nutritional diet stipulates that a certain type of food should not be eaten more than a certain amount at one time. For example, for a meal, meat should not be eaten more than 1 portion, fish should not be eaten more than 1 portion, eggs should not be eaten more than 1 portion, and vegetables should not be eaten more than 2 portions.\n\nMr.L wants to eat more fat while still following a nutritional diet, but of course, Mr.L's appetite is also limited.\n\ninput_format:\nThe first line contains three positive integers $n,m$, and $k$. It means that Mr.L can eat up to $m$of food per meal, and there are $n$kinds of food for Mr.L to choose, and this $n$kinds of food is divided into $k$category.\n\nThe second line contains a positive integer of $k$up to $10, indicating the maximum number of servings that can be eaten from $1 to $k$.\n\nThe next $n$rows each contain $2$positive integers representing the fat index $a_i$and the category $b_i$of the food, respectively.\n\noutput_format:\nIncluding a number that Mr.L can eat the maximum fat index and.\n*/\n\n#include<sstream>\n#include<stdlib.h>\n#include<algorithm>\n#include<math.h>\n#include<stdio.h>\n#include<vector>\n#include<string>\n#include<climits>\n#include<cstring>\n#include<iostream>\nusing namespace std;\n\n             \nstring solution(string std_in){\n    istringstream iss(std_in);\n             ", "constraints": "对于 $100\\%$ 的数据，$1\\leq n\\leq 200$，$1\\leq m\\leq 100$，$1\\leq k\\leq 100$，$1\\leq a_i\\leq 100$，$1\\leq b_i\\leq k$。", "samples": [["6 6 3\n3 3 2\n15 1\n15 2\n10 2\n15 2\n10 2\n5 3", "60"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}}
{"task_id": "P7694", "title": "[COCI2009-2010#4] AUTORI", "difficulty": "basic", "nl": "Scientific papers often cite earlier works, so it is not uncommon to encounter two different naming conventions within one paper. These two different naming conventions are:\n\n- Long form, which is formed by hyphenating the full words of each author's surname, such as `Knuth-Morris-Pratt`.\n- Short form, which is formed by concatenating only the first character of each author's surname, such as `KMP`.\n\nNow, you have found a paper that uses both long form and short form naming conventions, which makes you unhappy. Therefore, you want to write a program to convert all long form names to their short form equivalents.", "code": "#include<bits/stdc++.h>\nusing namespace std;\nchar a[200];\nint main(){\n\tscanf(\"%s\",a+1);\n\tcout<<a[1];\n\tfor(int i=2;a[i];i++)\n\t\tif(a[i]=='-')\n\t\t\tcout<<a[i+1];\n\treturn 0;\n}", "step": ["Declare a string variable.", "Accept string input into the variable.", "Iterate over all characters in the input string.", "If a character is uppercase, print it to the console.", "Exit the program."], "nl_cn": "科学论文会大量引用一些早期的著作，因此在一个论文中出现两种不同的命名约定并不少见。这两种不同的命名约定分别是：\n\n- 长变体，由每个作者姓氏的完整单词由连字符连接而成，例如 `Knuth-Morris-Pratt`。\n- 短变体，仅由每个作者姓氏的第一个字符拼接而成，例如 `KMP`。\n\n现在，你发现了一篇论文中同时使用了长变体和短变体这两种命名约定，这让你感到很不愉快，因此你想编写一个程序，将所有的长变体变为短变体。", "test_cases": [{"input": "Knuth-Morris-Pratt", "output": "KMP"}, {"input": "Mirko-Slavko", "output": "MS"}, {"input": "Pasko-Patak", "output": "PP"}, {"input": "John-Doe\n", "output": "JD"}, {"input": "Jane-Smith\n", "output": "JS"}, {"input": "Robert-Johnson\n", "output": "RJ"}, {"input": "Alice-Walker\n", "output": "AW"}, {"input": "Emily-Davis\n", "output": "ED"}, {"input": "Michael-Williams\n", "output": "MW"}, {"input": "Sarah-Brown\n", "output": "SB"}, {"input": "David-Anderson\n", "output": "DA"}, {"input": "Karen-Miller\n", "output": "KM"}, {"input": "Kevin-Jackson\n", "output": "KJ"}, {"input": "Laura-Thomas\n", "output": "LT"}, {"input": "Steven-White\n", "output": "SW"}, {"input": "Julia-Harris\n", "output": "JH"}, {"input": "Thomas-Clark\n", "output": "TC"}, {"input": "Nancy-Murphy\n", "output": "NM"}, {"input": "Patrick-Lee\n", "output": "PL"}, {"input": "Jessica-Hall\n", "output": "JH"}, {"input": "Alexis-Garcia-Peres", "output": "AGP"}, {"input": "Henry-George-Patrick-Costa", "output": "HGPC"}, {"input": "Samuel-Elliot-Cole", "output": "SEC"}, {"input": "Laura-Kim-Anderson", "output": "LKA"}, {"input": "Adam-Smith-Johnson", "output": "ASJ"}, {"input": "Benjamin-Maxwell-Harris", "output": "BMH"}, {"input": "Olivia-Taylor-Cook", "output": "OTC"}, {"input": "Aaron-White-Jones", "output": "AWJ"}, {"input": "Grace-Evelyn-Scott", "output": "GES"}, {"input": "Daniel-Thomas-Clark", "output": "DTC"}, {"input": "Sophia-Jackson-Walker", "output": "SJW"}, {"input": "Lucas-Harrison-Brown", "output": "LHB"}, {"input": "Emma-Anderson-Baker", "output": "EAB"}, {"input": "Michael-Johnson-Hall", "output": "MJH"}, {"input": "Emily-Davis-Ward", "output": "EDW"}, {"input": "Jacob-Wilson-Jenkins", "output": "JWJ"}, {"input": "Mia-Harris-Martin", "output": "MHM"}, {"input": "Simpson-Doe", "output": "SD"}, {"input": "Johnson-Smith", "output": "JS"}, {"input": "Brown-Lee", "output": "BL"}, {"input": "Garcia-Lopez", "output": "GL"}, {"input": "Wang-Wu", "output": "WW"}, {"input": "Taylor-Clark", "output": "TC"}, {"input": "Rodriguez-Martinez", "output": "RM"}, {"input": "Harris-Young", "output": "HY"}, {"input": "Allen-Hall", "output": "AH"}, {"input": "Green-Wilson", "output": "GW"}, {"input": "Martin-Walker", "output": "MW"}, {"input": "Lewis-Collins", "output": "LC"}, {"input": "Anderson-Thomas", "output": "AT"}, {"input": "Baker-Hill", "output": "BH"}, {"input": "Young-Moore", "output": "YM"}, {"input": "Lee-Stewart", "output": "LS"}, {"input": "Harris-Allen", "output": "HA"}, {"input": "John-Smith", "output": "JS"}, {"input": "Albert-Einstein", "output": "AE"}, {"input": "Isaac-Newton", "output": "IN"}, {"input": "Marie-Curie", "output": "MC"}, {"input": "William-Shakespeare", "output": "WS"}, {"input": "Thomas-Edison", "output": "TE"}, {"input": "Ada-Lovelace", "output": "AL"}, {"input": "Nikola-Tesla", "output": "NT"}, {"input": "Leonardo-Da-Vinci", "output": "LDV"}, {"input": "Alexander-Graham-Bell", "output": "AGB"}, {"input": "Grace-Hopper", "output": "GH"}, {"input": "Alan-Turing", "output": "AT"}, {"input": "Stephen-Hawking", "output": "SH"}, {"input": "Rosalind-Franklin", "output": "RF"}, {"input": "Marconi-De-Pop", "output": "MDP"}, {"input": "George-Boole", "output": "GB"}, {"input": "Augusta-Ada-King-Noel-Byron-Lovelace", "output": "AAKNBL"}, {"input": "Donald-Knuth\n", "output": "DK"}, {"input": "Linus-Torvalds\n", "output": "LT"}, {"input": "Guido-Van-Rossum\n", "output": "GVR"}, {"input": "Niklaus-Wirth\n", "output": "NW"}, {"input": "Dennis-Ritchie\n", "output": "DR"}, {"input": "Bjarne-Stroustrup\n", "output": "BS"}, {"input": "Ken-Thompson\n", "output": "KT"}, {"input": "Brian-Kernighan\n", "output": "BK"}, {"input": "Yukihiro-Matsumoto\n", "output": "YM"}, {"input": "James-Gosling\n", "output": "JG"}, {"input": "Anders-Hejlsberg\n", "output": "AH"}, {"input": "Tim-Berners-Lee\n", "output": "TBL"}, {"input": "Richard-Stallman\n", "output": "RS"}], "test": "#undef NDEBUG\n#include<assert.h>\nint main(){\n    assert(solution(\"Knuth-Morris-Pratt\") == \"KMP\");\n    assert(solution(\"Mirko-Slavko\") == \"MS\");\n    assert(solution(\"Pasko-Patak\") == \"PP\");\n    assert(solution(\"John-Doe\\n\") == \"JD\");\n    assert(solution(\"Jane-Smith\\n\") == \"JS\");\n    assert(solution(\"Robert-Johnson\\n\") == \"RJ\");\n    assert(solution(\"Alice-Walker\\n\") == \"AW\");\n    assert(solution(\"Emily-Davis\\n\") == \"ED\");\n    assert(solution(\"Michael-Williams\\n\") == \"MW\");\n    assert(solution(\"Sarah-Brown\\n\") == \"SB\");\n    assert(solution(\"David-Anderson\\n\") == \"DA\");\n    assert(solution(\"Karen-Miller\\n\") == \"KM\");\n    assert(solution(\"Kevin-Jackson\\n\") == \"KJ\");\n    assert(solution(\"Laura-Thomas\\n\") == \"LT\");\n    assert(solution(\"Steven-White\\n\") == \"SW\");\n    assert(solution(\"Julia-Harris\\n\") == \"JH\");\n    assert(solution(\"Thomas-Clark\\n\") == \"TC\");\n    assert(solution(\"Nancy-Murphy\\n\") == \"NM\");\n    assert(solution(\"Patrick-Lee\\n\") == \"PL\");\n    assert(solution(\"Jessica-Hall\\n\") == \"JH\");\n    assert(solution(\"Alexis-Garcia-Peres\") == \"AGP\");\n    assert(solution(\"Henry-George-Patrick-Costa\") == \"HGPC\");\n    assert(solution(\"Samuel-Elliot-Cole\") == \"SEC\");\n    assert(solution(\"Laura-Kim-Anderson\") == \"LKA\");\n    assert(solution(\"Adam-Smith-Johnson\") == \"ASJ\");\n    assert(solution(\"Benjamin-Maxwell-Harris\") == \"BMH\");\n    assert(solution(\"Olivia-Taylor-Cook\") == \"OTC\");\n    assert(solution(\"Aaron-White-Jones\") == \"AWJ\");\n    assert(solution(\"Grace-Evelyn-Scott\") == \"GES\");\n    assert(solution(\"Daniel-Thomas-Clark\") == \"DTC\");\n    assert(solution(\"Sophia-Jackson-Walker\") == \"SJW\");\n    assert(solution(\"Lucas-Harrison-Brown\") == \"LHB\");\n    assert(solution(\"Emma-Anderson-Baker\") == \"EAB\");\n    assert(solution(\"Michael-Johnson-Hall\") == \"MJH\");\n    assert(solution(\"Emily-Davis-Ward\") == \"EDW\");\n    assert(solution(\"Jacob-Wilson-Jenkins\") == \"JWJ\");\n    assert(solution(\"Mia-Harris-Martin\") == \"MHM\");\n    assert(solution(\"Simpson-Doe\") == \"SD\");\n    assert(solution(\"Johnson-Smith\") == \"JS\");\n    assert(solution(\"Brown-Lee\") == \"BL\");\n    assert(solution(\"Garcia-Lopez\") == \"GL\");\n    assert(solution(\"Wang-Wu\") == \"WW\");\n    assert(solution(\"Taylor-Clark\") == \"TC\");\n    assert(solution(\"Rodriguez-Martinez\") == \"RM\");\n    assert(solution(\"Harris-Young\") == \"HY\");\n    assert(solution(\"Allen-Hall\") == \"AH\");\n    assert(solution(\"Green-Wilson\") == \"GW\");\n    assert(solution(\"Martin-Walker\") == \"MW\");\n    assert(solution(\"Lewis-Collins\") == \"LC\");\n    assert(solution(\"Anderson-Thomas\") == \"AT\");\n    assert(solution(\"Baker-Hill\") == \"BH\");\n    assert(solution(\"Young-Moore\") == \"YM\");\n    assert(solution(\"Lee-Stewart\") == \"LS\");\n    assert(solution(\"Harris-Allen\") == \"HA\");\n    assert(solution(\"John-Smith\") == \"JS\");\n    assert(solution(\"Albert-Einstein\") == \"AE\");\n    assert(solution(\"Isaac-Newton\") == \"IN\");\n    assert(solution(\"Marie-Curie\") == \"MC\");\n    assert(solution(\"William-Shakespeare\") == \"WS\");\n    assert(solution(\"Thomas-Edison\") == \"TE\");\n    assert(solution(\"Ada-Lovelace\") == \"AL\");\n    assert(solution(\"Nikola-Tesla\") == \"NT\");\n    assert(solution(\"Leonardo-Da-Vinci\") == \"LDV\");\n    assert(solution(\"Alexander-Graham-Bell\") == \"AGB\");\n    assert(solution(\"Grace-Hopper\") == \"GH\");\n    assert(solution(\"Alan-Turing\") == \"AT\");\n    assert(solution(\"Stephen-Hawking\") == \"SH\");\n    assert(solution(\"Rosalind-Franklin\") == \"RF\");\n    assert(solution(\"Marconi-De-Pop\") == \"MDP\");\n    assert(solution(\"George-Boole\") == \"GB\");\n    assert(solution(\"Augusta-Ada-King-Noel-Byron-Lovelace\") == \"AAKNBL\");\n    assert(solution(\"Donald-Knuth\\n\") == \"DK\");\n    assert(solution(\"Linus-Torvalds\\n\") == \"LT\");\n    assert(solution(\"Guido-Van-Rossum\\n\") == \"GVR\");\n    assert(solution(\"Niklaus-Wirth\\n\") == \"NW\");\n    assert(solution(\"Dennis-Ritchie\\n\") == \"DR\");\n    assert(solution(\"Bjarne-Stroustrup\\n\") == \"BS\");\n    assert(solution(\"Ken-Thompson\\n\") == \"KT\");\n    assert(solution(\"Brian-Kernighan\\n\") == \"BK\");\n    assert(solution(\"Yukihiro-Matsumoto\\n\") == \"YM\");\n    assert(solution(\"James-Gosling\\n\") == \"JG\");\n    assert(solution(\"Anders-Hejlsberg\\n\") == \"AH\");\n    assert(solution(\"Tim-Berners-Lee\\n\") == \"TBL\");\n    assert(solution(\"Richard-Stallman\\n\") == \"RS\");\n    return 0; \n}", "prompt": "/*Scientific papers often cite earlier works, so it is not uncommon to encounter two different naming conventions within one paper. These two different naming conventions are:\n\n- Long form, which is formed by hyphenating the full words of each author's surname, such as `Knuth-Morris-Pratt`.\n- Short form, which is formed by concatenating only the first character of each author's surname, such as `KMP`.\n\nNow, you have found a paper that uses both long form and short form naming conventions, which makes you unhappy. Therefore, you want to write a program to convert all long form names to their short form equivalents.\n\ninput_format:\nThe input is just one line, a string, representing the long variant that appears in the paper.\n\nEach long variant must begin with a capital letter **.\n\noutput_format:\nThe output is a single line, a string, representing the short variant after the long variant has been transformed.\n*/\n\n#include<sstream>\n#include<stdlib.h>\n#include<algorithm>\n#include<math.h>\n#include<stdio.h>\n#include<vector>\n#include<string>\n#include<climits>\n#include<cstring>\n#include<iostream>\nusing namespace std;\n\n             \nstring solution(string std_in){\n    istringstream iss(std_in);\n             ", "constraints": "**【数据范围】**\n\n对于所有数据，满足字符串的长度不超过 $100$，且仅包含大小写英文字母和连字符 `-`。\n\n**【题目来源】**\n\n本题来源自 **_[COCI 2009-2010](https://hsin.hr/coci/archive/2009_2010/) [CONTEST 4](https://hsin.hr/coci/archive/2009_2010/contest4_tasks.pdf) T1 AUTORI_**，按照原题数据配置，满分 $30$ 分。\n\n由 [Eason_AC](https://www.luogu.com.cn/user/112917) 翻译整理提供。", "samples": [["Knuth-Morris-Pratt", "KMP"], ["Mirko-Slavko", "MS"], ["Pasko-Patak", "PP"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [32768, 32768, 32768, 32768, 32768, 32768, 32768, 32768, 32768, 32768]}}
{"task_id": "P1426", "title": "小鱼会有危险吗", "difficulty": "basic", "nl": "Once, a little fish wanted to swim to the right in a straight line from point A. The little fish can swim 7 meters in the first second, and from the second second onwards, it swims a distance that is only 98% of the previous second. An extremely evil hunter has installed a hidden detector at a location to the right of A that is s meters away. The detector detects a range within x meters to the left and right of it. Once the little fish enters the range of the detector, the detector will transmit a signal to the hunter at the end of that second. The hunter will then capture the waters within the range of the detector after one second. If the little fish is still within the range during this time, it is in danger. In other words, once the little fish enters the range of the detector, if it can swim out of the range of the detector immediately within the next second, it is still safe. Now given data for s and x, please determine if the little fish is in danger. Output 'y' if it is in danger and 'n' if it is not.", "code": "#include<cstdio>\n#include<iostream>\n#include<cmath>\nusing namespace std;\ndouble meter=7,s,x,l,r,now=0;//生成波光粼粼的河水和小鱼儿。 \nint main()\n{\n\tcin>>s>>x;               //邪恶的猎人埋下了罪恶的探测器。 \n\tl=s-x;                   //死亡探测器往左边最多扫到的地方。 \n\tr=s+x;                   //死亡探测器往左边最多扫到的地方。 \n\tfor(;;)                  //坚持不懈的鱼儿向着死亡游去。 \n\t{\n\t\tif (now>r)           //鱼儿的坚持感动了上苍，直接跳过了探测器的扫描范围。 \n\t\t{\n\t\t\tcout<<'n';       //活着！！ \n\t\t\treturn 0;        //程序的结束------世界的消逝。 \n\t\t}\n\t\tif (l<=now&&now<=r)  //被探测器扫到！核弹是否发射？？ \n\t\t{\n\t\t\tif (now+meter>r) //逃出生天！！真小鱼儿从不回头看爆炸！！ \n\t\t\t{\n\t\t\t\tcout<<'n';   //活着！！ \n\t\t\t\treturn 0;    //程序的结束------世界的消逝。 \n\t\t\t}\n\t\t\telse             //难道没逃出来？？？ \n\t\t\t{\n\t\t\t\tcout<<'y';   //十二号桌西湖醋鱼！！ \n\t\t\t\treturn 0;    //程序的结束------世界的消逝。 \n\t\t\t}\n\t\t}\n\t\tnow+=meter;          //小鱼努力游着...... \n\t\tmeter*=0.98;         //小鱼有点疲劳了。 \n\t}\n\treturn 0;                //程序的结束------世界的消逝。\n}", "step": ["Initialize variables including the length of the river, the starting and ending points, and the distance the frog can jump.", "Check if the frog can jump to the other side with one jump by comparing the current position of the frog to the distance between the starting point and the ending point.", "If the frog cannot jump to the other side in one jump, iterate through the sequence of jumps it will take to get there.", "At each iteration, check if the current position of the frog is within the range of the river where it can jump, then check if the next jump will be too far to make it to the other side.", "If the frog cannot make it to the other side with one jump or the iteration of jumps, return \"n\", otherwise return \"y\"."], "nl_cn": "有一次，小鱼要从 A 处沿直线往右边游，小鱼第一秒可以游 $7$ 米，从第二秒开始每秒游的距离只有前一秒的 $98\\%$。有个极其邪恶的猎人在距离 A 处右边 $s$ 米的地方，安装了一个隐蔽的探测器，探测器左右 $x$ 米之内是探测范围。一旦小鱼进入探测器的范围，探测器就会在这一秒结束时把信号传递给那个猎人，猎人在一秒后就要对探测器范围内的水域进行抓捕，这时如果小鱼还在这范围内就危险了。也就是说小鱼一旦进入探测器范围，如果能在下 $1$ 秒的时间内马上游出探测器的范围，还是安全的。现在给出 $s$ 和 $x$ 的数据，请你判断小鱼会不会有危险？如果有危险输出 `y`，没有危险输出 `n`。", "test_cases": [{"input": "14 1", "output": "n"}, {"input": "20 5", "output": "n"}, {"input": "15 4", "output": "n"}, {"input": "12 3", "output": "n"}, {"input": "18 4", "output": "n"}, {"input": "16 4", "output": "n"}, {"input": "13 3", "output": "n"}, {"input": "21 3\n", "output": "n"}, {"input": "10 5\n", "output": "y"}, {"input": "12 4\n", "output": "n"}, {"input": "13 4\n", "output": "n"}, {"input": "12 1\n", "output": "n"}, {"input": "18 6\n", "output": "y"}, {"input": "17 7\n", "output": "y"}, {"input": "11 1\n", "output": "n"}, {"input": "20 7\n", "output": "y"}, {"input": "20 2\n", "output": "n"}, {"input": "8 4\n", "output": "n"}, {"input": "5 1\n", "output": "n"}, {"input": "15 3\n", "output": "n"}, {"input": "6 2\n", "output": "n"}, {"input": "9 3\n", "output": "n"}, {"input": "13 5\n", "output": "n"}, {"input": "7 1\n", "output": "n"}, {"input": "30 6\n", "output": "y"}, {"input": "35 8\n", "output": "y"}, {"input": "40 10\n", "output": "y"}], "test": "#undef NDEBUG\n#include<assert.h>\nint main(){\n    assert(solution(\"14 1\") == \"n\");\n    assert(solution(\"20 5\") == \"n\");\n    assert(solution(\"15 4\") == \"n\");\n    assert(solution(\"12 3\") == \"n\");\n    assert(solution(\"18 4\") == \"n\");\n    assert(solution(\"16 4\") == \"n\");\n    assert(solution(\"13 3\") == \"n\");\n    assert(solution(\"21 3\\n\") == \"n\");\n    assert(solution(\"10 5\\n\") == \"y\");\n    assert(solution(\"12 4\\n\") == \"n\");\n    assert(solution(\"13 4\\n\") == \"n\");\n    assert(solution(\"12 1\\n\") == \"n\");\n    assert(solution(\"18 6\\n\") == \"y\");\n    assert(solution(\"17 7\\n\") == \"y\");\n    assert(solution(\"11 1\\n\") == \"n\");\n    assert(solution(\"20 7\\n\") == \"y\");\n    assert(solution(\"20 2\\n\") == \"n\");\n    assert(solution(\"8 4\\n\") == \"n\");\n    assert(solution(\"5 1\\n\") == \"n\");\n    assert(solution(\"15 3\\n\") == \"n\");\n    assert(solution(\"6 2\\n\") == \"n\");\n    assert(solution(\"9 3\\n\") == \"n\");\n    assert(solution(\"13 5\\n\") == \"n\");\n    assert(solution(\"7 1\\n\") == \"n\");\n    assert(solution(\"30 6\\n\") == \"y\");\n    assert(solution(\"35 8\\n\") == \"y\");\n    assert(solution(\"40 10\\n\") == \"y\");\n    return 0; \n}", "prompt": "/*Once, a little fish wanted to swim to the right in a straight line from point A. The little fish can swim 7 meters in the first second, and from the second second onwards, it swims a distance that is only 98% of the previous second. An extremely evil hunter has installed a hidden detector at a location to the right of A that is s meters away. The detector detects a range within x meters to the left and right of it. Once the little fish enters the range of the detector, the detector will transmit a signal to the hunter at the end of that second. The hunter will then capture the waters within the range of the detector after one second. If the little fish is still within the range during this time, it is in danger. In other words, once the little fish enters the range of the detector, if it can swim out of the range of the detector immediately within the next second, it is still safe. Now given data for s and x, please determine if the little fish is in danger. Output 'y' if it is in danger and 'n' if it is not.\n\ninput_format:\nEnter two real numbers in a line, separated by Spaces, representing $s$and $x$.\n\noutput_format:\nOutput 'y' or 'n' in a line indicates whether the fish will be in danger.\n*/\n\n#include<sstream>\n#include<stdlib.h>\n#include<algorithm>\n#include<math.h>\n#include<stdio.h>\n#include<vector>\n#include<string>\n#include<climits>\n#include<cstring>\n#include<iostream>\nusing namespace std;\n\n             \nstring solution(string std_in){\n    istringstream iss(std_in);\n             ", "constraints": "#### 数据规模与约定\n\n对于 $100\\%$ 的数据，保证 $1 \\leq s,x\\le100$，小数点后最多有 $6$ 位小数。", "samples": [["14 1", "n"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288]}}
{"task_id": "P1683", "title": "入门", "difficulty": "challenge", "nl": "Not everyone can enter Peach Blossom Island, and Huang Yaoshi hates people like Guo Jing who are stupid and foolish. Therefore, he built a small path at the only entrance of Peach Blossom Island, which is completely paved with square tiles. Some tiles can be stepped on, which we consider safe, while others will spew deadly poison as soon as you step on them, causing you to die. We consider them unsafe. You can only move from a safe tile to any of the four adjacent tiles, but the tile you move to must also be safe.\n\nAs a friend of Huang Rong, she told you in advance which tiles are safe and which are not, and she will guide you to fly to the first tile (which can be in any safe location). Now she tells you the secret of entering Peach Blossom Island: if you can walk through the most tiles without dying, then the door of Peach Blossom Island will automatically open, and you can fly directly into the gate from the current location.\n\nNote: Tiles can be walked on repeatedly, but cannot be counted repeatedly.", "code": "#include<iostream>\n#include<string>\nusing namespace std;\nstring str;\nint h,w,head=0,tail=1,p1[4]={1,0,0,-1},p2[4]={0,1,-1,0},ans,fx[1001],fy[1001],x,y;  //纯手工队列！\nbool l[1001][1001]={false};  //是否走过或能否走\nint main()\n{\n    cin>>w>>h;\n    for(int i=1;i<=h;i++)  //来自W和H的淡淡的忧伤\n    {\n        cin>>str;\n        for(int j=0;j<w;j++)\n        {\n            if(str[j]=='@')\n            {\n                fx[1]=i;\n                fy[1]=j+1;\n            }\n            if(str[j]=='#')\n                l[i][j+1]=true;\n        }\n    }\n    do    //广搜开始啦！\n    {\n        head++;\n        for(int i=0;i<=3;i++)\n        {\n            x=fx[head]+p1[i];\n            y=fy[head]+p2[i];\n            if(!l[x][y]&&x<=h&&y<=w&&x>=1&&y>=1)\n            {\n                ans++;\n                l[x][y]=true;\n                tail++;\n                fx[tail]=x;\n                fy[tail]=y;\n            }\n        }\n    }while(head<tail);\n    cout<<ans<<endl;    //没啦！\n}", "step": ["Initialize variables n, m and cnt to 1, and arrays a and vis.", "Read input n and m, initialize 2D array a with '0'.", "Read characters of the grid into array a, and record the position of '@' in variables w and e.", "Start dfs from position (w, e) and increment cnt for every new area discovered.", "Print cnt."], "nl_cn": "不是任何人都可以进入桃花岛的，黄药师最讨厌像郭靖一样呆头呆脑的人。所以，他在桃花岛的唯一入口处修了一条小路，这条小路全部用正方形瓷砖铺设而成。有的瓷砖可以踩，我们认为是安全的，而有的瓷砖一踩上去就会有喷出要命的毒气，那你就死翘翘了，我们认为是不安全的。你只能从一块安全的瓷砖上走到与他相邻的四块瓷砖中的任何一个上，但它也必须是安全的才行。\n\n由于你是黄蓉的朋友，她事先告诉你哪些砖是安全的、哪些砖是不安全的，并且她会指引你飞到第一块砖上（第一块砖可能在任意安全位置），现在她告诉你进入桃花岛的秘密就是：如果你能走过最多的瓷砖并且没有死，那么桃花岛的大门就会自动打开了，你就可以从当前位置直接飞进大门了。\n\n注意：瓷砖可以重复走过，但不能重复计数。\n", "test_cases": [{"input": "11 9\n.#.........\n.#.#######.\n.#.#.....#.\n.#.#.###.#.\n.#.#..@#.#.\n.#.#####.#.\n.#.......#.\n.#########.\n...........\n", "output": "59"}, {"input": "2 2\n.#\n@.\n", "output": "3"}], "test": "#undef NDEBUG\n#include<assert.h>\nint main(){\n    assert(solution(\"11 9\\n.#.........\\n.#.#######.\\n.#.#.....#.\\n.#.#.###.#.\\n.#.#..@#.#.\\n.#.#####.#.\\n.#.......#.\\n.#########.\\n...........\\n\") == \"59\");\n    assert(solution(\"2 2\\n.#\\n@.\\n\") == \"3\");\n    return 0; \n}", "prompt": "/*Not everyone can enter Peach Blossom Island, and Huang Yaoshi hates people like Guo Jing who are stupid and foolish. Therefore, he built a small path at the only entrance of Peach Blossom Island, which is completely paved with square tiles. Some tiles can be stepped on, which we consider safe, while others will spew deadly poison as soon as you step on them, causing you to die. We consider them unsafe. You can only move from a safe tile to any of the four adjacent tiles, but the tile you move to must also be safe.\n\nAs a friend of Huang Rong, she told you in advance which tiles are safe and which are not, and she will guide you to fly to the first tile (which can be in any safe location). Now she tells you the secret of entering Peach Blossom Island: if you can walk through the most tiles without dying, then the door of Peach Blossom Island will automatically open, and you can fly directly into the gate from the current location.\n\nNote: Tiles can be walked on repeatedly, but cannot be counted repeatedly.\n\ninput_format:\nThe first line has two positive integers $W$and $H$, indicating the width and length of the path, respectively.\n\nThe following $H$acts as a character matrix of $H\\times W$. Each character represents a tile. Where, '. 'represents the safe brick,' # 'represents the unsafe brick, and' @ 'represents the first brick.\n\noutput_format:\nOutput a line containing only one number, that is, the maximum number of bricks you can safely walk through from the first brick (including the first brick).\n*/\n\n#include<sstream>\n#include<stdlib.h>\n#include<algorithm>\n#include<math.h>\n#include<stdio.h>\n#include<vector>\n#include<string>\n#include<climits>\n#include<cstring>\n#include<iostream>\nusing namespace std;\n\n             \nstring solution(string std_in){\n    istringstream iss(std_in);\n             ", "constraints": "#### 数据规模与约定\n\n对于全部的测试点，保证 $1 \\leq W,H\\le 20$。", "samples": [["11 9\n.#.........\n.#.#######.\n.#.#.....#.\n.#.#.###.#.\n.#.#..@#.#.\n.#.#####.#.\n.#.......#.\n.#########.\n...........\n", "59"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}}
{"task_id": "P3079", "title": "[USACO13MAR]Farm Painting S", "difficulty": "advanced", "nl": "After several harsh winters, Farmer John has decided it is time to re-paint his farm. The farm consists of N fenced enclosures (1 <= N <= 50,000), each of which can be described by a rectangle in the 2D plane whose sides are parallel to the x and y axes. Enclosures may be contained within other enclosures, but no two fences intersect, so if two enclosures cover the same area of the 2D plane, one must be contained within the other.\n\nFJ figures that an enclosure contained within another enclosure will not be visible to the outside world, so he only wants to re-paint enclosures that are themselves not contained within any other enclosures. Please help FJ determine the total number of enclosures he needs to paint.", "code": "#include<bits/stdc++.h>\n#define mxn 1000003\nusing namespace std;\nstruct node{\n\tint x,i;\n};\nint n,ans,c[mxn];\nbool fl[50003];\nvector<pair<int,int> >ad[mxn],dl[mxn];\nvector<node>q[mxn];\nvoid add(int x,int y){\n\tfor(;x<=1000001;x+=x&-x)c[x]+=y;\n}\nint ask(int x){\n    int num=0;\n    for(;x;x-=x&-x)num+=c[x];\n    return num;\n}\nsigned main(){\n\tscanf(\"%d\",&n);\n\tfor(int i=0,x1,y1,x2,y2;i<n;++i){\n\t\tscanf(\"%d%d%d%d\",&x1,&y1,&x2,&y2);\n\t\ty1++,y2++;\n\t\tad[x1].push_back(make_pair(y1,y2));\n\t\tdl[x2].push_back(make_pair(y1,y2));\n\t\tq[x1].push_back({y1,i});\n\t}\n\tfor(int i=0;i<1000001;++i){\n\t\tfor(pair<int,int>p:ad[i]){\n\t\t\tadd(p.first,1);\n\t\t\tadd(p.second+1,-1);\n\t\t}\n\t\tfor(node j:q[i]){\n\t\t\tif(ask(j.x)!=1)fl[j.i]=1;\n\t\t}\n\t\tfor(pair<int,int>p:dl[i]){\n\t\t\tadd(p.first,-1);\n\t\t\tadd(p.second+1,1);\n\t\t}\n\t}\n\tfor(int i=0;i<n;++i)if(!fl[i])ans++;\n\tprintf(\"%d\",ans);\n\treturn 0;\n}", "step": ["Read input", "For every rectangle, add to add-delete list and query list for corresponding coordinates", "For every x-coordinate from 0 to 1000000, update the binary index tree with add-delete list data and count the number of overlapping rectangles for each query in the query list", "Print the number of non-overlapping rectangles"], "nl_cn": "After several harsh winters, Farmer John has decided it is time to re-paint his farm.  The farm consists of N fenced enclosures (1 <= N <= 50,000), each of which can be described by a rectangle in the 2D plane whose sides are parallel to the x and y axes.  Enclosures may be contained within other enclosures, but no two fences intersect, so if two enclosures cover the same area of the 2D plane, one must be contained within the other.\n\nFJ figures that an enclosure contained within another enclosure will not be visible to the outside world, so he only wants to re-paint enclosures that are themselves not contained within any other enclosures.  Please help FJ determine the total number of enclosures he needs to paint.\n\n经过几个严冬，农场主约翰决定是重新粉刷农场的时候了。该农场由$n$个围栏围成（$1<=n=50000$），每一个都可以用二维平面上的矩形来描述，其两侧平行于x和y轴。牛圈可能包含在其他牛圈中，但没有两个栅栏相交（不同牛圈的边不会有接触）。因此如果两个牛圈覆盖了二维平面的同一区域，那么一个必须包含在另一个内。\n\nFJ知道，被其他牛圈包含的牛圈是不会被外面的人看到的。众所周知，FJ非常懒，所以他只想刷露在外面的牛圈，请帮助他求出总共需要刷的牛圈的个数。\n", "test_cases": [{"input": "3 \n2 0 8 9 \n10 2 11 3 \n4 2 6 5 \n", "output": "2"}, {"input": "1 \n1 1 1 1 \n", "output": "1"}, {"input": "5 \n1 1 4 4 \n1 1 4 4 \n1 1 4 4 \n1 1 4 4 \n1 1 4 4 \n", "output": "0"}, {"input": "6 \n1 1 3 3 \n2 2 4 4 \n5 5 7 7 \n6 6 8 8 \n9 9 10 10 \n11 11 12 12 \n", "output": "4"}, {"input": "3 \n1 1 5 5 \n2 2 4 4 \n3 3 3 3 \n", "output": "1"}, {"input": "5 \n1 1 5 5 \n1 1 5 5 \n1 1 5 5 \n1 1 5 5 \n1 1 5 5 \n", "output": "0"}, {"input": "6 \n1 1 4 4 \n1 1 4 4 \n1 1 4 4 \n1 1 4 4 \n1 1 4 4 \n1 1 4 4 \n", "output": "0"}, {"input": "3 \n1 1 3 3 \n1 1 3 3 \n1 1 3 3 \n", "output": "0"}, {"input": "2 \n1 1 3 3 \n1 1 3 3 \n", "output": "0"}, {"input": "1 \n0 0 1 1 \n", "output": "1"}, {"input": "4 \n0 0 1 1 \n2 2 3 3 \n4 4 5 5 \n6 6 7 7 \n", "output": "4"}, {"input": "1 \n1 1 2 2 \n", "output": "1"}, {"input": "4 \n0 0 4 4 \n1 1 3 3 \n2 2 2 2 \n5 5 6 6 \n", "output": "2"}, {"input": "6 \n0 0 3 3 \n1 1 4 4 \n2 2 5 5 \n3 3 6 6 \n4 4 7 7 \n5 5 8 8 \n", "output": "1"}, {"input": "4 \n1 1 4 4 \n2 2 3 3 \n1 1 4 4 \n2 2 3 3 \n", "output": "0"}, {"input": "4 \n1 1 4 4 \n1 1 4 4 \n2 2 3 3 \n2 2 3 3 \n", "output": "0"}], "test": "#undef NDEBUG\n#include<assert.h>\nint main(){\n    assert(solution(\"3 \\n2 0 8 9 \\n10 2 11 3 \\n4 2 6 5 \\n\") == \"2\");\n    assert(solution(\"1 \\n1 1 1 1 \\n\") == \"1\");\n    assert(solution(\"5 \\n1 1 4 4 \\n1 1 4 4 \\n1 1 4 4 \\n1 1 4 4 \\n1 1 4 4 \\n\") == \"0\");\n    assert(solution(\"6 \\n1 1 3 3 \\n2 2 4 4 \\n5 5 7 7 \\n6 6 8 8 \\n9 9 10 10 \\n11 11 12 12 \\n\") == \"4\");\n    assert(solution(\"3 \\n1 1 5 5 \\n2 2 4 4 \\n3 3 3 3 \\n\") == \"1\");\n    assert(solution(\"5 \\n1 1 5 5 \\n1 1 5 5 \\n1 1 5 5 \\n1 1 5 5 \\n1 1 5 5 \\n\") == \"0\");\n    assert(solution(\"6 \\n1 1 4 4 \\n1 1 4 4 \\n1 1 4 4 \\n1 1 4 4 \\n1 1 4 4 \\n1 1 4 4 \\n\") == \"0\");\n    assert(solution(\"3 \\n1 1 3 3 \\n1 1 3 3 \\n1 1 3 3 \\n\") == \"0\");\n    assert(solution(\"2 \\n1 1 3 3 \\n1 1 3 3 \\n\") == \"0\");\n    assert(solution(\"1 \\n0 0 1 1 \\n\") == \"1\");\n    assert(solution(\"4 \\n0 0 1 1 \\n2 2 3 3 \\n4 4 5 5 \\n6 6 7 7 \\n\") == \"4\");\n    assert(solution(\"1 \\n1 1 2 2 \\n\") == \"1\");\n    assert(solution(\"4 \\n0 0 4 4 \\n1 1 3 3 \\n2 2 2 2 \\n5 5 6 6 \\n\") == \"2\");\n    assert(solution(\"6 \\n0 0 3 3 \\n1 1 4 4 \\n2 2 5 5 \\n3 3 6 6 \\n4 4 7 7 \\n5 5 8 8 \\n\") == \"1\");\n    assert(solution(\"4 \\n1 1 4 4 \\n2 2 3 3 \\n1 1 4 4 \\n2 2 3 3 \\n\") == \"0\");\n    assert(solution(\"4 \\n1 1 4 4 \\n1 1 4 4 \\n2 2 3 3 \\n2 2 3 3 \\n\") == \"0\");\n    return 0; \n}", "prompt": "/*After several harsh winters, Farmer John has decided it is time to re-paint his farm. The farm consists of N fenced enclosures (1 <= N <= 50,000), each of which can be described by a rectangle in the 2D plane whose sides are parallel to the x and y axes. Enclosures may be contained within other enclosures, but no two fences intersect, so if two enclosures cover the same area of the 2D plane, one must be contained within the other.\n\nFJ figures that an enclosure contained within another enclosure will not be visible to the outside world, so he only wants to re-paint enclosures that are themselves not contained within any other enclosures. Please help FJ determine the total number of enclosures he needs to paint.\n\ninput_format:\n\\* Line 1: The number of enclosures, N.\n\n\\* Lines 2.. 1+N: Each line describes an enclosure by 4 space-separated integers x1, y1, x2, and y2, where (x1,y1) is the lower-left corner of the enclosure and (x2,y2) is the upper-right corner. All coordinates are in the range 0.. 1000000.\n\nThe first row is a number, the total number of cattle pens is $n$\n\nThe second to $n+1$rows have four numbers per row, starting at $x1,y1$and ending at $x2,y2$\n\noutput_format:\n\\* Line 1: The number of enclosures that are not contained within other enclosures.\n\nFJ Total number of pens to brush\n*/\n\n#include<sstream>\n#include<stdlib.h>\n#include<algorithm>\n#include<math.h>\n#include<stdio.h>\n#include<vector>\n#include<string>\n#include<climits>\n#include<cstring>\n#include<iostream>\nusing namespace std;\n\n             \nstring solution(string std_in){\n    istringstream iss(std_in);\n             ", "constraints": "There are three enclosures.  The first has corners (2,0) and (8,9), and so on.\n\n\nEnclosure 3 is contained within enclosure 1, so there are two enclosures not contained within other enclosures.\n", "samples": [["3 \n2 0 8 9 \n10 2 11 3 \n4 2 6 5 \n", "2 \n"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}}
{"task_id": "P2788", "title": "数学1（math1）- 加减算式", "difficulty": "basic", "nl": "After struggling for a long time, HansBug finally reached the moment to do the last math problem. In front of him was a bunch of messy addition and subtraction formulas. Success was clearly within reach. However, his brain cells and RP were already exhausted, so he handed over this important task to you.", "code": "#include<bits/stdc++.h>\nusing namespace std;\nint ans,t;\nint main()\n{\n    while(cin>>t) ans+=t;//读入并计算\n    cout<<ans;//输出\n    return 0;\n}", "step": ["Initialize two variables ans and t to 0.", "While there is an integer input, add it to ans.", "Output the final value of ans.", "Return 0 to indicate successful completion of the program."], "nl_cn": "好不容易啊，HansBug终于熬到了做到数学最后一题的时刻了，眼前是一堆杂乱的加减算式。显然成功就在眼前了。可是他脑细胞和RP已经消耗殆尽，所以这个重要的任务就交给你们啦。\n", "test_cases": [{"input": "1+2-3", "output": "0"}, {"input": "-5+10-3", "output": "2"}, {"input": "7-4+8-2", "output": "9"}, {"input": "10-5-3-1", "output": "1"}, {"input": "4+6-2+8", "output": "16"}, {"input": "-3+2-9+5", "output": "-5"}, {"input": "1-2+3-4+5-6+7-8", "output": "-4"}, {"input": "10-7-2+5+3-6", "output": "3"}, {"input": "-1-2-3-4-5-6-7", "output": "-28"}, {"input": "9+3-6+2-5", "output": "3"}, {"input": "-8+2-5-3+6+1", "output": "-7"}, {"input": "10-1+2-3+4-5+6", "output": "13"}, {"input": "5+2+8-3-6", "output": "6"}, {"input": "3+6-8-4+7", "output": "4"}, {"input": "-9+5-2+6-3", "output": "-3"}, {"input": "1-3+5-7+9-11", "output": "-6"}, {"input": "-2-4-6+8+10", "output": "6"}, {"input": "7+3-1+4-2+5", "output": "16"}, {"input": "10-6-3-1+5", "output": "5"}, {"input": "-5+10+3-8-2", "output": "-2"}, {"input": "5+10-7\n", "output": "8"}, {"input": "100-50+75\n", "output": "125"}, {"input": "20+30-40\n", "output": "10"}, {"input": "3-2+4-1\n", "output": "4"}, {"input": "12-15+8\n", "output": "5"}, {"input": "7-3+2-5\n", "output": "1"}, {"input": "100+200-50\n", "output": "250"}, {"input": "6-2-1+4\n", "output": "7"}, {"input": "10+5-15\n", "output": "0"}, {"input": "2-4+1-3\n", "output": "-4"}, {"input": "50-20+30\n", "output": "60"}, {"input": "8+12-9\n", "output": "11"}, {"input": "17-6+5-10\n", "output": "6"}, {"input": "25+30-15\n", "output": "40"}, {"input": "9-3-2+6\n", "output": "10"}, {"input": "13+14-8\n", "output": "19"}, {"input": "65-20+45\n", "output": "90"}, {"input": "7-4+3-6\n", "output": "0"}, {"input": "100+10-99\n", "output": "11"}, {"input": "1+1-1\n", "output": "1"}, {"input": "10-5+3+2\n", "output": "10"}, {"input": "0+0-0+0+0+0\n", "output": "0"}, {"input": "100-50-25+15\n", "output": "40"}, {"input": "20+30-10+5-15\n", "output": "30"}, {"input": "2+3+4+5+6-15\n", "output": "5"}, {"input": "8\n", "output": "8"}, {"input": "-1+1+1\n", "output": "1"}, {"input": "-10+15+5\n", "output": "10"}, {"input": "-100+50\n", "output": "-50"}, {"input": "-9+4+7\n", "output": "2"}, {"input": "0-0-0-0-0\n", "output": "0"}, {"input": "-1-1-1-1-1\n", "output": "-5"}, {"input": "50-40+30+20\n", "output": "60"}, {"input": "5+2+1\n", "output": "8"}, {"input": "0+0+0+0+0+0+0+0+0+0+0+0\n", "output": "0"}, {"input": "-10-20-10\n", "output": "-40"}, {"input": "100+101-200\n", "output": "1"}], "test": "#undef NDEBUG\n#include<assert.h>\nint main(){\n    assert(solution(\"1+2-3\") == \"0\");\n    assert(solution(\"-5+10-3\") == \"2\");\n    assert(solution(\"7-4+8-2\") == \"9\");\n    assert(solution(\"10-5-3-1\") == \"1\");\n    assert(solution(\"4+6-2+8\") == \"16\");\n    assert(solution(\"-3+2-9+5\") == \"-5\");\n    assert(solution(\"1-2+3-4+5-6+7-8\") == \"-4\");\n    assert(solution(\"10-7-2+5+3-6\") == \"3\");\n    assert(solution(\"-1-2-3-4-5-6-7\") == \"-28\");\n    assert(solution(\"9+3-6+2-5\") == \"3\");\n    assert(solution(\"-8+2-5-3+6+1\") == \"-7\");\n    assert(solution(\"10-1+2-3+4-5+6\") == \"13\");\n    assert(solution(\"5+2+8-3-6\") == \"6\");\n    assert(solution(\"3+6-8-4+7\") == \"4\");\n    assert(solution(\"-9+5-2+6-3\") == \"-3\");\n    assert(solution(\"1-3+5-7+9-11\") == \"-6\");\n    assert(solution(\"-2-4-6+8+10\") == \"6\");\n    assert(solution(\"7+3-1+4-2+5\") == \"16\");\n    assert(solution(\"10-6-3-1+5\") == \"5\");\n    assert(solution(\"-5+10+3-8-2\") == \"-2\");\n    assert(solution(\"5+10-7\\n\") == \"8\");\n    assert(solution(\"100-50+75\\n\") == \"125\");\n    assert(solution(\"20+30-40\\n\") == \"10\");\n    assert(solution(\"3-2+4-1\\n\") == \"4\");\n    assert(solution(\"12-15+8\\n\") == \"5\");\n    assert(solution(\"7-3+2-5\\n\") == \"1\");\n    assert(solution(\"100+200-50\\n\") == \"250\");\n    assert(solution(\"6-2-1+4\\n\") == \"7\");\n    assert(solution(\"10+5-15\\n\") == \"0\");\n    assert(solution(\"2-4+1-3\\n\") == \"-4\");\n    assert(solution(\"50-20+30\\n\") == \"60\");\n    assert(solution(\"8+12-9\\n\") == \"11\");\n    assert(solution(\"17-6+5-10\\n\") == \"6\");\n    assert(solution(\"25+30-15\\n\") == \"40\");\n    assert(solution(\"9-3-2+6\\n\") == \"10\");\n    assert(solution(\"13+14-8\\n\") == \"19\");\n    assert(solution(\"65-20+45\\n\") == \"90\");\n    assert(solution(\"7-4+3-6\\n\") == \"0\");\n    assert(solution(\"100+10-99\\n\") == \"11\");\n    assert(solution(\"1+1-1\\n\") == \"1\");\n    assert(solution(\"10-5+3+2\\n\") == \"10\");\n    assert(solution(\"0+0-0+0+0+0\\n\") == \"0\");\n    assert(solution(\"100-50-25+15\\n\") == \"40\");\n    assert(solution(\"20+30-10+5-15\\n\") == \"30\");\n    assert(solution(\"2+3+4+5+6-15\\n\") == \"5\");\n    assert(solution(\"8\\n\") == \"8\");\n    assert(solution(\"-1+1+1\\n\") == \"1\");\n    assert(solution(\"-10+15+5\\n\") == \"10\");\n    assert(solution(\"-100+50\\n\") == \"-50\");\n    assert(solution(\"-9+4+7\\n\") == \"2\");\n    assert(solution(\"0-0-0-0-0\\n\") == \"0\");\n    assert(solution(\"-1-1-1-1-1\\n\") == \"-5\");\n    assert(solution(\"50-40+30+20\\n\") == \"60\");\n    assert(solution(\"5+2+1\\n\") == \"8\");\n    assert(solution(\"0+0+0+0+0+0+0+0+0+0+0+0\\n\") == \"0\");\n    assert(solution(\"-10-20-10\\n\") == \"-40\");\n    assert(solution(\"100+101-200\\n\") == \"1\");\n    return 0; \n}", "prompt": "/*After struggling for a long time, HansBug finally reached the moment to do the last math problem. In front of him was a bunch of messy addition and subtraction formulas. Success was clearly within reach. However, his brain cells and RP were already exhausted, so he handed over this important task to you.\n\ninput_format:\nOne line, including a string representation of a polynomial arithmetic expression (each term has a number range of 0-32767).\n\noutput_format:\nAn integer, which is the result of the calculation (ensure that the calculation does not exceed the long integer range).\n*/\n\n#include<sstream>\n#include<stdlib.h>\n#include<algorithm>\n#include<math.h>\n#include<stdio.h>\n#include<vector>\n#include<string>\n#include<climits>\n#include<cstring>\n#include<iostream>\nusing namespace std;\n\n             \nstring solution(string std_in){\n    istringstream iss(std_in);\n             ", "constraints": "数据保证字符串长度不超过 $60000$。\n", "samples": [["1+2-3", "0"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}}
{"task_id": "P3037", "title": "[USACO11DEC]Simplifying the Farm G", "difficulty": "advanced", "nl": "Farmer John is taking an algorithms course at a local university and has just learned about minimum spanning trees. He realizes that the layout of his farm is not efficient and wants to simplify it. The farm can be represented as a graph with fields as vertices and pathways as edges with associated lengths. For each distinct length, at most three pathways share this length. Farmer John wants to remove some pathways to make it a tree and wants it to be a minimum spanning tree with the smallest sum of edge lengths. Help him compute the sum of edge lengths in a minimum spanning tree and the number of different possible minimum spanning trees he can create.", "code": "/*!\n * FileName: luogu-3037.cpp\n * This Problem is on luogu. The ID of the problem is 3037. \n * Copyright(c) 2019 Shu_Yu_Mo\n * MIT Licensed\n * Luogu: https://www.luogu.org/space/show?uid=44615\n * Github: https://github.com/oldsuold/\n * Gitee: https://gitee.com/Shu_Yu_Mo/\n * These words were created by an amazing tool on 2019-08-03 22:47:58 written by Shu_Yu_Mo.\n */\n#include<cstdio>\n#include<cstring>\n#include<iostream>\n#include<set>\n#include<algorithm>\n#define inf 0x7fffffff\nusing namespace std;\nconst int _M = 1e5 + 100;\nconst int _N = 4e4 + 100;\nconst int MOD = 1000000007;\ninline int read()\n{\n    char c = getchar(); int sign = 1; int x = 0;\n    while(c > '9' || c < '0') { if(c=='-')sign = -1; c = getchar(); } \n    while(c <= '9' && c >= '0') { x *= 10; x += c - '0'; c = getchar(); }\n    return x * sign;\n}\nstruct edges{\n\tint u;\n\tint v;\n\tint w;\n\tbool operator < (const edges & A) const {\n\t\treturn w < A.w;\n\t}\n}E[_M];\nint n, m;\n//Kruskal 所用的并查集   Start\nint f[_N];\nint find(int x){ return f[x] == x ? x : f[x] = find(f[x]); }\nvoid initForSet()\n{\n\tfor(register int i = 1;i <= n;i++)\n\t\tf[i] = i;\n}\nvoid marge(int x, int y)\n{\n\tx = find(x);\n\ty = find(y);\n\tif(x == y) return;\n\tf[x] = y;\n}\nbool ask(int x, int y)\n{\n\treturn find(x) == find(y);\n}\n//Kruskal 所用的并查集   End\nint nxtIt(int now)//往下找最后一个边权相同的位置\n{\n\tfor(register int i = now;i <= m;i++)\n\t\tif(E[now].w != E[i].w)\n\t\t\treturn i - 1;\n\treturn m;\n}\nset <pair<int , int >  >  S;//\nint main()\n{\n\tn = read(), m = read();\n\tfor(register int i = 1;i <= m;i++)\n\t{\n\t\tE[i].u = read();\n\t\tE[i].v = read();\n\t\tE[i].w = read(); \n\t}\n\tinitForSet();\n\tsort(E + 1, E + 1 + m);\n\tint ans1 = 0;\n\tint ans2 = 1;\n\tint nxt;\n\tfor(register int i = 1;i <= m;)\n\t{\n\t\tS.clear();\n\t\tnxt = nxtIt(i);\n\t\tint totEdge = 0;\n\t\tfor(register int j = i;j <= nxt;j++)\n\t\t\tif(!ask(E[j].u, E[j].v))\n\t\t\t{\n\t\t\t\ttotEdge ++;\n\t\t\t\tint k1 = min(find(E[j].u), find(E[j].v));\n\t\t\t\tint k2 = max(find(E[j].u), find(E[j].v));\n\t\t\t\tS.insert(make_pair(k1, k2));\n\t\t\t}\n\t\tint totAdd = 0;\n\t\tfor(register int j = i;j <= nxt;j++)\n\t\t{\n\t\t\tif(!ask(E[j].u, E[j].v))\n\t\t\t{\n\t\t\t\tmarge(E[j].u, E[j].v);\n\t\t\t\ttotAdd ++;\n\t\t\t\tans1 = (ans1 + E[j].w) % MOD;\n\t\t\t}\n\t\t}\n\t\tif(totAdd == 1)\n\t\t\tans2 = ans2 * 1LL * totEdge % MOD;//分别是两条边权相同时的第一种情况    和    三条边权相同时的第三种情况。\n\t\tif(totAdd == 2 && totEdge == 3)\n\t\t{\n\t\t\tif(S.size() == 3) ans2 = ans2 * 3LL % MOD;//三条边权相同时的第一种情况\n\t\t\tif(S.size() == 2) ans2 = ans2 * 2LL % MOD; //三条边权相同时的第二种情况\n\t\t}\n\t\ti = nxt + 1;\n\t}\n\tprintf(\"%d %d\\n\", ans1 % MOD, ans2 % MOD);\n    return 0;\n}", "step": ["Initialize the set and read input", "Merged nodes that belong to the same set.", "Returns the weight of the minimum spanning tree in one line and then the number of different minimum spanning trees, modulo 1000000007, in the next in one line."], "nl_cn": "Farmer John has been taking an evening algorithms course at his local university, and he has just learned about minimum spanning trees.  However, Farmer John now realizes that the design of his farm is not as efficient as it could be, and he wants to simplify the layout of his farm.\n\nThe farm is currently arranged like a graph, with vertices representing fields and edges representing pathways between these fields, each having an associated length.  Farmer John notes that for each distinct length, at most three pathways on his farm share this length.  FJ would like to remove some of the pathways on his farm so that it becomes a tree -- that is, so that there is one unique route between any pair of fields.  Moreover, Farmer John would like this to be a minimum spanning tree -- a tree having the smallest possible sum of edge lengths.\n\nHelp Farmer John compute not only the sum of edge lengths in a minimum spanning tree derived from his farm graph, but also the number of different possible minimum spanning trees he can create.\n\n农夫约翰在一所夜校学习算法课程，他刚刚学会了最小生成树。现在约翰意识到他的农场设计得不够高效，他想简化农场的布局。\n\n\n约翰的农场可以看做一个图，农田代表图中顶点，田间小路代表图中的边，每条边有一定的长度。约翰注意到，农场中最多有三条小路有着相同的长度。约翰想删除一些小路使得农场成为一棵树，使得两块农田间只有一条路径。但是约翰想把农场设计成最小生成树，也就是农场道路的总长度最短。\n\n\n请帮助约翰找出最小生成树的总长度，同时请计算出总共有多少种最小生成树？\n", "test_cases": [{"input": "4 5 \n1 2 1 \n3 4 1 \n1 3 2 \n1 4 2 \n2 3 2 \n", "output": "4 3"}, {"input": "7 12 \n1 2 1 \n2 3 2 \n3 4 3 \n4 5 4 \n5 6 5 \n6 7 6 \n7 1 7 \n1 3 4 \n1 4 5 \n1 5 6 \n1 6 7 \n2 6 8 \n", "output": "21 1"}, {"input": "4 5\n1 2 1\n3 4 1\n1 3 2\n1 4 2\n2 3 2\n", "output": "4 3"}], "test": "#undef NDEBUG\n#include<assert.h>\nint main(){\n    assert(solution(\"4 5 \\n1 2 1 \\n3 4 1 \\n1 3 2 \\n1 4 2 \\n2 3 2 \\n\") == \"4 3\");\n    assert(solution(\"7 12 \\n1 2 1 \\n2 3 2 \\n3 4 3 \\n4 5 4 \\n5 6 5 \\n6 7 6 \\n7 1 7 \\n1 3 4 \\n1 4 5 \\n1 5 6 \\n1 6 7 \\n2 6 8 \\n\") == \"21 1\");\n    assert(solution(\"4 5\\n1 2 1\\n3 4 1\\n1 3 2\\n1 4 2\\n2 3 2\\n\") == \"4 3\");\n    return 0; \n}", "prompt": "/*Farmer John is taking an algorithms course at a local university and has just learned about minimum spanning trees. He realizes that the layout of his farm is not efficient and wants to simplify it. The farm can be represented as a graph with fields as vertices and pathways as edges with associated lengths. For each distinct length, at most three pathways share this length. Farmer John wants to remove some pathways to make it a tree and wants it to be a minimum spanning tree with the smallest sum of edge lengths. Help him compute the sum of edge lengths in a minimum spanning tree and the number of different possible minimum spanning trees he can create.\n\ninput_format:\n\\* Line 1: Two integers N and M (1 <= N <= 40,000; 1 <= M <= 100,000), representing the number of vertices and edges in the farm graph, respectively. Vertices are numbered as 1..N.\n\n\\* Lines 2..M+1: Three integers a\\_i, b\\_i and n\\_i (1 <= a\\_i, b\\_i <= N; 1 <= n\\_i <= 1,000,000) representing an edge from vertex a\\_i to b\\_i with length n\\_i. No edge length n\\_i will occur more than three times.\n\noutput_format:\n\\* Line 1: Two integers representing the length of the minimal spanning tree and the number of minimal spanning trees (mod\n\n1000000007).\n*/\n\n#include<sstream>\n#include<stdlib.h>\n#include<algorithm>\n#include<math.h>\n#include<stdio.h>\n#include<vector>\n#include<string>\n#include<climits>\n#include<cstring>\n#include<iostream>\nusing namespace std;\n\n             \nstring solution(string std_in){\n    istringstream iss(std_in);\n             ", "constraints": "Picking both edges with length 1 and any edge with length 2 yields a minimum spanning tree of length 4.\n\n", "samples": [["4 5 \n1 2 1 \n3 4 1 \n1 3 2 \n1 4 2 \n2 3 2 \n", "4 3 \n"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}}
{"task_id": "P5053", "title": "[COCI2017-2018#7] Clickbait", "difficulty": "challenge", "nl": "Slavko came across an advertisement while surfing the internet, which showed a system consisting of containers and pipelines (as shown below), with the caption: \"If container 1 is filled with water, please determine the order in which the containers are filled.\"\n\n\n\nThe system consists of K containers numbered from 1 to K. We can use a character matrix to describe the system, where the shape of the container is a **rectangle**, and the contour of the container and pipeline are represented by the following characters:\n\n- If it is the horizontal part of the contour, it is \"-\".\n- If it is the vertical part of the contour, it is \"|\".\n- If it is the position where the horizontal and vertical parts of the contour meet, it is \"+\".\nHowever, when the container and pipeline are connected, the contour of the container dominates (see the sample test).\n\nAt any position in the container, there is a string composed of numbers, which represents the label of the container. All other fields in the matrix are equal to \".\" (period).\n\nAll containers except the one labeled 1 have exactly one inlet pipe, which enters the container from the **top**. The container labeled 1 has no inlet pipe.\n\nContainers can have multiple (or no) outlet pipes, which are discharged from the **side** of the container. The position of the outlet pipe is in **different rows** in the matrix.\n\nThe pipeline directly connects two containers, which means that it is **impossible** to split the pipeline or connect multiple pipelines in the pipeline, and no two pipelines will intersect. On the route from the source container to the target container, the pipeline always goes down to the following row or stays on the same row. In other words, they never return to the previous row, so the water can flow freely from one container to another.\n\nWater enters a container until it is filled. If the water level reaches the height of the drainage pipe, the water will flow through the pipe until the container is filled.\n\nPlease help Slavko determine the order in which the containers are filled.\n\n**Note:**\n- In the test data, each character \"+\" is accurately surrounded by **one character \"-\"** on the left or right and **one character \"|\"** on the top or bottom, and all other adjacent characters around it are equal to \".\" (period).\n- In the matrix, the only place where a pipeline is adjacent to the container contour is where the pipeline enters and exits the container. In other words, the pipeline never runs closely against the container (except where it connects to the container). The entrance of the inlet pipe is marked with a character \"|\", while the outlet of the outlet pipe is marked with the character \"-\" on the side of the container.", "code": "#include <bits/stdc++.h>\nusing namespace std;\nint read(){\n\tint ret=0,f=1;char ch=getchar();\n\twhile (ch<'0'||ch>'9'){if (ch=='-') f=-f;ch=getchar();}\n\twhile (ch>='0'&&ch<='9') ret=(ret<<3)+(ret<<1)+ch-'0',ch=getchar();\n\treturn ret*f;\n}\nconst int maxn=1005,flg[4][2]={{-1,0},{0,1},{1,0},{0,-1}};\nint n,m;\nchar A[maxn][maxn];\nvoid DFS(int u,int x,int y){\n\tint L=0,H=0;\n\twhile (A[x][y]!='+') y--;\n\twhile (A[x+L+1][y]!='+') ++L;L+=2;\n\twhile (A[x][y+H+1]!='+') ++H;H+=2;//算箱子宽度和高度\n\tfor (int i=x;i<=x+L-1&&!u;i++)\n\tfor (int j=y;j<=y+H-1&&!u;j++)\n\tif (A[i][j]>='0'&&A[i][j]<='9'){//找编号\n\t\tchar ch=A[i][j];\n\t\twhile (ch>='0'&&ch<='9') u=(u<<3)+(u<<1)+ch-'0',ch=A[i][++j];//类似快读的操作\n\t\tbreak;\n\t}\n\tfor (int i=x+L-2;i>=x-1;i--)//枚举水位，并遍历\n\tif (A[i][y-1]=='-'||A[i][y+H]=='-'){\n\t\tint nx=i,ny,f;//f是方向，0，1，2，3具体代表什么方向看flg数组\n\t\tif (A[i][y-1]=='-') ny=y-1,f=3;\n\t\telse ny=y+H,f=1;\n\t\twhile (true){\n\t\t\tnx+=flg[f][0],ny+=flg[f][1];\n\t\t\tif (A[nx][ny]=='+'){\n\t\t\t\tif ((f==0||f==2)&&A[nx][ny-1]!='.') f=3;else\n\t\t\t\tif ((f==0||f==2)&&A[nx][ny+1]!='.') f=1;else\n\t\t\t\tif ((f==1||f==3)&&A[nx+1][ny]!='.') f=2;//判断管子是否换方向\n\t\t\t}else\n\t\t\tif (A[nx-flg[f][0]][ny-flg[f][1]]=='|'&&A[nx][ny]=='-') break;//判断是否走到水箱上了\n\t\t}\n\t\tDFS(0,nx,ny);//继续走\n\t}\n\tprintf(\"%d\\n\",u);\n}\nint main(){\n\tn=read(),m=read();\n\tfor (int i=1;i<=n;i++) scanf(\"%s\",A[i]+1);\n\tfor (int i=1;i<=n;i++)\n\tfor (int j=1;j<=m;j++)\n\tif (A[i][j]=='+'){DFS(1,i,j);return 0;}//第一个箱子肯定在最上面，因为'+'上不能插管子\n\treturn 0;\n}", "step": ["Define DFS function for traversing the grid.", "Find the starting cell (+ symbol) and call DFS function on it.", "Inside DFS function, find a cell with a number and extract it.", "Traverse the grid in all four directions from the cell until it reaches an end of the symbol (+,- or |) while storing the correct direction.", "Recursively call DFS function on the end cell in the stored direction of the previous step.", "Print the extracted number outside the DFS function."], "nl_cn": "While surfing online, Slavko came across an ad displaying a system of containers and pipes\n(an example of such system is illustrated in the image below) with the message: “If container\n**1** starts filling up with water, determine the order in which the containers get filled up.”\n\n\n\nThe system consists of K containers denoted with numbers from 1 to K, and we can describe\nit using a matrix of characters with N rows and M columns. The containers are **in the shape of a rectangle**​, and the outlines of the containers and pipes are shown with the following\ncharacters:\n\n-  ‘-’ if it’s a horizontal part of the outline,\n-  ‘|’ if it’s a vertical part of the outline, and\n-  ‘+’ if it’s a spot where the horizontal and vertical parts of the outline connect. An exception is where the containers and pipes connect. In that case, the container outline dominates (see sample tests).\n\nIn an arbitrary place within each container, there is a string of digits that represent the label\nof the container, and all the other fields in the matrix are equal to ‘.’ (dot).\n\nAll containers except the one labeled with 1 have **exactly one** supply pipe that enters the\ncontainer in its **upper side**​. The container labeled with 1 does not have a supply pipe.\n\nThe containers can have multiple (also possible, zero) discharge pipes that leave the\ncontainer out of its **lateral side**​. The places where discharge pipes leave a container will be\nin mutually **distinct rows** in the matrix.\n\nThe pipes directly connect two containers, which means that **it is not possible** to split the\npipes or connect multiple pipes into one, and no two pipes will intersect. On their way,\nlooking from the source to the destination container, the pipes always descend to the\nfollowing row or stay in the same row. In other words, they never go back to the previous\nrow, so the water can flow freely from one container to another.\n\nThe water enters a container until it is full. If the water level reaches the level of the\ndischarge pipe, the water will flow through that pipe until the container the pipe leads into is\nfilled up.\n\nHelp Slavko and determine the order in which the containers will fill up.\n\n**Please note:**\n- The test data is such that each character ‘+’ is surrounded with **exactly one character** ‘-’ to the left or the right side and **exactly one** character ‘|’ to the upper or lower side, and **all other** adjacent characters in directions up, down, left and right will be equal to ‘.’ (dot).\n- The only places where the pipe in the matrix is in a field adjacent to the container outline are the places where the pipe enters or exits the container. In other words, a pipe will never run right next to a container (except where it connects with the\ncontainer). The entry for the supply pipe is labeled with the character ‘|’ above a container, whereas the exit of the discharge pipe is labeled with the character ‘-’ on the lateral side of a container.", "test_cases": [{"input": "12 13\n..+--+.......\n+-|..|.......\n|.|.1|--+....\n|.+--+..|....\n|......+----+\n+---+..|..2.|\n....|..+----+\n.+--+........\n.|...........\n+---+........\n|.3.|........\n+---+........", "output": "2\n3\n1"}, {"input": "8 10\n..........\n.......+-+\n...+---|1|\n...|...+-+\n...|......\n..+-+.....\n..|2|.....\n..+-+.....\n", "output": "2\n1"}, {"input": "4 8\n........\n..+---+.\n..|.1.|\n..+-+.-\n", "output": "1"}], "test": "#undef NDEBUG\n#include<assert.h>\nint main(){\n    assert(solution(\"12 13\\n..+--+.......\\n+-|..|.......\\n|.|.1|--+....\\n|.+--+..|....\\n|......+----+\\n+---+..|..2.|\\n....|..+----+\\n.+--+........\\n.|...........\\n+---+........\\n|.3.|........\\n+---+........\") == \"2\\n3\\n1\");\n    assert(solution(\"8 10\\n..........\\n.......+-+\\n...+---|1|\\n...|...+-+\\n...|......\\n..+-+.....\\n..|2|.....\\n..+-+.....\\n\") == \"2\\n1\");\n    assert(solution(\"4 8\\n........\\n..+---+.\\n..|.1.|\\n..+-+.-\\n\") == \"1\");\n    return 0; \n}", "prompt": "/*Slavko came across an advertisement while surfing the internet, which showed a system consisting of containers and pipelines (as shown below), with the caption: \"If container 1 is filled with water, please determine the order in which the containers are filled.\"\n\n\n\nThe system consists of K containers numbered from 1 to K. We can use a character matrix to describe the system, where the shape of the container is a **rectangle**, and the contour of the container and pipeline are represented by the following characters:\n\n- If it is the horizontal part of the contour, it is \"-\".\n- If it is the vertical part of the contour, it is \"|\".\n- If it is the position where the horizontal and vertical parts of the contour meet, it is \"+\".\nHowever, when the container and pipeline are connected, the contour of the container dominates (see the sample test).\n\nAt any position in the container, there is a string composed of numbers, which represents the label of the container. All other fields in the matrix are equal to \".\" (period).\n\nAll containers except the one labeled 1 have exactly one inlet pipe, which enters the container from the **top**. The container labeled 1 has no inlet pipe.\n\nContainers can have multiple (or no) outlet pipes, which are discharged from the **side** of the container. The position of the outlet pipe is in **different rows** in the matrix.\n\nThe pipeline directly connects two containers, which means that it is **impossible** to split the pipeline or connect multiple pipelines in the pipeline, and no two pipelines will intersect. On the route from the source container to the target container, the pipeline always goes down to the following row or stays on the same row. In other words, they never return to the previous row, so the water can flow freely from one container to another.\n\nWater enters a container until it is filled. If the water level reaches the height of the drainage pipe, the water will flow through the pipe until the container is filled.\n\nPlease help Slavko determine the order in which the containers are filled.\n\n**Note:**\n- In the test data, each character \"+\" is accurately surrounded by **one character \"-\"** on the left or right and **one character \"|\"** on the top or bottom, and all other adjacent characters around it are equal to \".\" (period).\n- In the matrix, the only place where a pipeline is adjacent to the container contour is where the pipeline enters and exits the container. In other words, the pipeline never runs closely against the container (except where it connects to the container). The entrance of the inlet pipe is marked with a character \"|\", while the outlet of the outlet pipe is marked with the character \"-\" on the side of the container.\n\ninput_format:\nThe first line contains two integers N and M (1 ≤ N, M ≤ 1000), matrix dimensions.\n\nThe following N lines contain M characters describing the container system.\n\noutput_format:\nYou must output K lines. The $i^{th}$\nline contains the label of the container that fills up $i^{th}$\n. A\nsolution will always exist and will be unique.\n*/\n\n#include<sstream>\n#include<stdlib.h>\n#include<algorithm>\n#include<math.h>\n#include<stdio.h>\n#include<vector>\n#include<string>\n#include<climits>\n#include<cstring>\n#include<iostream>\nusing namespace std;\n\n             \nstring solution(string std_in){\n    istringstream iss(std_in);\n             ", "constraints": "In test cases worth 70% of total points, it will hold N, M ≤ 100.\n\n**Clarification of the first test case:**\n\nContainer 1 starts filling up with water.\n\nThe water level in container 1 grows, and in one moment reaches the level of the discharge pipe leading to container 2. The water flows through the pipe until container 2 fills up.\n\nAfter that, the water level in container 1 keeps growing until it reaches the level of the discharge pipe leading to container 3, which fills up next.\n\nFinally, the water level in container 1 keeps growing and the container fills up.", "samples": [["12 13\n..+--+.......\n+-|..|.......\n|.|.1|--+....\n|.+--+..|....\n|......+----+\n+---+..|..2.|\n....|..+----+\n.+--+........\n.|...........\n+---+........\n|.3.|........\n+---+........", "2\n3\n1"], ["8 10\n..........\n.......+-+\n...+---|1|\n...|...+-+\n...|......\n..+-+.....\n..|2|.....\n..+-+.....\n", "2\n1"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}}
{"task_id": "P2873", "title": "[USACO07DEC]Mud Puddles S", "difficulty": "challenge", "nl": "Farmer John must travel the shortest distance to reach Bessie's barn without stepping in any of the N puddles of mud located on the muddy field. His starting point is at (0, 0) and Bessie's location is at (X, Y) (-500 ≤ X ≤ 500; -500 ≤ Y ≤ 500). Each puddle occupies only the point it is on, and Farmer John can only travel parallel to the axes and turn at points with integer coordinates. There will always be a path without mud that Farmer John can take to reach Bessie.", "code": "#include<bits/stdc++.h>\nusing namespace std;\n\nint X,Y,n,dir[4][2]={{1,0},{0,1},{-1,0},{0,-1}};//dir数组存储四个方向\nbool mmap[1005][1005];//存储地图（注意这里不是500而是1000）\nstruct node{\n    int x,y,sum;\n};//定义结构体，x表示横坐标，y表示纵坐标，sum表示到这个点所需步数\nqueue <node> qwq;//当然要符合我们小猪佩奇的可爱气质啦\n\nint bfs ()//宽搜\n{\n    while (!qwq.empty())//队列非空\n    {\n        int xx,yy,s;\n        xx=qwq.front().x;\n        yy=qwq.front().y;\n        s=qwq.front().sum;//取队首元素进行扩展\n        for (int i=0;i<4;i++)//4个方向\n        {\n            int nx=xx+dir[i][0],\n                ny=yy+dir[i][1];//扩展\n            if (nx==X && ny==Y)//如果到达目的地\n            {\n                while (!qwq.empty())\n                  qwq.pop();//清空队列\n                return s+1;//返回值\n            }\n            else//没有到达目的地\n            {\n                if (!mmap[nx][ny])//可以走（即这里不是泥坑）\n                {\n                    mmap[nx][ny]=true;//把这里标记成走过的\n                    //其实可以再开一个vis数组，但对于这题完全没必要\n                    qwq.push({nx,ny,s+1});//入队\n                }\n            }\n        }\n        qwq.pop();//出队\n    }\n}\n\nint main()\n{\n    scanf (\"%d%d%d\",&X,&Y,&n);//输入\n    memset (mmap,false,sizeof (mmap));//初始化\n    X+=500;  Y+=500;//重要！！！一定要加500！！！\n    qwq.push({500,500,0});//初始情况入队\n    for (int i=1;i<=n;i++)\n    {\n        int a,b;\n        scanf (\"%d%d\",&a,&b);\n        a+=500; b+=500;//坐标加500\n        mmap[a][b]=true;//标记泥坑\n    }\n    printf (\"%d\\n\",bfs ());//输出\n    return 0;//完结撒花\n}", "step": ["Initialize input values and set X and Y coordinates to account for negative values.", "Set all cells to false except for the blocked ones.", "Add the starting cell to the queue and begin the BFS algorithm.", "For each cell in the queue, check its neighbors and add them to the queue if they are not blocked.", "If the target cell is found, empty the queue and return the sum of steps taken.", "If the queue is empty and the target cell has not been found, return -1."], "nl_cn": "Farmer John is leaving his house promptly at 6 AM for his daily milking of Bessie. However, the previous evening saw a heavy rain, and the fields are quite muddy. FJ starts at the point (0, 0) in the coordinate plane and heads toward Bessie who is located at (X, Y) (-500 ≤ X ≤ 500; -500 ≤ Y ≤ 500). He can see all N (1 ≤ N ≤ 10,000) puddles of mud, located at points (Ai, Bi) (-500 ≤ Ai ≤ 500; -500 ≤ Bi ≤ 500) on the field. Each puddle occupies only the point it is on.\n\nHaving just bought new boots, Farmer John absolutely does not want to dirty them by stepping in a puddle, but he also wants to get to Bessie as quickly as possible. He's already late because he had to count all the puddles. If Farmer John can only travel parallel to the axes and turn at points with integer coordinates, what is the shortest distance he must travel to reach Bessie and keep his boots clean? There will always be a path without mud that Farmer John can take to reach Bessie.\n\n清早6：00，Farmer John就离开了他的屋子，开始了他的例行工作：为贝茜挤奶。前一天晚上，整个农场刚经受过一场瓢泼大雨的洗礼，于是不难想见，FJ 现在面对的是一大片泥泞的土地。FJ的屋子在平面坐标(0, 0)的位置，贝茜所在的牛棚则位于坐标(X,Y) (-500 <= X <= 500; -500 <= Y <= 500)处。当然咯， FJ也看到了地上的所有N(1 <= N <= 10,000)个泥塘，第i个泥塘的坐标为 (A\\_i, B\\_i) (-500 <= A\\_i <= 500；-500 <= B\\_i <= 500)。每个泥塘都只占据了它所在的那个格子。 Farmer John自然不愿意弄脏他新买的靴子，但他同时想尽快到达贝茜所在的位置。为了数那些讨厌的泥塘，他已经耽搁了一些时间了。如果Farmer John 只能平行于坐标轴移动，并且只在x、y均为整数的坐标处转弯，那么他从屋子门口出发，最少要走多少路才能到贝茜所在的牛棚呢？你可以认为从FJ的屋子到牛棚总是存在至少一条不经过任何泥塘的路径。\n", "test_cases": [{"input": "1 2 7\n0 2\n-1 3\n3 1\n1 1\n4 2\n-1 1\n2 2", "output": "11"}, {"input": "0 0 2\n-1 0\n1 0\n", "output": "2"}, {"input": "0 0 2\n0 1\n0 -1\n", "output": "2"}, {"input": "0 0 2\n0 0\n0 1\n", "output": "2"}, {"input": "0 0 3\n0 0\n0 1\n0 -1\n", "output": "2"}, {"input": "1 1 0\n", "output": "2"}, {"input": "1 1 1\n1 1\n", "output": "2"}, {"input": "1 1 2\n1 1\n0 1\n", "output": "2"}, {"input": "1 1 3\n1 1\n0 1\n0 0\n", "output": "2"}, {"input": "-1 -1 0\n", "output": "2"}, {"input": "-1 -1 1\n-1 -1\n", "output": "2"}, {"input": "-1 -1 2\n-1 -1\n0 -1\n", "output": "2"}, {"input": "-1 -1 3\n-1 -1\n0 -1\n0 0\n", "output": "2"}, {"input": "5 5 0\n", "output": "10"}, {"input": "0 0 2\n0 1\n1 0\n", "output": "2"}, {"input": "3 4 0\n", "output": "7"}, {"input": "1 1 1\n0 0\n", "output": "2"}, {"input": "-1 -1 1\n0 0\n", "output": "2"}, {"input": "1 1 2\n0 0\n1 1\n", "output": "2"}, {"input": "-1 -1 2\n0 0\n-1 -1\n", "output": "2"}, {"input": "1 1 2\n1 1\n-1 -1\n", "output": "2"}, {"input": "-5 -4 1\n-4 -1\n", "output": "9"}], "test": "#undef NDEBUG\n#include<assert.h>\nint main(){\n    assert(solution(\"1 2 7\\n0 2\\n-1 3\\n3 1\\n1 1\\n4 2\\n-1 1\\n2 2\") == \"11\");\n    assert(solution(\"0 0 2\\n-1 0\\n1 0\\n\") == \"2\");\n    assert(solution(\"0 0 2\\n0 1\\n0 -1\\n\") == \"2\");\n    assert(solution(\"0 0 2\\n0 0\\n0 1\\n\") == \"2\");\n    assert(solution(\"0 0 3\\n0 0\\n0 1\\n0 -1\\n\") == \"2\");\n    assert(solution(\"1 1 0\\n\") == \"2\");\n    assert(solution(\"1 1 1\\n1 1\\n\") == \"2\");\n    assert(solution(\"1 1 2\\n1 1\\n0 1\\n\") == \"2\");\n    assert(solution(\"1 1 3\\n1 1\\n0 1\\n0 0\\n\") == \"2\");\n    assert(solution(\"-1 -1 0\\n\") == \"2\");\n    assert(solution(\"-1 -1 1\\n-1 -1\\n\") == \"2\");\n    assert(solution(\"-1 -1 2\\n-1 -1\\n0 -1\\n\") == \"2\");\n    assert(solution(\"-1 -1 3\\n-1 -1\\n0 -1\\n0 0\\n\") == \"2\");\n    assert(solution(\"5 5 0\\n\") == \"10\");\n    assert(solution(\"0 0 2\\n0 1\\n1 0\\n\") == \"2\");\n    assert(solution(\"3 4 0\\n\") == \"7\");\n    assert(solution(\"1 1 1\\n0 0\\n\") == \"2\");\n    assert(solution(\"-1 -1 1\\n0 0\\n\") == \"2\");\n    assert(solution(\"1 1 2\\n0 0\\n1 1\\n\") == \"2\");\n    assert(solution(\"-1 -1 2\\n0 0\\n-1 -1\\n\") == \"2\");\n    assert(solution(\"1 1 2\\n1 1\\n-1 -1\\n\") == \"2\");\n    assert(solution(\"-5 -4 1\\n-4 -1\\n\") == \"9\");\n    return 0; \n}", "prompt": "/*Farmer John must travel the shortest distance to reach Bessie's barn without stepping in any of the N puddles of mud located on the muddy field. His starting point is at (0, 0) and Bessie's location is at (X, Y) (-500 ≤ X ≤ 500; -500 ≤ Y ≤ 500). Each puddle occupies only the point it is on, and Farmer John can only travel parallel to the axes and turn at points with integer coordinates. There will always be a path without mud that Farmer John can take to reach Bessie.\n\ninput_format:\n\\* Line 1: Three space-separated integers: X, Y, and N.\n\n\\* Lines 2..N+1: Line i+1 contains two space-separated integers: Ai and Bi\n\n`````\n\n\\* Line 1: Three integers separated by a space: X, Y, and N.\n\n\\* Lines 2..N+1: Each line contains two integers separated by a space: Ai and Bi.\n\noutput_format:\n\\* Line 1: The minimum distance that Farmer John has to travel to reach Bessie without stepping in mud.\n*/\n\n#include<sstream>\n#include<stdlib.h>\n#include<algorithm>\n#include<math.h>\n#include<stdio.h>\n#include<vector>\n#include<string>\n#include<climits>\n#include<cstring>\n#include<iostream>\nusing namespace std;\n\n             \nstring solution(string std_in){\n    istringstream iss(std_in);\n             ", "constraints": "", "samples": [["1 2 7\n0 2\n-1 3\n3 1\n1 1\n4 2\n-1 1\n2 2", "11"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}}
{"task_id": "P2799", "title": "国王的魔镜", "difficulty": "challenge", "nl": "The king has a magic mirror that can double anything that touches its surface, but the added portion is reversed due to the reflection. For example, a necklace represented by AB where different letters represent different colored pearls. If the B end is touched to the mirror, the mirror will transform the necklace into ABBA. If the other end is also touched, it becomes ABBAABBA (assuming the king only uses one end of the necklace to touch the mirror). Given the final necklace, write a program to output the minimum possible length of the initial necklace before the king used the mirror.", "code": "#include <bits/stdc++.h>\nusing namespace std;\nstring s;\nint jc(int n){\n\tif((n+1)%2)return n+1;\n\tif(n==0)return 1;\n\tint l=0,r=n;\n\twhile(l<r){\n\t\tif(s[l]!=s[r])\n\t\t\treturn n+1;\n\t\t++l; --r;\n\t}\n\treturn jc(r);\n}\nint main(){\n\tcin>>s;\n\tprintf(\"%d\",jc(s.size()-1));\n\treturn 0;\n}", "step": ["Take user input for a string s.", "Define a jc function to calculate a unique number for the input.", "If input length is even, check symmetry from left and right until an asymmetry is found.", "If input length is odd, start symmetry checking from center outward.", "Return the position of the last symmetrical character if the string is symmetrical.", "If not, return the input length + 1."], "nl_cn": "国王有一个魔镜，可以把任何接触镜面的东西变成原来的两倍——只是，因为是镜子嘛，增加的那部分是反的。比如一条项链，我们用AB来表示，不同的字母表示不同颜色的珍珠。如果把B端接触镜面的话，魔镜会把这条项链变为ABBA。如果再用一端接触的话，则会变成ABBAABBA（假定国王只用项链的某一端接触魔镜）。给定最终的项链，请编写程序输出国王没使用魔镜之前，最初的项链可能的最小长度。\n", "test_cases": [{"input": "ABBAABBA", "output": "2"}, {"input": "A", "output": "1"}, {"input": "FFFF", "output": "1"}, {"input": "ABACADA", "output": "7"}, {"input": "CCCCC", "output": "5"}, {"input": "ABCDEDCBA", "output": "9"}, {"input": "BBB", "output": "3"}, {"input": "ABCDDEDCBA", "output": "10"}, {"input": "GGG", "output": "3"}, {"input": "ABCBA", "output": "5"}, {"input": "HHH", "output": "3"}, {"input": "PQRQP", "output": "5"}, {"input": "IIIII", "output": "5"}, {"input": "KLMNOP", "output": "6"}, {"input": "AABBCCDD", "output": "8"}, {"input": "AB", "output": "2"}, {"input": "ABAABA", "output": "3"}, {"input": "AABBAA", "output": "3"}, {"input": "ABABBABA", "output": "4"}, {"input": "AAAA", "output": "1"}, {"input": "ABCD", "output": "4"}, {"input": "ABA\n", "output": "3"}, {"input": "B\n", "output": "1"}, {"input": "ABACABA\n", "output": "7"}, {"input": "ABCDA\n", "output": "5"}], "test": "#undef NDEBUG\n#include<assert.h>\nint main(){\n    assert(solution(\"ABBAABBA\") == \"2\");\n    assert(solution(\"A\") == \"1\");\n    assert(solution(\"FFFF\") == \"1\");\n    assert(solution(\"ABACADA\") == \"7\");\n    assert(solution(\"CCCCC\") == \"5\");\n    assert(solution(\"ABCDEDCBA\") == \"9\");\n    assert(solution(\"BBB\") == \"3\");\n    assert(solution(\"ABCDDEDCBA\") == \"10\");\n    assert(solution(\"GGG\") == \"3\");\n    assert(solution(\"ABCBA\") == \"5\");\n    assert(solution(\"HHH\") == \"3\");\n    assert(solution(\"PQRQP\") == \"5\");\n    assert(solution(\"IIIII\") == \"5\");\n    assert(solution(\"KLMNOP\") == \"6\");\n    assert(solution(\"AABBCCDD\") == \"8\");\n    assert(solution(\"AB\") == \"2\");\n    assert(solution(\"ABAABA\") == \"3\");\n    assert(solution(\"AABBAA\") == \"3\");\n    assert(solution(\"ABABBABA\") == \"4\");\n    assert(solution(\"AAAA\") == \"1\");\n    assert(solution(\"ABCD\") == \"4\");\n    assert(solution(\"ABA\\n\") == \"3\");\n    assert(solution(\"B\\n\") == \"1\");\n    assert(solution(\"ABACABA\\n\") == \"7\");\n    assert(solution(\"ABCDA\\n\") == \"5\");\n    return 0; \n}", "prompt": "/*The king has a magic mirror that can double anything that touches its surface, but the added portion is reversed due to the reflection. For example, a necklace represented by AB where different letters represent different colored pearls. If the B end is touched to the mirror, the mirror will transform the necklace into ABBA. If the other end is also touched, it becomes ABBAABBA (assuming the king only uses one end of the necklace to touch the mirror). Given the final necklace, write a program to output the minimum possible length of the initial necklace before the king used the mirror.\n\ninput_format:\nOnly one string, composed of uppercase English letters (number of letters <= 100000), representing the final necklace.\n\noutput_format:\nThere is only one integer indicating the minimum possible length of the original necklace before the king did not use the magic mirror.\n*/\n\n#include<sstream>\n#include<stdlib.h>\n#include<algorithm>\n#include<math.h>\n#include<stdio.h>\n#include<vector>\n#include<string>\n#include<climits>\n#include<cstring>\n#include<iostream>\nusing namespace std;\n\n             \nstring solution(string std_in){\n    istringstream iss(std_in);\n             ", "constraints": "", "samples": [["ABBAABBA", "2"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}}
{"task_id": "P4461", "title": "[CQOI2018]九连环", "difficulty": "advanced", "nl": "The loading and unloading of annulus need to follow two rules:\n\n1. The first (rightmost) annulus can be loaded or unloaded at any time.\n\n2. If the k-th annulus has not been unloaded, and all the annuli to the right of the k-th annulus have been unloaded, then the k+1 th annulus (adjacent annulus to the left of the k-th annulus) can be loaded or unloaded at will.\n\nUnlike the ever-changing Rubik's Cube, there is only one optimal strategy for solving the Nine-Linked Rings. For simplicity, we take the \"Four-Linked Rings\" as an example to demonstrate this process. Here 1 represents the annulus on the \"sword\", and 0 represents the unloaded annulus.\n\nThe initial state is 1111, and each step of the operation is as follows:\n\n1. 1101 (Unloading the second annulus according to rule 2)\n\n2. 1100 (Unloading the first annulus according to rule 1)\n\n3. 0100 (Unloading the fourth annulus according to rule 2)\n\n4. 0101 (Loading the first annulus according to rule 1)\n\n5. 0111 (Loading the second annulus according to rule 2)\n\n6. 0110 (Unloading the first annulus according to rule 1)\n\n7. 0010 (Unloading the third annulus according to rule 2)\n\n8. 0011 (Loading the first annulus according to rule 1)\n\n9. 0001 (Unloading the second annulus according to rule 2)\n\n10. 0000 (Unloading the first annulus according to rule 1)\n\nThus, it can be seen that it takes at least 10 steps to unload the \"Four-Linked Rings\". As the number of annuli increases, the required number of steps will also increase. For example, unloading the Nine-Linked Rings requires at least 341 steps.\n\nPlease calculate the minimum number of steps required to unload all annuli according to the rules when there are n annuli.", "code": "#include<bits/stdc++.h>\n#define reg register\ntypedef long long ll;\nusing namespace std;\nconst int MN=10005;\nint n;\nstruct BigInt{\n    static const int BASE=10000;\n    int d[MN],len;\n    inline void clear(int x=0){\n        memset(d,len=0,sizeof(d));if(!x)len=1;while(x)d[len++]=x%BASE,x/=BASE;len--;\n    }\n    inline BigInt operator*(BigInt x){\n        reg BigInt res;res.clear();\n        for(reg int i=0;i<=len;i++)\n            for(reg int j=0;j<=x.len;j++){\n                res.d[i+j]+=d[i]*x.d[j];\n                res.d[i+j+1]+=res.d[i+j]/BASE,res.d[i+j]%=BASE;\n            }\n        res.len=len+x.len+1;\n        while(~res.len&&!res.d[res.len])res.len--;\n        return res;\n    }\n}Ans,A;\nnamespace Out{\n    const int _outlim=1<<20;\n    char outbuf[_outlim+5];\n    int cnt;\n    inline void pc(char ch){\n        outbuf[cnt++]=ch;\n        if(cnt==_outlim)fwrite(outbuf,1,cnt,stdout),cnt=0;\n    }\n    inline void write(BigInt x){\n    \treg bool f=0;\n        if(x.d[x.len]>999)pc(x.d[x.len]/1000+'0'),f=1;x.d[x.len]%=1000;\n        if(x.d[x.len]>99||f)pc(x.d[x.len]/100+'0'),f=1;x.d[x.len]%=100;\n        if(x.d[x.len]>9||f)pc(x.d[x.len]/10+'0'),f=1;x.d[x.len]%=10;\n        pc(x.d[x.len]+'0');\n        for(reg int i=x.len-1;~i;i--){\n            pc(x.d[i]/1000+'0');x.d[i]%=1000;\n            pc(x.d[i]/100+'0');x.d[i]%=100;\n            pc(x.d[i]/10+'0');x.d[i]%=10;\n            pc(x.d[i]+'0');\n        }\n        pc('\\n');\n    }\n    inline void end(){\n        if(cnt)fwrite(outbuf,1,cnt,stdout),cnt=0;fclose(stdin);fclose(stdout);\n    }\n}\nint main(){\n    reg int T;scanf(\"%d\",&T);\n    while(T--){\n        scanf(\"%d\",&n);Ans.clear(1);A.clear(2);reg int b=n+1;\n        while(b){if(b&1)Ans=Ans*A;A=A*A;b>>=1;}Ans.d[0]+=(n&1)-2;reg int q=0;\n        for(reg int i=Ans.len;~i;i--)q=q*Ans.BASE+Ans.d[i],Ans.d[i]=q/3,q%=3;\n        while(~Ans.len&&!Ans.d[Ans.len])Ans.len--;\n        Out::write(Ans);\n    }\n    Out::end();\n    return 0;\n}", "step": ["Create a structure for BigInt with some defined operations", "Define a Out structure for writing the output", "Declare a variable T and read the value of T", "A while loop that runs n times where n is the input", "Inside the while loop calculate the Ans and A variables", "Calculate the result and print it using Out::write"], "nl_cn": "圆环的装卸需要遵守两个规则:\n\n1. 第一个(最右边) 环任何时候都可以任意装上或卸下\n\n2. 如果第k 个环没有被卸下，且第k 个环右边的所有环都被卸下，则第k+1个环(第k 个环左边相邻的环) 可以任意装上或卸下\n\n与魔方的千变万化不同，解九连环的最优策略是唯一的。为简单起见，我们以“四连环”为例，演示这一过程。这里用1表示环在“剑”上，0 表示环已经卸下。\n\n初始状态为1111,每步的操作如下:\n\n1. 1101 (根据规则2,卸下第2 个环)\n\n2. 1100 (根据规则1,卸下第1 个环)\n\n3. 0100 (根据规则2,卸下第4 个环)\n\n4. 0101 (根据规则1,装上第1 个环)\n\n5. 0111 (根据规则2,装上第2 个环)\n\n6. 0110 (根据规则1,卸下第1 个环)\n\n7. 0010 (根据规则2,卸下第3 个环)\n\n8. 0011 (根据规则1,装上第1 个环)\n\n9. 0001 (根据规则2,卸下第2 个环)\n\n10. 0000 (根据规则1,卸下第1 个环)\n\n由此可见，卸下“四连环”至少需要10 步。随着环数增加，需要的步数也会随之增多。例如卸下九连环，就至少需要341步。\n\n请你计算，有n 个环的情况下，按照规则，  全部卸下至少需要多少步。", "test_cases": [{"input": "3\n3\n5\n9", "output": "5\n21\n341"}, {"input": "1\n1\n", "output": "1"}], "test": "#undef NDEBUG\n#include<assert.h>\nint main(){\n    assert(solution(\"3\\n3\\n5\\n9\") == \"5\\n21\\n341\");\n    assert(solution(\"1\\n1\\n\") == \"1\");\n    return 0; \n}", "prompt": "/*The loading and unloading of annulus need to follow two rules:\n\n1. The first (rightmost) annulus can be loaded or unloaded at any time.\n\n2. If the k-th annulus has not been unloaded, and all the annuli to the right of the k-th annulus have been unloaded, then the k+1 th annulus (adjacent annulus to the left of the k-th annulus) can be loaded or unloaded at will.\n\nUnlike the ever-changing Rubik's Cube, there is only one optimal strategy for solving the Nine-Linked Rings. For simplicity, we take the \"Four-Linked Rings\" as an example to demonstrate this process. Here 1 represents the annulus on the \"sword\", and 0 represents the unloaded annulus.\n\nThe initial state is 1111, and each step of the operation is as follows:\n\n1. 1101 (Unloading the second annulus according to rule 2)\n\n2. 1100 (Unloading the first annulus according to rule 1)\n\n3. 0100 (Unloading the fourth annulus according to rule 2)\n\n4. 0101 (Loading the first annulus according to rule 1)\n\n5. 0111 (Loading the second annulus according to rule 2)\n\n6. 0110 (Unloading the first annulus according to rule 1)\n\n7. 0010 (Unloading the third annulus according to rule 2)\n\n8. 0011 (Loading the first annulus according to rule 1)\n\n9. 0001 (Unloading the second annulus according to rule 2)\n\n10. 0000 (Unloading the first annulus according to rule 1)\n\nThus, it can be seen that it takes at least 10 steps to unload the \"Four-Linked Rings\". As the number of annuli increases, the required number of steps will also increase. For example, unloading the Nine-Linked Rings requires at least 341 steps.\n\nPlease calculate the minimum number of steps required to unload all annuli according to the rules when there are n annuli.\n\ninput_format:\nThe first line of the input file is an integer m, indicating the number of test points.\n\nNext m lines, each with an integer n.\n\noutput_format:\nThe output file contains m lines, corresponding to the calculation results of each test point.\n*/\n\n#include<sstream>\n#include<stdlib.h>\n#include<algorithm>\n#include<math.h>\n#include<stdio.h>\n#include<vector>\n#include<string>\n#include<climits>\n#include<cstring>\n#include<iostream>\nusing namespace std;\n\n             \nstring solution(string std_in){\n    istringstream iss(std_in);\n             ", "constraints": "对于10%的数据，$1≤n≤10$\n\n对于30%的数据，$1≤n≤30$\n\n对于100%的数据，$1≤n≤10^5,1≤m≤10$", "samples": [["3\n3\n5\n9", "5\n21\n341"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000]}}
{"task_id": "P2914", "title": "[USACO08OCT]Power Failure G", "difficulty": "advanced", "nl": "A severe thunderstorm has damaged some of the power lines on Farmer John's farm! He has a map of all N (2≤N≤1000) power poles, conveniently numbered 1≤Wi≤N and located at integer coordinates (xi,yi) (−100000≤xi≤100000,−100000≤yi≤100000).\n\nW (1≤W≤10000) wires connect power poles Pi and Pj (1≤Pi≤N,1≤Pj≤N).\n\nHe needs to get power from point 1 to point n (which means a series of wires can run through intermediate poles from point 1 to point n).\n\nGiven the position of the N poles and the list of remaining wires, determine the minimum wire length needed to restore electrical connectivity so that current can flow from point 1 to point n. No wire can exceed a certain real number M (0.0<M≤200000.0).\n\nFor example, on the left below is a map of 9 poles and 3 wires after the storm. For this task, M=2.0. The optimal set of wires will connect pole 4 to 6 and pole 6 to 9.\n\nThe total length will be 1.414213562+1.414213562=2.828427124.\n\nNumber of points: 350.", "code": "#include <bits/stdc++.h>\nusing namespace std;\nint n, w;\ndouble m, d[1001];\nbool v[1001];\ndouble a[1001][1001];\nstruct rec {\n\tdouble x, y;\n} p[1001];\nint main() {\n//\tfreopen(\"data.in\", \"r\", stdin);\n//\tfreopen(\"data.out\", \"w\", stdout);\n\tcin >> n >> w >> m;\n//\tfor (register int i = 1; i <= n; ++i)\n//\t\tfor (register int j = 1; j <= n; ++j)\n//\t\t\ta[i][j] = 1e18;\n\tfor (register int i = 1; i <= n; ++i) scanf(\"%lf%lf\", &p[i].x, &p[i].y);\n\tfor (register int i = 1; i <= n; ++i) \n\t\tfor (register int j = 1; j <= n; ++j) {\n\t\t\ta[i][j] = sqrt(pow(p[i].x - p[j].x, 2) + pow(p[i].y - p[j].y, 2));\n\t\t\tif (a[i][j] > m) a[i][j] = 1e18;\n\t\t}\n\tfor (register int i = 1; i <= w; ++i) {\n\t\tint x, y;\n\t\tscanf(\"%d%d\", &x, &y);\n\t\ta[y][x] = a[x][y] = 0;\n\t}\n\tpriority_queue<pair<double, int> > q;\n\tfor (register int i = 1; i <= n; ++i) d[i] = 1e18;\n\tq.push(make_pair(0.0, 1));\n\tmemset(v, 0, sizeof v);\n\td[1] = 0;\n\twhile (q.size()) {\n\t\tint x = q.top().second;\n\t\tq.pop();\n\t\tif (v[x]) continue;\n\t\tv[x] = 1;\n\t\tfor (register int i = 1; i <= n; ++i) {\n\t\t\tdouble z = a[x][i];\n\t\t\tif (z == 1e18) continue;\n\t\t\tif (d[i] > d[x] + z) {\n\t\t\t\td[i] = d[x] + z;\n\t\t\t\tq.push(make_pair(-d[i], i));\n\t\t\t}\n\t\t}\n\t}\n\tif (d[n] == 1e18) puts(\"-1\");\n\telse printf(\"%.0lf\", floor(d[n] * 1000));\n}", "step": ["Initialize n, w and m.", "Read in the coordinates of n points and calculate their pairwise distances.", "Based on restrictions, set some pairwise distances to be very large.", "Read in w restrictions and override the calculations from step 3.", "Compute the shortest path between given points using priority queue and Dijkstra's algorithm.", "If the shortest path exists, output its length, otherwise output -1."], "nl_cn": "A vicious thunderstorm has destroyed some of the wires of the farm's electrical power grid! Farmer John has a map of all $N$ ($2\\le N \\le 1000$) of the powerpoles, which are conveniently numbered $1\\ldots N$ and located on integer plane coordinates $(x_i,y_i)$ ($-100000 \\le x_i \\le 100000, -100000 \\le y_i \\le 100000$).\n\nSome $W$ ($1 \\le W \\le 10000$) power wires connect pairs of power poles $P_i$ and $P_j$ ($1 \\le Pi \\le N, 1 \\le Pj \\le N$).\n\nHe needs to get power from pole $1$ to pole $N$ (which means that some series of wires can traverse from pole $1$ to pole $N$, probably through some intermediate set of poles).\n\nGiven the locations of the $N$ poles and the list of remaining power wires, determine the minimum length of power wire required to restore the electrical connection so that electricity can flow from pole $1$ to pole $N$.  No wire can be longer than some real number $M$ ($0.0 < M \\le 200000.0$).\n\nAs an example, below on the left is a map of the $9$ poles and $3$ wires after the storm. For this task, $M = 2.0$. The best set of wires to add would connect poles $4$ and $6$ and also poles $6$ and $9$.\n\n```cpp\n   After the storm              Optimally reconnected\n3  . . . 7 9 . . . . .          3  . . . 7 9 . . . . .\n                                          /\n2  . . 5 6 . . . . . .          2  . . 5 6 . . . . . .\n                                        /\n1  2-3-4 . 8 . . . . .          1  2-3-4 . 8 . . . . .\n   |                               |\n0  1 . . . . . . . . .          0  1 . . . . . . . . .\n\n   0 1 2 3 4 5 6 7 8 9             0 1 2 3 4 5 6 7 8 9\n```\n\nThe total length is then $1.414213562 + 1.414213562 = 2.828427124$.\n\nPOINTS: 350\n", "test_cases": [{"input": "9 3 \n2.0 \n0 0 \n0 1 \n1 1 \n2 1 \n2 2 \n3 2 \n3 3 \n4 1 \n4 3 \n1 2 \n2 3 \n3 4 \n", "output": "2828"}, {"input": "6 3 \n1.0 \n0 0 \n1 1 \n2 2 \n1 0 \n1 2 \n0 1 \n0 2 \n", "output": "1000"}], "test": "#undef NDEBUG\n#include<assert.h>\nint main(){\n    assert(solution(\"9 3 \\n2.0 \\n0 0 \\n0 1 \\n1 1 \\n2 1 \\n2 2 \\n3 2 \\n3 3 \\n4 1 \\n4 3 \\n1 2 \\n2 3 \\n3 4 \\n\") == \"2828\");\n    assert(solution(\"6 3 \\n1.0 \\n0 0 \\n1 1 \\n2 2 \\n1 0 \\n1 2 \\n0 1 \\n0 2 \\n\") == \"1000\");\n    return 0; \n}", "prompt": "/*A severe thunderstorm has damaged some of the power lines on Farmer John's farm! He has a map of all N (2≤N≤1000) power poles, conveniently numbered 1≤Wi≤N and located at integer coordinates (xi,yi) (−100000≤xi≤100000,−100000≤yi≤100000).\n\nW (1≤W≤10000) wires connect power poles Pi and Pj (1≤Pi≤N,1≤Pj≤N).\n\nHe needs to get power from point 1 to point n (which means a series of wires can run through intermediate poles from point 1 to point n).\n\nGiven the position of the N poles and the list of remaining wires, determine the minimum wire length needed to restore electrical connectivity so that current can flow from point 1 to point n. No wire can exceed a certain real number M (0.0<M≤200000.0).\n\nFor example, on the left below is a map of 9 poles and 3 wires after the storm. For this task, M=2.0. The optimal set of wires will connect pole 4 to 6 and pole 6 to 9.\n\nThe total length will be 1.414213562+1.414213562=2.828427124.\n\nNumber of points: 350.\n\ninput_format:\nLine $1$: Two space-separated integers: $N$ and $W$.\n\nLine $2$: A single real number: $M$.\n\nLines $3\\ldots N+2$: Each line contains two space-separated integers: $x_i$ and $y_i$.\n\nLines $N+3\\ldots N+2+W$: Two space-separated integers: $P_i$ and $P_j$.\n\nTranslated to English:\nLine 1: The first line consists of two integers separated by a space: $N$ and $W$.\n\nLine 2: The second line consists of a single real number: $M$.\n\nLines 3 to $N+2$: Each line contains two integers separated by a space: $x_i$ and $y_i$.\n\nLines $N+3$ to $N+2+W$: Each line consists of two integers separated by a space: $P_i$ and $P_j$.\n\noutput_format:\nLine 1: A single integer on a single line. If restoring connection is impossible, output `-1`. Otherwise, output a single integer that is $1000$ times the total minimum cost to restoreelectricity. Do not perform any rounding; truncate the resulting product.\n*/\n\n#include<sstream>\n#include<stdlib.h>\n#include<algorithm>\n#include<math.h>\n#include<stdio.h>\n#include<vector>\n#include<string>\n#include<climits>\n#include<cstring>\n#include<iostream>\nusing namespace std;\n\n             \nstring solution(string std_in){\n    istringstream iss(std_in);\n             ", "constraints": "Just as in the diagram above.\n\n\nAs above.\n", "samples": [["9 3 \n2.0 \n0 0 \n0 1 \n1 1 \n2 1 \n2 2 \n3 2 \n3 3 \n4 1 \n4 3 \n1 2 \n2 3 \n3 4 \n", "2828 \n"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}}
{"task_id": "P3217", "title": "[HNOI2011]数矩形", "difficulty": "advanced", "nl": "Recently, a singer is studying his global tour plan and he represents all the desired cities as a point on the plane. He plans to select 4 cities as the venues for this tour.\n\nTo show his uniqueness, he requests the existence of a rectangle with the 4 selected points as its vertices, and he hopes that the area of this rectangle is maximum.\n\nThis makes his agent very anxious, so he invites plans from fans around the world, of course, you, as a fan, won't miss this opportunity.", "code": "#include<bits/stdc++.h>\n#define int long long\nusing namespace std;\ntemplate< typename T > inline void read(T &x){\n\tchar c=getchar();x=0;int f=0;\n\tfor(;!isdigit(c);c=getchar()) f|=(c=='-');\n\tfor(;isdigit(c);c=getchar()) x=((x<<3)+(x<<1)+(c^48));\n\tx=f?-x:x;\n}\nint n;\nstruct node{\n\tint ax,ay;\n\tint bx,by;\n\tlong long d;\n\tlong long cx,cy;\n};\nnode l[2250010];\nint tot;\nstruct Node{\n\tint x,y;\n};\nNode wsl[1510];\nbool cmp(node a,node b){\n\tif(a.d==b.d)\n\t{\n\t\tif(a.cx==b.cx)return a.cy>b.cy;\n\t\treturn a.cx>b.cx;\n\t}\n\treturn a.d>b.d;\n}\nlong long ans=0;\nsigned main(){\n\tscanf(\"%lld\",&n);\n\tfor(int i=1;i<=n;i++){\n\t\tread(wsl[i].x);\n\t\tread(wsl[i].y);\n\t}\n\tfor(int i=1;i<=n;i++){\n\t\tfor(int j=i+1;j<=n;j++){\n\t\t\tl[++tot].cx=wsl[i].x+wsl[j].x;\n\t\t\tl[tot].cy=wsl[i].y+wsl[j].y;\n\t\t\tl[tot].ax=wsl[i].x,l[tot].ay=wsl[i].y;\n\t\t\tl[tot].bx=wsl[j].x,l[tot].by=wsl[j].y;\n\t\t\tl[tot].d=1ll*(wsl[i].x-wsl[j].x)*(wsl[i].x-wsl[j].x)+(wsl[i].y-wsl[j].y)*(wsl[i].y-wsl[j].y);\n\t\t}\n\t}//处理每条线段信息 \n\tsort(l+1,l+1+tot,cmp);\n\tfor(int i=1;i<tot;i++){\n\t\tfor(int j=i+1;j<=tot;j++){\n\t\t\tif(l[i].d!=l[j].d||l[i].cx!=l[j].cx||l[i].cy!=l[j].cy)break;//不符合直接跳出 \n\t\t\tif(l[i].cx==l[j].cx&&l[i].cy==l[j].cy){\n\t\t\t\tint wx=l[i].ax,wy=l[i].ay;\n\t\t\t\tint sx=l[i].bx,sy=l[i].by;\n\t\t\t\tint lx=l[j].ax,ly=l[j].ay;\n\t\t\t\tans=max(ans,1ll*(abs(wx*sy+sx*ly+lx*wy-wy*sx-sy*lx-ly*wx)));//三角形坐标面积公式 \n\t\t\t}\n\t\t}\n\t}\n\tprintf(\"%lld\",ans);\n\treturn 0;\n}", "step": ["Read input values for n and points", "Generate segments from points and sort them in a particular order", "Find intersection points between the segments", "Calculate the maximum area polygon using the intersection points", "Output the result"], "nl_cn": "最近某歌手在研究自己的全球巡回演出计划，他将所有心仪的城市都用平面上的一个点来表示，并打算从中挑选出 4 个城市作为这次巡回演出的地点。\n\n为了显示自己与众不同，他要求存在一个矩形使得挑选出的 4 个点恰好是这个矩形的 4 个顶点，并且希望这个矩形的面积最大。\n\n这可急坏了其经纪人，于是他向全球歌迷征集方案，当然你这位歌迷一定不会错过这个机会。\n", "test_cases": [{"input": "8\n-2 3\n-2 -1\n0 3\n0 -1\n1 -1\n2 1 \n-3 1 \n-2 1\n", "output": "10"}, {"input": "3\n1 1\n2 2\n3 3\n", "output": "0"}, {"input": "2\n-1 -1\n0 0\n", "output": "0"}, {"input": "4\n-4 4\n-4 -4\n4 4\n4 -4\n", "output": "64"}, {"input": "3\n10 20\n30 40\n50 60\n", "output": "0"}, {"input": "5\n-1 -1\n-2 -2\n-3 -3\n-4 -4\n-5 -5\n", "output": "0"}, {"input": "1\n0 0\n", "output": "0"}, {"input": "2\n5 10\n20 25\n", "output": "0"}, {"input": "4\n0 0\n0 10\n10 0\n10 10\n", "output": "100"}, {"input": "3\n1 2\n3 4\n5 6\n", "output": "0"}, {"input": "6\n-100 -100\n-100 -100\n-100 -100\n-100 -100\n-100 -100\n-100 -100\n", "output": "0"}, {"input": "4\n1 1\n1 1\n1 1\n1 1\n", "output": "0"}, {"input": "8\n-2 3\n-2 -1\n0 3\n0 -1\n1 -1\n2 1\n-3 1\n-2 1\n", "output": "10"}, {"input": "1\n2 2\n", "output": "0"}, {"input": "5\n-1 -1\n-1 1\n1 1\n1 -1\n0 0\n", "output": "4"}, {"input": "6\n-2 -2\n-1 -1\n0 0\n1 1\n2 2\n3 3\n", "output": "0"}, {"input": "5\n-1 -1\n1 1\n-1 1\n1 -1\n0 0\n", "output": "4"}, {"input": "4\n-2 -2\n2 -2\n-2 2\n2 2\n", "output": "16"}, {"input": "3\n0 0\n1 0\n0 1\n", "output": "0"}, {"input": "3\n0 0\n1 0\n1 1\n", "output": "0"}, {"input": "3\n0 0\n1 1\n1 0\n", "output": "0"}, {"input": "6\n-1 0\n0 -1\n1 0\n0 1\n0 0\n-1 1\n", "output": "2"}, {"input": "6\n-1 0\n0 -1\n1 0\n0 1\n0 0\n1 -1\n", "output": "2"}, {"input": "6\n1 1\n-1 -1\n1 -1\n-1 1\n0 0\n1 0\n", "output": "4"}, {"input": "6\n1 1\n-1 -1\n1 -1\n-1 1\n0 0\n0 1\n", "output": "4"}, {"input": "2\n-1 0\n1 0\n", "output": "0"}, {"input": "2\n0 1\n0 -1\n", "output": "0"}, {"input": "5\n1 1\n2 2\n3 3\n4 4\n5 5\n", "output": "0"}, {"input": "4\n1 1\n2 1\n1 2\n2 2\n", "output": "1"}, {"input": "10\n0 0\n1 0\n1 1\n0 1\n2 0\n2 1\n2 2\n0 2\n1 2\n3 1\n", "output": "4"}, {"input": "3\n-2 -2\n-2 -1\n-1 -2\n", "output": "0"}, {"input": "2\n-2 -2\n-1 -1\n", "output": "0"}, {"input": "5\n1 0\n2 0\n3 0\n4 0\n5 0\n", "output": "0"}, {"input": "6\n1 0\n2 0\n3 0\n4 0\n5 0\n6 0\n", "output": "0"}, {"input": "4\n1 0\n2 0\n1 0\n2 0\n", "output": "0"}, {"input": "10\n-1 0\n-2 0\n-3 0\n-4 0\n-5 0\n0 -1\n0 -2\n0 -3\n0 -4\n0 -5\n", "output": "0"}, {"input": "10\n0 -1\n0 -2\n0 -3\n0 -4\n0 -5\n-1 0\n-2 0\n-3 0\n-4 0\n-5 0\n", "output": "0"}, {"input": "3\n0 -1\n0 -2\n-1 0\n", "output": "0"}, {"input": "3\n-1 0\n0 -1\n0 -2\n", "output": "0"}], "test": "#undef NDEBUG\n#include<assert.h>\nint main(){\n    assert(solution(\"8\\n-2 3\\n-2 -1\\n0 3\\n0 -1\\n1 -1\\n2 1 \\n-3 1 \\n-2 1\\n\") == \"10\");\n    assert(solution(\"3\\n1 1\\n2 2\\n3 3\\n\") == \"0\");\n    assert(solution(\"2\\n-1 -1\\n0 0\\n\") == \"0\");\n    assert(solution(\"4\\n-4 4\\n-4 -4\\n4 4\\n4 -4\\n\") == \"64\");\n    assert(solution(\"3\\n10 20\\n30 40\\n50 60\\n\") == \"0\");\n    assert(solution(\"5\\n-1 -1\\n-2 -2\\n-3 -3\\n-4 -4\\n-5 -5\\n\") == \"0\");\n    assert(solution(\"1\\n0 0\\n\") == \"0\");\n    assert(solution(\"2\\n5 10\\n20 25\\n\") == \"0\");\n    assert(solution(\"4\\n0 0\\n0 10\\n10 0\\n10 10\\n\") == \"100\");\n    assert(solution(\"3\\n1 2\\n3 4\\n5 6\\n\") == \"0\");\n    assert(solution(\"6\\n-100 -100\\n-100 -100\\n-100 -100\\n-100 -100\\n-100 -100\\n-100 -100\\n\") == \"0\");\n    assert(solution(\"4\\n1 1\\n1 1\\n1 1\\n1 1\\n\") == \"0\");\n    assert(solution(\"8\\n-2 3\\n-2 -1\\n0 3\\n0 -1\\n1 -1\\n2 1\\n-3 1\\n-2 1\\n\") == \"10\");\n    assert(solution(\"1\\n2 2\\n\") == \"0\");\n    assert(solution(\"5\\n-1 -1\\n-1 1\\n1 1\\n1 -1\\n0 0\\n\") == \"4\");\n    assert(solution(\"6\\n-2 -2\\n-1 -1\\n0 0\\n1 1\\n2 2\\n3 3\\n\") == \"0\");\n    assert(solution(\"5\\n-1 -1\\n1 1\\n-1 1\\n1 -1\\n0 0\\n\") == \"4\");\n    assert(solution(\"4\\n-2 -2\\n2 -2\\n-2 2\\n2 2\\n\") == \"16\");\n    assert(solution(\"3\\n0 0\\n1 0\\n0 1\\n\") == \"0\");\n    assert(solution(\"3\\n0 0\\n1 0\\n1 1\\n\") == \"0\");\n    assert(solution(\"3\\n0 0\\n1 1\\n1 0\\n\") == \"0\");\n    assert(solution(\"6\\n-1 0\\n0 -1\\n1 0\\n0 1\\n0 0\\n-1 1\\n\") == \"2\");\n    assert(solution(\"6\\n-1 0\\n0 -1\\n1 0\\n0 1\\n0 0\\n1 -1\\n\") == \"2\");\n    assert(solution(\"6\\n1 1\\n-1 -1\\n1 -1\\n-1 1\\n0 0\\n1 0\\n\") == \"4\");\n    assert(solution(\"6\\n1 1\\n-1 -1\\n1 -1\\n-1 1\\n0 0\\n0 1\\n\") == \"4\");\n    assert(solution(\"2\\n-1 0\\n1 0\\n\") == \"0\");\n    assert(solution(\"2\\n0 1\\n0 -1\\n\") == \"0\");\n    assert(solution(\"5\\n1 1\\n2 2\\n3 3\\n4 4\\n5 5\\n\") == \"0\");\n    assert(solution(\"4\\n1 1\\n2 1\\n1 2\\n2 2\\n\") == \"1\");\n    assert(solution(\"10\\n0 0\\n1 0\\n1 1\\n0 1\\n2 0\\n2 1\\n2 2\\n0 2\\n1 2\\n3 1\\n\") == \"4\");\n    assert(solution(\"3\\n-2 -2\\n-2 -1\\n-1 -2\\n\") == \"0\");\n    assert(solution(\"2\\n-2 -2\\n-1 -1\\n\") == \"0\");\n    assert(solution(\"5\\n1 0\\n2 0\\n3 0\\n4 0\\n5 0\\n\") == \"0\");\n    assert(solution(\"6\\n1 0\\n2 0\\n3 0\\n4 0\\n5 0\\n6 0\\n\") == \"0\");\n    assert(solution(\"4\\n1 0\\n2 0\\n1 0\\n2 0\\n\") == \"0\");\n    assert(solution(\"10\\n-1 0\\n-2 0\\n-3 0\\n-4 0\\n-5 0\\n0 -1\\n0 -2\\n0 -3\\n0 -4\\n0 -5\\n\") == \"0\");\n    assert(solution(\"10\\n0 -1\\n0 -2\\n0 -3\\n0 -4\\n0 -5\\n-1 0\\n-2 0\\n-3 0\\n-4 0\\n-5 0\\n\") == \"0\");\n    assert(solution(\"3\\n0 -1\\n0 -2\\n-1 0\\n\") == \"0\");\n    assert(solution(\"3\\n-1 0\\n0 -1\\n0 -2\\n\") == \"0\");\n    return 0; \n}", "prompt": "/*Recently, a singer is studying his global tour plan and he represents all the desired cities as a point on the plane. He plans to select 4 cities as the venues for this tour.\n\nTo show his uniqueness, he requests the existence of a rectangle with the 4 selected points as its vertices, and he hopes that the area of this rectangle is maximum.\n\nThis makes his agent very anxious, so he invites plans from fans around the world, of course, you, as a fan, won't miss this opportunity.\n\ninput_format:\nRead data from the input.txt file, the first line of the input file is a positive integer $N$, representing the number of points on the plane (i.e., the number of cities that a certain singer likes). The next $N$line, each of which is two integers $X_i$and $Y_i$separated by a space, represents the coordinates of its corresponding points. 20% of the data meets $N\\leq 500$, 100% of the data meets $N\\leq 1500$, $-10^8\\leq X_i,Y_i\\leq 10^8$, and the input data guarantees the existence of the answer.\n\noutput_format:\nThe output file output.txt contains only one non-negative integer, representing the largest rectangular area.\n*/\n\n#include<sstream>\n#include<stdlib.h>\n#include<algorithm>\n#include<math.h>\n#include<stdio.h>\n#include<vector>\n#include<string>\n#include<climits>\n#include<cstring>\n#include<iostream>\nusing namespace std;\n\n             \nstring solution(string std_in){\n    istringstream iss(std_in);\n             ", "constraints": "", "samples": [["8\n-2 3\n-2 -1\n0 3\n0 -1\n1 -1\n2 1 \n-3 1 \n-2 1\n", "10"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}}
{"task_id": "P1739", "title": "表达式括号匹配", "difficulty": "basic", "nl": "Assuming an expression consists of lowercase English letters, operators (`+`, `-`, `*`, `/`), and left/right parentheses, and ends with `@`, write a program to check if the left and right parentheses in the expression match. If they do, output `YES`; otherwise, output `NO`. The length of the expression is less than 255, and there are fewer than 20 left parentheses.", "code": "#include <cstdio>\n#include <iostream>\n#include <cstring>\n#include <cmath>//头文件\nusing namespace std;//不加这个会出错（告诉一些新人的，大佬勿喷）\nint ok=0;//状态的变量（大佬千万别改bool）\nchar a;//记录字符\nint i=0;//之后的特判要用\nint main()\n{\n    for (;;i++)//很无脑对不对，但是很有用\n    {\n        a=getchar();//读入\n        if (i==0&&a==')') {printf (\"NO\");return 0;}//特判：第一个为‘）’，结束，不对，自己想想看\n        if (a=='(') ok++;//是左括号就++\n        if (a==')') ok--;//是有括号就--\n        if (ok<0) {printf (\"NO\");return 0;}//特判：多了右括号，结束（多了左没事，但不可以多右，想想看）\n        if (a=='@') {if (!ok) printf (\"YES\");else printf (\"NO\");return 0;}\n//特判无效：比较ok是不是为0（是0表示左右括号都一样多，结束）\n    }\n}", "step": ["Read input string to a queue", "Process each bracket by incrementing left and right variables", "If current bracket is '(', increment t as well", "If current bracket is ')', decrement t", "Pop processed bracket from queue", "Check if left equals right and t equals 0, print 'YES', else print 'NO'"], "nl_cn": "假设一个表达式有英文字母（小写）、运算符（`+`、`-`、`*`、`/`）和左右小（圆）括号构成，以 `@` 作为表达式的结束符。请编写一个程序检查表达式中的左右圆括号是否匹配，若匹配，则输出 `YES`；否则输出 `NO`。表达式长度小于 $255$，左圆括号少于 $20$ 个。\n", "test_cases": [{"input": "2*(x+y)/(1-x)@\n", "output": "YES"}, {"input": "(25+x)*(a*(a+b+b)@\n", "output": "NO"}, {"input": "(a+b*(c-d))/e@\n", "output": "YES"}, {"input": "((x+y)*z)@\n", "output": "YES"}, {"input": "((a+b)@\n", "output": "NO"}, {"input": "(a+b)/(c-d))@\n", "output": "NO"}, {"input": "(a+b)*((c+d)@\n", "output": "NO"}, {"input": "a+b)@\n", "output": "NO"}, {"input": "a+b/c)@\n", "output": "NO"}, {"input": "a+b/(c-d))@\n", "output": "NO"}, {"input": "a+b/(c-d)+e)@\n", "output": "NO"}, {"input": "a+b/(c-d+e)@\n", "output": "YES"}, {"input": "((a+b)/(c-d)+e)@\n", "output": "YES"}, {"input": "(((a+b)/(c-d)+e))@\n", "output": "YES"}, {"input": "((a+b)/(c-d)+e))@\n", "output": "NO"}, {"input": "(())@\n", "output": "YES"}, {"input": "((()@\n", "output": "NO"}, {"input": "))(@\n", "output": "NO"}, {"input": "((x))@\n", "output": "YES"}, {"input": "((()()()))@\n", "output": "YES"}, {"input": "(a+b+c)@\n", "output": "YES"}, {"input": "((((()))))@\n", "output": "YES"}, {"input": "(((a+b)@\n", "output": "NO"}, {"input": "(a@@\n", "output": "NO"}, {"input": "(a+b+c-d)@\n", "output": "YES"}, {"input": "(a+b-c-d)@\n", "output": "YES"}, {"input": "((a+b)*(c-d))@\n", "output": "YES"}, {"input": "()@\n", "output": "YES"}, {"input": "(((x+y)@\n", "output": "NO"}, {"input": ")((@\n", "output": "NO"}, {"input": "(@))@\n", "output": "NO"}, {"input": "(a-b)@(x*(y*z))@\n", "output": "YES"}, {"input": "((a+b))@(x-y)@\n", "output": "YES"}, {"input": "(@\n", "output": "NO"}, {"input": "a+b)@(x*y)@\n", "output": "NO"}, {"input": "(a+b)@(x/y)@\n", "output": "YES"}, {"input": "(a*b+c)@(x/y)@\n", "output": "YES"}, {"input": "(a+b))@(x*y)@\n", "output": "NO"}, {"input": "((a+b)@(x-y)@\n", "output": "NO"}, {"input": "(a+b*(c-d))/(x+y+z)@\n", "output": "YES"}, {"input": "(a+b)@(x*y+z)@\n", "output": "YES"}, {"input": "(a+b)@(x*y/z)@\n", "output": "YES"}, {"input": "(a*(b+c-d)@\n", "output": "NO"}, {"input": "(a+b)*(c+d)@", "output": "YES"}, {"input": "(x@", "output": "NO"}, {"input": "(a)|((b)@", "output": "NO"}, {"input": "(a+b-c)*d/(e+f+g)@", "output": "YES"}, {"input": "(x*(x-2)@(x+1)(*x)@", "output": "NO"}, {"input": "((a*(((b))+(c))@", "output": "NO"}, {"input": "((a+b-c+d)*(e*f/(g+h))@(x+y+z)@", "output": "NO"}, {"input": "@", "output": "YES"}, {"input": "((((@", "output": "NO"}, {"input": "(a+(b)@(a-b)+(c-d)@", "output": "NO"}, {"input": "((a*b-c)d+e)/(f+g+h)@", "output": "YES"}, {"input": "(x+y)@", "output": "YES"}], "test": "#undef NDEBUG\n#include<assert.h>\nint main(){\n    assert(solution(\"2*(x+y)/(1-x)@\\n\") == \"YES\");\n    assert(solution(\"(25+x)*(a*(a+b+b)@\\n\") == \"NO\");\n    assert(solution(\"(a+b*(c-d))/e@\\n\") == \"YES\");\n    assert(solution(\"((x+y)*z)@\\n\") == \"YES\");\n    assert(solution(\"((a+b)@\\n\") == \"NO\");\n    assert(solution(\"(a+b)/(c-d))@\\n\") == \"NO\");\n    assert(solution(\"(a+b)*((c+d)@\\n\") == \"NO\");\n    assert(solution(\"a+b)@\\n\") == \"NO\");\n    assert(solution(\"a+b/c)@\\n\") == \"NO\");\n    assert(solution(\"a+b/(c-d))@\\n\") == \"NO\");\n    assert(solution(\"a+b/(c-d)+e)@\\n\") == \"NO\");\n    assert(solution(\"a+b/(c-d+e)@\\n\") == \"YES\");\n    assert(solution(\"((a+b)/(c-d)+e)@\\n\") == \"YES\");\n    assert(solution(\"(((a+b)/(c-d)+e))@\\n\") == \"YES\");\n    assert(solution(\"((a+b)/(c-d)+e))@\\n\") == \"NO\");\n    assert(solution(\"(())@\\n\") == \"YES\");\n    assert(solution(\"((()@\\n\") == \"NO\");\n    assert(solution(\"))(@\\n\") == \"NO\");\n    assert(solution(\"((x))@\\n\") == \"YES\");\n    assert(solution(\"((()()()))@\\n\") == \"YES\");\n    assert(solution(\"(a+b+c)@\\n\") == \"YES\");\n    assert(solution(\"((((()))))@\\n\") == \"YES\");\n    assert(solution(\"(((a+b)@\\n\") == \"NO\");\n    assert(solution(\"(a@@\\n\") == \"NO\");\n    assert(solution(\"(a+b+c-d)@\\n\") == \"YES\");\n    assert(solution(\"(a+b-c-d)@\\n\") == \"YES\");\n    assert(solution(\"((a+b)*(c-d))@\\n\") == \"YES\");\n    assert(solution(\"()@\\n\") == \"YES\");\n    assert(solution(\"(((x+y)@\\n\") == \"NO\");\n    assert(solution(\")((@\\n\") == \"NO\");\n    assert(solution(\"(@))@\\n\") == \"NO\");\n    assert(solution(\"(a-b)@(x*(y*z))@\\n\") == \"YES\");\n    assert(solution(\"((a+b))@(x-y)@\\n\") == \"YES\");\n    assert(solution(\"(@\\n\") == \"NO\");\n    assert(solution(\"a+b)@(x*y)@\\n\") == \"NO\");\n    assert(solution(\"(a+b)@(x/y)@\\n\") == \"YES\");\n    assert(solution(\"(a*b+c)@(x/y)@\\n\") == \"YES\");\n    assert(solution(\"(a+b))@(x*y)@\\n\") == \"NO\");\n    assert(solution(\"((a+b)@(x-y)@\\n\") == \"NO\");\n    assert(solution(\"(a+b*(c-d))/(x+y+z)@\\n\") == \"YES\");\n    assert(solution(\"(a+b)@(x*y+z)@\\n\") == \"YES\");\n    assert(solution(\"(a+b)@(x*y/z)@\\n\") == \"YES\");\n    assert(solution(\"(a*(b+c-d)@\\n\") == \"NO\");\n    assert(solution(\"(a+b)*(c+d)@\") == \"YES\");\n    assert(solution(\"(x@\") == \"NO\");\n    assert(solution(\"(a)|((b)@\") == \"NO\");\n    assert(solution(\"(a+b-c)*d/(e+f+g)@\") == \"YES\");\n    assert(solution(\"(x*(x-2)@(x+1)(*x)@\") == \"NO\");\n    assert(solution(\"((a*(((b))+(c))@\") == \"NO\");\n    assert(solution(\"((a+b-c+d)*(e*f/(g+h))@(x+y+z)@\") == \"NO\");\n    assert(solution(\"@\") == \"YES\");\n    assert(solution(\"((((@\") == \"NO\");\n    assert(solution(\"(a+(b)@(a-b)+(c-d)@\") == \"NO\");\n    assert(solution(\"((a*b-c)d+e)/(f+g+h)@\") == \"YES\");\n    assert(solution(\"(x+y)@\") == \"YES\");\n    return 0; \n}", "prompt": "/*Assuming an expression consists of lowercase English letters, operators (`+`, `-`, `*`, `/`), and left/right parentheses, and ends with `@`, write a program to check if the left and right parentheses in the expression match. If they do, output `YES`; otherwise, output `NO`. The length of the expression is less than 255, and there are fewer than 20 left parentheses.\n\ninput_format:\nLine: Expression.\n\noutput_format:\nLine: 'YES' or 'NO'.\n*/\n\n#include<sstream>\n#include<stdlib.h>\n#include<algorithm>\n#include<math.h>\n#include<stdio.h>\n#include<vector>\n#include<string>\n#include<climits>\n#include<cstring>\n#include<iostream>\nusing namespace std;\n\n             \nstring solution(string std_in){\n    istringstream iss(std_in);\n             ", "constraints": "表达式长度小于 $255$，左圆括号少于 $20$ 个。\n", "samples": [["2*(x+y)/(1-x)@\n", "YES\n"], ["(25+x)*(a*(a+b+b)@\n", "NO\n"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072]}}
{"task_id": "P4439", "title": "[COCI2017-2018#3] Aron", "difficulty": "basic", "nl": "The holiday season is approaching and Aron wants to buy gifts for his friends in Zagreb. To ensure timely delivery, he visits a well-known toy store in London. After selecting the gifts, he finds that there are already N people in the queue. Fortunately, he notices that there are groups of people in the queue along with individual customers. A group of people consists of a customer and their friends waiting for them to complete the purchase.\n\nThe moment a customer is done, they and their friends leave the queue. People in a group stand one behind the other and wear matching colored shirts. Two adjacent groups, adjacent individuals, or an adjacent individual and group will never wear shirts of the same color. Write a program that will output the position of Aron in the queue given the data about the people standing in line.", "code": "#include<bits/stdc++.h>\nusing namespace std;\nint n,ans;\nint main(){\n\tscanf(\"%d\",&n);\n\tchar k='#';//变量K，题目给出衣服颜色一定是大写字母，所以我们初始化一个#。 \n\tfor(int i=1;i<=n;i++){//循环 \n\t\tchar s;//当前人的衣服颜色 \n\t\tcin>>s;\n\t\tif(s==k)continue;//属于同一块 \n\t\tans++;\n\t\tk=s;\n\t}ans++;\n\tprintf(\"%d\",ans);//输出答案 \n\treturn 0;\n}", "step": ["Take input an integer n.", "Set a character k to #.", "Loop through the string n times and take input a character s.", "If s is equal to k, continue to the next iteration without incrementing ans.", "Else, increment ans by 1 and set k to s.", "Increment ans again after the loop.", "Print the value of ans and exit the program."], "nl_cn": "The holiday season is near! Aron wants to get gifts for his friends in Zagreb, so in order to get them on time, he visited a famous toy store in London. After picking out the gifts, he went to the register and discovered that there were already N people in line. Luckily, he noticed that there were groups of people standing in line, in addition to individual customers. A group of people consists of a customer and their friends waiting for them to complete the purchase.\nThe moment when the customer is done, they and their friends leave the line.\n\nThe people considered a group are standing one behind the other and are wearing shirts of matching colour. Two adjacent groups, adjacent individuals or adjacent individual and a group, will never be wearing shirts of the same colour.\n\nWrite a program that will, given the data on the people standing in line, output which person in line Aron is.\n", "test_cases": [{"input": "3\nC\nZ\nP\n", "output": "4"}, {"input": "6\nC\nC\nP\nC\nZ\nZ", "output": "5"}, {"input": "6\nB\nB\nB\nB\nB\nB", "output": "2"}, {"input": "1\nA\n", "output": "2"}, {"input": "4\nA\nB\nC\nD\n", "output": "5"}, {"input": "2\nX\nY\n", "output": "3"}, {"input": "7\nA\nB\nC\nD\nE\nF\nG\n", "output": "8"}, {"input": "3\nA\nB\nC\n", "output": "4"}, {"input": "2\nP\nP\n", "output": "2"}, {"input": "4\nZ\nZ\nZ\nZ\n", "output": "2"}, {"input": "8\nM\nM\nN\nN\nO\nO\nP\nP\n", "output": "5"}, {"input": "1\nP\n", "output": "2"}, {"input": "3\nA\nA\nA\n", "output": "2"}, {"input": "2\nX\nZ\n", "output": "3"}, {"input": "5\nX\nX\nY\nY\nZ\n", "output": "4"}, {"input": "0\n", "output": "1"}, {"input": "2\nA\nB\n", "output": "3"}, {"input": "5\nA\nB\nC\nD\nE\n", "output": "6"}, {"input": "4\nA\nP\nB\nP\n", "output": "5"}, {"input": "2\nX\nX\n", "output": "2"}, {"input": "6\nA\nB\nC\nD\nE\nF\n", "output": "7"}, {"input": "2\nY\nZ\n", "output": "3"}, {"input": "1\nB\n", "output": "2"}, {"input": "6\nG\nG\nH\nH\nI\nI\n", "output": "4"}, {"input": "3\nP\nQ\nP\n", "output": "4"}, {"input": "5\nL\nL\nL\nL\nL\n", "output": "2"}, {"input": "2\nM\nN\n", "output": "3"}, {"input": "6\nS\nT\nU\nV\nW\nX\n", "output": "7"}, {"input": "3\nR\nS\nT\n", "output": "4"}, {"input": "4\nX\nX\nX\nX\n", "output": "2"}, {"input": "2\nA\nA\n", "output": "2"}, {"input": "5\nW\nW\nW\nW\nW\n", "output": "2"}, {"input": "6\nX\nY\nY\nX\nX\nX\n", "output": "4"}, {"input": "3\nW\nW\nW\n", "output": "2"}, {"input": "4\nC\nC\nC\nC\n", "output": "2"}, {"input": "7\nA\nA\nB\nB\nB\nB\nA\n", "output": "4"}], "test": "#undef NDEBUG\n#include<assert.h>\nint main(){\n    assert(solution(\"3\\nC\\nZ\\nP\\n\") == \"4\");\n    assert(solution(\"6\\nC\\nC\\nP\\nC\\nZ\\nZ\") == \"5\");\n    assert(solution(\"6\\nB\\nB\\nB\\nB\\nB\\nB\") == \"2\");\n    assert(solution(\"1\\nA\\n\") == \"2\");\n    assert(solution(\"4\\nA\\nB\\nC\\nD\\n\") == \"5\");\n    assert(solution(\"2\\nX\\nY\\n\") == \"3\");\n    assert(solution(\"7\\nA\\nB\\nC\\nD\\nE\\nF\\nG\\n\") == \"8\");\n    assert(solution(\"3\\nA\\nB\\nC\\n\") == \"4\");\n    assert(solution(\"2\\nP\\nP\\n\") == \"2\");\n    assert(solution(\"4\\nZ\\nZ\\nZ\\nZ\\n\") == \"2\");\n    assert(solution(\"8\\nM\\nM\\nN\\nN\\nO\\nO\\nP\\nP\\n\") == \"5\");\n    assert(solution(\"1\\nP\\n\") == \"2\");\n    assert(solution(\"3\\nA\\nA\\nA\\n\") == \"2\");\n    assert(solution(\"2\\nX\\nZ\\n\") == \"3\");\n    assert(solution(\"5\\nX\\nX\\nY\\nY\\nZ\\n\") == \"4\");\n    assert(solution(\"0\\n\") == \"1\");\n    assert(solution(\"2\\nA\\nB\\n\") == \"3\");\n    assert(solution(\"5\\nA\\nB\\nC\\nD\\nE\\n\") == \"6\");\n    assert(solution(\"4\\nA\\nP\\nB\\nP\\n\") == \"5\");\n    assert(solution(\"2\\nX\\nX\\n\") == \"2\");\n    assert(solution(\"6\\nA\\nB\\nC\\nD\\nE\\nF\\n\") == \"7\");\n    assert(solution(\"2\\nY\\nZ\\n\") == \"3\");\n    assert(solution(\"1\\nB\\n\") == \"2\");\n    assert(solution(\"6\\nG\\nG\\nH\\nH\\nI\\nI\\n\") == \"4\");\n    assert(solution(\"3\\nP\\nQ\\nP\\n\") == \"4\");\n    assert(solution(\"5\\nL\\nL\\nL\\nL\\nL\\n\") == \"2\");\n    assert(solution(\"2\\nM\\nN\\n\") == \"3\");\n    assert(solution(\"6\\nS\\nT\\nU\\nV\\nW\\nX\\n\") == \"7\");\n    assert(solution(\"3\\nR\\nS\\nT\\n\") == \"4\");\n    assert(solution(\"4\\nX\\nX\\nX\\nX\\n\") == \"2\");\n    assert(solution(\"2\\nA\\nA\\n\") == \"2\");\n    assert(solution(\"5\\nW\\nW\\nW\\nW\\nW\\n\") == \"2\");\n    assert(solution(\"6\\nX\\nY\\nY\\nX\\nX\\nX\\n\") == \"4\");\n    assert(solution(\"3\\nW\\nW\\nW\\n\") == \"2\");\n    assert(solution(\"4\\nC\\nC\\nC\\nC\\n\") == \"2\");\n    assert(solution(\"7\\nA\\nA\\nB\\nB\\nB\\nB\\nA\\n\") == \"4\");\n    return 0; \n}", "prompt": "/*The holiday season is approaching and Aron wants to buy gifts for his friends in Zagreb. To ensure timely delivery, he visits a well-known toy store in London. After selecting the gifts, he finds that there are already N people in the queue. Fortunately, he notices that there are groups of people in the queue along with individual customers. A group of people consists of a customer and their friends waiting for them to complete the purchase.\n\nThe moment a customer is done, they and their friends leave the queue. People in a group stand one behind the other and wear matching colored shirts. Two adjacent groups, adjacent individuals, or an adjacent individual and group will never wear shirts of the same color. Write a program that will output the position of Aron in the queue given the data about the people standing in line.\n\ninput_format:\nThe first line of input contains the positive integer N (1 ≤ N ≤ 25) from the task.\nEach of the following N lines contains a single character, an uppercase letter of the English alphabet that represents the shirt colour of the $i^{th}$ person in line.\n\noutput_format:\nYou must output the required number from the task.\n*/\n\n#include<sstream>\n#include<stdlib.h>\n#include<algorithm>\n#include<math.h>\n#include<stdio.h>\n#include<vector>\n#include<string>\n#include<climits>\n#include<cstring>\n#include<iostream>\nusing namespace std;\n\n             \nstring solution(string std_in){\n    istringstream iss(std_in);\n             ", "constraints": "**Clarification​ ​of​ ​the​ ​second​ ​test​ ​case:**\n\nFirst in line is the group consisting of two people in red shirts. Second in line is an individual in the blue shirt, third in line is an individual in the red shirt, and fourth in line is a group in green shirts. This makes Aron fifth in line.", "samples": [["3\nC\nZ\nP\n", "4"], ["6\nC\nC\nP\nC\nZ\nZ", "5"], ["6\nB\nB\nB\nB\nB\nB", "2"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [64000, 64000, 64000, 64000, 64000, 64000, 64000, 64000, 64000, 64000, 64000, 64000, 64000]}}
{"task_id": "P2238", "title": "逛庙会", "difficulty": "advanced", "nl": "There is a temple fair in the city with many booths. The venue of the fair is a large matrix consisting of H booths in the north-south direction and W booths in the east-west direction. A booth located at the i-th row from the north and the j-th column from the west is represented as (i,j).\n\nA beautiful girl is currently located at position (1,1) of the fair, and she needs to walk eastward or southward until she meets BaWei.You. Neither (1,1) nor (H,W), nor any of their adjacent booths on the north, south, east, or west is open. Other booths may also not be open.\n\nThe beautiful girl is a foodie. Whenever she reaches a booth, she cannot resist the temptation of the snacks. If the booth is open and the snack has not been bought, she will buy it. The aroma of the snacks from the adjacent booths on the north, south, east, or west is also tempting to her, and if the adjacent snack has not been bought, she will buy r-1 snacks from these adjacent booths (up, down, left, and right) where there are r booths and r-1 of them have not been bought. Then, she continues to walk eastward or southward. She won't buy from the same booth multiple times.\n\nAlthough the beautiful girl is a foodie, she has limited pocket money. But she just can't control herself and wants to buy, buy, buy. Therefore, she wants to know the minimum amount of money she needs to spend.", "code": "#include <stdio.h>\n\n#define chmin(a,b) if ((a) > (b)) { a = (b); }\n\nconst int INF = 1000000;\nint H, W;\nint shop[1020][1020];\nint dp[1020][1020][16];\nint bc[] = { 0, 1, 1, 2, 1, 2, 2, 3, 1, 2, 2, 3, 2, 3, 3, 4 };//二进制中1的个数\n\nint main()\n{\n    int i, j, k, k2, cost;\n    char in[1020];\n    scanf(\"%d%d\", &H, &W);\n\n    for (i = 0; i < H + 3; ++i) {\n        for (j = 0; j < W + 3; ++j) {\n            shop[i][j] = 0;\n            for (k = 0; k < 16; ++k) dp[i][j][k] = INF;\n        }\n    }\n\n    for (i = 0; i < H; ++i) {\n        scanf(\"%s\", in);\n        for (j = 0; j < W; ++j) {\n            shop[i + 1][j + 1] = (in[j] == '.' ? 0 : (in[j] - '0'));\n        }\n    }\n\n    dp[1][1][15] = 0;\n    for (i = 1; i <= H; ++i) {\n        for (j = 1; j <= W; ++j) {\n            for (k = 0; k < 16; ++k) {\n                // move to (i + 1, j)\n                for (k2 = 0; k2 < 16; ++k2) {\n                    if (\n                        ((k & 4) == 0) != ((k2 & 8) == 0) \n                        ||!(k & 2)\n                        ||(bc[k & 1] + bc[k2 & 6] <= 1)\n                    ) continue;\n                \n                    cost = dp[i][j][k];\n                    if (k2 & 1) cost += shop[i + 2][j - 1];\n                    if (k2 & 2) cost += shop[i + 2][j];\n                    if (k2 & 4) cost += shop[i + 1][j + 1];\n\n                    chmin(dp[i + 1][j][k2], cost);\n                }\n\n                // move to (i, j + 1)\n                for (k2 = 0; k2 < 16; ++k2) {\n                    if (\n                        ((k & 2) == 0) != ((k2 & 1) == 0)\n                        ||!(k & 4)\n                        ||(bc[k & 8] + bc[k2 & 6] <= 1)\n                    ) continue;\n                \n\n                    cost = dp[i][j][k];\n                    if (k2 & 8) cost += shop[i - 1][j + 2];\n                    if (k2 & 4) cost += shop[i][j + 2];\n                    if (k2 & 2) cost += shop[i + 1][j + 1];\n\n                    chmin(dp[i][j + 1][k2], cost);\n                }\n            }\n        }\n    }\n\n    printf(\"%d\\n\", dp[H][W][15]);\n    return 0;\n}", "step": ["Initialize all the element of 2-D array dp with infinite", "Reading grid size, then create a map and preparing to read the grid", "Read grid", "Use dynamic programming to iterate each step in the grid and filling the dp array", "Last but not least, get the minimum value of dp[cx][cy][k][x] and print it out as the result"], "nl_cn": "城市里正在举行庙会。庙会里有很多摊位。庙会的会场是一个南北向H个摊位、东西向W个摊位组成的大型方阵。从北开始第i行、西开始第j列的一个摊位，我们表示为(i,j)。\n\n\n正妹现在处于庙会的(1,1)位置，然后要往东或者往南走，一直走到(H,W)跟八尾勇汇合。(1,1)点和(H,W)和它们的东西南北邻近一个摊位都没有开张。别的地方也可能有一些摊位没有开张。\n\n\n正妹是个吃货。只要到达一个摊位，总是经不起小吃的诱惑。如果这个摊位开张了，而且该摊位小吃还没有买过，就会买下这个摊位的小吃。无论这个摊位是否有开张，其东西南北直接相邻的摊位小吃的香味也很诱人，如果邻近的摊位的小吃没有买过，那么就在这些邻近（上下左右）的且没有买过的摊位（假设有r个）中，买其中的r-1个摊位的小吃。然后继续往东或者南走。同一家小摊，不会购买多次。\n\n\n虽然正妹是个吃货，但是零用钱还是很有限。可是她又是管不住自己，就是要买买买。所以她希望知道自己最少能吃掉多少钱的东西。\n", "test_cases": [{"input": "5 5\n....7\n.21.8\n9346.\n..45.\n.8...", "output": "9"}, {"input": "1 1\n3", "output": "0"}, {"input": "2 3\n5..1\n.94.\n", "output": "4"}, {"input": "6 6\n......\n......\n......\n......\n......\n......\n", "output": "0"}, {"input": "4 3\n82.\n...2\n175\n..36\n", "output": "4"}, {"input": "1 1\n.\n", "output": "0"}], "test": "#undef NDEBUG\n#include<assert.h>\nint main(){\n    assert(solution(\"5 5\\n....7\\n.21.8\\n9346.\\n..45.\\n.8...\") == \"9\");\n    assert(solution(\"1 1\\n3\") == \"0\");\n    assert(solution(\"2 3\\n5..1\\n.94.\\n\") == \"4\");\n    assert(solution(\"6 6\\n......\\n......\\n......\\n......\\n......\\n......\\n\") == \"0\");\n    assert(solution(\"4 3\\n82.\\n...2\\n175\\n..36\\n\") == \"4\");\n    assert(solution(\"1 1\\n.\\n\") == \"0\");\n    return 0; \n}", "prompt": "/*There is a temple fair in the city with many booths. The venue of the fair is a large matrix consisting of H booths in the north-south direction and W booths in the east-west direction. A booth located at the i-th row from the north and the j-th column from the west is represented as (i,j).\n\nA beautiful girl is currently located at position (1,1) of the fair, and she needs to walk eastward or southward until she meets BaWei.You. Neither (1,1) nor (H,W), nor any of their adjacent booths on the north, south, east, or west is open. Other booths may also not be open.\n\nThe beautiful girl is a foodie. Whenever she reaches a booth, she cannot resist the temptation of the snacks. If the booth is open and the snack has not been bought, she will buy it. The aroma of the snacks from the adjacent booths on the north, south, east, or west is also tempting to her, and if the adjacent snack has not been bought, she will buy r-1 snacks from these adjacent booths (up, down, left, and right) where there are r booths and r-1 of them have not been bought. Then, she continues to walk eastward or southward. She won't buy from the same booth multiple times.\n\nAlthough the beautiful girl is a foodie, she has limited pocket money. But she just can't control herself and wants to buy, buy, buy. Therefore, she wants to know the minimum amount of money she needs to spend.\n\ninput_format:\nThe first row has two numbers, H and W\n\nNext H lines, W strings per line, ** No Spaces separated **, is 1-9 or one of the '.', indicating the price, and a dot indicates that there is no opening.\n\noutput_format:\nA whole number representing the least amount spent\n*/\n\n#include<sstream>\n#include<stdlib.h>\n#include<algorithm>\n#include<math.h>\n#include<stdio.h>\n#include<vector>\n#include<string>\n#include<climits>\n#include<cstring>\n#include<iostream>\nusing namespace std;\n\n             \nstring solution(string std_in){\n    istringstream iss(std_in);\n             ", "constraints": "```cpp\n样例解释：o为正妹经过的路线，x为她顺便买的小吃。当走到(2,4)时，左下右都有开张且没有买过的摊位，于是买左和右，继续沿着路线走。由于之后路线没有经过没有买过摊位，而且上下左右开张且没买过的摊位不超过1，所以一个都不买了。\n5 5\noooo7\n.2xoo\n9346o\n..45o\n.8..o\n```\n20%数据，开张的摊位不超过20\n\n\n100%数据， (3 ≦ H ≦ 1000, 3 ≦ W ≦ 1000) \n\n特别注意：数据是在windows生成，输入数据换行符可能是“\\r\\n”（两个字符）或者\"\\n\"。而评测机是linux。请特别注意。不接受赛后以“本地能过，评测wa”的理由申诉。\n\n参考读入方式（节选自std）：\n\n```cpp\n    for (i = 0; i < H; ++i) {\n        scanf(\"%s\", in);\n        for (j = 0; j < W; ++j) {\n            shop[i][j] = blabla..\n        }\n    }\n```", "samples": [["5 5\n....7\n.21.8\n9346.\n..45.\n.8...", "9"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000]}}
{"task_id": "P1567", "title": "统计天数", "difficulty": "basic", "nl": "On a scorching summer day, KC is extremely unhappy. He would rather endure the cold of the Arctic than the summer of Xiamen. Recently, he started researching the weather changes. He hopes to predict the future weather using the research results.\n\nAfter experiencing many difficulties, he collected a continuous series of highest temperature data of length N (1 <= N <= 10^6).\n\nNow, he wants to know the longest continuous days of rising highest temperatures.", "code": "#include <cstdio>\n\nusing namespace std;\n\nint main()\n{\n    int n, count = 1, max = 1;\n    long long last, cur;\n    scanf(\"%d%d\", &n, &cur);\n    for (int i = 2; i <= n; i++)\n    {\n        last = cur;\n        scanf(\"%d\", &cur);\n        if (cur > last)\n        {\n            count++;\n        }\n        else\n        {\n            count = 1;\n        }\n        if (count > max) max = count;\n    }\n    printf(\"%d\\n\", max);\n    return 0;\n}", "step": ["Initialize an integer array 'a' of size 3 and 'n', 'x' and 'num' of integer type.", "Read the value of 'n' from the user.", "Using a for loop, read 'n' values into the array 'a'.", "If the current value is greater than or equal to the previous value, increment 'x' and update 'num' with the maximum value of 'x' and 'num'.", "If the current value is less than the previous value, reset 'x' to 1.", "Print the value of 'num'."], "nl_cn": "炎热的夏日，KC 非常的不爽。他宁可忍受北极的寒冷，也不愿忍受厦门的夏天。最近，他开始研究天气的变化。他希望用研究的结果预测未来的天气。\n\n\n经历千辛万苦，他收集了连续 $N(1 \\leq N \\leq 10^6)$ 的最高气温数据。\n\n现在，他想知道最高气温一直上升的最长连续天数。\n", "test_cases": [{"input": "10\n1 2 3 2 4 5 6 8 5 9\n", "output": "5"}, {"input": "5\n9 8 7 6 5\n", "output": "1"}, {"input": "7\n1 2 3 4 5 6 7\n", "output": "7"}, {"input": "6\n10 20 30 40 50 60\n", "output": "6"}, {"input": "3\n100 150 200\n", "output": "3"}, {"input": "12\n5 4 3 2 3 4 5 6 5 4 3 2\n", "output": "5"}, {"input": "6\n10 11 12 13 12 11\n", "output": "4"}, {"input": "7\n100 90 80 70 80 90 100\n", "output": "4"}, {"input": "10\n1 3 5 7 9 11 13 15 17 19\n", "output": "10"}, {"input": "4\n1 2 1 2\n", "output": "2"}, {"input": "5\n5 4 3 2 1\n", "output": "1"}, {"input": "8\n5 2 3 4 5 6 7 8\n", "output": "7"}, {"input": "6\n1 2 3 2 1 2\n", "output": "3"}, {"input": "3\n1 2 3\n", "output": "3"}, {"input": "4\n8 6 2 1\n", "output": "1"}, {"input": "6\n3 2 1 2 3 4\n", "output": "4"}, {"input": "5\n1 2 3 4 5\n", "output": "5"}, {"input": "6\n6 5 4 3 2 1\n", "output": "1"}, {"input": "9\n2 4 6 8 10 12 14 16 18\n", "output": "9"}, {"input": "10\n10 9 8 7 6 5 4 3 2 1\n", "output": "1"}, {"input": "5\n5 4 5 4 5\n", "output": "2"}, {"input": "7\n6 5 4 3 4 5 6\n", "output": "4"}, {"input": "3\n1 2 1\n", "output": "2"}, {"input": "5\n10 11 12 13 14\n", "output": "5"}, {"input": "1\n100\n", "output": "1"}, {"input": "8\n1 2 3 2 1 2 3 4\n", "output": "4"}, {"input": "5\n1 2 3 2 1\n", "output": "3"}, {"input": "9\n1 2 3 4 5 6 7 8 9\n", "output": "9"}, {"input": "5\n2 1 2 1 2\n", "output": "2"}, {"input": "3\n2 1 2\n", "output": "2"}, {"input": "5\n10 20 30 40 50\n", "output": "5"}, {"input": "5\n50 40 30 20 10\n", "output": "1"}, {"input": "6\n1 2 3 1 2 3\n", "output": "3"}, {"input": "8\n1 2 3 4 3 2 4 5\n", "output": "4"}, {"input": "9\n10 20 30 40 30 20 10 5 7\n", "output": "4"}, {"input": "12\n5 4 3 2 1 2 3 4 5 6 7 8\n", "output": "8"}, {"input": "4\n1 2 3 4\n", "output": "4"}, {"input": "8\n1 2 3 4 5 6 7 8\n", "output": "8"}, {"input": "5\n10 9 8 7 6\n", "output": "1"}], "test": "#undef NDEBUG\n#include<assert.h>\nint main(){\n    assert(solution(\"10\\n1 2 3 2 4 5 6 8 5 9\\n\") == \"5\");\n    assert(solution(\"5\\n9 8 7 6 5\\n\") == \"1\");\n    assert(solution(\"7\\n1 2 3 4 5 6 7\\n\") == \"7\");\n    assert(solution(\"6\\n10 20 30 40 50 60\\n\") == \"6\");\n    assert(solution(\"3\\n100 150 200\\n\") == \"3\");\n    assert(solution(\"12\\n5 4 3 2 3 4 5 6 5 4 3 2\\n\") == \"5\");\n    assert(solution(\"6\\n10 11 12 13 12 11\\n\") == \"4\");\n    assert(solution(\"7\\n100 90 80 70 80 90 100\\n\") == \"4\");\n    assert(solution(\"10\\n1 3 5 7 9 11 13 15 17 19\\n\") == \"10\");\n    assert(solution(\"4\\n1 2 1 2\\n\") == \"2\");\n    assert(solution(\"5\\n5 4 3 2 1\\n\") == \"1\");\n    assert(solution(\"8\\n5 2 3 4 5 6 7 8\\n\") == \"7\");\n    assert(solution(\"6\\n1 2 3 2 1 2\\n\") == \"3\");\n    assert(solution(\"3\\n1 2 3\\n\") == \"3\");\n    assert(solution(\"4\\n8 6 2 1\\n\") == \"1\");\n    assert(solution(\"6\\n3 2 1 2 3 4\\n\") == \"4\");\n    assert(solution(\"5\\n1 2 3 4 5\\n\") == \"5\");\n    assert(solution(\"6\\n6 5 4 3 2 1\\n\") == \"1\");\n    assert(solution(\"9\\n2 4 6 8 10 12 14 16 18\\n\") == \"9\");\n    assert(solution(\"10\\n10 9 8 7 6 5 4 3 2 1\\n\") == \"1\");\n    assert(solution(\"5\\n5 4 5 4 5\\n\") == \"2\");\n    assert(solution(\"7\\n6 5 4 3 4 5 6\\n\") == \"4\");\n    assert(solution(\"3\\n1 2 1\\n\") == \"2\");\n    assert(solution(\"5\\n10 11 12 13 14\\n\") == \"5\");\n    assert(solution(\"1\\n100\\n\") == \"1\");\n    assert(solution(\"8\\n1 2 3 2 1 2 3 4\\n\") == \"4\");\n    assert(solution(\"5\\n1 2 3 2 1\\n\") == \"3\");\n    assert(solution(\"9\\n1 2 3 4 5 6 7 8 9\\n\") == \"9\");\n    assert(solution(\"5\\n2 1 2 1 2\\n\") == \"2\");\n    assert(solution(\"3\\n2 1 2\\n\") == \"2\");\n    assert(solution(\"5\\n10 20 30 40 50\\n\") == \"5\");\n    assert(solution(\"5\\n50 40 30 20 10\\n\") == \"1\");\n    assert(solution(\"6\\n1 2 3 1 2 3\\n\") == \"3\");\n    assert(solution(\"8\\n1 2 3 4 3 2 4 5\\n\") == \"4\");\n    assert(solution(\"9\\n10 20 30 40 30 20 10 5 7\\n\") == \"4\");\n    assert(solution(\"12\\n5 4 3 2 1 2 3 4 5 6 7 8\\n\") == \"8\");\n    assert(solution(\"4\\n1 2 3 4\\n\") == \"4\");\n    assert(solution(\"8\\n1 2 3 4 5 6 7 8\\n\") == \"8\");\n    assert(solution(\"5\\n10 9 8 7 6\\n\") == \"1\");\n    return 0; \n}", "prompt": "/*On a scorching summer day, KC is extremely unhappy. He would rather endure the cold of the Arctic than the summer of Xiamen. Recently, he started researching the weather changes. He hopes to predict the future weather using the research results.\n\nAfter experiencing many difficulties, he collected a continuous series of highest temperature data of length N (1 <= N <= 10^6).\n\nNow, he wants to know the longest continuous days of rising highest temperatures.\n\ninput_format:\nLine 1: An integer $N$. $1 \\leq N \\leq 10^6$\n\nLine 2: An integer separated by $N$Spaces, indicating the maximum temperature for consecutive $N$days. $0 \\leq$Maximum temperature $\\leq 10^9$.\n\noutput_format:\nRow 1: An integer indicating the longest consecutive days with a consistently rising maximum temperature.\n*/\n\n#include<sstream>\n#include<stdlib.h>\n#include<algorithm>\n#include<math.h>\n#include<stdio.h>\n#include<vector>\n#include<string>\n#include<climits>\n#include<cstring>\n#include<iostream>\nusing namespace std;\n\n             \nstring solution(string std_in){\n    istringstream iss(std_in);\n             ", "constraints": "", "samples": [["10\n1 2 3 2 4 5 6 8 5 9\n", "5"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}}
{"task_id": "P1528", "title": "切蛋糕", "difficulty": "advanced", "nl": "Facer bought n cakes today, but unfortunately they were discovered by the lazy good-eating guys in the information group, such as Qiuqiu, so he had to waste some cakes to fill their mouths. He promised to leave a bite for each person and measured the size of each person's mouth. Facer has a knife and can cut cakes, but he cannot combine two pieces of cake, nor can he give any person two pieces of cake. Now the question is, how can Facer cut the cakes to satisfy the most people? (Facer's knife is very strong and will not waste cake when cutting.)", "code": "#include<stdio.h>\n#include<stdlib.h>\n#include<algorithm>\n#include<queue>\nusing namespace std;\nint c[51],p[1100],n,m,b[51];\npriority_queue<int> tmp;\nbool cmp(int x,int y){\n\treturn x>y;\n}\nbool check(int N){\n\tint i,j,time=1000;\n\twhile(time--){//既然拼RP，当然要多rand几遍 \n\t\tfor(i=1;i<=n;i++)\n\t\t\tb[i]=c[i];//复制一份蛋糕副本 \n\t\trandom_shuffle(b+1,b+n+1);//该函数的功能是把一段区间随机打乱 \n\t\tint flag;\n\t\tfor(i=N;i>=1;i--){//这里对要满足的人从大到小枚举 \n\t\t\tflag=0;\n\t\t\tfor(j=1;j<=n;j++){//n比较小，暴力枚举蛋糕 \n\t\t\t\tif(b[j]>=p[i]){\n\t\t\t\t\tflag=1;\n\t\t\t\t\tb[j]-=p[i];\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(!flag) break;//如果找不到可以满足这个口的蛋糕，说明不行 \n\t\t}\n\t\tif(flag) return true;\n\t}\n\treturn false;\n}\nint main(){\n\tint i,j,l,r,mid,ans=0;\n\tscanf(\"%d\",&n);\n\tfor(i=1;i<=n;i++)\n\t\tscanf(\"%d\",&c[i]);\n\tscanf(\"%d\",&m);\n\tfor(i=1;i<=m;i++)\n\t\tscanf(\"%d\",&p[i]);\n\tsort(p+1,p+m+1);//贪心，口小的人优先取 \n\tl=0;r=m;\n\twhile(l<=r){//二分 \n\t\tmid=l+r>>1;\n\t\tif(mid>=0&&check(mid)){\n\t\t\tans=mid;\n\t\t\tl=mid+1;\n\t\t}\n\t\telse r=mid-1;\n\t}\n\tprintf(\"%d\",ans);\n\treturn 0;\n}", "step": ["Read inputs for the number of cake types and cakes, the number of people and their capacities.", "Sort the capacities of people in increasing order and calculate the sum of their capacities.", "Determine the maximum number of people possible under certain constraints using binary search.", "Use depth-first search to check if the maximum number of people is feasible, and return the result.", "Output the maximum number of people that can eat the cakes."], "nl_cn": "Facer今天买了 $n$ 块蛋糕，不料被信息组中球球等好吃懒做的家伙发现了，没办法，只好浪费一点来填他们的嘴巴。他答应给每个人留一口，然后量了量每个人口的大小。Facer 有把刀，可以切蛋糕，但他不能把两块蛋糕拼起来，但是他又不会给任何人两块蛋糕。现在问你，facer 怎样切蛋糕，才能满足最多的人。（facer 的刀很强，切的时候不会浪费蛋糕）。\n\n \n ", "test_cases": [{"input": "4\r\n30\r\n40\r\n50\r\n25\r\n10\r\n15\r\n16\r\n17\r\n18\r\n19\r\n20\r\n21\r\n25\r\n24\r\n30\r\n\r\n \r\n", "output": "7"}, {"input": "4\n30\n40\n50\n25\n10\n15\n16\n17\n18\n19\n20\n21\n25\n24\n30\n", "output": "7"}, {"input": "8\n10\n10\n10\n10\n10\n10\n10\n10\n3\n3\n3\n3\n3\n3\n", "output": "3"}, {"input": "7\n2\n4\n6\n8\n10\n12\n14\n3\n5\n7\n9\n11\n13\n15\n", "output": "3"}, {"input": "4\n4\n4\n4\n4\n2\n2\n2\n2\n", "output": "2"}, {"input": "3\r\n10\r\n7\r\n6\r\n2\r\n3\r\n4\r\n5\r\n6\r\n\r\n \r\n", "output": "2"}, {"input": "2\r\n6\r\n8\r\n2\r\n4\r\n6\r\n8\r\n\r\n \r\n", "output": "2"}, {"input": "5\r\n10\r\n20\r\n30\r\n15\r\n25\r\n3\r\n5\r\n10\r\n15\r\n20\r\n\r\n \r\n", "output": "3"}, {"input": "4\r\n8\r\n16\r\n24\r\n32\r\n3\r\n4\r\n5\r\n6\r\n7\r\n\r\n \r\n", "output": "3"}], "test": "#undef NDEBUG\n#include<assert.h>\nint main(){\n    assert(solution(\"4\\r\\n30\\r\\n40\\r\\n50\\r\\n25\\r\\n10\\r\\n15\\r\\n16\\r\\n17\\r\\n18\\r\\n19\\r\\n20\\r\\n21\\r\\n25\\r\\n24\\r\\n30\\r\\n\\r\\n \\r\\n\") == \"7\");\n    assert(solution(\"4\\n30\\n40\\n50\\n25\\n10\\n15\\n16\\n17\\n18\\n19\\n20\\n21\\n25\\n24\\n30\\n\") == \"7\");\n    assert(solution(\"8\\n10\\n10\\n10\\n10\\n10\\n10\\n10\\n10\\n3\\n3\\n3\\n3\\n3\\n3\\n\") == \"3\");\n    assert(solution(\"7\\n2\\n4\\n6\\n8\\n10\\n12\\n14\\n3\\n5\\n7\\n9\\n11\\n13\\n15\\n\") == \"3\");\n    assert(solution(\"4\\n4\\n4\\n4\\n4\\n2\\n2\\n2\\n2\\n\") == \"2\");\n    assert(solution(\"3\\r\\n10\\r\\n7\\r\\n6\\r\\n2\\r\\n3\\r\\n4\\r\\n5\\r\\n6\\r\\n\\r\\n \\r\\n\") == \"2\");\n    assert(solution(\"2\\r\\n6\\r\\n8\\r\\n2\\r\\n4\\r\\n6\\r\\n8\\r\\n\\r\\n \\r\\n\") == \"2\");\n    assert(solution(\"5\\r\\n10\\r\\n20\\r\\n30\\r\\n15\\r\\n25\\r\\n3\\r\\n5\\r\\n10\\r\\n15\\r\\n20\\r\\n\\r\\n \\r\\n\") == \"3\");\n    assert(solution(\"4\\r\\n8\\r\\n16\\r\\n24\\r\\n32\\r\\n3\\r\\n4\\r\\n5\\r\\n6\\r\\n7\\r\\n\\r\\n \\r\\n\") == \"3\");\n    return 0; \n}", "prompt": "/*Facer bought n cakes today, but unfortunately they were discovered by the lazy good-eating guys in the information group, such as Qiuqiu, so he had to waste some cakes to fill their mouths. He promised to leave a bite for each person and measured the size of each person's mouth. Facer has a knife and can cut cakes, but he cannot combine two pieces of cake, nor can he give any person two pieces of cake. Now the question is, how can Facer cut the cakes to satisfy the most people? (Facer's knife is very strong and will not waste cake when cutting.)\n\ninput_format:\nThe first row is $n$. The facer has $n$cakes. Next, $n$lines, each representing the size of a cake. Another line with a number $m$for the number of people in the field, and then $m$lines with one number per line for the size of a person's mouth. $(1\\le n\\le 50$, $1\\le m\\le 1024)$\n\noutput_format:\nThe maximum number of mouths facer can fill in a line.\n*/\n\n#include<sstream>\n#include<stdlib.h>\n#include<algorithm>\n#include<math.h>\n#include<stdio.h>\n#include<vector>\n#include<string>\n#include<climits>\n#include<cstring>\n#include<iostream>\nusing namespace std;\n\n             \nstring solution(string std_in){\n    istringstream iss(std_in);\n             ", "constraints": "", "samples": [["4\r\n30\r\n40\r\n50\r\n25\r\n10\r\n15\r\n16\r\n17\r\n18\r\n19\r\n20\r\n21\r\n25\r\n24\r\n30\r\n\r\n \r\n", "7\r\n"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072]}}
{"task_id": "P3213", "title": "[HNOI2011]勾股定理", "difficulty": "advanced", "nl": "MoMo is recently studying Pythagorean theorem. For two positive integers A and B, if there exists a positive integer C such that A^2 + B^2 = C^2, and A and B are coprime, then (A,B) is called a coprime Pythagorean couple.\n\nOne day, MoMo got N sticks, each of which has a positive integer length. She is going to choose several sticks to play a jigsaw puzzle game. In order to make the pattern messy and beautiful, she hopes that the lengths of any two selected sticks are not coprime Pythagorean couples. Now, MoMo wants to know how many ways are there to choose sticks that meet the requirements. Since the answer may be large, you only need to output the result modulo $10^9+7$.", "code": "#include<bits/stdc++.h>\nusing namespace std;\n\nconst int mod = 1e9 + 7;\nint PW2[1000005];\n\nconst int maxN = 1e6;\n\nint n;\nint num[1000005];\n\nvector<int> to[1000005];\nbool vis[1000005];\nbool ins[1000005];\nint  sat[1000005];\n\nvector<int> QE;\n\nvoid dfs_init( int x, int f ) {\n    vis[x] = true;\n    for( auto N : to[x] ) if( N ^ f ) {\n        if( !vis[N] ) dfs_init( N, x );\n        else {\n            if( !ins[x] ) QE.push_back( x );\n            if( !ins[N] ) QE.push_back( N );\n            ins[x] = ins[N] = true;\n        }\n    }\n}\n\nint dp[1000005][2];\nint des[1000005];\nint pnt = 0;\n\nint dfs_dp( int x ) {\n    dp[x][0] = 1; dp[x][1] = PW2[ num[x] ] - 1; des[x] = pnt;\n    for( auto N : to[x] ) if( des[N] ^ pnt ) {\n        dp[x][0] = 1ll * dp[x][0] * dfs_dp( N ) % mod;\n        dp[x][1] = 1ll * dp[x][1] * dp[N][0] % mod;\n    }\n    if( sat[x] ==  1 ) dp[x][0] = 0;\n    if( sat[x] == -1 ) dp[x][1] = 0;\n    return ( dp[x][0] + dp[x][1] ) % mod;\n}\n\nbool check() {\n    for( auto P : QE ) for( auto N : to[P] ) \n      { if( sat[P] == 1 and sat[N] == 1 ) return false; }\n    return true;\n}\n\nint query(int x) {\n    QE.clear(); dfs_init( x, x );\n    int ans = 0;\n    int len = 1 << QE.size();\n    for( int i = 0; i < len; i ++ ) {\n        for( int j = 0; j < QE.size(); j ++ ) \n          { sat[ QE[j] ] = (i & (1 << j)) ? 1 : -1; }\n        if( check() ) pnt ++, ( ans += dfs_dp( x ) ) %= mod;\n    }\n    for( int i = 0; i < QE.size(); i ++ ) sat[ QE[i] ] = 0;\n    return ans;\n}\n\nint main(){\n    int n; cin >> n; PW2[0] = 1;\n    for(int i = 1;i <= n;i ++) PW2[i] = PW2[i - 1] * 2 % mod;\n    for(int i = 1;i <= n;i ++) { int x; cin >> x; num[x] ++; }\n    for(int i = 1;i * i <= maxN;i ++) for(int j = i + 1;2 * i * j <= maxN;j ++) {\n        if( j * j > 2 * maxN ) break;\n        int x = j * j - i * i, y = 2 * i * j;\n        if( x > maxN or y > maxN ) continue;\n        if( !num[x] or !num[y] or __gcd( x, y ) != 1 ) continue;\n        to[x].push_back(y); to[y].push_back(x);\n    }\n    int ans = 1;\n    for(int i = 1;i <= maxN;i ++) if( num[i] and !vis[i] ) \n      { ans = 1ll * ans * query(i) % mod; }\n    cout << ( ans - 1 + mod ) % mod;\n    return 0;\n}", "step": ["Initializes and defines the constants mod, PW2, maxN, n, num, to, vis, ins, and sat", "Performs dfs_init which determines sets of elements that form circles", "Performs dfs_dp which recursively calculates the value for each element based on its children", "Checks for elements that violate a given condition", "Calculates and returns the final value based on all elements that form circles", "Prints the final calculated value"], "nl_cn": "沫沫最近在研究勾股定理。对于两个正整数 A 与 B，若存在正整数 C 使得 A2+B2=C2，且 A 与 B 互质，则称(A,B)为一个互质勾股数对。\n\n\n有一天，沫沫得到了 N 根木棍，其长度都是正整数，她准备从中挑选出若干根木棍来玩拼图游戏，为了使拼出的图案有凌乱美，她希望挑选出的木棍中任意两根的长度均不是互质勾股数对。现在，沫沫想知道有多少种满足要求的挑选木棍的方案。由于答案可能很大，你只要输出答案对 $10^9+7$ 取模的结果。\n", "test_cases": [{"input": "4\t\t\t\t\n5 12 35 5\t\n", "output": "8"}, {"input": "4\n5 12 35 5\n", "output": "8"}, {"input": "1\n1000000\n", "output": "1"}, {"input": "2\n3 4\n", "output": "2"}, {"input": "1\n50\n", "output": "1"}, {"input": "1\n43\n", "output": "1"}, {"input": "2\n18 20\n", "output": "3"}], "test": "#undef NDEBUG\n#include<assert.h>\nint main(){\n    assert(solution(\"4\\t\\t\\t\\t\\n5 12 35 5\\t\\n\") == \"8\");\n    assert(solution(\"4\\n5 12 35 5\\n\") == \"8\");\n    assert(solution(\"1\\n1000000\\n\") == \"1\");\n    assert(solution(\"2\\n3 4\\n\") == \"2\");\n    assert(solution(\"1\\n50\\n\") == \"1\");\n    assert(solution(\"1\\n43\\n\") == \"1\");\n    assert(solution(\"2\\n18 20\\n\") == \"3\");\n    return 0; \n}", "prompt": "/*MoMo is recently studying Pythagorean theorem. For two positive integers A and B, if there exists a positive integer C such that A^2 + B^2 = C^2, and A and B are coprime, then (A,B) is called a coprime Pythagorean couple.\n\nOne day, MoMo got N sticks, each of which has a positive integer length. She is going to choose several sticks to play a jigsaw puzzle game. In order to make the pattern messy and beautiful, she hopes that the lengths of any two selected sticks are not coprime Pythagorean couples. Now, MoMo wants to know how many ways are there to choose sticks that meet the requirements. Since the answer may be large, you only need to output the result modulo $10^9+7$.\n\ninput_format:\nTo read data from the file input.txt, the first line of the input file is a positive integer N, indicating how many sticks there are.\n\nThe second line of the input file is N positive integers separated by Spaces h1, h2,... , hN, where for 1≤i≤N, hi represents the length of the I-th stick.\n\nEnsure that 30% of the input data meets the requirements for $1≤i≤N$. $1≤h_i≤3000$.\n\nThe other 30% of the data meets the requirement of $1≤i≤N$, $1≤hi≤200000$,\n\nThe remaining 40% of the data meets the requirements of $1≤i≤N$, $20000≤h_i≤ 1,000,000 $,\n\n100% of the data must be between $N and $1,000,000.\n\noutput_format:\nThe output file output.txt contains only one non-negative integer, representing the result of modulo 109+7 for the number of schemes that meet the requirements for selecting sticks.\n*/\n\n#include<sstream>\n#include<stdlib.h>\n#include<algorithm>\n#include<math.h>\n#include<stdio.h>\n#include<vector>\n#include<string>\n#include<climits>\n#include<cstring>\n#include<iostream>\nusing namespace std;\n\n             \nstring solution(string std_in){\n    istringstream iss(std_in);\n             ", "constraints": "样例解释：（5,12）与（12,35）是互质勾股数对，故满足要求的挑选木棍的方案有8种，即：\n\n\n{5}，{12}，{35}，{5}，{5,35}，{35,5}，{5,5}，{5,35,5}。\n", "samples": [["4\t\t\t\t\n5 12 35 5\t\n", "8"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}}
{"task_id": "P2151", "title": "[SDOI2009] HH去散步", "difficulty": "advanced", "nl": "HH has a habit of walking for a hundred steps after meals. The so-called hundred steps walk is a walk, which is to walk a certain distance in a certain time. However, HH is also a person who likes changes, so he won't immediately walk back along the path he just walked. Because HH is a person who likes changes, the path he walks every day is not exactly the same. He wants to know how many ways there are for him to take a walk.\n\nNow, given a map of the school (assuming that the length of each road is the same and is 1), the question is how many paths are there from the given point A to the given point B that meet the conditions with a length of t.", "code": "#include<cstdio>\n#include<algorithm>\n#include<cstring>\nusing namespace std;\nconst int mod=45989;\nstruct Matr{\n\tint m[150][150];\n\tint R,C;\n\tMatr() {memset(m,0,sizeof(m));}\n\tMatr operator * (const Matr &a) const\n\t{\n\t\tMatr t;\n\t\tt.R=R;t.C=a.C;\n\t\tfor(int i=1;i<=R;i++)\n\t\tfor(int j=1;j<=t.C;j++)\n\t\tfor(int k=1;k<=C;k++)\n\t\tt.m[i][j]=(t.m[i][j]+(m[i][k]*a.m[k][j])%mod)%mod;\n\t\treturn t;\n\t}\n}ini,trans;//分别是初始矩阵和转移矩阵\nstruct E{\n\tint u,v;\n}e[127];//为了更方便的枚举边使用邻接表存储边\nint first[57],nt[127],ES;\nint N,M,S,T,t;\nMatr operator ^ (Matr a,int k)//矩阵快速幂\n{\n\tMatr s;\n\ts.C=a.C;s.R=a.R;\n\tfor(int i=1;i<=a.R;i++)\n\t\ts.m[i][i]=1;\n\twhile(k)\n\t{\n\t\tif(k&1) s=s*a;\n\t\ta=a*a;\n\t\tk>>=1;\n\t}\n\treturn s;\n}\nint anti(int x)//因为我是从1开始存边所以不能异或只能自己写函数了\n{\n\treturn x%2==0?x-1:x+1;\n}\nint main()\n{\n\tscanf(\"%d%d%d%d%d\",&N,&M,&t,&S,&T);\n\tif(t==0)//特殊判断t=0的情况\n\t{\n\t\tputs(\"0\");\n\t\treturn 0;\n\t}\n\tint u,v;S++;T++;//题目给的是0开始编号要记得加\n\tfor(int i=1;i<=M;i++)\n\t{\n\t\tscanf(\"%d%d\",&u,&v);u++;v++;//要记得加\n\t\te[++ES]=(E){u,v};\n\t\tnt[ES]=first[u];\n\t\tfirst[u]=ES;\n\t\te[++ES]=(E){v,u};\n\t\tnt[ES]=first[v];\n\t\tfirst[v]=ES;\n\t}\n\tfor(int i=1;i<=ES;i++)\n\t{//如果某一条边的始点与当前这条边的终点重合\n         //则称当前这条边可以转移到\"某一条边\"\n\t\tfor(int k=first[e[i].v];k;k=nt[k])\n\t\t{\n\t\t\tif(k!=anti(i))//记得不可以是反边，否则会违背题目要求\n\t\t\ttrans.m[k][i]++;//下标千万莫写反了，自己要搞清楚\n\t\t}\n\t}\n\ttrans.C=trans.R=ES;//矩阵大小表示\n\tini.R=ES;ini.C=1;//表示错了乘法无法正确进行\n\tfor(int i=first[S];i;i=nt[i])\n\t\tini.m[i][1]++;//由于初状态不好确定  \n        //干脆就把初始矩阵当成已经走出的距离为1时的状态\n\ttrans=trans^(t-1);\n        //因为初始矩阵当成了距离为1的状态这里只能t-1次幂\n\ttrans=trans*ini;\n\tint ans=0;\n\tfor(int i=first[T];i;i=nt[i])\n        //直接枚举终点为给定点的边不太好枚举\n        //就枚举始点为给定终点的边然后取反边即可\n\tans=(ans+trans.m[anti(i)][1])%mod;//我最开始还没取模.....\n\tprintf(\"%d\",ans);\n\treturn 0;\n}", "step": ["Read input N, M, t, S and T.", "Create structure Matr to represent matrix, and struct E to represent edges.", "Read edges and store them in a linked list.", "Fill in the transition matrix with 1's and 0's according to the graph.", "Raise the transition matrix to the power t-1.", "Multiply the transition matrix by a matrix representing the starting node S.", "Sum up the values of the entries in the resulting matrix corresponding to T's neighbors."], "nl_cn": "HH有个一成不变的习惯，喜欢饭后百步走。所谓百步走，就是散步，就是在一定的时间 内，走过一定的距离。 但是同时HH又是个喜欢变化的人，所以他不会立刻沿着刚刚走来的路走回。 又因为HH是个喜欢变化的人，所以他每天走过的路径都不完全一样，他想知道他究竟有多 少种散步的方法。\n\n现在给你学校的地图（假设每条路的长度都是一样的都是1），问长度为t，从给定地 点A走到给定地点B共有多少条符合条件的路径\n", "test_cases": [{"input": "4 5 3 0 0\n0 1\n0 2\n0 3\n2 1\n3 2", "output": "4"}, {"input": "3 2 2 0 2\n0 1\n1 2\n", "output": "1"}, {"input": "3 1 3 0 1\n0 1\n", "output": "0"}, {"input": "3 2 3 0 2\n0 1\n1 2\n", "output": "0"}, {"input": "2 2 2 0 1\n0 1\n1 0\n", "output": "0"}, {"input": "6 5 4 3 5\n0 1\n0 5\n1 2\n5 4\n4 3\n", "output": "0"}, {"input": "4 2 2 0 1\n0 1\n2 3\n", "output": "0"}, {"input": "5 4 3 1 4\n0 1\n0 2\n1 3\n2 4", "output": "1"}, {"input": "4 4 2 0 1\n1 2\n2 3\n2 0\n3 0", "output": "1"}, {"input": "6 5 4 0 5\n0 1\n0 2\n1 3\n2 3\n2 4", "output": "0"}, {"input": "6 6 2 3 1\n0 1\n0 2\n1 3\n2 4\n3 5\n4 5", "output": "0"}, {"input": "2 1 5 0 1\n1 0", "output": "0"}, {"input": "3 3 2 0 1\n0 1\n1 2\n0 2\n", "output": "1"}, {"input": "9 9 3 0 3\n0 1\n1 2\n2 8\n8 7\n7 6\n6 1\n2 3\n1 3\n3 4\n", "output": "1"}, {"input": "7 8 3 0 1\n0 1\n1 2\n2 3\n0 4\n2 4\n0 5\n5 4\n0 6\n", "output": "1"}, {"input": "4 4 2 0 2\n0 1\n1 2\n2 3\n0 3\n", "output": "2"}, {"input": "6 8 5 0 2\n0 1\n1 2\n2 3\n0 3\n0 4\n4 3\n2 5\n4 5\n", "output": "3"}, {"input": "3 2 2 1 0\n1 0\n2 1\n", "output": "0"}, {"input": "4 4 2 0 2\n0 1\n0 3\n2 1\n2 3\n", "output": "2"}, {"input": "2 1 3 0 1\n1 0\n", "output": "0"}, {"input": "3 3 2 0 1\n0 2\n0 1\n1 2\n", "output": "1"}, {"input": "2 1 2 0 0\n1 0\n", "output": "0"}, {"input": "4 3 3 1 0\n0 2\n0 1\n1 2\n", "output": "0"}, {"input": "5 6 2 0 3\n0 1\n0 2\n0 3\n1 3\n2 4\n3 4\n", "output": "1"}, {"input": "4 4 2 0 3\n0 1\n0 2\n0 3\n1 3\n", "output": "1"}], "test": "#undef NDEBUG\n#include<assert.h>\nint main(){\n    assert(solution(\"4 5 3 0 0\\n0 1\\n0 2\\n0 3\\n2 1\\n3 2\") == \"4\");\n    assert(solution(\"3 2 2 0 2\\n0 1\\n1 2\\n\") == \"1\");\n    assert(solution(\"3 1 3 0 1\\n0 1\\n\") == \"0\");\n    assert(solution(\"3 2 3 0 2\\n0 1\\n1 2\\n\") == \"0\");\n    assert(solution(\"2 2 2 0 1\\n0 1\\n1 0\\n\") == \"0\");\n    assert(solution(\"6 5 4 3 5\\n0 1\\n0 5\\n1 2\\n5 4\\n4 3\\n\") == \"0\");\n    assert(solution(\"4 2 2 0 1\\n0 1\\n2 3\\n\") == \"0\");\n    assert(solution(\"5 4 3 1 4\\n0 1\\n0 2\\n1 3\\n2 4\") == \"1\");\n    assert(solution(\"4 4 2 0 1\\n1 2\\n2 3\\n2 0\\n3 0\") == \"1\");\n    assert(solution(\"6 5 4 0 5\\n0 1\\n0 2\\n1 3\\n2 3\\n2 4\") == \"0\");\n    assert(solution(\"6 6 2 3 1\\n0 1\\n0 2\\n1 3\\n2 4\\n3 5\\n4 5\") == \"0\");\n    assert(solution(\"2 1 5 0 1\\n1 0\") == \"0\");\n    assert(solution(\"3 3 2 0 1\\n0 1\\n1 2\\n0 2\\n\") == \"1\");\n    assert(solution(\"9 9 3 0 3\\n0 1\\n1 2\\n2 8\\n8 7\\n7 6\\n6 1\\n2 3\\n1 3\\n3 4\\n\") == \"1\");\n    assert(solution(\"7 8 3 0 1\\n0 1\\n1 2\\n2 3\\n0 4\\n2 4\\n0 5\\n5 4\\n0 6\\n\") == \"1\");\n    assert(solution(\"4 4 2 0 2\\n0 1\\n1 2\\n2 3\\n0 3\\n\") == \"2\");\n    assert(solution(\"6 8 5 0 2\\n0 1\\n1 2\\n2 3\\n0 3\\n0 4\\n4 3\\n2 5\\n4 5\\n\") == \"3\");\n    assert(solution(\"3 2 2 1 0\\n1 0\\n2 1\\n\") == \"0\");\n    assert(solution(\"4 4 2 0 2\\n0 1\\n0 3\\n2 1\\n2 3\\n\") == \"2\");\n    assert(solution(\"2 1 3 0 1\\n1 0\\n\") == \"0\");\n    assert(solution(\"3 3 2 0 1\\n0 2\\n0 1\\n1 2\\n\") == \"1\");\n    assert(solution(\"2 1 2 0 0\\n1 0\\n\") == \"0\");\n    assert(solution(\"4 3 3 1 0\\n0 2\\n0 1\\n1 2\\n\") == \"0\");\n    assert(solution(\"5 6 2 0 3\\n0 1\\n0 2\\n0 3\\n1 3\\n2 4\\n3 4\\n\") == \"1\");\n    assert(solution(\"4 4 2 0 3\\n0 1\\n0 2\\n0 3\\n1 3\\n\") == \"1\");\n    return 0; \n}", "prompt": "/*HH has a habit of walking for a hundred steps after meals. The so-called hundred steps walk is a walk, which is to walk a certain distance in a certain time. However, HH is also a person who likes changes, so he won't immediately walk back along the path he just walked. Because HH is a person who likes changes, the path he walks every day is not exactly the same. He wants to know how many ways there are for him to take a walk.\n\nNow, given a map of the school (assuming that the length of each road is the same and is 1), the question is how many paths are there from the given point A to the given point B that meet the conditions with a length of t.\n\ninput_format:\nFirst line: Five integers N, M, t, A, B. Where N is the number of intersections in the school, M is the number of roads in the school, t is the distance HH wants to walk, A is the starting point of the walk, and B is the end of the walk.\n\nThe next M rows, each with a set of Ai, Bi, indicate that there is a road from junction Ai to junction Bi. Data guaranteed Ai! = Bi, but there is no guarantee that there is at most one road connecting any two intersections. Intersections are numbered from 0 to N − 1. All data in a row is separated by a space with no extra space at the end of the row. There are no extra empty lines. Answer mode 45989.\n\noutput_format:\nOne line, representing the answer.\n*/\n\n#include<sstream>\n#include<stdlib.h>\n#include<algorithm>\n#include<math.h>\n#include<stdio.h>\n#include<vector>\n#include<string>\n#include<climits>\n#include<cstring>\n#include<iostream>\nusing namespace std;\n\n             \nstring solution(string std_in){\n    istringstream iss(std_in);\n             ", "constraints": "### 数据范围及约定\n\n对于 $30\\%$ 的数据，$N \\le 4$，$M \\le 10$，$t \\le 10$。\n\n对于 $100\\%$ 的数据，$N \\le 50$，$M \\le 60$，$t \\le 2^{30}$，$0 \\le A,B$。", "samples": [["4 5 3 0 0\n0 1\n0 2\n0 3\n2 1\n3 2", "4"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}}
{"task_id": "P1420", "title": "最长连号", "difficulty": "basic", "nl": "Given a positive integer sequence of length $n$, find the length of the longest consecutive natural numbers in the sequence, sorted in ascending order.", "code": "#include<bits/stdc++.h>       //神奇头文件不用解释\n#define INF 10234567\nusing namespace std;             //额……@_@\nint main()                                //不用递归\n{\n    int n,s[1001],ans=0,max=-INF;            //n表示输入有n个正整数，ans呢待会解释，max可以不用想了，一定是最后的答案,为什么被赋值为-INF下面解释\n    cin>>n;                                               //输入n\n    for(int i=1;i<=n;i++)                           //循环了n次\n        cin>>s[i];                                    //将数存进s数组里，其实也可以不存，这样会更好理解\n    for(int i=1;i<=n;i++)                          //仍旧循环n次，对n个数进行处理\n    {                                                         //以下以样例为例来解释代码：10\\n3 5 6 2 3 4 5 6 8 9\n        if(s[i+1]-s[i]==1)ans++;             //i从1到n，当i=1时s[i+1]表示3后面一个数，即为5，如果5-3==1，就说明3，5是连号，这里显然不是。如果是就将ans++，所以这里的ans只是为了临时存一下连号的个数，以此类推。\n        else ans=0;                                  //一旦发现了一次不连号，就将临时存储的数据变为0\n        if(ans>max)max=ans;                 //将max赋为-INF的原因是为了找到ans中的最大值，达到题目目的\n    }\n    cout<<++max;                                  //最后输出最大值\n}", "step": ["Initialize variables n, ans, temp, b and max with 0 and 1.", "Read the value of n and b.", "Loop from i = 1 to n - 1 and read the value of temp.", "Check if temp is equal to b + 1, if yes, increment max, otherwise reset max to 1.", "Update ans with the maximum value of max and ans.", "Set the value of b to temp.", "Print the value of ans and exit."], "nl_cn": "输入长度为 $n$ 的一个正整数序列，要求输出序列中最长连号的长度。\n\n连号指在序列中，从小到大的连续自然数。\n", "test_cases": [{"input": "10\n1 5 6 2 3 4 5 6 8 9", "output": "5"}, {"input": "5\n10 9 8 7 6\n", "output": "1"}, {"input": "6\n2 4 6 8 10 12\n", "output": "1"}, {"input": "4\n100 101 102 103\n", "output": "4"}, {"input": "8\n5 3 1 7 7 2 4 6\n", "output": "1"}, {"input": "10\n89 86 83 80 77 74 71 68 65 62\n", "output": "1"}, {"input": "4\n123 124 125 126\n", "output": "4"}, {"input": "9\n45 48 51 54 57 60 63 66 69\n", "output": "1"}, {"input": "6\n55 50 45 40 35 30\n", "output": "1"}, {"input": "7\n500 499 498 497 496 495 494\n", "output": "1"}, {"input": "6\n10 11 12 13 14 15\n", "output": "6"}, {"input": "3\n20 21 22\n", "output": "3"}, {"input": "4\n50 51 51 52\n", "output": "2"}, {"input": "7\n7 8 8 8 9 10 10\n", "output": "3"}, {"input": "2\n1 3\n", "output": "1"}, {"input": "7\n3 4 5 6 7 8 9\n", "output": "7"}, {"input": "4\n3 2 1 0\n", "output": "1"}, {"input": "3\n1000 1001 1002\n", "output": "3"}, {"input": "2\n50 52\n", "output": "1"}, {"input": "8\n1 2 3 4 5 6 7 8\n", "output": "8"}, {"input": "10\n7 6 5 4 3 2 1 0 -1 -2\n", "output": "1"}, {"input": "3\n10 20 30\n", "output": "1"}, {"input": "5\n1 2 3 4 5\n", "output": "5"}, {"input": "6\n10 11 12 13 15 16\n", "output": "4"}, {"input": "4\n5 4 3 2\n", "output": "1"}, {"input": "8\n1 3 5 7 9 11 13 15\n", "output": "1"}, {"input": "9\n5 6 7 8 9 10 11 12 13\n", "output": "9"}, {"input": "12\n10 11 12 14 15 16 20 21 22 23 24 25\n", "output": "6"}, {"input": "6\n5 6 7 10 11 12\n", "output": "3"}, {"input": "5\n100 200 300 400 500\n", "output": "1"}, {"input": "4\n1000 2000 3000 4000\n", "output": "1"}, {"input": "9\n1 2 3 4 5 7 8 9 10\n", "output": "5"}, {"input": "7\n765 767 769 771 773 775 777\n", "output": "1"}, {"input": "3\n-1 -2 -3\n", "output": "1"}, {"input": "6\n98 99 100 101 102 103\n", "output": "6"}, {"input": "10\n0 1 2 3 4 5 6 7 8 9\n", "output": "10"}, {"input": "5\n6 4 8 10 12\n", "output": "1"}, {"input": "5\n2 3 4 5 6\n", "output": "5"}, {"input": "6\n8 9 10 11 12 13\n", "output": "6"}, {"input": "4\n4 5 6 7\n", "output": "4"}, {"input": "3\n10 11 12\n", "output": "3"}, {"input": "5\n5 6 8 10 11\n", "output": "2"}, {"input": "2\n4 5\n", "output": "2"}, {"input": "4\n1 2 3 4\n", "output": "4"}, {"input": "3\n7 8 9\n", "output": "3"}, {"input": "5\n10 11 12 13 14\n", "output": "5"}, {"input": "8\n1 2 3 4 5 6 7 9\n", "output": "7"}, {"input": "9\n1 2 3 4 5 6 7 8 9\n", "output": "9"}, {"input": "4\n5 6 7 8\n", "output": "4"}, {"input": "6\n10 11 12 14 15 16\n", "output": "3"}], "test": "#undef NDEBUG\n#include<assert.h>\nint main(){\n    assert(solution(\"10\\n1 5 6 2 3 4 5 6 8 9\") == \"5\");\n    assert(solution(\"5\\n10 9 8 7 6\\n\") == \"1\");\n    assert(solution(\"6\\n2 4 6 8 10 12\\n\") == \"1\");\n    assert(solution(\"4\\n100 101 102 103\\n\") == \"4\");\n    assert(solution(\"8\\n5 3 1 7 7 2 4 6\\n\") == \"1\");\n    assert(solution(\"10\\n89 86 83 80 77 74 71 68 65 62\\n\") == \"1\");\n    assert(solution(\"4\\n123 124 125 126\\n\") == \"4\");\n    assert(solution(\"9\\n45 48 51 54 57 60 63 66 69\\n\") == \"1\");\n    assert(solution(\"6\\n55 50 45 40 35 30\\n\") == \"1\");\n    assert(solution(\"7\\n500 499 498 497 496 495 494\\n\") == \"1\");\n    assert(solution(\"6\\n10 11 12 13 14 15\\n\") == \"6\");\n    assert(solution(\"3\\n20 21 22\\n\") == \"3\");\n    assert(solution(\"4\\n50 51 51 52\\n\") == \"2\");\n    assert(solution(\"7\\n7 8 8 8 9 10 10\\n\") == \"3\");\n    assert(solution(\"2\\n1 3\\n\") == \"1\");\n    assert(solution(\"7\\n3 4 5 6 7 8 9\\n\") == \"7\");\n    assert(solution(\"4\\n3 2 1 0\\n\") == \"1\");\n    assert(solution(\"3\\n1000 1001 1002\\n\") == \"3\");\n    assert(solution(\"2\\n50 52\\n\") == \"1\");\n    assert(solution(\"8\\n1 2 3 4 5 6 7 8\\n\") == \"8\");\n    assert(solution(\"10\\n7 6 5 4 3 2 1 0 -1 -2\\n\") == \"1\");\n    assert(solution(\"3\\n10 20 30\\n\") == \"1\");\n    assert(solution(\"5\\n1 2 3 4 5\\n\") == \"5\");\n    assert(solution(\"6\\n10 11 12 13 15 16\\n\") == \"4\");\n    assert(solution(\"4\\n5 4 3 2\\n\") == \"1\");\n    assert(solution(\"8\\n1 3 5 7 9 11 13 15\\n\") == \"1\");\n    assert(solution(\"9\\n5 6 7 8 9 10 11 12 13\\n\") == \"9\");\n    assert(solution(\"12\\n10 11 12 14 15 16 20 21 22 23 24 25\\n\") == \"6\");\n    assert(solution(\"6\\n5 6 7 10 11 12\\n\") == \"3\");\n    assert(solution(\"5\\n100 200 300 400 500\\n\") == \"1\");\n    assert(solution(\"4\\n1000 2000 3000 4000\\n\") == \"1\");\n    assert(solution(\"9\\n1 2 3 4 5 7 8 9 10\\n\") == \"5\");\n    assert(solution(\"7\\n765 767 769 771 773 775 777\\n\") == \"1\");\n    assert(solution(\"3\\n-1 -2 -3\\n\") == \"1\");\n    assert(solution(\"6\\n98 99 100 101 102 103\\n\") == \"6\");\n    assert(solution(\"10\\n0 1 2 3 4 5 6 7 8 9\\n\") == \"10\");\n    assert(solution(\"5\\n6 4 8 10 12\\n\") == \"1\");\n    assert(solution(\"5\\n2 3 4 5 6\\n\") == \"5\");\n    assert(solution(\"6\\n8 9 10 11 12 13\\n\") == \"6\");\n    assert(solution(\"4\\n4 5 6 7\\n\") == \"4\");\n    assert(solution(\"3\\n10 11 12\\n\") == \"3\");\n    assert(solution(\"5\\n5 6 8 10 11\\n\") == \"2\");\n    assert(solution(\"2\\n4 5\\n\") == \"2\");\n    assert(solution(\"4\\n1 2 3 4\\n\") == \"4\");\n    assert(solution(\"3\\n7 8 9\\n\") == \"3\");\n    assert(solution(\"5\\n10 11 12 13 14\\n\") == \"5\");\n    assert(solution(\"8\\n1 2 3 4 5 6 7 9\\n\") == \"7\");\n    assert(solution(\"9\\n1 2 3 4 5 6 7 8 9\\n\") == \"9\");\n    assert(solution(\"4\\n5 6 7 8\\n\") == \"4\");\n    assert(solution(\"6\\n10 11 12 14 15 16\\n\") == \"3\");\n    return 0; \n}", "prompt": "/*Given a positive integer sequence of length $n$, find the length of the longest consecutive natural numbers in the sequence, sorted in ascending order.\n\ninput_format:\nThe first line, an integer $n$.\n\nOn the second line, $n$is an integer $a_i$, separated by a space.\n\noutput_format:\nA number, the number of the longest consecutive sign.\n*/\n\n#include<sstream>\n#include<stdlib.h>\n#include<algorithm>\n#include<math.h>\n#include<stdio.h>\n#include<vector>\n#include<string>\n#include<climits>\n#include<cstring>\n#include<iostream>\nusing namespace std;\n\n             \nstring solution(string std_in){\n    istringstream iss(std_in);\n             ", "constraints": "#### 数据规模与约定\n\n对于 $100\\%$ 的数据，保证 $1 \\leq n \\leq 10^4$，$1 \\leq a_i \\leq 10^9$。", "samples": [["10\n1 5 6 2 3 4 5 6 8 9", "5\n\n"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000], "memory": [131072, 131072, 131072, 131072, 131072]}}
{"task_id": "P8355", "title": "「WHOI-1」Ranker", "difficulty": "basic", "nl": "Given a string of parentheses $s$. Define an operation as swapping two adjacent characters in the string.\n\nYour task is to find the maximum length of a prefix of $s$ such that it can be transformed into a string with balanced parentheses by performing a series of operations.", "code": "#include<bits/stdc++.h>\n#define ll long long\nusing namespace std;\nstring s;\nint len,l,r;\nint main(){\n\tcin>>len;\n\tcin>>s;\n\tfor(int i=0;i<len;i++){\n\t\tif(s[i]=='(') l++;//左括号\n\t\telse if(s[i]==')') r++;\t//右括号\n\t}\n\tcout<<min(l,r)*2;//左括号个数和右括号个数中较小的个数就是匹配串的个数，一个串有2个括号\n\treturn 0;\n}", "step": ["Take input string length and string from the user.", "Initialize the count of left and right parentheses as 0.", "Loop through the string and increment the count of left parentheses if the current character is '('. Likewise, increment the count of right parentheses if the current character is ')'.", "Return the minimum count between left and right parentheses multiplied by 2."], "nl_cn": "给你一个括号串 $s$。定义一次操作是交换他们当中相邻的两个字符。\n\n你的任务是找出若干次操作后 $s$ 的括号匹配前缀长度最大值。\n", "test_cases": [{"input": "3\n(()", "output": "2"}, {"input": "2\n()", "output": "2"}, {"input": "5\n((())\n", "output": "4"}, {"input": "7\n())((((\n", "output": "4"}, {"input": "8\n(((())))\n", "output": "8"}, {"input": "10\n((()(())))\n", "output": "10"}, {"input": "11\n(())(()(()))\n", "output": "10"}, {"input": "13\n((((()()())))\n", "output": "12"}, {"input": "15\n((()(((())((\n", "output": "6"}, {"input": "10\n((((()))))", "output": "10"}, {"input": "6\n()()()", "output": "6"}, {"input": "7\n((())))", "output": "6"}, {"input": "12\n(((((())))))", "output": "12"}, {"input": "10\n((())(())(", "output": "8"}, {"input": "4\n(()(", "output": "2"}, {"input": "7\n(((((((", "output": "0"}, {"input": "11\n(((((((((((", "output": "0"}, {"input": "3\n(())\n", "output": "2"}, {"input": "6\n((()))\n", "output": "6"}, {"input": "4\n(())()\n", "output": "4"}, {"input": "7\n(()())\n", "output": "6"}, {"input": "9\n()()()()\n", "output": "8"}, {"input": "11\n(()())()()\n", "output": "10"}, {"input": "13\n(()())(())()\n", "output": "12"}, {"input": "15\n((()))()()()()\n", "output": "14"}, {"input": "16\n(())(())(())()\n", "output": "14"}, {"input": "17\n(()())(())(())()\n", "output": "16"}, {"input": "20\n(())(())(())(())()\n", "output": "18"}, {"input": "21\n(()())(())(())(())()\n", "output": "20"}, {"input": "5\n()())\n", "output": "4"}, {"input": "8\n())((()))\n", "output": "8"}, {"input": "7\n()()())\n", "output": "6"}, {"input": "4\n()()\n", "output": "4"}, {"input": "1\n(\n", "output": "0"}, {"input": "10\n(((())(()\n", "output": "6"}, {"input": "11\n((()()()()\n", "output": "8"}, {"input": "3\n((", "output": "0"}, {"input": "2\n))", "output": "0"}, {"input": "4\n(())", "output": "4"}, {"input": "5\n()(())", "output": "4"}, {"input": "8\n((()()))", "output": "8"}, {"input": "9\n(((())))", "output": "8"}, {"input": "11\n((()((()))))", "output": "10"}], "test": "#undef NDEBUG\n#include<assert.h>\nint main(){\n    assert(solution(\"3\\n(()\") == \"2\");\n    assert(solution(\"2\\n()\") == \"2\");\n    assert(solution(\"5\\n((())\\n\") == \"4\");\n    assert(solution(\"7\\n())((((\\n\") == \"4\");\n    assert(solution(\"8\\n(((())))\\n\") == \"8\");\n    assert(solution(\"10\\n((()(())))\\n\") == \"10\");\n    assert(solution(\"11\\n(())(()(()))\\n\") == \"10\");\n    assert(solution(\"13\\n((((()()())))\\n\") == \"12\");\n    assert(solution(\"15\\n((()(((())((\\n\") == \"6\");\n    assert(solution(\"10\\n((((()))))\") == \"10\");\n    assert(solution(\"6\\n()()()\") == \"6\");\n    assert(solution(\"7\\n((())))\") == \"6\");\n    assert(solution(\"12\\n(((((())))))\") == \"12\");\n    assert(solution(\"10\\n((())(())(\") == \"8\");\n    assert(solution(\"4\\n(()(\") == \"2\");\n    assert(solution(\"7\\n(((((((\") == \"0\");\n    assert(solution(\"11\\n(((((((((((\") == \"0\");\n    assert(solution(\"3\\n(())\\n\") == \"2\");\n    assert(solution(\"6\\n((()))\\n\") == \"6\");\n    assert(solution(\"4\\n(())()\\n\") == \"4\");\n    assert(solution(\"7\\n(()())\\n\") == \"6\");\n    assert(solution(\"9\\n()()()()\\n\") == \"8\");\n    assert(solution(\"11\\n(()())()()\\n\") == \"10\");\n    assert(solution(\"13\\n(()())(())()\\n\") == \"12\");\n    assert(solution(\"15\\n((()))()()()()\\n\") == \"14\");\n    assert(solution(\"16\\n(())(())(())()\\n\") == \"14\");\n    assert(solution(\"17\\n(()())(())(())()\\n\") == \"16\");\n    assert(solution(\"20\\n(())(())(())(())()\\n\") == \"18\");\n    assert(solution(\"21\\n(()())(())(())(())()\\n\") == \"20\");\n    assert(solution(\"5\\n()())\\n\") == \"4\");\n    assert(solution(\"8\\n())((()))\\n\") == \"8\");\n    assert(solution(\"7\\n()()())\\n\") == \"6\");\n    assert(solution(\"4\\n()()\\n\") == \"4\");\n    assert(solution(\"1\\n(\\n\") == \"0\");\n    assert(solution(\"10\\n(((())(()\\n\") == \"6\");\n    assert(solution(\"11\\n((()()()()\\n\") == \"8\");\n    assert(solution(\"3\\n((\") == \"0\");\n    assert(solution(\"2\\n))\") == \"0\");\n    assert(solution(\"4\\n(())\") == \"4\");\n    assert(solution(\"5\\n()(())\") == \"4\");\n    assert(solution(\"8\\n((()()))\") == \"8\");\n    assert(solution(\"9\\n(((())))\") == \"8\");\n    assert(solution(\"11\\n((()((()))))\") == \"10\");\n    return 0; \n}", "prompt": "/*Given a string of parentheses $s$. Define an operation as swapping two adjacent characters in the string.\n\nYour task is to find the maximum length of a prefix of $s$ such that it can be transformed into a string with balanced parentheses by performing a series of operations.\n\ninput_format:\nA line of a positive integer $n$indicates the string length.\n\nThe next line has a string representing $s$.\n\noutput_format:\nOne natural number in a row represents the answer.\n*/\n\n#include<sstream>\n#include<stdlib.h>\n#include<algorithm>\n#include<math.h>\n#include<stdio.h>\n#include<vector>\n#include<string>\n#include<climits>\n#include<cstring>\n#include<iostream>\nusing namespace std;\n\n             \nstring solution(string std_in){\n    istringstream iss(std_in);\n             ", "constraints": "\n\n**本题采用 $\\texttt{Subtask}$ 计分方式，只有通过该 $\\texttt{Subtask}$ 的所有测试点才能得到该点的分数。**\n\n| $\\texttt{Subtask}$ 编号 | 特殊限制 | 分值 |\n| :----------: | :----------: | :----------: |\n| 1 | 只含左括号或只含右括号 | 2 |\n| 2 | $n \\leq 2$ | 3 |\n| 3 | $n \\leq 10$ | 10 |\n| 4 | $n \\leq 1000$ | 20 |\n| 5 | 无| 65 |\n\n对于 $100\\%$ 的数据，保证 $ 1\\leq n\\leq10^6$。", "samples": [["3\n(()", "2"], ["2\n()", "2"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144]}}
{"task_id": "P2592", "title": "[ZJOI2008]生日聚会", "difficulty": "advanced", "nl": "Today is hidadz's birthday, and she has invited many friends to her birthday party. hidadz and her friends came to the garden and planned to sit in a row to play games. In order to avoid boredom during the game, the seating arrangement should meet the following conditions:\n\nFor any continuous segment, the absolute difference between the number of boys and girls should not exceed k.\n\nSoon, the kids found a seating arrangement and started playing games. hidadz's good friend Susie found that there are actually many such seating arrangements, so everyone quickly found one. So, how many such arrangements are there? hidadz and her math-loving friends began to ponder this question...\n\nAssuming that there are n boys and m girls among the attendees, can you answer Susie and hidadz's question? Since the number can be large, they only want to know the remainder of the number divided by 12345678.", "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\nconst int N=150+5;\nconst int mod=12345678;\nint n,m,k;\nint d[N][N];\nint main(){\n\tint i,j;\n\tcin>>n>>m>>k;\n\tint ans=0;\n\tfor(int p=0;p<=k;p++){\n\t\tmemset(d,0,sizeof(d));\n\t\td[0][0]=1;\n\t\tfor(i=0;i<=n;i++){\n\t\t\tfor(j=0;j<=m;j++){\n\t\t\t\tif(j<i-p||j>i+k-p) continue;\n\t\t\t\td[i+1][j]=(d[i+1][j]+d[i][j])%mod;\n\t\t\t\td[i][j+1]=(d[i][j+1]+d[i][j])%mod;\n\t\t\t}\n\t\t}\n\t\tif(m<n-p||m>n+k-p) continue;\n\t\tans=(ans+d[n][m])%mod;\n\t}\n\tk--;\n\tfor(int p=0;p<=k;p++){\n\t\tmemset(d,0,sizeof(d));\n\t\td[0][0]=1;\n\t\tfor(i=0;i<=n;i++){\n\t\t\tfor(j=0;j<=m;j++){\n\t\t\t\tif(j<i-p||j>i+k-p) continue;\n\t\t\t\td[i+1][j]=(d[i+1][j]+d[i][j])%mod;\n\t\t\t\td[i][j+1]=(d[i][j+1]+d[i][j])%mod;\n\t\t\t}\n\t\t}\n\t\tif(m<n-p||m>n+k-p) continue;\n\t\tans=(ans-d[n][m]+mod)%mod;\n\t}\n\tcout<<ans;\n\treturn 0;\n}", "step": ["Read the values for n, m, and k.", "Initialize ans to 0.", "For p from 0 to k, calculate the number of paths using p diagonal moves.", "If the number of diagonal moves is greater than k, continue.", "Add the number of paths from the current iteration to the ans.", "Decrement k by 1.", "For p from 0 to k, calculate the number of paths using p diagonal moves.", "If the number of diagonal moves is greater than k, continue.", "Subtract the number of paths from the current iteration from the ans.", "Print the final value of ans."], "nl_cn": "今天是hidadz小朋友的生日，她邀请了许多朋友来参加她的生日party。 hidadz带着朋友们来到花园中，打算坐成一排玩游戏。为了游戏不至于无聊，就座的方案应满足如下条件：\n\n对于任意连续的一段，男孩与女孩的数目之差不超过k。\n\n很快，小朋友便找到了一种方案坐了下来开始游戏。hidadz的好朋友Susie发现，这样的就座方案其实是很多的，所以大家很快就找到了一种，那么到底有多少种呢？热爱数学的hidadz和她的朋友们开始思考这个问题……\n\n假设参加party的人中共有n个男孩与m个女孩，你是否能解答Susie和hidadz的疑问呢？由于这个数目可能很多，他们只想知道这个数目除以12345678的余数。\n", "test_cases": [{"input": "1 2 1", "output": "1"}, {"input": "6 0 1\n", "output": "0"}, {"input": "0 6 1\n", "output": "0"}, {"input": "0 0 0\n", "output": "1"}, {"input": "3 0 0\n", "output": "0"}, {"input": "2 2 0\n", "output": "0"}, {"input": "6 3 1\n", "output": "0"}, {"input": "5 0 2\n", "output": "0"}, {"input": "0 5 2\n", "output": "0"}, {"input": "5 5 0\n", "output": "0"}, {"input": "3 4 0\n", "output": "0"}, {"input": "6 6 0\n", "output": "0"}, {"input": "4 3 0\n", "output": "0"}, {"input": "5 4 0\n", "output": "0"}, {"input": "7 7 0\n", "output": "0"}], "test": "#undef NDEBUG\n#include<assert.h>\nint main(){\n    assert(solution(\"1 2 1\") == \"1\");\n    assert(solution(\"6 0 1\\n\") == \"0\");\n    assert(solution(\"0 6 1\\n\") == \"0\");\n    assert(solution(\"0 0 0\\n\") == \"1\");\n    assert(solution(\"3 0 0\\n\") == \"0\");\n    assert(solution(\"2 2 0\\n\") == \"0\");\n    assert(solution(\"6 3 1\\n\") == \"0\");\n    assert(solution(\"5 0 2\\n\") == \"0\");\n    assert(solution(\"0 5 2\\n\") == \"0\");\n    assert(solution(\"5 5 0\\n\") == \"0\");\n    assert(solution(\"3 4 0\\n\") == \"0\");\n    assert(solution(\"6 6 0\\n\") == \"0\");\n    assert(solution(\"4 3 0\\n\") == \"0\");\n    assert(solution(\"5 4 0\\n\") == \"0\");\n    assert(solution(\"7 7 0\\n\") == \"0\");\n    return 0; \n}", "prompt": "/*Today is hidadz's birthday, and she has invited many friends to her birthday party. hidadz and her friends came to the garden and planned to sit in a row to play games. In order to avoid boredom during the game, the seating arrangement should meet the following conditions:\n\nFor any continuous segment, the absolute difference between the number of boys and girls should not exceed k.\n\nSoon, the kids found a seating arrangement and started playing games. hidadz's good friend Susie found that there are actually many such seating arrangements, so everyone quickly found one. So, how many such arrangements are there? hidadz and her math-loving friends began to ponder this question...\n\nAssuming that there are n boys and m girls among the attendees, can you answer Susie and hidadz's question? Since the number can be large, they only want to know the remainder of the number divided by 12345678.\n\ninput_format:\nThe input file party.in contains only one line with 3 integers, representing the number of boys n, the number of girls m, and the constant k respectively.\n\noutput_format:\nThe output file part.out should contain a line for the answer requested in the question.\n*/\n\n#include<sstream>\n#include<stdlib.h>\n#include<algorithm>\n#include<math.h>\n#include<stdio.h>\n#include<vector>\n#include<string>\n#include<climits>\n#include<cstring>\n#include<iostream>\nusing namespace std;\n\n             \nstring solution(string std_in){\n    istringstream iss(std_in);\n             ", "constraints": "对于30%的数据，n , m ≤ 20；\n\n对于100%的数据, n , m ≤ 150，k ≤ 20。\n\n    ", "samples": [["1 2 1", "1"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}}
{"task_id": "P6703", "title": "[COCI2010-2011#7] KOLO", "difficulty": "challenge", "nl": "Mirko recently purchased a Wheel of Fortune. He wrote a capital letter on each sector, without repeating any letters and in clockwise order. Here's an example for case 3:\n\n\n\nAs the wheel rotates, a pointer stops at the same position (pointing to `H` in the example above). When the wheel is rotated, the letter pointed to by the pointer changes accordingly.\n\nMirko made $k$ consecutive rotations and recorded the number of changes for the letter pointed to by the arrow, as well as the letter pointed to at the end of the rotation.\n\nSlavko found the record and wants to know what letters Mirko wrote on the wheel sectors. The total number of sectors is known.", "code": "#include<bits/stdc++.h>\nusing namespace std;\nchar c;\nint f[128],ans[26],s/*改变次数*/,k/*转向次数*/,i,j,n/*转子数*/,x/*指针*/; \nint main()\n{\n\tcin>>n>>k; \n\tfor(i=1;i<=k;i++)\n\t{\n\t\tcin>>s>>c;\n\t\tx=(x+s)%n;\n\t\tif(ans[x]!=0&&int(c)!=ans[x]||f[c]&&ans[x]!=int(c))\n\t\t{\n\t\t\tcout<<'!';return 0;\n\t\t}\n\t\tans[x]=int(c);\n\t\tf[c]=1;\n\t}\n\tfor(i=x;i>=0;i--)\n\tif(ans[i]!=0)cout<<char(ans[i]);\n\telse cout<<'?';\n\tfor(i=n-1;i>=x+1;i--)\n\tif(ans[i]!=0)cout<<char(ans[i]);\n\telse cout<<'?';\n  \treturn 0;\n}", "step": ["Read values for n and k.", "Read k pairs of values for x and y.", "Calculate the string using the given values, and check if it is valid.", "If the string is valid, print the string in reverse order.", "If the string is invalid, print \"!\" and exit the program."], "nl_cn": "Mirko 最近购买了一个命运之轮。 他在每个扇形上写了一个大写英文字母，像这样（比如样例 $3$）：\n\n\n\n\n轮中没有字母重复出现，而且轮沿顺时针方向旋转。 \n\n轮旋转时，有一个指针停留在同一位置（上图中指向 `H`）。 当我们旋转盘时，指针所指向的字母相应地发生变化。\n\nMirko 连续旋转了 $k$ 次，每次都记录了箭头指向的字母改变了多少次，以及旋转结束时所指的字母。\n\nSlavko 找到了那张纸，她想知道 Mirko 在车轮的扇形上写了些什么。另外，扇形的总数是已知的。", "test_cases": [{"input": "3 3\n1 A\n2 B\n3 C\n", "output": "!"}, {"input": "5 6\n1 A\n2 B\n5 B\n1 C\n2 A\n2 B\n", "output": "B?A?C"}, {"input": "8 8\n4 V\n3 I\n7 T\n7 A\n6 R\n5 N\n1 O\n9 H\n", "output": "HONITAVR"}, {"input": "1 1\n1 W\n", "output": "W"}, {"input": "1 1\n1 A\n", "output": "A"}, {"input": "2 1\n1 A\n", "output": "A?"}, {"input": "2 2\n2 A\n1 B\n", "output": "BA"}, {"input": "3 2\n2 A\n2 B\n", "output": "B?A"}], "test": "#undef NDEBUG\n#include<assert.h>\nint main(){\n    assert(solution(\"3 3\\n1 A\\n2 B\\n3 C\\n\") == \"!\");\n    assert(solution(\"5 6\\n1 A\\n2 B\\n5 B\\n1 C\\n2 A\\n2 B\\n\") == \"B?A?C\");\n    assert(solution(\"8 8\\n4 V\\n3 I\\n7 T\\n7 A\\n6 R\\n5 N\\n1 O\\n9 H\\n\") == \"HONITAVR\");\n    assert(solution(\"1 1\\n1 W\\n\") == \"W\");\n    assert(solution(\"1 1\\n1 A\\n\") == \"A\");\n    assert(solution(\"2 1\\n1 A\\n\") == \"A?\");\n    assert(solution(\"2 2\\n2 A\\n1 B\\n\") == \"BA\");\n    assert(solution(\"3 2\\n2 A\\n2 B\\n\") == \"B?A\");\n    return 0; \n}", "prompt": "/*Mirko recently purchased a Wheel of Fortune. He wrote a capital letter on each sector, without repeating any letters and in clockwise order. Here's an example for case 3:\n\n\n\nAs the wheel rotates, a pointer stops at the same position (pointing to `H` in the example above). When the wheel is rotated, the letter pointed to by the pointer changes accordingly.\n\nMirko made $k$ consecutive rotations and recorded the number of changes for the letter pointed to by the arrow, as well as the letter pointed to at the end of the rotation.\n\nSlavko found the record and wants to know what letters Mirko wrote on the wheel sectors. The total number of sectors is known.\n\ninput_format:\nInput data in a row.\n\nIn the first row, $2$has positive integers $n$, representing the number of wedges on the wheel, and $k$, representing the number of rotations.\n\nThe next $k$line represents the order description Mirko records for each rotation. Each line contains an integer $s$and a capital letter $c$, representing the number of times the pointing letter has changed during that rotation, and $c$representing the capital letter where the pointer stops.\n\noutput_format:\nIf no disk meets the above requirements, output $\\texttt! $.\n\nOtherwise, the letters on the disk, starting with the pointed letter at the end of the last rotation, are output in a clockwise direction. If certain letters cannot be determined, print $\\texttt? At the corresponding location. $.\n*/\n\n#include<sstream>\n#include<stdlib.h>\n#include<algorithm>\n#include<math.h>\n#include<stdio.h>\n#include<vector>\n#include<string>\n#include<climits>\n#include<cstring>\n#include<iostream>\nusing namespace std;\n\n             \nstring solution(string std_in){\n    istringstream iss(std_in);\n             ", "constraints": "#### 数据规模及约定\n\n对于 $100\\%$ 的数据，$2 \\le n \\le 25, 1 \\le k \\le 100, 1 \\le s \\le 100$。\n\n#### 说明\n\n本题满分 $50$ 分。\n\n译自 [COCI2010-2011](https://hsin.hr/coci/archive/2010_2011/) [CONTEST #7](https://hsin.hr/coci/archive/2010_2011/contest7_tasks.pdf) T2 KOLO", "samples": [["3 3\n1 A\n2 B\n3 C\n", "!"], ["5 6\n1 A\n2 B\n5 B\n1 C\n2 A\n2 B\n", "B?A?C"], ["8 8\n4 V\n3 I\n7 T\n7 A\n6 R\n5 N\n1 O\n9 H\n", "HONITAVR"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072]}}
{"task_id": "P2009", "title": "跑步", "difficulty": "challenge", "nl": "The running track for Chang Shenniu is a polygon (with at most 20 edges, and each vertex represented by a capital English letter), and there are some paths inside the polygon connecting two non-adjacent vertices. All edges and paths are bidirectional. For example, in the following figure:\n\n  \n\nSuppose Chang Shenniu runs from point A to point D, the shortest path is A-E-D (with length 6).\n\nNow you are given the number of edges n, the length of each edge, the number k of connections inside the polygon, the two endpoints and the length of each connection, as well as the start point and the end point. Please output the length of the shortest path. However, Chang Shenniu has a bit of obsessive-compulsive disorder. If there are multiple paths directly connecting two points, he will choose the longest one.\n\nNote: The input data does not guarantee that the start point and the end point are different, nor does it guarantee that the start and end points of a path are different. If there are multiple paths between two points in the input, then the distance between them is the maximum value of these paths. Therefore, if a point with the same starting and ending point is given as input, the distance from this point to itself is not 0.", "code": "#include <iostream>\n#include <cstdio>\n#include <cstring> \n\nusing namespace std;\n\nint n,k,d[105][105]; //d[i][j]表示i到j的最短路距离\n\nint main()\n{\n\tscanf(\"%d%d\",&n,&k);\n\tmemset(d,0x3f,sizeof(d));\n\tfor(int i=1;i<=n;i++)\n\t{\n\t\tint t;\n\t\tscanf(\"%d\",&t);\n\t\tif(d[i][i%n+1]!=d[104][104])//本题一大坑点 \n\t\t{\n\t\t\tt=max(t,d[i][i%n+1]);\n\t\t}\n\t\td[i][i%n+1]=t;\n\t\td[i%n+1][i]=t;\n\t}\n\tfor(int i=1;i<=k;i++)\n\t{\n\t\tchar s,e;\n\t\tint t;\n\t\tcin>>s>>e;\n\t\tscanf(\"%d\",&t);\n\t\ts=s-'A'+1;//字符->数字转换\n\t\te=e-'A'+1;//字符->数字转换\n\t\tif(d[s][e]!=d[104][104])//本题一大坑点 \n\t\t{\n\t\t\tt=max(t,d[s][e]);\n\t\t}\n\t\td[s][e]=t;\n\t\td[e][s]=t;\n\t}\n\tfor(int k=1;k<=n;k++)//枚举中间点\n\t{\n\t\tfor(int i=1;i<=n;i++)//枚举起点\n\t\t{\n\t\t\tfor(int j=1;j<=n;j++)//枚举终点\n\t\t\t{\n\t\t\t\td[i][j]=min(d[i][j],d[i][k]+d[k][j]);//更新\n\t\t\t}\n\t\t}\n\t}\n\tchar s,e;\n\tcin>>s>>e;\n\ts=s-'A'+1;//字符->数字转换\n\te=e-'A'+1;//字符->数字转换\n\tprintf(\"%d\\n\",d[s][e]);\n\treturn 0;\n}", "step": ["Scan the number of nodes and edges in the graph.", "Initialize the distance array with infinite values.", "Scan the adjacent nodes of every node in the graph and update the distance array accordingly.", "Scan the edges and weights of the graph and update the distance array.", "Update the distance array using Floyd Warshall algorithm to find the shortest path.", "Scan the starting and ending node for which shortest path is to be found and return the shortest distance."], "nl_cn": "常神牛跑步的场地是一个多边形（边数≤20，每个顶点用英文大写字母表示），并且在这个多边形内部，还会有一些小道，连接两个不相邻的顶点。所有的边长和小道都是双向通行的举例来说，下面一个图：\n\n  \n\n假设常神牛从A点跑到D点，最短的路径是A-E-D（长度为6）。\n\n现在告诉你多边形的边数n，多边形每条边的长度，多边形内的连线数k，每条连线的两个端点及长度，以及起始点和结束点，请你输出最短路径的长度。但是常神牛有点强迫症，如果两点之间有多条道路直接连接，他会选择最长的那条。\n\n注意：输入数据不保证起点和终点不同，也不保证小道的起点和终点不同。在读入过程中，如果两点之间有多条小道，那么它们间的距离为这些小道的最大值。所以，如果读入一个小道起点和终点相同，那么这个点到它本身的距离不为0。\n", "test_cases": [{"input": "5 2\n6 4 5 4 2\nA D 7\nE B 8\nA D", "output": "6"}, {"input": "3 1\n3 2 5\nA C 6\nA C\n", "output": "5"}, {"input": "2 1\n1 1\nA B 1\nA B\n", "output": "1"}, {"input": "3 2\n5 4 3\nA C 5\nB C 6\nA B\n", "output": "5"}, {"input": "2 1\n1 1\nA B 1\nB A\n", "output": "1"}, {"input": "3 1\n5 3 4\nB C 6\nA B", "output": "5"}, {"input": "3 2\n5 2 3\nA C 4\nB C 2\nA B", "output": "5"}, {"input": "2 1\n3 1\nA B 6\nA B\n", "output": "6"}, {"input": "2 1\n1 2\nA B 6\nB A\n", "output": "6"}, {"input": "3 2\n4 3 5\nA C 6\nA B 7\nA B\n", "output": "7"}], "test": "#undef NDEBUG\n#include<assert.h>\nint main(){\n    assert(solution(\"5 2\\n6 4 5 4 2\\nA D 7\\nE B 8\\nA D\") == \"6\");\n    assert(solution(\"3 1\\n3 2 5\\nA C 6\\nA C\\n\") == \"5\");\n    assert(solution(\"2 1\\n1 1\\nA B 1\\nA B\\n\") == \"1\");\n    assert(solution(\"3 2\\n5 4 3\\nA C 5\\nB C 6\\nA B\\n\") == \"5\");\n    assert(solution(\"2 1\\n1 1\\nA B 1\\nB A\\n\") == \"1\");\n    assert(solution(\"3 1\\n5 3 4\\nB C 6\\nA B\") == \"5\");\n    assert(solution(\"3 2\\n5 2 3\\nA C 4\\nB C 2\\nA B\") == \"5\");\n    assert(solution(\"2 1\\n3 1\\nA B 6\\nA B\\n\") == \"6\");\n    assert(solution(\"2 1\\n1 2\\nA B 6\\nB A\\n\") == \"6\");\n    assert(solution(\"3 2\\n4 3 5\\nA C 6\\nA B 7\\nA B\\n\") == \"7\");\n    return 0; \n}", "prompt": "/*The running track for Chang Shenniu is a polygon (with at most 20 edges, and each vertex represented by a capital English letter), and there are some paths inside the polygon connecting two non-adjacent vertices. All edges and paths are bidirectional. For example, in the following figure:\n\n  \n\nSuppose Chang Shenniu runs from point A to point D, the shortest path is A-E-D (with length 6).\n\nNow you are given the number of edges n, the length of each edge, the number k of connections inside the polygon, the two endpoints and the length of each connection, as well as the start point and the end point. Please output the length of the shortest path. However, Chang Shenniu has a bit of obsessive-compulsive disorder. If there are multiple paths directly connecting two points, he will choose the longest one.\n\nNote: The input data does not guarantee that the start point and the end point are different, nor does it guarantee that the start and end points of a path are different. If there are multiple paths between two points in the input, then the distance between them is the maximum value of these paths. Therefore, if a point with the same starting and ending point is given as input, the distance from this point to itself is not 0.\n\ninput_format:\nThe input file is run.in.\n\nFirst row, 2 numbers, n,k.\n\nThe second line, n numbers, represent the length of each side of the polygon (given in clockwise order, i.e. AB,BC,CD,DE... Length).\n\nThe following k lines, each line two letters and a number, two letters represent the start and end of the line, the number represents the length.\n\nThe last line, two letters, was the start and end of his run.\n\nAll lines of letters and numbers are separated by a space.\n\noutput_format:\nThe output file is run.out.\n\nA line, a number, indicates the length of the shortest circuit.\n*/\n\n#include<sstream>\n#include<stdlib.h>\n#include<algorithm>\n#include<math.h>\n#include<stdio.h>\n#include<vector>\n#include<string>\n#include<climits>\n#include<cstring>\n#include<iostream>\nusing namespace std;\n\n             \nstring solution(string std_in){\n    istringstream iss(std_in);\n             ", "constraints": "对于 $20\\%$ 的数据，$k=0$；\n\n对于 $50\\%$ 的数据，$k \\leq 10$；\n\n对于 $100\\%$ 的数据，$1 \\leq n \\leq 20$，$0 \\leq m \\leq 50$，$k \\leq 100$，所有路径长度均不大于 $1000$。", "samples": [["5 2\n6 4 5 4 2\nA D 7\nE B 8\nA D", "6"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}}
{"task_id": "P1210", "title": "[USACO1.3]最长的回文 Calf Flac", "difficulty": "challenge", "nl": "It is said that if you give an infinite number of cows and an infinite number of giant portable computers with very large keyboards, the cows will create the best palindrome in the world. Your task is to find these miraculous palindromes created by the cows.\n\nWhen searching for palindromes, punctuation and spaces should be ignored (but kept for output purposes), and only the letters 'A'-'Z' and 'a'-'z' should be considered. The longest palindrome you are looking for is a string of no more than 20,000 characters. We guarantee that the longest palindrome will not exceed 2,000 characters (before removing punctuation and spaces).", "code": "#include<iostream>\n#include<cstdio>\n#include<cstring>\nusing namespace std;\n\nconst int N=50000;\nint n,ln,id[N],sa[N],rk[N],tmp[N],c[N],height[N];\nstring ss;\nchar s[N];\n\nvoid Read()//读入加反转\n{\n\tstring str;\n\tfor(getline(cin,ss);getline(cin,str);ss+='\\n'+str);\n\tint len=ss.length();\n\tn=0;\n\tfor(int i=0;i<len;++i)\n\t{\n\t\tif(ss[i]>='a'&&ss[i]<='z')\n\t\t\ts[n]=ss[i],id[n]=i,++n;\n\t\tif(ss[i]>='A'&&ss[i]<='Z')//字符要统一大小写\n\t\t\ts[n]=ss[i]+'a'-'A',id[n]=i,++n;\n\t}\n\tfor(int i=0;i<n;++i) s[n+n-i]=s[i];\n\ts[n]=2,s[n+n+1]=1;\n\tln=n,n=n+n+2;\n}\n\nvoid Make_Sa()//后缀数组的模板——求sa[]与rank[]\n{\n\tint i,j,len,na;\n\tna=256;\n\tmemset(c,0,na*sizeof(int));\n\tfor(i=0;i<n;++i)\n\t{\n\t\trk[i]=s[i]&0xff,\n\t\t++c[rk[i]];\n\t}\n\tfor(i=1;i<na;++i) c[i]+=c[i-1];\n\tfor(i=0;i<n;++i)\n\t{\n\t\t--c[rk[i]],\n\t\tsa[c[rk[i]]]=i;\n\t}\n\tfor(len=1;len<n;len<<=1)\n\t{\n\t\tfor(i=0;i<n;++i)\n\t\t{\n\t\t\tj=sa[i]-len;\n\t\t\tif(j<0) j+=n;\n\t\t\ttmp[c[rk[j]]++]=j;\n\t\t}\n\t\tc[0]=0,j=0,\n\t\tsa[tmp[0]]=0;\n\t\tfor(i=1;i<n;++i)\n\t\t{\n\t\t\tif(rk[tmp[i]]!=rk[tmp[i-1]]\n\t\t\t||rk[tmp[i]+len]!=rk[tmp[i-1]+len])\n\t\t\t\tc[++j]=i;\n\t\t\tsa[tmp[i]]=j;\n\t\t}\n\t\tmemcpy(rk,sa,n*sizeof(int)),\n\t\tmemcpy(sa,tmp,n*sizeof(int));\n\t\tif(j>=n-1) break;\n\t}\n}\n\nvoid Lcp()//后缀数组的模板——求Height[]\n{\n\tint i=0,j,k=0;\n\theight[0]=0;\n\tfor(j=rk[0];i<n-1;++i,++k)\n\t\tfor(;k>=0&&s[i]!=s[sa[j-1]+k];)\n\t\t{\n\t\t\theight[j]=k, --k;\n\t\t\tj=rk[sa[j]+1];\n\t\t}\n}\n\nvoid PutAns()\n{\n\tint ID=0,Ans=0;\n\tfor(int i=1;i<n;++i)\n\t{\n\t\tif(sa[i]<ln&&sa[i-1]>ln)//必须一个为原字母串，另一个为反转字母串\n\t\t\tif((height[i]>Ans)\n\t\t\t||(height[i]==Ans&&sa[i]<ID))//坑点：还有字母最靠前\n\t\t\t\tAns=height[i],ID=sa[i];\n\t\tif(sa[i]>ln&&sa[i-1]<ln)\n\t\t\tif(height[i]>Ans\n\t\t\t||(height[i]==Ans&&sa[i-1]<ID))\n\t\t\t\tAns=height[i],ID=sa[i-1];\n\t}\n\tprintf(\"%d\\n\",Ans);\n\tfor(int i=id[ID];i<=id[ID+Ans-1];++i)//id的巧处\n\t\tprintf(\"%c\",ss[i]);\n}\n\nint main()\n{\n\tRead(),Make_Sa(),Lcp(),PutAns();\n\treturn 0;\n}", "step": ["Read in the input string and store lowercase characters and their corresponding positions in arrays.", "Find the longest palindrome substring by iterating through all possible centers and calculating the length of palindromes around those centers.", "Update the maximum palindrome length and its center as you find bigger palindromes.", "Print out the maximum palindrome length and the substring that constitutes the palindrome."], "nl_cn": "据说如果你给无限只母牛和无限台巨型便携式电脑(有非常大的键盘),那么母牛们会制造出世上最棒的回文。你的工作就是去寻找这些牛制造的奇观(最棒的回文)。\n\n\n在寻找回文时不用理睬那些标点符号、空格(但应该保留下来以便做为答案输出),只用考虑字母'A'-'Z'和'a'-'z'。要你寻找的最长的回文的文章是一个不超过20,000个字符的字符串。我们将保证最长的回文不会超过2,000个字符(在除去标点符号、空格之前)。\n", "test_cases": [{"input": "Confucius say: Madam, I'm Adam. ", "output": "11\nMadam, I'm Adam"}, {"input": "Aibohphobia", "output": "11\nAibohphobia"}, {"input": "Taco Cat", "output": "7\nTaco Cat"}, {"input": "Racecar", "output": "7\nRacecar"}, {"input": "My gym", "output": "5\nMy gym"}, {"input": "A man, a plan, a canal: Panama", "output": "21\nA man, a plan, a canal: Panama"}, {"input": "A man, a plan, a canal, Panama!", "output": "21\nA man, a plan, a canal, Panama"}, {"input": "Do geese see God?", "output": "13\nDo geese see God"}, {"input": "Madam, in Eden I'm Adam.", "output": "17\nMadam, in Eden I'm Adam"}, {"input": "A man, a plan, a canal, Panama", "output": "21\nA man, a plan, a canal, Panama"}, {"input": "racecar", "output": "7\nracecar"}, {"input": "level", "output": "5\nlevel"}, {"input": "deed", "output": "4\ndeed"}, {"input": "redder", "output": "6\nredder"}, {"input": "madam", "output": "5\nmadam"}, {"input": "kayak", "output": "5\nkayak"}, {"input": "radar", "output": "5\nradar"}, {"input": "civic", "output": "5\ncivic"}, {"input": "refer", "output": "5\nrefer"}, {"input": "solos", "output": "5\nsolos"}, {"input": "rotator", "output": "7\nrotator"}, {"input": "deified", "output": "7\ndeified"}, {"input": "repaper", "output": "7\nrepaper"}, {"input": "detartrated", "output": "11\ndetartrated"}, {"input": "redivider", "output": "9\nredivider"}], "test": "#undef NDEBUG\n#include<assert.h>\nint main(){\n    assert(solution(\"\"Confucius say: Madam, Im Adam. \"\") == \"\"11\\nMadam, Im Adam\"\");\n    assert(solution(\"Aibohphobia\") == \"11\\nAibohphobia\");\n    assert(solution(\"Taco Cat\") == \"7\\nTaco Cat\");\n    assert(solution(\"Racecar\") == \"7\\nRacecar\");\n    assert(solution(\"My gym\") == \"5\\nMy gym\");\n    assert(solution(\"A man, a plan, a canal: Panama\") == \"21\\nA man, a plan, a canal: Panama\");\n    assert(solution(\"A man, a plan, a canal, Panama!\") == \"21\\nA man, a plan, a canal, Panama\");\n    assert(solution(\"Do geese see God?\") == \"13\\nDo geese see God\");\n    assert(solution(\"\"Madam, in Eden Im Adam.\"\") == \"\"17\\nMadam, in Eden Im Adam\"\");\n    assert(solution(\"A man, a plan, a canal, Panama\") == \"21\\nA man, a plan, a canal, Panama\");\n    assert(solution(\"racecar\") == \"7\\nracecar\");\n    assert(solution(\"level\") == \"5\\nlevel\");\n    assert(solution(\"deed\") == \"4\\ndeed\");\n    assert(solution(\"redder\") == \"6\\nredder\");\n    assert(solution(\"madam\") == \"5\\nmadam\");\n    assert(solution(\"kayak\") == \"5\\nkayak\");\n    assert(solution(\"radar\") == \"5\\nradar\");\n    assert(solution(\"civic\") == \"5\\ncivic\");\n    assert(solution(\"refer\") == \"5\\nrefer\");\n    assert(solution(\"solos\") == \"5\\nsolos\");\n    assert(solution(\"rotator\") == \"7\\nrotator\");\n    assert(solution(\"deified\") == \"7\\ndeified\");\n    assert(solution(\"repaper\") == \"7\\nrepaper\");\n    assert(solution(\"detartrated\") == \"11\\ndetartrated\");\n    assert(solution(\"redivider\") == \"9\\nredivider\");\n    return 0; \n}", "prompt": "/*It is said that if you give an infinite number of cows and an infinite number of giant portable computers with very large keyboards, the cows will create the best palindrome in the world. Your task is to find these miraculous palindromes created by the cows.\n\nWhen searching for palindromes, punctuation and spaces should be ignored (but kept for output purposes), and only the letters 'A'-'Z' and 'a'-'z' should be considered. The longest palindrome you are looking for is a string of no more than 20,000 characters. We guarantee that the longest palindrome will not exceed 2,000 characters (before removing punctuation and spaces).\n\ninput_format:\nThe input file will not exceed 20,000 characters. The file may consist of one or multiple lines, but each line will not exceed 80 characters (excluding the trailing newline character).\n\noutput_format:\nThe first line of output should include the length of the longest palindrome found.\n\nThe next line or lines should include the original text of the palindrome (without removing punctuation, Spaces), and output the palindrome to one or more lines (if the palindrome includes a newline).\n\nIf there are multiple palindromes whose length is equal to the maximum value, output the one that appears first.\n*/\n\n#include<sstream>\n#include<stdlib.h>\n#include<algorithm>\n#include<math.h>\n#include<stdio.h>\n#include<vector>\n#include<string>\n#include<climits>\n#include<cstring>\n#include<iostream>\nusing namespace std;\n\n             \nstring solution(string std_in){\n    istringstream iss(std_in);\n             ", "constraints": "题目翻译来自NOCOW。\n\nUSACO Training Section 1.3\n", "samples": [["Confucius say: Madam, I'm Adam. ", "11\nMadam, I'm Adam"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}}
{"task_id": "P8795", "title": "[蓝桥杯 2022 国 A] 选素数", "difficulty": "advanced", "nl": "Little Blue has a number $x$. Each time, he selects a prime number $p$ less than $x$, and continuously adds $1$ to $x$ before $x$ becomes a multiple of $p$ (if $x$ is already a multiple of $p$, $x$ remains the same).\n\nLittle Qiao saw the result $n$ obtained by Little Blue after two such operations, and she wants to know the initial value of $x$. If there are multiple possible values, she wants to know the smallest possible initial value of $x$. If there is no solution, it means Little Qiao made a mistake, and -1 should be outputted instead.", "code": "#include<bits/stdc++.h>\n#define ri register int\n#define maxn 1000005\n#define inf 0xffffff\nusing namespace std;\ninline int read(){\n    int x=0,f=1;\n    char ch=getchar();\n    while(ch<'0'||ch>'9'){\n        if(ch=='-')\n            f=-1;\n        ch=getchar();\n    }\n    while(ch>='0'&&ch<='9'){\n        x=x*10+ch-48;\n        ch=getchar();\n    }\n    return x*f;\n}\ninline void write(int n){\n    if(n<0){\n        putchar('-');\n        n=-n;\n    }\n    if(n>9)\n        write(n/10);\n    putchar(n%10+'0');\n}\nint n;\nint np[maxn];\nvector<int>pri;\nvoid init(){\n    for(ri i=2;i<=n;i++){\n        if(!np[i]){\n            pri.push_back(i);\n            np[i]=i;\n        }\n        for(auto j:pri){\n            if(i*j>n)break;\n            np[i*j]=max(max(np[i*j],j),np[i]);\n            if(!(i%j))break;\n        }\n    }\n}\n//zy:~~kunkun~~zhiyin(max)(+1)\nint zy[maxn];\nsigned main(){\n    n=read();\n    init();\n    for(ri i=2;i<=n;i++){\n        if(np[i]^i)zy[i]=i-np[i]+1;\n        else zy[i]=i;\n    }\n    int mini=inf;\n    if(np[n]==n||!np[n])write(-1);\n    else{\n        for(ri i=n-np[n]+1;i<=n;i++)if(np[i]!=i)mini=min(mini,zy[i]);\n        write(mini);\n    }\n    return 0;\n}", "step": ["Initialize sieve of Eratosthenes algorithm and find the prime numbers up to n", "For each number i from 2 to n, find the largest prime factor of i, or i itself if it is a prime, and calculate the length of the prime chain ending in i", "If n is not a prime or it is not contained in the prime chain, output -1", "Otherwise, find the minimum length of the prime chain ending in n"], "nl_cn": "小蓝有一个数 $x$，每次操作小蓝会选择一个小于 $x$ 的素数 $p$，然后在 $x$ 成为 $p$ 的倍数前不断将 $x$ 加 $1$，（如果 $x$ 一开始就是 $p$ 的倍数则 $x$ 不变）。\n\n小乔看到了小蓝进行了 $2$ 次上述操作后得到的结果 $n$，他想知道 $x$ 在一开始是多少。如果有多种可能，他想知道 $x$  一开始最小可以是多少，而如果不存在任何解，说明小乔看错了，此时请输出 $-1$。", "test_cases": [{"input": "22", "output": "8"}, {"input": "1\n", "output": "-1"}], "test": "#undef NDEBUG\n#include<assert.h>\nint main(){\n    assert(solution(\"22\") == \"8\");\n    assert(solution(\"1\\n\") == \"-1\");\n    return 0; \n}", "prompt": "/*Little Blue has a number $x$. Each time, he selects a prime number $p$ less than $x$, and continuously adds $1$ to $x$ before $x$ becomes a multiple of $p$ (if $x$ is already a multiple of $p$, $x$ remains the same).\n\nLittle Qiao saw the result $n$ obtained by Little Blue after two such operations, and she wants to know the initial value of $x$. If there are multiple possible values, she wants to know the smallest possible initial value of $x$. If there is no solution, it means Little Qiao made a mistake, and -1 should be outputted instead.\n\ninput_format:\nThe input line contains an integer $n$, representing the value of $x$after two operations.\n\noutput_format:\nThe output line contains an integer representing the initial value of $x$. If there are multiple solutions, output the smallest. If no solution exists, print $-1$.\n*/\n\n#include<sstream>\n#include<stdlib.h>\n#include<algorithm>\n#include<math.h>\n#include<stdio.h>\n#include<vector>\n#include<string>\n#include<climits>\n#include<cstring>\n#include<iostream>\nusing namespace std;\n\n             \nstring solution(string std_in){\n    istringstream iss(std_in);\n             ", "constraints": "**【评测用例规模与约定】**\n\n- 对于 $60\\%$ 的评测用例，$1 \\leq n \\leq 5000$；\n- 对于所有评测用例，$1 \\leq n \\leq 10^6$。\n\n蓝桥杯 2022 国赛 A 组 G 题。", "samples": [["22", "8"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072]}}
{"task_id": "P2343", "title": "宝石管理系统", "difficulty": "advanced", "nl": "GY has purchased a batch of gemstones and put them into the warehouse. One day, he wants to count his gemstones and takes out $m$ gemstones and puts them into the gem management system. Each gemstone $i$ has a value of $v_i$. He wants you to write a program to find the $n$th most valuable gemstone from the largest to the smallest. However, the problem is that he accidentally left some gemstones in the warehouse and may need to add them to the existing system. The number of these gemstones is relatively small. He is very sorry, but still hopes that your system can work.", "code": "#include<bits/stdc++.h>\nusing namespace std;\nstruct node\n{\n\tint l,r,sz,pri,val;\n}tree[150005];\nint tot=0,root,m,q;\nint newnode(int x)\n{\n\ttree[++tot].val=x;\n\ttree[tot].pri=rand();\n\ttree[tot].sz=1;\n\treturn tot;\n}\nvoid pushup(int u)\n{\n\ttree[u].sz=tree[tree[u].l].sz+tree[tree[u].r].sz+1;\n}\nvoid split(int u,int x,int &l,int &r)\n{\n\tif(!u)\n\t{\n\t\tl=r=0;\n\t\treturn;\n\t}\n\tif(tree[u].val<=x)\n\t{\n\t\tl=u;\n\t\tsplit(tree[u].r,x,tree[u].r,r);\n\t}\n\telse\n\t{\n\t\tr=u;\n\t\tsplit(tree[u].l,x,l,tree[u].l);\n\t}\n\tpushup(u);\n}\nint merge(int l,int r)\n{\n\tif(!l||!r)return l+r;\n\tif(tree[l].pri<tree[r].pri)\n\t{\n\t\ttree[l].r=merge(tree[l].r,r);\n\t\tpushup(l);\n\t\treturn l;\n\t}\n\telse\n\t{\n\t\ttree[r].l=merge(l,tree[r].l);\n\t\tpushup(r);\n\t\treturn r;\n\t}\n}\nint kth(int u,int rank)\n{\n\twhile(1)\n\t{\n\t\tif(rank<=tree[tree[u].l].sz)\n\t\t{\n\t\t\tu=tree[u].l;\n\t\t}\n\t\telse if(rank==tree[tree[u].l].sz+1)\n\t\t{\n\t\t\treturn tree[u].val;\n\t\t}\n\t\telse\n\t\t{\n\t\t\trank=rank-tree[tree[u].l].sz-1;\n\t\t\tu=tree[u].r;\n\t\t}\n\t}\n}\nvoid ins(int x)\n{\n\tint L,R;\n\tsplit(root,x,L,R);\n\troot=merge(merge(L,newnode(x)),R);\n}\nint main()\n{\n\tsrand(19260817);\n\tscanf(\"%d%d\",&m,&q);\n\tfor(int i=1;i<=m;++i)\n\t{\n\t\tint v;\n\t\tscanf(\"%d\",&v);\n\t\tins(v);\n\t}\n\tfor(int i=1;i<=q;++i)\n\t{\n\t\tint c,n;\n\t\tscanf(\"%d%d\",&c,&n);\n\t\tif(c==1)\n\t\t{\n\t\t\tprintf(\"%d\\n\",kth(root,tree[root].sz-n+1));\n\t\t}\n\t\tif(c==2)\n\t\t{\n\t\t\tins(n);\n\t\t}\n\t}\n\treturn 0;\n}", "step": ["Define necessary variables including structure 'node' representing the treap", "Define a function to create new nodes with value as input", "Define a function to maintain balance while splitting the nodes", "Define a function to maintain balance while merging different nodes", "Define a function to find the kth smallest element in the tree", "Define a function to insert a new node", "Handle input queries which finds kth smallest and insert a new node"], "nl_cn": "GY 君购买了一批宝石放进了仓库。有一天 GY 君心血来潮，想要清点他的宝石，于是把 $m$ 个宝石都取出来放进了宝石管理系统。每个宝石 $i$ 都有一个珍贵值 $v_i$，他希望你能编写程序查找到从大到小第 $n$ 珍贵的宝石。但是现在问题来了，他非常不小心的留了一些宝石在仓库里面，有可能要往现有的系统中添加宝石。这些宝石的个数比较少。他表示非常抱歉，但是还是希望你的系统能起作用。\n", "test_cases": [{"input": "5 3\n1 3 2 5 6\n1 3\n2 4\n1 6\n", "output": "3\n1"}, {"input": "5 2\n9 8 7 6 5\n1 1\n2 10\n", "output": "9"}, {"input": "3 2\n100 200 300\n1 1\n2 400\n", "output": "300"}, {"input": "4 1\n10 20 30 40\n1 4\n", "output": "10"}, {"input": "2 2\n5 10\n1 2\n2 7\n", "output": "5"}, {"input": "6 2\n1 3 5 7 9 11\n1 4\n2 8\n", "output": "5"}, {"input": "2 1\n1000 2000\n1 2\n", "output": "1000"}, {"input": "4 2\n12 4 6 8\n1 3\n2 10\n", "output": "6"}, {"input": "3 1\n50 30 40\n1 2\n", "output": "40"}, {"input": "1 1\n99\n1 1\n", "output": "99"}, {"input": "4 1\n5 10 15 20\n1 2\n", "output": "15"}, {"input": "6 2\n4 4 4 4 4 4\n1 3\n2 3\n", "output": "4"}, {"input": "3 2\n1 2 3\n1 1\n2 4\n", "output": "3"}, {"input": "2 1\n67 99\n1 2\n", "output": "67"}, {"input": "4 1\n5 6 9 2\n1 4\n", "output": "2"}, {"input": "4 2\n7 2 4 1\n1 2\n2 9\n", "output": "4"}, {"input": "3 1\n9 5 2\n1 2\n", "output": "5"}, {"input": "2 1\n10 20\n1 1\n", "output": "20"}, {"input": "7 2\n4 2 8 6 9 1 3\n1 1\n2 5\n", "output": "9"}, {"input": "3 1\n10 15 20\n1 2\n", "output": "15"}, {"input": "4 2\n7 4 10 2\n2 3\n1 1\n", "output": "10"}, {"input": "3 2\n9 12 6\n1 2\n2 10\n", "output": "9"}, {"input": "5 2\n4 8 2 5 9\n1 1\n2 7\n", "output": "9"}, {"input": "3 1\n5 10 3\n1 3\n", "output": "3"}, {"input": "2 1\n8 6\n1 1\n", "output": "8"}, {"input": "1 1\n10\n1 1\n", "output": "10"}, {"input": "3 1\n5 1 4\n1 2\n", "output": "4"}, {"input": "1 2\n7\n1 1\n2 2\n", "output": "7"}, {"input": "5 1\n2 6 1 7 3\n1 2\n", "output": "6"}, {"input": "3 2\n8 5 3\n1 2\n1 1\n", "output": "5\n8"}], "test": "#undef NDEBUG\n#include<assert.h>\nint main(){\n    assert(solution(\"5 3\\n1 3 2 5 6\\n1 3\\n2 4\\n1 6\\n\") == \"3\\n1\");\n    assert(solution(\"5 2\\n9 8 7 6 5\\n1 1\\n2 10\\n\") == \"9\");\n    assert(solution(\"3 2\\n100 200 300\\n1 1\\n2 400\\n\") == \"300\");\n    assert(solution(\"4 1\\n10 20 30 40\\n1 4\\n\") == \"10\");\n    assert(solution(\"2 2\\n5 10\\n1 2\\n2 7\\n\") == \"5\");\n    assert(solution(\"6 2\\n1 3 5 7 9 11\\n1 4\\n2 8\\n\") == \"5\");\n    assert(solution(\"2 1\\n1000 2000\\n1 2\\n\") == \"1000\");\n    assert(solution(\"4 2\\n12 4 6 8\\n1 3\\n2 10\\n\") == \"6\");\n    assert(solution(\"3 1\\n50 30 40\\n1 2\\n\") == \"40\");\n    assert(solution(\"1 1\\n99\\n1 1\\n\") == \"99\");\n    assert(solution(\"4 1\\n5 10 15 20\\n1 2\\n\") == \"15\");\n    assert(solution(\"6 2\\n4 4 4 4 4 4\\n1 3\\n2 3\\n\") == \"4\");\n    assert(solution(\"3 2\\n1 2 3\\n1 1\\n2 4\\n\") == \"3\");\n    assert(solution(\"2 1\\n67 99\\n1 2\\n\") == \"67\");\n    assert(solution(\"4 1\\n5 6 9 2\\n1 4\\n\") == \"2\");\n    assert(solution(\"4 2\\n7 2 4 1\\n1 2\\n2 9\\n\") == \"4\");\n    assert(solution(\"3 1\\n9 5 2\\n1 2\\n\") == \"5\");\n    assert(solution(\"2 1\\n10 20\\n1 1\\n\") == \"20\");\n    assert(solution(\"7 2\\n4 2 8 6 9 1 3\\n1 1\\n2 5\\n\") == \"9\");\n    assert(solution(\"3 1\\n10 15 20\\n1 2\\n\") == \"15\");\n    assert(solution(\"4 2\\n7 4 10 2\\n2 3\\n1 1\\n\") == \"10\");\n    assert(solution(\"3 2\\n9 12 6\\n1 2\\n2 10\\n\") == \"9\");\n    assert(solution(\"5 2\\n4 8 2 5 9\\n1 1\\n2 7\\n\") == \"9\");\n    assert(solution(\"3 1\\n5 10 3\\n1 3\\n\") == \"3\");\n    assert(solution(\"2 1\\n8 6\\n1 1\\n\") == \"8\");\n    assert(solution(\"1 1\\n10\\n1 1\\n\") == \"10\");\n    assert(solution(\"3 1\\n5 1 4\\n1 2\\n\") == \"4\");\n    assert(solution(\"1 2\\n7\\n1 1\\n2 2\\n\") == \"7\");\n    assert(solution(\"5 1\\n2 6 1 7 3\\n1 2\\n\") == \"6\");\n    assert(solution(\"3 2\\n8 5 3\\n1 2\\n1 1\\n\") == \"5\\n8\");\n    return 0; \n}", "prompt": "/*GY has purchased a batch of gemstones and put them into the warehouse. One day, he wants to count his gemstones and takes out $m$ gemstones and puts them into the gem management system. Each gemstone $i$ has a value of $v_i$. He wants you to write a program to find the $n$th most valuable gemstone from the largest to the smallest. However, the problem is that he accidentally left some gemstones in the warehouse and may need to add them to the existing system. The number of these gemstones is relatively small. He is very sorry, but still hopes that your system can work.\n\ninput_format:\nThe first line contains two integers, $m$ and $q$, representing the number of gems already taken and the number of upcoming queries or insertions.\n\nThe second line contains $m$ positive integers, representing the preciousness values of these $m$ gems.\n\nThe following $q$ lines each contain two integers, $c$ and $n$.\n\nIf $c=1$ (i.e. query), output the preciousness of the $n$th gem.\n\nIf $c=2$ (i.e. insertion), insert a gem with a preciousness value of $n$ into the system.\n\noutput_format:\nFor each $c=1$(query), output the precious value of the current $n$precious gem $v_i$.\n*/\n\n#include<sstream>\n#include<stdlib.h>\n#include<algorithm>\n#include<math.h>\n#include<stdio.h>\n#include<vector>\n#include<string>\n#include<climits>\n#include<cstring>\n#include<iostream>\nusing namespace std;\n\n             \nstring solution(string std_in){\n    istringstream iss(std_in);\n             ", "constraints": "对于 $50\\%$ 的数据，没有 $c=2$ 的情况；\n\n对于 $100\\%$ 的数据，$m\\leq 100000$，$c=2$ 的情况不超过 $10000$ 次，$q\\leq 30000$，$0 \\leq v_i \\lt 2^{31}$。\n", "samples": [["5 3\n1 3 2 5 6\n1 3\n2 4\n1 6\n", "3\n1"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}}
{"task_id": "P6330", "title": "[COCI2007-2008#1] CETVRTA", "difficulty": "basic", "nl": "Given the coordinates of three vertices of a rectangle in a coordinate system, please determine and output the coordinates of the fourth vertex.\n\nIt is guaranteed that the edges of the rectangle are parallel to the coordinate axes.", "code": "#include<bits/stdc++.h>\nusing namespace std;\nint main(){\n\tlong long n1,n2,n3,m1,m2,m3;\n\tscanf(\"%lld%lld%lld%lld%lld%lld\",&n1,&m1,&n2,&m2,&n3,&m3);\n\tprintf(\"%lld %lld\",n1+n2+n3-(n1+n2+n3-max(n1,max(n2,n3))-min(n1,min(n2,n3)))*2,m1+m2+m3-(m1+m2+m3-max(m1,max(m2,m3))-min(m1,min(m2,m3)))*2);\n    return 0;\n}", "step": ["Declare six variables of long long type.", "Read in six integer inputs.", "Calculate the maximum and minimum values of n1, n2, and n3.", "Calculate the maximum and minimum values of m1, m2, and m3.", "Calculate and print the output of the formulas for n and m."], "nl_cn": "给出坐标系中一个矩形的三个顶点的坐标，请你确定第四个顶点的坐标并输出。\n\n保证矩形的边与坐标轴平行。", "test_cases": [{"input": "5 5\n5 7\n7 5", "output": "7 7"}, {"input": "30 20\n10 10\n10 20", "output": "30 10"}, {"input": "0 0\n2 0\n0 1\n", "output": "2 1"}, {"input": "10 10\n15 10\n10 15\n", "output": "15 15"}, {"input": "99 50\n50 0\n50 50\n", "output": "99 0"}, {"input": "1 1\n2 1\n1 2\n", "output": "2 2"}, {"input": "5 10\n7 10\n5 15\n", "output": "7 15"}, {"input": "0 0\n0 5\n5 0\n", "output": "5 5"}, {"input": "8 8\n8 9\n9 8\n", "output": "9 9"}, {"input": "3 7\n9 7\n3 12\n", "output": "9 12"}, {"input": "11 11\n15 11\n11 16\n", "output": "15 16"}, {"input": "9 5\n9 8\n10 5\n", "output": "10 8"}, {"input": "55 55\n65 55\n55 75\n", "output": "65 75"}, {"input": "100 200\n200 200\n100 300\n", "output": "200 300"}, {"input": "4 4\n7 4\n4 8\n", "output": "7 8"}, {"input": "1 1\n1 100\n100 1\n", "output": "100 100"}, {"input": "11 11\n17 11\n11 17\n", "output": "17 17"}, {"input": "20 10\n30 10\n20 30\n", "output": "30 30"}, {"input": "1 1\n1 3\n3 1", "output": "3 3"}, {"input": "0 0\n0 1\n1 0", "output": "1 1"}, {"input": "-5 -5\n-5 -10\n-10 -5", "output": "-10 -10"}, {"input": "100 100\n100 200\n200 100", "output": "200 200"}, {"input": "0 0\n5 0\n0 5", "output": "5 5"}, {"input": "10 5\n7 5\n7 6", "output": "10 6"}, {"input": "2 2\n3 2\n2 3", "output": "3 3"}, {"input": "8 8\n8 10\n10 8", "output": "10 10"}, {"input": "-3 -3\n-5 -3\n-3 -5", "output": "-5 -5"}, {"input": "-10 -10\n-10 -20\n-20 -10", "output": "-20 -20"}, {"input": "2 2\n4 2\n2 4", "output": "4 4"}, {"input": "-5 -5\n-8 -5\n-5 -8", "output": "-8 -8"}, {"input": "0 0\n0 -2\n2 0", "output": "2 -2"}, {"input": "6 6\n5 6\n5 7", "output": "6 7"}, {"input": "-10 -10\n-20 -10\n-10 -20", "output": "-20 -20"}, {"input": "0 0\n0 2\n2 0", "output": "2 2"}, {"input": "5 5\n4 5\n4 6", "output": "5 6"}, {"input": "-5 -5\n-4 -5\n-4 -4", "output": "-5 -4"}, {"input": "10 10\n20 10\n10 20", "output": "20 20"}, {"input": "0 0\n0 -1\n-1 0", "output": "-1 -1"}, {"input": "0 0\n0 3\n4 0\n", "output": "4 3"}, {"input": "-1 -1\n3 -1\n-1 3\n", "output": "3 3"}, {"input": "8 3\n8 -1\n5 3\n", "output": "5 -1"}, {"input": "7 0\n2 5\n7 5\n", "output": "2 0"}, {"input": "0 0\n0 0\n0 0\n", "output": "0 0"}, {"input": "1 2\n1 2\n1 2\n", "output": "1 2"}, {"input": "-5 0\n0 -3\n0 0\n", "output": "-5 -3"}, {"input": "0 5\n10 5\n0 -5\n", "output": "10 -5"}, {"input": "-5 -5\n-5 -5\n-6 -6\n", "output": "-6 -6"}, {"input": "0 0\n1 0\n0 1\n", "output": "1 1"}, {"input": "0 0\n0 10\n10 0\n", "output": "10 10"}, {"input": "0 50\n50 0\n0 0\n", "output": "50 50"}, {"input": "100 100\n200 200\n100 200\n", "output": "200 100"}, {"input": "-5 5\n-5 -5\n0 -5\n", "output": "0 5"}, {"input": "0 0\n10 0\n0 10\n", "output": "10 10"}, {"input": "10 10\n-10 -10\n10 -10\n", "output": "-10 10"}, {"input": "-1 -1\n-1 -10\n-10 -1\n", "output": "-10 -10"}, {"input": "1000 2000\n3000 4000\n2000 1000\n", "output": "2000 3000"}, {"input": "-50 -50\n50 -50\n-50 50\n", "output": "50 50"}], "test": "#undef NDEBUG\n#include<assert.h>\nint main(){\n    assert(solution(\"5 5\\n5 7\\n7 5\") == \"7 7\");\n    assert(solution(\"30 20\\n10 10\\n10 20\") == \"30 10\");\n    assert(solution(\"0 0\\n2 0\\n0 1\\n\") == \"2 1\");\n    assert(solution(\"10 10\\n15 10\\n10 15\\n\") == \"15 15\");\n    assert(solution(\"99 50\\n50 0\\n50 50\\n\") == \"99 0\");\n    assert(solution(\"1 1\\n2 1\\n1 2\\n\") == \"2 2\");\n    assert(solution(\"5 10\\n7 10\\n5 15\\n\") == \"7 15\");\n    assert(solution(\"0 0\\n0 5\\n5 0\\n\") == \"5 5\");\n    assert(solution(\"8 8\\n8 9\\n9 8\\n\") == \"9 9\");\n    assert(solution(\"3 7\\n9 7\\n3 12\\n\") == \"9 12\");\n    assert(solution(\"11 11\\n15 11\\n11 16\\n\") == \"15 16\");\n    assert(solution(\"9 5\\n9 8\\n10 5\\n\") == \"10 8\");\n    assert(solution(\"55 55\\n65 55\\n55 75\\n\") == \"65 75\");\n    assert(solution(\"100 200\\n200 200\\n100 300\\n\") == \"200 300\");\n    assert(solution(\"4 4\\n7 4\\n4 8\\n\") == \"7 8\");\n    assert(solution(\"1 1\\n1 100\\n100 1\\n\") == \"100 100\");\n    assert(solution(\"11 11\\n17 11\\n11 17\\n\") == \"17 17\");\n    assert(solution(\"20 10\\n30 10\\n20 30\\n\") == \"30 30\");\n    assert(solution(\"1 1\\n1 3\\n3 1\") == \"3 3\");\n    assert(solution(\"0 0\\n0 1\\n1 0\") == \"1 1\");\n    assert(solution(\"-5 -5\\n-5 -10\\n-10 -5\") == \"-10 -10\");\n    assert(solution(\"100 100\\n100 200\\n200 100\") == \"200 200\");\n    assert(solution(\"0 0\\n5 0\\n0 5\") == \"5 5\");\n    assert(solution(\"10 5\\n7 5\\n7 6\") == \"10 6\");\n    assert(solution(\"2 2\\n3 2\\n2 3\") == \"3 3\");\n    assert(solution(\"8 8\\n8 10\\n10 8\") == \"10 10\");\n    assert(solution(\"-3 -3\\n-5 -3\\n-3 -5\") == \"-5 -5\");\n    assert(solution(\"-10 -10\\n-10 -20\\n-20 -10\") == \"-20 -20\");\n    assert(solution(\"2 2\\n4 2\\n2 4\") == \"4 4\");\n    assert(solution(\"-5 -5\\n-8 -5\\n-5 -8\") == \"-8 -8\");\n    assert(solution(\"0 0\\n0 -2\\n2 0\") == \"2 -2\");\n    assert(solution(\"6 6\\n5 6\\n5 7\") == \"6 7\");\n    assert(solution(\"-10 -10\\n-20 -10\\n-10 -20\") == \"-20 -20\");\n    assert(solution(\"0 0\\n0 2\\n2 0\") == \"2 2\");\n    assert(solution(\"5 5\\n4 5\\n4 6\") == \"5 6\");\n    assert(solution(\"-5 -5\\n-4 -5\\n-4 -4\") == \"-5 -4\");\n    assert(solution(\"10 10\\n20 10\\n10 20\") == \"20 20\");\n    assert(solution(\"0 0\\n0 -1\\n-1 0\") == \"-1 -1\");\n    assert(solution(\"0 0\\n0 3\\n4 0\\n\") == \"4 3\");\n    assert(solution(\"-1 -1\\n3 -1\\n-1 3\\n\") == \"3 3\");\n    assert(solution(\"8 3\\n8 -1\\n5 3\\n\") == \"5 -1\");\n    assert(solution(\"7 0\\n2 5\\n7 5\\n\") == \"2 0\");\n    assert(solution(\"0 0\\n0 0\\n0 0\\n\") == \"0 0\");\n    assert(solution(\"1 2\\n1 2\\n1 2\\n\") == \"1 2\");\n    assert(solution(\"-5 0\\n0 -3\\n0 0\\n\") == \"-5 -3\");\n    assert(solution(\"0 5\\n10 5\\n0 -5\\n\") == \"10 -5\");\n    assert(solution(\"-5 -5\\n-5 -5\\n-6 -6\\n\") == \"-6 -6\");\n    assert(solution(\"0 0\\n1 0\\n0 1\\n\") == \"1 1\");\n    assert(solution(\"0 0\\n0 10\\n10 0\\n\") == \"10 10\");\n    assert(solution(\"0 50\\n50 0\\n0 0\\n\") == \"50 50\");\n    assert(solution(\"100 100\\n200 200\\n100 200\\n\") == \"200 100\");\n    assert(solution(\"-5 5\\n-5 -5\\n0 -5\\n\") == \"0 5\");\n    assert(solution(\"0 0\\n10 0\\n0 10\\n\") == \"10 10\");\n    assert(solution(\"10 10\\n-10 -10\\n10 -10\\n\") == \"-10 10\");\n    assert(solution(\"-1 -1\\n-1 -10\\n-10 -1\\n\") == \"-10 -10\");\n    assert(solution(\"1000 2000\\n3000 4000\\n2000 1000\\n\") == \"2000 3000\");\n    assert(solution(\"-50 -50\\n50 -50\\n-50 50\\n\") == \"50 50\");\n    return 0; \n}", "prompt": "/*Given the coordinates of three vertices of a rectangle in a coordinate system, please determine and output the coordinates of the fourth vertex.\n\nIt is guaranteed that the edges of the rectangle are parallel to the coordinate axes.\n\ninput_format:\nA total of $3$rows, integers (including endpoints) between two $1\\sim 1000$in each row, representing the coordinates of one vertex of this rectangle.\n\noutput_format:\nOutput a row of two integers representing the coordinates of the fourth vertex.\n*/\n\n#include<sstream>\n#include<stdlib.h>\n#include<algorithm>\n#include<math.h>\n#include<stdio.h>\n#include<vector>\n#include<string>\n#include<climits>\n#include<cstring>\n#include<iostream>\nusing namespace std;\n\n             \nstring solution(string std_in){\n    istringstream iss(std_in);\n             ", "constraints": "#### 说明\n\n**题目译自 [COCI2007-2008](https://hsin.hr/coci/archive/2007_2008/) [CONTEST #1](https://hsin.hr/coci/archive/2007_2008/contest1_tasks.pdf) *T1 CETVRTA***", "samples": [["5 5\n5 7\n7 5", "7 7"], ["30 20\n10 10\n10 20", "30 10"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000], "memory": [32000, 32000, 32000, 32000, 32000]}}
{"task_id": "P7644", "title": "[COCI2012-2013#5] LJESTVICA", "difficulty": "basic", "nl": "In this problem, we only consider A minor and C major. The A minor scale is $\\{ A,B,C,D,E,F,G \\}$, and the C major scale is $\\{ C,D,E,F,G,A,B \\}$.\n\nWe define the first, fourth, and fifth notes of each scale as the tonic notes. You need to determine whether the given sheet music is in A minor or C major.\n\nThe method of determination is as follows: for each measure, determine whether its first note is the tonic note of A minor or C major, and then count the number of tonic notes in each scale. If the counts are equal, the scale of the last note of the entire sheet music is used to determine the scale. If the last note is an A, the piece is in A minor. Otherwise, it is in C major.", "code": "#include<bits/stdc++.h>\nusing namespace std;\nint main(){\n\tstring a;\n\tcin>>a;\n\tint n=a.size(),x=0,y=0;//x计C调主调的个数，y计A调主调的个数\n\tfor(int i=0;i<=n-1;i++){\n\t\tif(i==0 || a[i-1]=='|'){//判断是不是每个小节的第一个，注意a[0]也是\n\t\t\tif(a[i]=='C' || a[i]=='F' || a[i]=='G') x++;//C调主调\n\t\t\tif(a[i]=='A' || a[i]=='D' || a[i]=='E') y++;//A调主调\n\t\t}\n\t}\n\tif(x>y) cout<<\"C-dur\";\n\tif(x<y) cout<<\"A-mol\";\n\tif(x==y){//若主调个数相等\n\t\t//查看最后一个字符\n\t\tif(a[n-1]=='C') cout<<\"C-dur\";\n\t\telse cout<<\"A-mol\";\n\t}\n\treturn 0;\n}", "step": ["Take input a string and initialize size, x and y to 0.", "Iterate over the string and increment x or y based on the character's frequency.", "Check if x or y is greater than the other, and print the corresponding scale.", "If the frequencies of both x and y are equal, check the last character of the string and print the corresponding scale.", "Return 0."], "nl_cn": "在这个问题中，我们只考虑 A 小调和 C 大调。其中 A 小调音阶为 $\\{ A,B,C,D,E,F,G \\}$，C 大调音阶为 $\\{ C,D,E,F,G,A,B \\}$。\n\n称每个音阶的第一个、第四个和第五个音为主调，你需要判断给定的乐谱是 A 小调或是 C 大调。\n\n判断方法：判断此乐谱中每个小节的第一个音符，是 A 小调的主调或是 C 大调的主调，最后判断哪个音阶的主音个数更多。如果两者个数一样多，取整个乐谱的最后一个音符所属的音阶。\n\n最后一个音符为 A 则属于 A 小调，否则属于 C 大调", "test_cases": [{"input": "AEB|C", "output": "C-dur"}, {"input": "CD|EC|CD|EC|EF|G|EF|G|GAGF|EC|GAGF|EC|CG|C|CG|C", "output": "C-dur"}, {"input": "CDCD|EFEF|GAGA|CBCB|CDCD|EFEF|GAGA|CDCD|EFEF|GAGA|CBCB|CDCD|GAGA|GAGA|CDCD\n", "output": "C-dur"}, {"input": "AGCEF|GACEF|GCDEF|GCDEF|GCDEF|GACEF|AGCEF|AGFDC|GACEF|GCDEF|GCDEF|GACEF|AGFDC|GG|ABAC\n", "output": "C-dur"}, {"input": "C#B#A#|B#A#G#|A#B#A#|C#B#A#|B#A#G#|A#B#A#|C#B#A#|B#A#G#|A#B#A#|C#B#A#|B#A#G#|A#B#A#\n", "output": "A-mol"}, {"input": "CEA|EBG|G#C#|ABF#|GE|DC|BE|CA\n", "output": "C-dur"}, {"input": "CEB|BEG|GEC|GBA|DAG|CGD|GEC\n", "output": "C-dur"}, {"input": "ADG|CEF|BCA|FEG|EBG|FED|BAG|CED|DGA|CED|DGA|CED|BCA|FEG|EBG|FED\n", "output": "C-dur"}, {"input": "CC|FF|GG|AA|CC|FF|GG|CC|FF|GG|AA|CC|GG|GG|CC\n", "output": "C-dur"}, {"input": "CF|GC|DA|EC|FB|GC|EC|CG\n", "output": "C-dur"}, {"input": "AGC|GCE|BAG|AGC|GCE|DFA|GCE|BAG|AGC|GCE|DFA|GBA|GCE|BAG|AGC|GCE|DFA|GBA|CGE|GCE|DFA|FED|GCE|DFA|GCE\n", "output": "C-dur"}, {"input": "CGD|GFD|CGD|GFD|CEB|CEB|CEB|GBD|EAE|AGF|EAE|AGF|CGD|AGF|EAE|FCD|CGD|GBD|GFD|GBD|GFD|CEB|CEB|CEB|GBD|EAE|AGF|EAE|AGF|CGD|AGF|EAE|FCD\n", "output": "C-dur"}, {"input": "GAGF|A#CC|D#DD#A#F#A#GAF#D#|G#A#C#CDE|G#AFEDE|D#D#A#F#A#GAF#D#|\n", "output": "A-mol"}, {"input": "C|G|A|D|F|E|B|C", "output": "C-dur"}, {"input": "GFE|CDD|ABE|DCF", "output": "A-mol"}, {"input": "ABC|CDF|EGC|ADG", "output": "A-mol"}, {"input": "FA|CE|DB|AC|GED|CBA", "output": "C-dur"}, {"input": "CA|CF|CG|AD", "output": "C-dur"}, {"input": "EDA|FBD|ACF|GAB", "output": "A-mol"}, {"input": "AG|AB|BC|CA|FG|GAG", "output": "C-dur"}, {"input": "BA|DA|EE|FF|GG|GD|CA", "output": "C-dur"}, {"input": "DE|GC|DF|BA|CB|GF|ED", "output": "A-mol"}, {"input": "CDF|BED|CGB|EAC", "output": "C-dur"}, {"input": "DB|GB|AB|EF|CG|FA|G|FD", "output": "C-dur"}, {"input": "AEB|C|BCD|EF|GA|C|BA", "output": "C-dur"}, {"input": "A\n", "output": "A-mol"}, {"input": "CGAGFEDCCB|CGAGFEDCB|CGAGFEDCCB|\n", "output": "C-dur"}, {"input": "A|B|C|D|E|F|G|A\n", "output": "A-mol"}, {"input": "C|D|E|F|G|A|B|C\n", "output": "C-dur"}, {"input": "CD|ED|FD|GD|AD|BD|CD\n", "output": "C-dur"}, {"input": "AC|BC|CC|DC|EC|FC|GC|A\n", "output": "A-mol"}, {"input": "AC|BC|CC|DC|EC|FC|GC|AG\n", "output": "A-mol"}, {"input": "CG|FD|FD|EG|AG|CG|FD|C\n", "output": "C-dur"}, {"input": "C|C|C|C|C|C|C|C\n", "output": "C-dur"}, {"input": "A|A|A|A|A|A|A|A\n", "output": "A-mol"}, {"input": "CC|CD|FE|FD|CA|BA|GE|GA|CC|CD|FE|FD|CA|BA|GE|GA\n", "output": "C-dur"}, {"input": "E|E|E|E|E|E|E|E\n", "output": "A-mol"}, {"input": "C|C|C|C|C|C|C|C|A|A|A|A|A|A|A|A\n", "output": "A-mol"}, {"input": "C|C|C|C|C|C|C|C|G|G|G|G|G|G|G|G\n", "output": "C-dur"}, {"input": "CDEF|DC|D|D|CDCD|FDEFDCD|CDCDCDCD\n", "output": "C-dur"}, {"input": "AA|AA|AA|AA|AA|AA|AA|AA|AA|AA\n", "output": "A-mol"}, {"input": "GG|GG|GG|GG|GG|GG|GG|GG|GG|GG\n", "output": "C-dur"}, {"input": "CDF|G|G|G|G|GG|FEDC\n", "output": "C-dur"}, {"input": "F|DE|CA|DE|F|DE|CA|DE|C\n", "output": "C-dur"}, {"input": "ADE|ADE|ADE|ADE|ADE|ADE|ADE|ADE|ADE|ADE\n", "output": "A-mol"}, {"input": "C\n", "output": "C-dur"}, {"input": "CC\n", "output": "C-dur"}, {"input": "AA\n", "output": "A-mol"}, {"input": "FF\n", "output": "C-dur"}, {"input": "GG\n", "output": "C-dur"}, {"input": "BB\n", "output": "A-mol"}, {"input": "CCCC|EEEE|CC|EEEE|CC|GGGG\n", "output": "C-dur"}, {"input": "DADA\n", "output": "A-mol"}, {"input": "AEC|CDE|GAB|CAGAGD|EB|GABCDEF|ECAGFA|GEC|ADG|BGEDC\n", "output": "C-dur"}, {"input": "ACG|FA|FED|D|GFEFD|A|C|E|G|A\n", "output": "A-mol"}, {"input": "CAG|E|GAFG|ECAF|GAG|A|C|E|FEC|GAFED|CDFED|ECD|EEE|CFG\n", "output": "C-dur"}, {"input": "AEC|AEC|AEC|AEC|AED|ECD|ECD|ECD|ECD|EC\n", "output": "A-mol"}, {"input": "EFG|GGFEDC|ACEGFEDG|GFE|F|G|ECD|F|G|ECD|FEDC\n", "output": "C-dur"}, {"input": "FED|ECD|FED|ECD|C|D|EFG|GR|GR|GR|GR|EFG|GAFE|D&C|C\n", "output": "C-dur"}, {"input": "ACD|EFEDC|ACD|EDC|A|G|GEDC|A|G|EC\n", "output": "A-mol"}, {"input": "ACE|CDFEDC|CEF|CDFEDC|ABC|D|E|F|G|A|GC\n", "output": "C-dur"}, {"input": "EC|CAGE|EFEDC|AEC|EC|EC\n", "output": "A-mol"}, {"input": "EC|FED|EC|FED|C|D|EFG|GR|GR|GR|GR|EFG|GAFE|D&C|C\n", "output": "C-dur"}], "test": "#undef NDEBUG\n#include<assert.h>\nint main(){\n    assert(solution(\"AEB|C\") == \"C-dur\");\n    assert(solution(\"CD|EC|CD|EC|EF|G|EF|G|GAGF|EC|GAGF|EC|CG|C|CG|C\") == \"C-dur\");\n    assert(solution(\"CDCD|EFEF|GAGA|CBCB|CDCD|EFEF|GAGA|CDCD|EFEF|GAGA|CBCB|CDCD|GAGA|GAGA|CDCD\\n\") == \"C-dur\");\n    assert(solution(\"AGCEF|GACEF|GCDEF|GCDEF|GCDEF|GACEF|AGCEF|AGFDC|GACEF|GCDEF|GCDEF|GACEF|AGFDC|GG|ABAC\\n\") == \"C-dur\");\n    assert(solution(\"C#B#A#|B#A#G#|A#B#A#|C#B#A#|B#A#G#|A#B#A#|C#B#A#|B#A#G#|A#B#A#|C#B#A#|B#A#G#|A#B#A#\\n\") == \"A-mol\");\n    assert(solution(\"CEA|EBG|G#C#|ABF#|GE|DC|BE|CA\\n\") == \"C-dur\");\n    assert(solution(\"CEB|BEG|GEC|GBA|DAG|CGD|GEC\\n\") == \"C-dur\");\n    assert(solution(\"ADG|CEF|BCA|FEG|EBG|FED|BAG|CED|DGA|CED|DGA|CED|BCA|FEG|EBG|FED\\n\") == \"C-dur\");\n    assert(solution(\"CC|FF|GG|AA|CC|FF|GG|CC|FF|GG|AA|CC|GG|GG|CC\\n\") == \"C-dur\");\n    assert(solution(\"CF|GC|DA|EC|FB|GC|EC|CG\\n\") == \"C-dur\");\n    assert(solution(\"AGC|GCE|BAG|AGC|GCE|DFA|GCE|BAG|AGC|GCE|DFA|GBA|GCE|BAG|AGC|GCE|DFA|GBA|CGE|GCE|DFA|FED|GCE|DFA|GCE\\n\") == \"C-dur\");\n    assert(solution(\"CGD|GFD|CGD|GFD|CEB|CEB|CEB|GBD|EAE|AGF|EAE|AGF|CGD|AGF|EAE|FCD|CGD|GBD|GFD|GBD|GFD|CEB|CEB|CEB|GBD|EAE|AGF|EAE|AGF|CGD|AGF|EAE|FCD\\n\") == \"C-dur\");\n    assert(solution(\"GAGF|A#CC|D#DD#A#F#A#GAF#D#|G#A#C#CDE|G#AFEDE|D#D#A#F#A#GAF#D#|\\n\") == \"A-mol\");\n    assert(solution(\"C|G|A|D|F|E|B|C\") == \"C-dur\");\n    assert(solution(\"GFE|CDD|ABE|DCF\") == \"A-mol\");\n    assert(solution(\"ABC|CDF|EGC|ADG\") == \"A-mol\");\n    assert(solution(\"FA|CE|DB|AC|GED|CBA\") == \"C-dur\");\n    assert(solution(\"CA|CF|CG|AD\") == \"C-dur\");\n    assert(solution(\"EDA|FBD|ACF|GAB\") == \"A-mol\");\n    assert(solution(\"AG|AB|BC|CA|FG|GAG\") == \"C-dur\");\n    assert(solution(\"BA|DA|EE|FF|GG|GD|CA\") == \"C-dur\");\n    assert(solution(\"DE|GC|DF|BA|CB|GF|ED\") == \"A-mol\");\n    assert(solution(\"CDF|BED|CGB|EAC\") == \"C-dur\");\n    assert(solution(\"DB|GB|AB|EF|CG|FA|G|FD\") == \"C-dur\");\n    assert(solution(\"AEB|C|BCD|EF|GA|C|BA\") == \"C-dur\");\n    assert(solution(\"A\\n\") == \"A-mol\");\n    assert(solution(\"CGAGFEDCCB|CGAGFEDCB|CGAGFEDCCB|\\n\") == \"C-dur\");\n    assert(solution(\"A|B|C|D|E|F|G|A\\n\") == \"A-mol\");\n    assert(solution(\"C|D|E|F|G|A|B|C\\n\") == \"C-dur\");\n    assert(solution(\"CD|ED|FD|GD|AD|BD|CD\\n\") == \"C-dur\");\n    assert(solution(\"AC|BC|CC|DC|EC|FC|GC|A\\n\") == \"A-mol\");\n    assert(solution(\"AC|BC|CC|DC|EC|FC|GC|AG\\n\") == \"A-mol\");\n    assert(solution(\"CG|FD|FD|EG|AG|CG|FD|C\\n\") == \"C-dur\");\n    assert(solution(\"C|C|C|C|C|C|C|C\\n\") == \"C-dur\");\n    assert(solution(\"A|A|A|A|A|A|A|A\\n\") == \"A-mol\");\n    assert(solution(\"CC|CD|FE|FD|CA|BA|GE|GA|CC|CD|FE|FD|CA|BA|GE|GA\\n\") == \"C-dur\");\n    assert(solution(\"E|E|E|E|E|E|E|E\\n\") == \"A-mol\");\n    assert(solution(\"C|C|C|C|C|C|C|C|A|A|A|A|A|A|A|A\\n\") == \"A-mol\");\n    assert(solution(\"C|C|C|C|C|C|C|C|G|G|G|G|G|G|G|G\\n\") == \"C-dur\");\n    assert(solution(\"CDEF|DC|D|D|CDCD|FDEFDCD|CDCDCDCD\\n\") == \"C-dur\");\n    assert(solution(\"AA|AA|AA|AA|AA|AA|AA|AA|AA|AA\\n\") == \"A-mol\");\n    assert(solution(\"GG|GG|GG|GG|GG|GG|GG|GG|GG|GG\\n\") == \"C-dur\");\n    assert(solution(\"CDF|G|G|G|G|GG|FEDC\\n\") == \"C-dur\");\n    assert(solution(\"F|DE|CA|DE|F|DE|CA|DE|C\\n\") == \"C-dur\");\n    assert(solution(\"ADE|ADE|ADE|ADE|ADE|ADE|ADE|ADE|ADE|ADE\\n\") == \"A-mol\");\n    assert(solution(\"C\\n\") == \"C-dur\");\n    assert(solution(\"CC\\n\") == \"C-dur\");\n    assert(solution(\"AA\\n\") == \"A-mol\");\n    assert(solution(\"FF\\n\") == \"C-dur\");\n    assert(solution(\"GG\\n\") == \"C-dur\");\n    assert(solution(\"BB\\n\") == \"A-mol\");\n    assert(solution(\"CCCC|EEEE|CC|EEEE|CC|GGGG\\n\") == \"C-dur\");\n    assert(solution(\"DADA\\n\") == \"A-mol\");\n    assert(solution(\"AEC|CDE|GAB|CAGAGD|EB|GABCDEF|ECAGFA|GEC|ADG|BGEDC\\n\") == \"C-dur\");\n    assert(solution(\"ACG|FA|FED|D|GFEFD|A|C|E|G|A\\n\") == \"A-mol\");\n    assert(solution(\"CAG|E|GAFG|ECAF|GAG|A|C|E|FEC|GAFED|CDFED|ECD|EEE|CFG\\n\") == \"C-dur\");\n    assert(solution(\"AEC|AEC|AEC|AEC|AED|ECD|ECD|ECD|ECD|EC\\n\") == \"A-mol\");\n    assert(solution(\"EFG|GGFEDC|ACEGFEDG|GFE|F|G|ECD|F|G|ECD|FEDC\\n\") == \"C-dur\");\n    assert(solution(\"FED|ECD|FED|ECD|C|D|EFG|GR|GR|GR|GR|EFG|GAFE|D&C|C\\n\") == \"C-dur\");\n    assert(solution(\"ACD|EFEDC|ACD|EDC|A|G|GEDC|A|G|EC\\n\") == \"A-mol\");\n    assert(solution(\"ACE|CDFEDC|CEF|CDFEDC|ABC|D|E|F|G|A|GC\\n\") == \"C-dur\");\n    assert(solution(\"EC|CAGE|EFEDC|AEC|EC|EC\\n\") == \"A-mol\");\n    assert(solution(\"EC|FED|EC|FED|C|D|EFG|GR|GR|GR|GR|EFG|GAFE|D&C|C\\n\") == \"C-dur\");\n    return 0; \n}", "prompt": "/*In this problem, we only consider A minor and C major. The A minor scale is $\\{ A,B,C,D,E,F,G \\}$, and the C major scale is $\\{ C,D,E,F,G,A,B \\}$.\n\nWe define the first, fourth, and fifth notes of each scale as the tonic notes. You need to determine whether the given sheet music is in A minor or C major.\n\nThe method of determination is as follows: for each measure, determine whether its first note is the tonic note of A minor or C major, and then count the number of tonic notes in each scale. If the counts are equal, the scale of the last note of the entire sheet music is used to determine the scale. If the last note is an A, the piece is in A minor. Otherwise, it is in C major.\n\ninput_format:\nInput line, A string, said given piece of music, the promise of music contains only $\\ {$` A `, ` B `, ` C `, ` D ` ` E ` ` F `, ` G `, ` | ` $\\} $, including ` | ` used segmentation section.\n\noutput_format:\nOutput A single line, A string 'C-dur' for C major, or 'A-mol' for a minor.\n*/\n\n#include<sstream>\n#include<stdlib.h>\n#include<algorithm>\n#include<math.h>\n#include<stdio.h>\n#include<vector>\n#include<string>\n#include<climits>\n#include<cstring>\n#include<iostream>\nusing namespace std;\n\n             \nstring solution(string std_in){\n    istringstream iss(std_in);\n             ", "constraints": "**【样例解释#1】**\n\n两个小节的第一个音符分别为 `A` 和 `C`，由于两个音阶的主调个数相同，取后出现的 `C`，即 C 大调。\n\n\n------------\n\n**【数据范围】**\n\n对于 $100\\%$ 的数据，保证 $5\\le$ 乐谱长度 $\\le100$，且给出的乐谱合法。\n\n\n------------\n\n**【说明】**\n\n本题分值按 COCI 原题设置，满分 $50$。\n\n题目译自 [COCI2012~2013](https://hsin.hr/coci/archive/2012_2013/) [CONTEST #5](https://hsin.hr/coci/archive/2012_2013/contest5_tasks.pdf) _**T1 LJESTVICA**_ 。", "samples": [["AEB|C", "C-dur"], ["CD|EC|CD|EC|EF|G|EF|G|GAGF|EC|GAGF|EC|CG|C|CG|C", "C-dur"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [32768, 32768, 32768, 32768, 32768, 32768, 32768, 32768, 32768, 32768, 32768, 32768, 32768, 32768, 32768]}}
{"task_id": "P2907", "title": "[USACO08OPEN]Roads Around The Farm S", "difficulty": "basic", "nl": "Farmer John's cows are interested in exploring the land around the farm. Initially, all N (1 <= N <= 1,000,000,000) cows move as a large group along the road. At intersections, the group may sometimes choose to split into two smaller (non-empty) groups, with each group continuing along a different path. When one of the groups reaches another intersection, it may split again and so on.\n\nThese cows have come up with a peculiar way of splitting up: if they can split into two groups of exactly K (1 <= K <= 1000) difference in size, then they will split up in this way. Otherwise, they will stop exploring and peacefully graze.\n\nAssuming new intersections will always appear on the road, calculate the final number of cow groups grazing peacefully.", "code": "#include<iostream>\nusing namespace std;\n\nint k;\nint f(int a){\t\t//请别吐槽这个函数名-_-||\n\tif(a-k>0&&(a-k)%2==0)return f((a+k)/2)+f((a-k)/2);//终于散伙咯\n\telse return 1;\t//想分手!没门\n}\n\nint main(){\n\tint n;\n    cin>>n>>k;\n\tcout<<f(n);\n    return 0;\n}", "step": ["Take input for n and k", "Call the recursive function f(n)", "If a-k is greater than 0 and even, call f((a+k)/2) and f((a-k)/2)", "Otherwise return 1", "Print the final output"], "nl_cn": "Farmer John's cows have taken an interest in exploring the territory around the farm. Initially, all N (1 <= N <= 1,000,000,000) cows commence traveling down a road in one big group. Upon encountering a fork in the road, the group sometimes chooses to break into two smaller (nonempty) groups with each group continuing down one of the roads.  When one of those groups arrives at another fork, it might split again, and so on.\n\nThe cows have crafted a peculiar way of splitting: if they can split into two groups such that the sizes of the groups differ by exactly K (1 <= K <= 1000), then they will split in that way; otherwise, they stop exploring and just start grazing peacefully.\n\nAssuming that there will always be new forks in the road, compute the final number of groups of peacefully grazing cows.", "test_cases": [{"input": "6 2 \n", "output": "3"}, {"input": "10 3 \n", "output": "1"}, {"input": "8 2 \n", "output": "2"}, {"input": "50 7 \n", "output": "1"}, {"input": "18 4 \n", "output": "2"}, {"input": "2 1 \n", "output": "1"}, {"input": "12 5 \n", "output": "1"}, {"input": "30 15 \n", "output": "1"}], "test": "#undef NDEBUG\n#include<assert.h>\nint main(){\n    assert(solution(\"6 2 \\n\") == \"3\");\n    assert(solution(\"10 3 \\n\") == \"1\");\n    assert(solution(\"8 2 \\n\") == \"2\");\n    assert(solution(\"50 7 \\n\") == \"1\");\n    assert(solution(\"18 4 \\n\") == \"2\");\n    assert(solution(\"2 1 \\n\") == \"1\");\n    assert(solution(\"12 5 \\n\") == \"1\");\n    assert(solution(\"30 15 \\n\") == \"1\");\n    return 0; \n}", "prompt": "/*Farmer John's cows are interested in exploring the land around the farm. Initially, all N (1 <= N <= 1,000,000,000) cows move as a large group along the road. At intersections, the group may sometimes choose to split into two smaller (non-empty) groups, with each group continuing along a different path. When one of the groups reaches another intersection, it may split again and so on.\n\nThese cows have come up with a peculiar way of splitting up: if they can split into two groups of exactly K (1 <= K <= 1000) difference in size, then they will split up in this way. Otherwise, they will stop exploring and peacefully graze.\n\nAssuming new intersections will always appear on the road, calculate the final number of cow groups grazing peacefully.\n\ninput_format:\n\\* Line 1: Two integers separated by a space: N and K\n\noutput_format:\n\\* Line 1: A single integer representing the number of groups of grazing cows\n*/\n\n#include<sstream>\n#include<stdlib.h>\n#include<algorithm>\n#include<math.h>\n#include<stdio.h>\n#include<vector>\n#include<string>\n#include<climits>\n#include<cstring>\n#include<iostream>\nusing namespace std;\n\n             \nstring solution(string std_in){\n    istringstream iss(std_in);\n             ", "constraints": "There are 6 cows and the difference in group sizes is 2.\n\n\nThere are 3 final groups (with 2, 1, and 3 cows in them). \n\n6\n/ \\\n2   4\n/ \\\n1   3", "samples": [["6 2 \n", "3 \n"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}}
{"task_id": "P1626", "title": "象棋比赛", "difficulty": "challenge", "nl": "There are N people participating in an international chess competition, which involves K rounds. Each person can participate in at most two matches and at least zero matches. Each person has a unique level (represented by a positive integer) that is different from others.\n\nIn the matches, the person with a higher level must use the black chess pieces while the person with a lower level must use the white chess pieces. Each person can only use black or white pieces once. In order to increase the competitiveness of the matches, viewers hope that the total difference in levels between opponents in the K rounds is minimized.\n\nFor example, if there are 7 players with levels 30, 17, 26, 41, 19, 38, and 18, and there are 3 matches, the best arrangement is for player 2 to play against player 7, player 7 to play against player 5, and player 6 to play against player 4. In this case, the total difference in levels is (18-17) + (19-18) + (41-38) = 5, which is minimized.", "code": "#include<iostream> \n#include<cstdio> \n#include<cmath> \n#include<algorithm> \n#include<cstring>\nusing namespace std; \nint main()\n{\n    int n,k,i,a[100001],b[100001],ans=0;\n    scanf(\"%d%d\",&n,&k);\n    for(i=1;i<=n;i++)\n    scanf(\"%d\",&a[i]);\n    sort(a+1,a+n+1);//sort从小到大排序 \n    for(i=1;i<=n-1;i++)\n    b[i]=a[i+1]-a[i];//算出各等级选手的差 \n    sort(b+1,b+n);//sort从小到大排序 \n    for(i=1;i<=k;i++)\n    ans+=b[i];//找出前K个等级差的和 \n    printf(\"%d\",ans);//输出 \n    return 0;\n}", "step": ["Take input of integers n and k", "Take input of array a of size n", "Sort array a in ascending order", "Calculate the difference between consecutive elements of sorted array a and store in array b", "Sort array b in ascending order", "Calculate the sum of first k elements of array b", "Print the sum"], "nl_cn": "有N个人要参加国际象棋比赛，该比赛要进行K场对弈。每个人最多参加两场对弈，最少参加零场对弈。每个人都有一个与其他人不相同的等级（用一个正整数来表示）。\n\n在对弈中，等级高的人必须用黑色的棋子，等级低的人必须用白色的棋子。每个人最多只能用一次黑色的棋子和一次白色的棋子。为增加比赛的可观度，观众希望K场对弈中双方的等级差的总和最小。\n\n比如有7个选手，他们的等级分别是30，17，26，41，19，38，18，要进行3场比赛。最好的安排是选手2对选手7，选手7对选手5，选手6对选手4。此时等级差的总和等于（18-17）+（19-18）+（41-38）=5达到最小。\n\n", "test_cases": [{"input": "7 3\n30\n17\n26\n41\n19\n38\n18", "output": "5"}, {"input": "4 1\n20\n10\n15\n30\n", "output": "5"}, {"input": "2 1\n5\n2\n", "output": "3"}, {"input": "4 1\n10\n20\n5\n15\n", "output": "5"}, {"input": "8 1\n20\n15\n30\n40\n25\n35\n10\n45\n", "output": "5"}, {"input": "6 3\n20\n10\n30\n15\n25\n35\n", "output": "15"}, {"input": "7 1\n30\n40\n10\n45\n25\n35\n15\n", "output": "5"}, {"input": "3 1\n1\n2\n3", "output": "1"}, {"input": "4 2\n8\n6\n4\n2", "output": "4"}, {"input": "2 1\n1000\n1", "output": "999"}, {"input": "6 2\n200\n400\n600\n800\n1000\n1200", "output": "400"}, {"input": "4 2\n15\n10\n20\n5", "output": "10"}, {"input": "3 1\n100\n50\n200", "output": "50"}, {"input": "10 5\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n", "output": "5"}, {"input": "1 0\n50\n", "output": "0"}, {"input": "10 5\n1\n11\n21\n31\n41\n51\n61\n71\n81\n91\n", "output": "50"}, {"input": "2 1\n50\n100\n", "output": "50"}, {"input": "6 4\n5\n10\n15\n20\n25\n30\n", "output": "20"}, {"input": "2 1\n5\n10\n", "output": "5"}, {"input": "5 2\n8\n10\n20\n30\n40\n", "output": "12"}, {"input": "2 1\n10\n15\n", "output": "5"}, {"input": "6 4\n10\n20\n30\n40\n50\n60\n", "output": "40"}, {"input": "5 3\n5\n15\n25\n35\n45\n", "output": "30"}, {"input": "3 2\n10\n20\n30\n", "output": "20"}, {"input": "2 2\n15\n20\n", "output": "5"}, {"input": "3 1\n8\n15\n22\n", "output": "7"}, {"input": "5 2\n5\n10\n15\n20\n25\n", "output": "10"}, {"input": "6 3\n50\n30\n60\n40\n70\n10\n", "output": "30"}, {"input": "2 1\n100\n200\n", "output": "100"}, {"input": "4 2\n15\n30\n25\n35\n", "output": "10"}, {"input": "6 2\n20\n15\n30\n10\n25\n5\n", "output": "10"}, {"input": "3 1\n8\n5\n2\n", "output": "3"}, {"input": "2 1\n1\n2\n", "output": "1"}, {"input": "5 2\n15\n10\n25\n20\n5\n", "output": "10"}, {"input": "6 3\n60\n40\n80\n20\n100\n10\n", "output": "50"}], "test": "#undef NDEBUG\n#include<assert.h>\nint main(){\n    assert(solution(\"7 3\\n30\\n17\\n26\\n41\\n19\\n38\\n18\") == \"5\");\n    assert(solution(\"4 1\\n20\\n10\\n15\\n30\\n\") == \"5\");\n    assert(solution(\"2 1\\n5\\n2\\n\") == \"3\");\n    assert(solution(\"4 1\\n10\\n20\\n5\\n15\\n\") == \"5\");\n    assert(solution(\"8 1\\n20\\n15\\n30\\n40\\n25\\n35\\n10\\n45\\n\") == \"5\");\n    assert(solution(\"6 3\\n20\\n10\\n30\\n15\\n25\\n35\\n\") == \"15\");\n    assert(solution(\"7 1\\n30\\n40\\n10\\n45\\n25\\n35\\n15\\n\") == \"5\");\n    assert(solution(\"3 1\\n1\\n2\\n3\") == \"1\");\n    assert(solution(\"4 2\\n8\\n6\\n4\\n2\") == \"4\");\n    assert(solution(\"2 1\\n1000\\n1\") == \"999\");\n    assert(solution(\"6 2\\n200\\n400\\n600\\n800\\n1000\\n1200\") == \"400\");\n    assert(solution(\"4 2\\n15\\n10\\n20\\n5\") == \"10\");\n    assert(solution(\"3 1\\n100\\n50\\n200\") == \"50\");\n    assert(solution(\"10 5\\n1\\n2\\n3\\n4\\n5\\n6\\n7\\n8\\n9\\n10\\n\") == \"5\");\n    assert(solution(\"1 0\\n50\\n\") == \"0\");\n    assert(solution(\"10 5\\n1\\n11\\n21\\n31\\n41\\n51\\n61\\n71\\n81\\n91\\n\") == \"50\");\n    assert(solution(\"2 1\\n50\\n100\\n\") == \"50\");\n    assert(solution(\"6 4\\n5\\n10\\n15\\n20\\n25\\n30\\n\") == \"20\");\n    assert(solution(\"2 1\\n5\\n10\\n\") == \"5\");\n    assert(solution(\"5 2\\n8\\n10\\n20\\n30\\n40\\n\") == \"12\");\n    assert(solution(\"2 1\\n10\\n15\\n\") == \"5\");\n    assert(solution(\"6 4\\n10\\n20\\n30\\n40\\n50\\n60\\n\") == \"40\");\n    assert(solution(\"5 3\\n5\\n15\\n25\\n35\\n45\\n\") == \"30\");\n    assert(solution(\"3 2\\n10\\n20\\n30\\n\") == \"20\");\n    assert(solution(\"2 2\\n15\\n20\\n\") == \"5\");\n    assert(solution(\"3 1\\n8\\n15\\n22\\n\") == \"7\");\n    assert(solution(\"5 2\\n5\\n10\\n15\\n20\\n25\\n\") == \"10\");\n    assert(solution(\"6 3\\n50\\n30\\n60\\n40\\n70\\n10\\n\") == \"30\");\n    assert(solution(\"2 1\\n100\\n200\\n\") == \"100\");\n    assert(solution(\"4 2\\n15\\n30\\n25\\n35\\n\") == \"10\");\n    assert(solution(\"6 2\\n20\\n15\\n30\\n10\\n25\\n5\\n\") == \"10\");\n    assert(solution(\"3 1\\n8\\n5\\n2\\n\") == \"3\");\n    assert(solution(\"2 1\\n1\\n2\\n\") == \"1\");\n    assert(solution(\"5 2\\n15\\n10\\n25\\n20\\n5\\n\") == \"10\");\n    assert(solution(\"6 3\\n60\\n40\\n80\\n20\\n100\\n10\\n\") == \"50\");\n    return 0; \n}", "prompt": "/*There are N people participating in an international chess competition, which involves K rounds. Each person can participate in at most two matches and at least zero matches. Each person has a unique level (represented by a positive integer) that is different from others.\n\nIn the matches, the person with a higher level must use the black chess pieces while the person with a lower level must use the white chess pieces. Each person can only use black or white pieces once. In order to increase the competitiveness of the matches, viewers hope that the total difference in levels between opponents in the K rounds is minimized.\n\nFor example, if there are 7 players with levels 30, 17, 26, 41, 19, 38, and 18, and there are 3 matches, the best arrangement is for player 2 to play against player 7, player 7 to play against player 5, and player 6 to play against player 4. In this case, the total difference in levels is (18-17) + (19-18) + (41-38) = 5, which is minimized.\n\ninput_format:\nThe first row has two positive integers N, K\n\nThere are N lines, and the i line represents the i-1 personal level.\n\n[Data size]\n\nIn 90% of the data, 1≤N≤3000;\n\nIn 100% of the data, 1≤N≤100000;\n\nEnsure that the level value of all input data is less than 100000000, and 1≤K≤N-1.\n\noutput_format:\nOutput the sum of the smallest level differences in the first line.\n*/\n\n#include<sstream>\n#include<stdlib.h>\n#include<algorithm>\n#include<math.h>\n#include<stdio.h>\n#include<vector>\n#include<string>\n#include<climits>\n#include<cstring>\n#include<iostream>\nusing namespace std;\n\n             \nstring solution(string std_in){\n    istringstream iss(std_in);\n             ", "constraints": "### 数据范围及约定\n\n- 在 $90\\%$ 的数据中，$1 \\le N \\le 3000$；\n- 在 $100\\%$ 的数据中，$1 \\le N \\le 100000$。\n\n保证所有输入数据中等级的值小于 $10^9$，$1 \\le K \\le N-1$。", "samples": [["7 3\n30\n17\n26\n41\n19\n38\n18", "5"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}}
{"task_id": "P1161", "title": "开灯", "difficulty": "basic", "nl": "On an infinitely long road, there is a row of infinitely long streetlights numbered as $1,2,3,4,\\dots$.\n\nEach streetlight can only have two possible states, on or off. If you press the switch of a streetlight, its state will be changed. If it was on, it will be turned off; if it was off, it will be turned on.\n\nAt the beginning, all streetlights are off. Each time, Xiaoming can perform the following operation:\n\nSpecify two numbers, $a,t$ (where $a$ is a real number and $t$ is a positive integer). Turn on/off the streetlights with numbers $\\lfloor a\\rfloor,\\lfloor 2 \\times a\\rfloor,\\lfloor3 \\times a\\rfloor,\\dots,\\lfloor t  \\times a\\rfloor$, where $\\lfloor k \\rfloor$ denotes the integer part of $k$.\n\nAfter performing $n$ operations, Xiaoming suddenly notices that there is only one light on, but he cannot recognize the number of the light since it is too far away. Fortunately, Xiaoming remembers the $n$ operations he has performed before, and he asks for your help to calculate the number of the light that is on.", "code": "#include<bits/stdc++.h>\nusing namespace std;\nint a[2000001],n;\ndouble x,y;\nint main(){\n\tcin>>n;\n\tfor(int i=1;i<=n;i++){\n\t\tcin>>x>>y;\n\t\tfor(double j=1;j<=y;++j){\n\t\t\tif(a[int(j*x)]==0) a[int(j*x)]=1;\n\t\t\telse a[int(j*x)]=0;\n\t\t}\n\t}\n\tfor(int i=1;;i++){\n\t\tif(a[i]==1){\n\t\t\tcout<<i;\n\t\t\tbreak;\n\t\t}\n\t}\n\treturn 0;\n}", "step": ["Initialize an integer array and n variable", "Loop through the input to flip the status of elements", "Check for the first element with value 1 in the array and output its index", "Exit the program"], "nl_cn": "在一条无限长的路上，有一排无限长的路灯，编号为 $1,2,3,4,\\dots$。\n\n每一盏灯只有两种可能的状态，开或者关。如果按一下某一盏灯的开关，那么这盏灯的状态将发生改变。如果原来是开，将变成关。如果原来是关，将变成开。\n\n在刚开始的时候，所有的灯都是关的。小明每次可以进行如下的操作：\n\n指定两个数，$a,t$（$a$ 为实数，$t$ 为正整数）。将编号为 $\\lfloor a\\rfloor,\\lfloor 2 \\times a\\rfloor,\\lfloor3 \\times a\\rfloor,\\dots,\\lfloor t  \\times a\\rfloor$ 的灯的开关各按一次。其中 $\\lfloor k \\rfloor$ 表示实数 $k$ 的整数部分。\n\n在小明进行了 $n$ 次操作后，小明突然发现，这个时候只有一盏灯是开的，小明很想知道这盏灯的编号，可是这盏灯离小明太远了，小明看不清编号是多少。\n\n幸好，小明还记得之前的 $n$ 次操作。于是小明找到了你，你能帮他计算出这盏开着的灯的编号吗？\n", "test_cases": [{"input": "3\n1.618034 13\n2.618034 7\n1.000000 21", "output": "20"}, {"input": "3\n0.707106 21\n0.866025 15\n0.866025 8\n", "output": "1"}, {"input": "1\n2.236068 8\n", "output": "2"}, {"input": "2\n1 1\n2 2\n", "output": "1"}, {"input": "1\n0.1 10\n", "output": "1"}, {"input": "3\n0.123 5\n0.246 8\n0.369 3\n", "output": "1"}, {"input": "1\n0.77 13\n", "output": "1"}], "test": "#undef NDEBUG\n#include<assert.h>\nint main(){\n    assert(solution(\"3\\n1.618034 13\\n2.618034 7\\n1.000000 21\") == \"20\");\n    assert(solution(\"3\\n0.707106 21\\n0.866025 15\\n0.866025 8\\n\") == \"1\");\n    assert(solution(\"1\\n2.236068 8\\n\") == \"2\");\n    assert(solution(\"2\\n1 1\\n2 2\\n\") == \"1\");\n    assert(solution(\"1\\n0.1 10\\n\") == \"1\");\n    assert(solution(\"3\\n0.123 5\\n0.246 8\\n0.369 3\\n\") == \"1\");\n    assert(solution(\"1\\n0.77 13\\n\") == \"1\");\n    return 0; \n}", "prompt": "/*On an infinitely long road, there is a row of infinitely long streetlights numbered as $1,2,3,4,\\dots$.\n\nEach streetlight can only have two possible states, on or off. If you press the switch of a streetlight, its state will be changed. If it was on, it will be turned off; if it was off, it will be turned on.\n\nAt the beginning, all streetlights are off. Each time, Xiaoming can perform the following operation:\n\nSpecify two numbers, $a,t$ (where $a$ is a real number and $t$ is a positive integer). Turn on/off the streetlights with numbers $\\lfloor a\\rfloor,\\lfloor 2 \\times a\\rfloor,\\lfloor3 \\times a\\rfloor,\\dots,\\lfloor t  \\times a\\rfloor$, where $\\lfloor k \\rfloor$ denotes the integer part of $k$.\n\nAfter performing $n$ operations, Xiaoming suddenly notices that there is only one light on, but he cannot recognize the number of the light since it is too far away. Fortunately, Xiaoming remembers the $n$ operations he has performed before, and he asks for your help to calculate the number of the light that is on.\n\ninput_format:\nThe first line contains a positive integer $n$, indicating the number of operations.\n\nFollowing are $n$ lines, each line contains two numbers $a_i$ and $t_i$. $a_i$ is a real number with exactly $6$ decimal places, and $t_i$ is a positive integer.\n\noutput_format:\nJust a positive integer, the number of the light that's on.\n*/\n\n#include<sstream>\n#include<stdlib.h>\n#include<algorithm>\n#include<math.h>\n#include<stdio.h>\n#include<vector>\n#include<string>\n#include<climits>\n#include<cstring>\n#include<iostream>\nusing namespace std;\n\n             \nstring solution(string std_in){\n    istringstream iss(std_in);\n             ", "constraints": "记 $T=\\sum \\limits_{i=1}^n t_i = t_1+t_2+t_3+\\dots+t_n$。\n\n- 对于 $30\\%$ 的数据，满足 $T \\le 1000$；\n- 对于 $80\\%$ 的数据，满足 $T \\le 200000$；\n- 对于 $100\\%$ 的数据，满足 $T \\le 2000000$；\n- 对于 $100\\%$ 的数据，满足 $n \\le 5000$，$1 \\le a_i<1000$，$1 \\le t_i \\le T$。\n\n数据保证，在经过 $n$ 次操作后，有且只有一盏灯是开的，不必判错。而且对于所有的 $i$ 来说，$t_i\\times a_i$ 的最大值不超过 $2000000$。", "samples": [["3\n1.618034 13\n2.618034 7\n1.000000 21", "20"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}}
{"task_id": "P7775", "title": "[COCI2009-2010#2] VUK", "difficulty": "challenge", "nl": "A wolf named Vjekoslav is running away from a group of vicious hunters. \n\nThese hunters are very fierce and often hide behind trees, but Vjekoslav does not know which tree has a hunter behind it. For safety, Vjekoslav wants to stay as far away from trees as possible while escaping back to its comfortable den.\n\nThe forest can be abstracted as an $N\\times M$ matrix. Each grid can be empty (represented by `.`) or have a tree in the center (represented by `+`). Vjekoslav is located at `V` and its den is located at `J`. The distance between Vjekoslav and a tree is defined as the Manhattan distance between their grid positions (i.e., the absolute difference of their row and column indices).\n\nVjekoslav can move in any of the four cardinal directions (north, south, east, or west) even if the next grid has a tree (which does not block Vjekoslav in this problem). Help find a path from `V` to `J` such that the maximum value of the minimum distance between Vjekoslav and a tree along the path is maximized.\n\nNote that Vjekoslav's den does not occupy a whole grid, so `J` must be included in your path.", "code": "#include<bits/stdc++.h>\nusing namespace std;\nconst int maxn=505;\nint mhd[maxn][maxn],n,m;\nbool danger[maxn][maxn],vis[maxn][maxn];\nstruct wolf{\n\tint x;\n\tint y;\n\tint Manhattan_distance;//Vjekoslav 在逃回窝的途中离它最近的树的距离的最小值\n\tbool operator < (const wolf &tmp) const {//重载一下运算符\n\t\treturn Manhattan_distance<tmp.Manhattan_distance;\n\t} \n};\nstruct node{\n\tint x,y,h;\n}e,s;\nint dx[4]={0,0,1,-1};//方向函数\nint dy[4]={1,-1,0,0};\nqueue<node> nq;\nvoid bfs1(){//求曼哈顿距离\n\twhile(!nq.empty()){\n\t\tnode cur=nq.front();\n\t\tnq.pop();\n\t\tmhd[cur.x][cur.y]=cur.h;\n\t\tfor(int i=0;i<4;i++){\n\t\t\tint nx=cur.x+dx[i];\n\t\t\tint ny=cur.y+dy[i];\n\t\t\tif(1<=nx&&nx<=n&&1<=ny&&ny<=m&&!danger[nx][ny]){\n\t\t\t\tdanger[nx][ny]=1;\n\t\t\t\tnq.push({nx,ny,cur.h+1});\n\t\t\t}\n\t\t}\n\t}\n\treturn;\n}\nint bfs(int x,int y){//求答案\n\tint ans=1e9;\n\tpriority_queue<wolf> q;\n\tvis[x][y]=1;\n\tq.push({x,y,mhd[x][y]});\n\twhile(!q.empty()){\n\t\twolf cur=q.top();\n\t\tq.pop();\n\t\tif(cur.x==e.x&&cur.y==e.y) {//取最小答案\n\t\t\tans=min(ans,cur.Manhattan_distance);\n\t\t}\n\t\tfor(int i=0;i<4;i++){\n\t\t\tint nx=cur.x+dx[i];\n\t\t\tint ny=cur.y+dy[i];\n\t\t\tif(1<=nx&&nx<=n&&1<=ny&&ny<=m&&!vis[nx][ny]){\n\t\t\t\tvis[nx][ny]=1;\n\t\t\t\tq.push({nx,ny,min(cur.Manhattan_distance,mhd[nx][ny])});\n\t\t\t}\n\t\t}\n\t}\n\treturn ans;//返回答案\n}\nint main(){\n    cin>>n>>m;\n    for(int i=1;i<=n;i++){\n    \tfor(int j=1;j<=m;j++){\n    \t\tchar a;\n    \t\tcin>>a;\n    \t\tif(a=='+'){//树\n    \t\t\tdanger[i][j]=1;\n    \t\t\tnq.push({i,j,0});\n\t\t\t}\n\t\t\telse if(a=='V'){//起点\n\t\t\t\ts={i,j};\n\t\t\t}\n\t\t\telse if(a=='J'){//终点\n\t\t\t\te={i,j};\n\t\t\t}\n\t\t}\n\t}\n\tbfs1();\n\tcout<<bfs(s.x,s.y);\n\treturn 0;\n}", "step": ["Read input of n and m", "Initialize the matrix of dangerous squares with '+' in the input coordinates and add them to the queue", "Get the coordinates of the starting and ending positions, and store in 's' and 'e'", "Use bfs to calculate the Manhattan distance from all locations in the matrix to the nearest dangerous square", "Use a priority queue for bfs to find the shortest distance to reach the ending position while avoiding dangerous squares", "Output the minimum Manhattan distance to reach the ending position"], "nl_cn": "一匹狼 Vjekoslav 正在逃离一批残暴的猎人的追捕。\n\n这些猎人非常凶残，经常躲在树后面，但 Vjekoslav 并不知道哪棵树后有猎人。为了保险，Vjekoslav 希望在逃回它舒适的窝的过程中离树越远越好。\n\n森林可以抽象为 $N\\times M$ 的矩阵。每个格子可能是空的（用`.`表示），也有可能有一棵树在中心位置（用`+`表示）。Vjekoslav在`V`标示的地方而它的窝在`J`标示的地方。定义 Vjekoslav 与某棵树的距离为它们所在格的曼哈顿距离（即这两个格子所在行、列之差的绝对值之和）。\n\nVjekoslav 每次可以往东南西北中的任一方向移动，**即使它下一步移动到的格子有树（此题树并不会阻挡 Vjekoslav）**。帮忙找出这样一条从`V`到`J`的路径，使得 Vjekoslav 在途中离它最近的树的距离的最小值最大。\n\n**注意 Vjekoslav 的窝并不占据整块格子，因此你的路径中必须包含`J`。**", "test_cases": [{"input": "4 4\n+...\n....\n....\nV..J\n", "output": "3"}, {"input": "4 5\n.....\n.+++.\n.+.+.\nV+.J+", "output": "0"}, {"input": "3 3\n.J.\n+V+\n...", "output": "1"}, {"input": "2 2\nJ.\n.V", "output": "0"}, {"input": "4 5\nV....\n.....\n.+++.\n.J+..", "output": "1"}, {"input": "4 3\nJ.+\nV+.\n.++\n+..", "output": "1"}, {"input": "5 6\n.....\n.....\n..+++J\n..V+..\n.....\n", "output": "1"}, {"input": "3 4\n....\n+..+\nVJ..\n", "output": "1"}, {"input": "5 4\n..+.\n....\n...J\n..+.\nV+..\n", "output": "1"}, {"input": "4 4\n..V.\n.+..\n...J\n....\n", "output": "2"}, {"input": "3 4\n..+.\n...V\n..+J\n", "output": "1"}, {"input": "5 4\n.....\n.+..V\n.....\n..+J.\n", "output": "1"}, {"input": "2 2\nVV\nJJ\n", "output": "0"}, {"input": "6 6\n......\n..+...\n..+.+.\n.VJ...\n..+...\n..+...\n", "output": "1"}, {"input": "4 4\n++++\n..+.\n.VJ.\n....\n", "output": "1"}, {"input": "5 5\n..+V+\n.....\n..+..\n....J\n.....\n", "output": "1"}, {"input": "2 2\n.V\nJ.\n", "output": "0"}, {"input": "3 4\n.V..\nJ+..\n....\n", "output": "1"}, {"input": "5 5\n.V...\n...+.\n.....\n.++..\n..J..\n", "output": "1"}, {"input": "5 3\n+V.\n.J.\n+..\n.J.\n...\n", "output": "1"}, {"input": "2 2\nV.\n.J\n", "output": "0"}, {"input": "2 4\nV+..\n.J..\n", "output": "1"}, {"input": "4 3\n.J.\nV+.\n..+\n..+\n", "output": "1"}, {"input": "3 3\n.VJ\n...\n+++\n", "output": "2"}, {"input": "4 7\n.V...++\n.....++\nV...++J\n..VV...\n", "output": "1"}, {"input": "3 3\n..V\n..+\n++J\n", "output": "0"}], "test": "#undef NDEBUG\n#include<assert.h>\nint main(){\n    assert(solution(\"4 4\\n+...\\n....\\n....\\nV..J\\n\") == \"3\");\n    assert(solution(\"4 5\\n.....\\n.+++.\\n.+.+.\\nV+.J+\") == \"0\");\n    assert(solution(\"3 3\\n.J.\\n+V+\\n...\") == \"1\");\n    assert(solution(\"2 2\\nJ.\\n.V\") == \"0\");\n    assert(solution(\"4 5\\nV....\\n.....\\n.+++.\\n.J+..\") == \"1\");\n    assert(solution(\"4 3\\nJ.+\\nV+.\\n.++\\n+..\") == \"1\");\n    assert(solution(\"5 6\\n.....\\n.....\\n..+++J\\n..V+..\\n.....\\n\") == \"1\");\n    assert(solution(\"3 4\\n....\\n+..+\\nVJ..\\n\") == \"1\");\n    assert(solution(\"5 4\\n..+.\\n....\\n...J\\n..+.\\nV+..\\n\") == \"1\");\n    assert(solution(\"4 4\\n..V.\\n.+..\\n...J\\n....\\n\") == \"2\");\n    assert(solution(\"3 4\\n..+.\\n...V\\n..+J\\n\") == \"1\");\n    assert(solution(\"5 4\\n.....\\n.+..V\\n.....\\n..+J.\\n\") == \"1\");\n    assert(solution(\"2 2\\nVV\\nJJ\\n\") == \"0\");\n    assert(solution(\"6 6\\n......\\n..+...\\n..+.+.\\n.VJ...\\n..+...\\n..+...\\n\") == \"1\");\n    assert(solution(\"4 4\\n++++\\n..+.\\n.VJ.\\n....\\n\") == \"1\");\n    assert(solution(\"5 5\\n..+V+\\n.....\\n..+..\\n....J\\n.....\\n\") == \"1\");\n    assert(solution(\"2 2\\n.V\\nJ.\\n\") == \"0\");\n    assert(solution(\"3 4\\n.V..\\nJ+..\\n....\\n\") == \"1\");\n    assert(solution(\"5 5\\n.V...\\n...+.\\n.....\\n.++..\\n..J..\\n\") == \"1\");\n    assert(solution(\"5 3\\n+V.\\n.J.\\n+..\\n.J.\\n...\\n\") == \"1\");\n    assert(solution(\"2 2\\nV.\\n.J\\n\") == \"0\");\n    assert(solution(\"2 4\\nV+..\\n.J..\\n\") == \"1\");\n    assert(solution(\"4 3\\n.J.\\nV+.\\n..+\\n..+\\n\") == \"1\");\n    assert(solution(\"3 3\\n.VJ\\n...\\n+++\\n\") == \"2\");\n    assert(solution(\"4 7\\n.V...++\\n.....++\\nV...++J\\n..VV...\\n\") == \"1\");\n    assert(solution(\"3 3\\n..V\\n..+\\n++J\\n\") == \"0\");\n    return 0; \n}", "prompt": "/*A wolf named Vjekoslav is running away from a group of vicious hunters. \n\nThese hunters are very fierce and often hide behind trees, but Vjekoslav does not know which tree has a hunter behind it. For safety, Vjekoslav wants to stay as far away from trees as possible while escaping back to its comfortable den.\n\nThe forest can be abstracted as an $N\\times M$ matrix. Each grid can be empty (represented by `.`) or have a tree in the center (represented by `+`). Vjekoslav is located at `V` and its den is located at `J`. The distance between Vjekoslav and a tree is defined as the Manhattan distance between their grid positions (i.e., the absolute difference of their row and column indices).\n\nVjekoslav can move in any of the four cardinal directions (north, south, east, or west) even if the next grid has a tree (which does not block Vjekoslav in this problem). Help find a path from `V` to `J` such that the maximum value of the minimum distance between Vjekoslav and a tree along the path is maximized.\n\nNote that Vjekoslav's den does not occupy a whole grid, so `J` must be included in your path.\n\ninput_format:\nThe first row has two integers $N,M$.\n\nNext, $N$lines with $M$characters on each line describe the forest.\n\nIn the description of this forest, there will only be one 'V' and one 'J', and at least one '+' is guaranteed.\n\noutput_format:\nA row of integers, the maximum possible minimum distance from the nearest tree for Vjekoslav on his way back to the nest.\n*/\n\n#include<sstream>\n#include<stdlib.h>\n#include<algorithm>\n#include<math.h>\n#include<stdio.h>\n#include<vector>\n#include<string>\n#include<climits>\n#include<cstring>\n#include<iostream>\nusing namespace std;\n\n             \nstring solution(string std_in){\n    istringstream iss(std_in);\n             ", "constraints": "$1\\leq N,M\\leq500$。", "samples": [["4 4\n+...\n....\n....\nV..J\n", "3"], ["4 5\n.....\n.+++.\n.+.+.\nV+.J+", "0"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [32768, 32768, 32768, 32768, 32768, 32768, 32768, 32768, 32768, 32768]}}
{"task_id": "P2876", "title": "[USACO07JAN]Problem Solving G", "difficulty": "advanced", "nl": "Farmer John's cows have P (1 ≤ P ≤ 300) problems to be solved by hiring consultants. Each consultant can solve any problem in a single month and demands two payments: one in advance (1 ≤ payment ≤ M) to be paid at the start of the month problem-solving is commenced and one more payment at the start of the month after the problem is solved (1 ≤ payment ≤ M). The cows have M (1 ≤ M ≤ 1000) money on a normal month, but cannot save any money from month-to-month. Money not used is wasted on cow candy. The problems must be solved mostly in order, and each month the cows can spend the money earned during the previous month to pay for consultants. Determine the number of months it takes to solve all of the cows' problems and pay for the solutions.", "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define int long long\n#define getchar() (p1 == p2 && (p2 = (p1 = buf1) + fread(buf1, 1, 1 << 21, stdin), p1 == p2) ? EOF : *p1++)\nchar buf1[1 << 23], *p1 = buf1, *p2 = buf1, ubuf[1 << 23], *u = ubuf;\nnamespace IO\n{\n\ttemplate<typename T>\n\tvoid read(T &_x){_x=0;int _f=1;char ch=getchar();while(!isdigit(ch)) _f=(ch=='-'?-1:_f),ch=getchar();while(isdigit(ch)) _x=_x*10+(ch^48),ch=getchar();_x*=_f;}\n\ttemplate<typename T,typename... Args>\n\tvoid read(T &_x,Args&...others){Read(_x);Read(others...);}\n\tconst int BUF=20000000;char buf[BUF],to,stk[32];int plen;\n\t#define pc(x) buf[plen++]=x\n\t#define flush(); fwrite(buf,1,plen,stdout),plen=0;\n\ttemplate<typename T>inline void print(T x){if(!x){pc(48);return;}if(x<0) x=-x,pc('-');for(;x;x/=10) stk[++to]=48+x%10;while(to) pc(stk[to--]);}\n}\nusing namespace IO;\nconst int N = 310,M = 1010;\nint n,m,a[N],b[N],f[N][M],ans,o,o1;//解决j个问题，上个月有z要付款至少要几个月 \nsigned main()\n{\n//\tfreopen(\".in\",\"r\",stdin);\n//\tfreopen(\".out\",\"w\",stdout);\n\tread(m),read(n);\n\tfor(int i = 1;i <= n;i++) read(a[i]),read(b[i]);\n\tfor(int i = 0;i <= n;i++)\n\t\tfor(int j = 0;j <= m;j++)\n\t\t\tf[i][j] = 1e9+7; \n\tf[0][0] = 1;\n\tfor(int i = 0;i <= n;i++)\n\t\tfor(int j = 0;j <= m;j++)\n\t\t\tif(f[i][j] != 1e9+7)\n\t\t\t{\n\t\t\t\to = m-j,o1 = 0;\n\t\t\t\tfor(int z = i+1;z <= n;z++)\n\t\t\t\t{\n\t\t\t\t\to -= a[z],o1 += b[z];\n\t\t\t\t\tif(o < 0 || o1 > m) break;\n\t\t\t\t\tf[z][o1] = min(f[z][o1],f[i][j]+1);\n\t\t\t\t\tf[z][0] = min(f[z][0],f[z][o1]+1);\n\t\t\t\t}\n\t\t\t} ans = f[n][0];\n\tprint(ans); flush();\n\treturn 0;\n}\n/*\n\n*/", "step": ["Read in the input values.", "Initialize the dynamic programming array with a large value.", "Set the initial values for the dynamic programming array.", "Read in the values for q and h arrays.", "Calculate the cumulative sums for q and h arrays.", "Fill up the dynamic programming array by computing optimal values.", "Determine the minimum number of helicopters needed for the mission.", "Print the minimum number of helicopters."], "nl_cn": "In easier times, Farmer John's cows had no problems. These days, though, they have problems, lots of problems; they have P (1 ≤ P ≤ 300) problems, to be exact. They have quit providing milk and have taken regular jobs like all other good citizens. In fact, on a normal month they make M (1 ≤ M ≤ 1000) money.\n\nTheir problems, however, are so complex they must hire consultants to solve them. Consultants are not free, but they are competent: consultants can solve any problem in a single month. Each consultant demands two payments: one in advance (1 ≤ payment ≤ M) to be paid at the start of the month problem-solving is commenced and one more payment at the start of the month after the problem is solved (1 ≤ payment ≤ M). Thus, each month the cows can spend the money earned during the previous month to pay for consultants. Cows are spendthrifts: they can never save any money from month-to-month; money not used is wasted on cow candy.\n\nSince the problems to be solved depend on each other, they must be solved mostly in order. For example, problem 3 must be solved before problem 4 or during the same month as problem 4.\n\nDetermine the number of months it takes to solve all of the cows' problems and pay for the solutions.\n\nP个问题，雇佣相同的人去解决，每个人每月解决一道题，每个人解决问题的代价都分两次，解决问题当月给a[i],事后第二月给b[i],然后每个月有m的钱，问最快多久解决所有问题。（问题必须按照序号一个个解决）\n这个月用上个月的钱支付，然后结余会用来买糖\n", "test_cases": [{"input": "100 5\n40 20\n60 20\n30 50\n30 50\n40 40", "output": "6"}, {"input": "70 3\n10 5\n20 10\n10 5\n", "output": "3"}, {"input": "110 4\n50 30\n30 15\n20 10\n40 30\n", "output": "4"}, {"input": "50 2\n20 40\n30 30\n", "output": "5"}, {"input": "50 3\n40 50\n20 30\n20 10\n", "output": "5"}, {"input": "150 4\n10 10\n20 20\n30 30\n40 40\n", "output": "3"}, {"input": "100 3\n10 10\n20 20\n30 30\n", "output": "3"}, {"input": "100 2\n10 50\n20 100\n", "output": "4"}, {"input": "100 4\n10 50\n20 40\n30 30\n40 20\n", "output": "5"}], "test": "#undef NDEBUG\n#include<assert.h>\nint main(){\n    assert(solution(\"100 5\\n40 20\\n60 20\\n30 50\\n30 50\\n40 40\") == \"6\");\n    assert(solution(\"70 3\\n10 5\\n20 10\\n10 5\\n\") == \"3\");\n    assert(solution(\"110 4\\n50 30\\n30 15\\n20 10\\n40 30\\n\") == \"4\");\n    assert(solution(\"50 2\\n20 40\\n30 30\\n\") == \"5\");\n    assert(solution(\"50 3\\n40 50\\n20 30\\n20 10\\n\") == \"5\");\n    assert(solution(\"150 4\\n10 10\\n20 20\\n30 30\\n40 40\\n\") == \"3\");\n    assert(solution(\"100 3\\n10 10\\n20 20\\n30 30\\n\") == \"3\");\n    assert(solution(\"100 2\\n10 50\\n20 100\\n\") == \"4\");\n    assert(solution(\"100 4\\n10 50\\n20 40\\n30 30\\n40 20\\n\") == \"5\");\n    return 0; \n}", "prompt": "/*Farmer John's cows have P (1 ≤ P ≤ 300) problems to be solved by hiring consultants. Each consultant can solve any problem in a single month and demands two payments: one in advance (1 ≤ payment ≤ M) to be paid at the start of the month problem-solving is commenced and one more payment at the start of the month after the problem is solved (1 ≤ payment ≤ M). The cows have M (1 ≤ M ≤ 1000) money on a normal month, but cannot save any money from month-to-month. Money not used is wasted on cow candy. The problems must be solved mostly in order, and each month the cows can spend the money earned during the previous month to pay for consultants. Determine the number of months it takes to solve all of the cows' problems and pay for the solutions.\n\ninput_format:\nLine 1: Two space-separated integers: M and P.\nLines 2..P+1: Line i+1 describes problem i with two space-separated integers: Bi and Ai. Bi is the payment to the consult BEFORE the problem is solved; Ai is the payment to the consult AFTER the problem is solved.\n\noutput_format:\nLine 1: The number of months it takes to solve and pay for all the cows' problems.\n*/\n\n#include<sstream>\n#include<stdlib.h>\n#include<algorithm>\n#include<math.h>\n#include<stdio.h>\n#include<vector>\n#include<string>\n#include<climits>\n#include<cstring>\n#include<iostream>\nusing namespace std;\n\n             \nstring solution(string std_in){\n    istringstream iss(std_in);\n             ", "constraints": "|      | Avail | Probs  | Before  | After   | Candy  |\n| :-----------: | :-----------: | :-----------: | :-----------: | :-----------: | :-----------: |\n|Month | Money | Solved | Payment | Payment | Money  |\n| 1    | 0     | -none- | 0       | 0       | 0      |\n| 2    | 100   | 1, 2   | 40+60   | 0       | 0      |\n| 3    | 100   | 3, 4   | 30+30   | 20+20   | 0      |\n| 4    | 100   | -none- | 0       | 50+50   | 0      |\n| 5    | 100   | 5      | 40      | 0       | 60     |\n| 6    | 100   | -none- | 0       | 40      | 60     |", "samples": [["100 5\n40 20\n60 20\n30 50\n30 50\n40 40", "6"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}}
{"task_id": "P2376", "title": "[USACO09OCT]Allowance G", "difficulty": "advanced", "nl": "As a reward for setting a new milk production record, Farmer John has decided to start giving Bessie a weekly allowance.\n\nFJ has some coins of N (1 <= N <= 20) different denominations. Each denomination is divisible by all larger denominations.\n\nHe wants to use a given set of coins to be able to pay Bessie at least some amount C (1 <= C <= 100000000) for each week. Please help him calculate the maximum number of weeks he can pay Bessie.", "code": "#include <cstdio>\n#include <algorithm>\nusing namespace std;\n\ntypedef struct coin {int v,b;}coin;\n\ncoin cn[30];\nint n,c,sum=0,k=0;\n\nbool cmp(coin a,coin b) {return a.v<b.v;}\n\ninline int read(){\n    int num=0,k=1; char c=getchar();\n    while(c>'9' || c<'0') k=(c=='-')?-1:k,c=getchar();\n    while(c>='0' && c<='9') num=(num<<3)+(num<<1)+c-'0',c=getchar();\n    return num*k;\n}\n\nint main() {\n    n=read(); c=read();\n    for(int i=1;i<=n;i++){\n        int v=read(),b=read();\n        if(v>=c) {sum+=b; continue;}\n        cn[++k].v=v; cn[k].b=b;\n    }\n    sort(cn+1,cn+k+1,cmp);\n    while(true){\n        int x=c,v[30]={0};\n        for(int i=k;i>=1;i--){\n            if(cn[i].b<=0 || cn[i].v>x) continue;\n            if(cn[i].b>=x/cn[i].v) v[i]+=x/cn[i].v,x=x%cn[i].v;\n            else v[i]+=cn[i].b,x-=cn[i].b*cn[i].v;\n        }\n        for(int i=1;i<=k;i++){\n            if(x<=0) break;\n            if(cn[i].b-v[i]<=0 || x>cn[i].v) continue;\n            x-=cn[i].v; v[i]++;\n        }\n        if(x>0) break;\n        int ans=1000000000;\n        for(int i=1;i<=k;i++) if(v[i]) ans=min(ans,cn[i].b/v[i]);\n        for(int i=1;i<=k;i++) cn[i].b-=ans*v[i];\n        sum+=ans;\n    }\n    printf(\"%d\",sum);\n    return 0;\n}", "step": ["Read in the number of coins and the total amount of money.", "Store the types of coins and their values in a struct array, and if the value of the coin is greater than or equal to the total amount of money, add it to the sum of coins required.", "Sort the coins in ascending order based on their values.", "Using a greedy algorithm, calculate the minimum number of each coin required to form the total amount of money.", "If there are any remaining coins, add the minimum number of coins to the sum and reduce the number of those coins from the available coins.", "Output the sum of coins required."], "nl_cn": "作为创造产奶纪录的回报，Farmer John决定开始每个星期给Bessie一点零花钱。\n\nFJ有一些硬币，一共有N (1 <= N <= 20)种不同的面额。每一个面额都能整除所有比它大的面额。\n\n他想用给定的硬币的集合，每个星期至少给Bessie某个零花钱的数目C (1 <= C <= 100000000)。请帮他计算他最多能支付多少个星期的零花钱。\n", "test_cases": [{"input": "3 6\n10 1\n1 100\n5 120", "output": "111"}, {"input": "1 1\n1 1\n", "output": "1"}, {"input": "2 3\n4 1\n3 2\n", "output": "3"}, {"input": "1 100000000\n200000000 1\n", "output": "1"}, {"input": "2 8\n9 1\n4 2\n", "output": "2"}, {"input": "1 5\n5 1", "output": "1"}, {"input": "4 20\n20 1\n10 2\n5 5\n1 100", "output": "8"}, {"input": "1 7\n7 1", "output": "1"}, {"input": "2 12\n12 1\n6 2", "output": "2"}, {"input": "3 18\n18 1\n9 2\n3 10", "output": "3"}, {"input": "5 35\n35 1\n25 2\n15 3\n10 4\n5 5", "output": "5"}, {"input": "6 50\n50 1\n40 2\n30 3\n20 4\n10 5\n5 5", "output": "7"}, {"input": "2 50\n80 3\n60 4\n", "output": "7"}, {"input": "2 8\n20 1\n10 2\n", "output": "3"}, {"input": "2 8\n15 1\n10 2\n", "output": "3"}, {"input": "2 8\n15 1\n12 2\n", "output": "3"}, {"input": "2 7\n2 5\n3 10\n", "output": "5"}, {"input": "2 6\n3 4\n4 3\n", "output": "3"}], "test": "#undef NDEBUG\n#include<assert.h>\nint main(){\n    assert(solution(\"3 6\\n10 1\\n1 100\\n5 120\") == \"111\");\n    assert(solution(\"1 1\\n1 1\\n\") == \"1\");\n    assert(solution(\"2 3\\n4 1\\n3 2\\n\") == \"3\");\n    assert(solution(\"1 100000000\\n200000000 1\\n\") == \"1\");\n    assert(solution(\"2 8\\n9 1\\n4 2\\n\") == \"2\");\n    assert(solution(\"1 5\\n5 1\") == \"1\");\n    assert(solution(\"4 20\\n20 1\\n10 2\\n5 5\\n1 100\") == \"8\");\n    assert(solution(\"1 7\\n7 1\") == \"1\");\n    assert(solution(\"2 12\\n12 1\\n6 2\") == \"2\");\n    assert(solution(\"3 18\\n18 1\\n9 2\\n3 10\") == \"3\");\n    assert(solution(\"5 35\\n35 1\\n25 2\\n15 3\\n10 4\\n5 5\") == \"5\");\n    assert(solution(\"6 50\\n50 1\\n40 2\\n30 3\\n20 4\\n10 5\\n5 5\") == \"7\");\n    assert(solution(\"2 50\\n80 3\\n60 4\\n\") == \"7\");\n    assert(solution(\"2 8\\n20 1\\n10 2\\n\") == \"3\");\n    assert(solution(\"2 8\\n15 1\\n10 2\\n\") == \"3\");\n    assert(solution(\"2 8\\n15 1\\n12 2\\n\") == \"3\");\n    assert(solution(\"2 7\\n2 5\\n3 10\\n\") == \"5\");\n    assert(solution(\"2 6\\n3 4\\n4 3\\n\") == \"3\");\n    return 0; \n}", "prompt": "/*As a reward for setting a new milk production record, Farmer John has decided to start giving Bessie a weekly allowance.\n\nFJ has some coins of N (1 <= N <= 20) different denominations. Each denomination is divisible by all larger denominations.\n\nHe wants to use a given set of coins to be able to pay Bessie at least some amount C (1 <= C <= 100000000) for each week. Please help him calculate the maximum number of weeks he can pay Bessie.\n\ninput_format:\nLine 1: Two integers separated by a space: N and C;\n\nLines 2 to N+1: Each line contains two integers representing a coin denomination: coin denomination V (1 <= V <= 100,000,000) and the number of coins with that denomination B (1 <= B <= 1,000,000).\n\n(Thanks to fyszzhouzj, the error has been corrected)\n\noutput_format:\nLine 1: A single integer indicating the maximum number of weeks that can be paid in allowance of at least C.\n*/\n\n#include<sstream>\n#include<stdlib.h>\n#include<algorithm>\n#include<math.h>\n#include<stdio.h>\n#include<vector>\n#include<string>\n#include<climits>\n#include<cstring>\n#include<iostream>\nusing namespace std;\n\n             \nstring solution(string std_in){\n    istringstream iss(std_in);\n             ", "constraints": "", "samples": [["3 6\n10 1\n1 100\n5 120", "111"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}}
{"task_id": "P3124", "title": "[USACO15OPEN]Trapped in the Haybales S", "difficulty": "advanced", "nl": "Farmer John has received $N$ shipments of hay bales ($1 \\le N \\le 100,000$), and has placed them at various positions along the one-dimensional road connecting his barn and his house. Each bale $j$ has a size $S_j$ and a distinct position $P_j$ specifying where it sits along the road. Cow Bessie is currently located at position $B$, where there is no hay bale. Bessie is free to move along the route, and can even reach the position of a hay bale, but she cannot pass through that position. However, if she moves distance $D$ in the same direction, she can build up enough speed to permanently eliminate any hay bale with size strictly less than $D$. Of course, after doing this, she might open up more space that allows her to attack other hay bales and eliminate them as well. FJ is currently repainting his house and barn, and wants to make sure Bessie cannot reach either one (cows and fresh paint don't mix well!). Therefore, FJ wants to make sure that Bessie will never pass through the leftmost or rightmost hay bale, so she can effectively be trapped. FJ has the ability to add hay to a single bale of his choosing in order to help keep Bessie trapped. Please help him determine the minimum additional size that needs to be added to some bale to guarantee that Bessie remains trapped.", "code": "#include<bits/stdc++.h>\n#define R register\n#define inf 1e18\n#define int long long\n\nusing namespace std;\nconst int N = 1e5+5;\nint n,b,ans = inf,now;\nint l,r,d;\nstruct node {\n\tint pos,size;\n}g[N];\n\ninline bool cmp(node a,node b) { return a.pos < b.pos; }\n\nsigned main() {\n\tscanf(\"%lld%lld\",&n,&b);\n\tfor(R int i = 1;i <= n;++ i) {\n\t\tscanf(\"%lld%lld\",&g[i].size,&g[i].pos);\n\t}\n\tsort(g + 1,g + n + 1,cmp);\n\tfor(R int i = 1;i <= n;++ i)\n\t\tif(g[i].pos > b) { now = i;break; }\n\tl = now - 1,r = now,d = g[r].pos - g[l].pos;\n\twhile(l >= 1 && r <= n) {\n\t\tif(g[l].size >= d && g[r].size >= d) { printf(\"0\");return 0; }\n\t\tif(g[r].size < d) { r ++;d += g[r].pos - g[r - 1].pos;continue; }\n\t\tif(g[l].size < d) {\tans = min(d - g[l].size,ans);l --;d += g[l + 1].pos - g[l].pos; }\n\t}\n\tl = now - 1,r = now,d = g[r].pos - g[l].pos;\n\twhile(l >= 1 && r <= n) {\n\t\tif(g[l].size >= d && g[r].size >= d) { printf(\"0\");return 0; }\n\t\tif(g[l].size < d) { l --;d += g[l + 1].pos - g[l].pos;continue; }\n\t\tif(g[r].size < d) {\tans = min(d - g[r].size,ans);r ++;d += g[r].pos - g[r - 1].pos; }\n\t}\n\tprintf(\"%lld\",ans == inf ? -1 : ans);\n\treturn 0;\n}", "step": ["Read in the value of n and b.", "Read in n lines with two integer values x and y, where x represents the position of the weight point and y represents its weight.", "Sort the n points array in ascending order of position of the point.", "Find the position of the weight point B, and set the left and right pointers to the positions of the nearest two points on the left and right sides of B, respectively.", "Cycle through the leftward pointer position until arriving at the left end or the triangle is found, expanding leftward and adjusting the rightward pointer value if the value at the left point is too small.", "Cycle through the rightward pointer position until arriving at the right end or the triangle is found, expanding rightward, and adjusting the leftward pointer value if the value at the right point is too small.", "Output the smallest weight found for a triangle or -1 if no weight exists."], "nl_cn": "Farmer John has received a shipment of $N$ large hay bales\n\n($1 \\le N \\le 100,000$), and placed them at various locations along the road\n\nconnecting the barn with his house.  Each bale $j$ has a size $S_j$ and a\n\ndistinct position $P_j$ giving its location along the one-dimensional road.\n\nBessie the cow is currently located at position $B$, where there is no hay bale.\n\nBessie the cow can move around freely along the road, even up to the position at\n\nwhich a bale is located, but she cannot cross through this position.  As an\n\nexception, if she runs in the same direction for $D$ units of distance, she\n\nbuilds up enough speed to break through and permanently eliminate any hay bale\n\nof size strictly less than $D$.  Of course, after doing this, she might\n\nopen up more space to allow her to make a run at other hay bales, eliminating\n\nthem as well.\n\nFJ is currently re-painting his house and his barn, and wants to make sure\n\nBessie cannot reach either one (cows and fresh paint do not make a good\n\ncombination!)  Accordingly, FJ wants to make sure Bessie never breaks through\n\nthe leftmost or rightmost hay bale, so she stays effectively trapped within the\n\nhay bales.  FJ has the ability to add hay to a single bale of his choosing to\n\nhelp keep Bessie trapped.  Please help him determine the minimum amount of extra\n\nsize he needs to add to some bale to ensure Bessie stays trapped.\n", "test_cases": [{"input": "5 7\n8 1\n1 4\n3 8\n12 15\n20 20", "output": "4"}, {"input": "1 5\n10 1", "output": "-1"}, {"input": "6 20\n7 1\n9 5\n3 7\n8 13\n5 17\n10 20", "output": "-1"}, {"input": "4 4\n5 1\n6 5\n4 6\n1 10", "output": "0"}, {"input": "2 5\n5 4\n6 3\n", "output": "-1"}, {"input": "7 5\n5 1\n7 3\n3 2\n4 4\n1 5\n2 7\n6 6\n", "output": "0"}, {"input": "5 4\n7 2\n8 3\n4 1\n9 5\n1 6\n", "output": "0"}, {"input": "3 6\n7 4\n1 2\n10 8\n", "output": "0"}, {"input": "8 4\n1 1\n7 5\n4 8\n2 10\n3 15\n6 20\n5 25\n8 30\n", "output": "3"}, {"input": "6 7\n1 1\n2 3\n3 5\n4 7\n5 9\n6 11\n", "output": "0"}, {"input": "9 5\n2 1\n3 4\n4 8\n5 12\n1 15\n7 18\n6 20\n9 25\n8 30\n", "output": "1"}, {"input": "5 4\n2 1\n3 4\n4 8\n5 12\n1 15\n", "output": "1"}, {"input": "10 9\n1 1\n2 3\n3 5\n4 7\n5 9\n6 11\n7 13\n8 15\n9 17\n10 19\n", "output": "0"}, {"input": "6 4\n4 2\n8 5\n12 7\n16 10\n20 15\n24 20\n", "output": "0"}], "test": "#undef NDEBUG\n#include<assert.h>\nint main(){\n    assert(solution(\"5 7\\n8 1\\n1 4\\n3 8\\n12 15\\n20 20\") == \"4\");\n    assert(solution(\"1 5\\n10 1\") == \"-1\");\n    assert(solution(\"6 20\\n7 1\\n9 5\\n3 7\\n8 13\\n5 17\\n10 20\") == \"-1\");\n    assert(solution(\"4 4\\n5 1\\n6 5\\n4 6\\n1 10\") == \"0\");\n    assert(solution(\"2 5\\n5 4\\n6 3\\n\") == \"-1\");\n    assert(solution(\"7 5\\n5 1\\n7 3\\n3 2\\n4 4\\n1 5\\n2 7\\n6 6\\n\") == \"0\");\n    assert(solution(\"5 4\\n7 2\\n8 3\\n4 1\\n9 5\\n1 6\\n\") == \"0\");\n    assert(solution(\"3 6\\n7 4\\n1 2\\n10 8\\n\") == \"0\");\n    assert(solution(\"8 4\\n1 1\\n7 5\\n4 8\\n2 10\\n3 15\\n6 20\\n5 25\\n8 30\\n\") == \"3\");\n    assert(solution(\"6 7\\n1 1\\n2 3\\n3 5\\n4 7\\n5 9\\n6 11\\n\") == \"0\");\n    assert(solution(\"9 5\\n2 1\\n3 4\\n4 8\\n5 12\\n1 15\\n7 18\\n6 20\\n9 25\\n8 30\\n\") == \"1\");\n    assert(solution(\"5 4\\n2 1\\n3 4\\n4 8\\n5 12\\n1 15\\n\") == \"1\");\n    assert(solution(\"10 9\\n1 1\\n2 3\\n3 5\\n4 7\\n5 9\\n6 11\\n7 13\\n8 15\\n9 17\\n10 19\\n\") == \"0\");\n    assert(solution(\"6 4\\n4 2\\n8 5\\n12 7\\n16 10\\n20 15\\n24 20\\n\") == \"0\");\n    return 0; \n}", "prompt": "/*Farmer John has received $N$ shipments of hay bales ($1 \\le N \\le 100,000$), and has placed them at various positions along the one-dimensional road connecting his barn and his house. Each bale $j$ has a size $S_j$ and a distinct position $P_j$ specifying where it sits along the road. Cow Bessie is currently located at position $B$, where there is no hay bale. Bessie is free to move along the route, and can even reach the position of a hay bale, but she cannot pass through that position. However, if she moves distance $D$ in the same direction, she can build up enough speed to permanently eliminate any hay bale with size strictly less than $D$. Of course, after doing this, she might open up more space that allows her to attack other hay bales and eliminate them as well. FJ is currently repainting his house and barn, and wants to make sure Bessie cannot reach either one (cows and fresh paint don't mix well!). Therefore, FJ wants to make sure that Bessie will never pass through the leftmost or rightmost hay bale, so she can effectively be trapped. FJ has the ability to add hay to a single bale of his choosing in order to help keep Bessie trapped. Please help him determine the minimum additional size that needs to be added to some bale to guarantee that Bessie remains trapped.\n\ninput_format:\nThe first line of input contains $N$ as well as Bessie's initial position $B$.\n\nEach of the next $N$ lines describes a bale, and contains two integers giving\n\nits size and position.  All sizes and positions are in the range $1\\ldots 10^9$.\n\noutput_format:\nPrint a single integer, giving the minimum amount of hay FJ needs to add to\n\nprevent Bessie from escaping.  Print -1 if it is impossible to prevent Bessie's\n\nescape.\n*/\n\n#include<sstream>\n#include<stdlib.h>\n#include<algorithm>\n#include<math.h>\n#include<stdio.h>\n#include<vector>\n#include<string>\n#include<climits>\n#include<cstring>\n#include<iostream>\nusing namespace std;\n\n             \nstring solution(string std_in){\n    istringstream iss(std_in);\n             ", "constraints": "", "samples": [["5 7\n8 1\n1 4\n3 8\n12 15\n20 20", "4"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}}
{"task_id": "P2599", "title": "[ZJOI2009]取石子游戏", "difficulty": "advanced", "nl": "After studying Nim game and various variations, Orez discovered a brand new game of taking stones. The game goes like this:\n\nThere are n piles of stones, arranged in a row. The game is played by two people, taking turns to make moves. Each player can take any number of stones from the leftmost or rightmost pile, including taking all the stones in that pile, but cannot choose to not take any stones. The player who cannot make a move loses.\n\nOrez asks: for any initial situation, does there exist a winning strategy for the first player?", "code": "#include<iostream>\n#include<cstdio>\nusing namespace std;\n#define MAX 1010\ninline int read()\n{\n\tint x=0;bool t=false;char ch=getchar();\n\twhile((ch<'0'||ch>'9')&&ch!='-')ch=getchar();\n\tif(ch=='-')t=true,ch=getchar();\n\twhile(ch<='9'&&ch>='0')x=x*10+ch-48,ch=getchar();\n\treturn t?-x:x;\n}\nint n,a[MAX],L[MAX][MAX],R[MAX][MAX];\nint main()\n{\n\tint T=read();\n\twhile(T--)\n\t{\n\t\tn=read();\n\t\tfor(int i=1;i<=n;++i)a[i]=read();\n\t\tfor(int i=1;i<=n;++i)L[i][i]=R[i][i]=a[i];\n\t\tfor(int len=2;len<=n;++len)\n\t\t\tfor(int i=1,j=i+len-1;j<=n;++i,++j)\n\t\t\t{\n\t\t\t\tint x=a[j],l=L[i][j-1],r=R[i][j-1];\n\t\t\t\tif(x==r)L[i][j]=0;\n\t\t\t\telse if((x>l&&x>r)||(x<l&&x<r))L[i][j]=x;\n\t\t\t\telse if(r<x&&x<l)L[i][j]=x-1;\n\t\t\t\telse L[i][j]=x+1;\n\t\t\t\tx=a[i],l=L[i+1][j],r=R[i+1][j];\n\t\t\t\tif(x==l)R[i][j]=0;\n\t\t\t\telse if((x>l&&x>r)||(x<l&&x<r))R[i][j]=x;\n\t\t\t\telse if(r<x&&x<l)R[i][j]=x+1;\n\t\t\t\telse R[i][j]=x-1;\n\t\t\t}\n\t\tputs(a[1]==L[2][n]?\"0\":\"1\");\n\t}\n}", "step": ["Read in the number of test cases.", "For each test case, read in the array and initialize L and R matrices.", "Fill out the L and R matrices using dynamic programming.", "Determine whether the array is already a strictly increasing array.", "Print the solution to the problem."], "nl_cn": "在研究过 Nim 游戏及各种变种之后，Orez 又发现了一种全新的取石子游戏，这个游戏是这样的：\n\n有 $n$ 堆石子，将这 $n$ 堆石子摆成一排。游戏由两个人进行，两人轮流操作，每次操作者都可以从最左或最右的一堆中取出若干颗石子，可以将那一堆全部取掉，但不能不取，不能操作的人就输了。\n\nOrez 问：对于任意给出一个初始一个局面，是否存在先手必胜策略。", "test_cases": [{"input": "1\n4\n3 1 9 4\n", "output": "0"}, {"input": "1\n3\n2 3 5\n", "output": "1"}, {"input": "1\n6\n1 3 5 7 9 11\n", "output": "1"}, {"input": "1\n2\n9 10\n", "output": "1"}, {"input": "1\n7\n2 4 6 7 8 9 10\n", "output": "1"}, {"input": "1\n3\n1 2 3\n", "output": "1"}, {"input": "1\n7\n0 1 2 3 4 5 6\n", "output": "1"}, {"input": "1\n1\n10\n", "output": "1"}, {"input": "1\n8\n9 8 7 6 5 4 3 2\n", "output": "1"}, {"input": "1\n3\n50 60 70\n", "output": "1"}, {"input": "1\n6\n1000 900 800 700 650 600\n", "output": "1"}, {"input": "1\n5\n5 4 3 2 1\n", "output": "1"}, {"input": "1\n3\n7 8 9\n", "output": "1"}, {"input": "1\n6\n1 2 3 4 5 6\n", "output": "1"}, {"input": "1\n2\n6 5\n", "output": "1"}, {"input": "1\n5\n1 2 3 4 5\n", "output": "1"}, {"input": "1\n3\n9 8 7\n", "output": "1"}, {"input": "1\n4\n4 5 6 7\n", "output": "1"}, {"input": "1\n5\n1 1 2 2 3\n", "output": "1"}, {"input": "1\n8\n7 6 5 4 3 2 1 0\n", "output": "1"}, {"input": "1\n10\n1 2 3 8 7 6 5 4 9 10\n", "output": "1"}, {"input": "1\n11\n8 7 6 5 4 3 2 1 9 10 11\n", "output": "1"}, {"input": "1\n12\n2 5 8 11 1 4 7 10 3 6 9 12\n", "output": "1"}, {"input": "1\n13\n3 3 5 5 7 7 9 9 3 4 6 8 10\n", "output": "1"}, {"input": "1\n2\n5 5\n", "output": "0"}, {"input": "1\n4\n5 9 2 4\n", "output": "0"}, {"input": "1\n3\n2 4 1\n", "output": "1"}, {"input": "1\n6\n4 9 2 5 3 1\n", "output": "1"}, {"input": "1\n5\n2 9 5 8 4\n", "output": "1"}, {"input": "1\n6\n8 7 3 2 4 9\n", "output": "1"}, {"input": "1\n5\n3 6 9 1 5\n", "output": "1"}, {"input": "1\n3\n8 2 4\n", "output": "1"}, {"input": "1\n3\n8 7 4\n", "output": "1"}, {"input": "1\n2\n1 1\n", "output": "0"}, {"input": "1\n5\n2 4 6 8 10\n", "output": "1"}, {"input": "1\n4\n1 1 1 2\n", "output": "1"}, {"input": "1\n3\n5 10 15\n", "output": "1"}, {"input": "1\n2\n0 0\n", "output": "0"}, {"input": "1\n6\n1 3 5 8 10 12\n", "output": "1"}, {"input": "1\n4\n2 3 4 5\n", "output": "1"}, {"input": "1\n3\n4 3 2\n", "output": "1"}, {"input": "1\n4\n4 5 3 2\n", "output": "1"}, {"input": "1\n1\n1\n", "output": "1"}, {"input": "1\n3\n2 2 2\n", "output": "1"}, {"input": "1\n2\n5 10\n", "output": "1"}, {"input": "1\n5\n2 2 2 2 2\n", "output": "1"}], "test": "#undef NDEBUG\n#include<assert.h>\nint main(){\n    assert(solution(\"1\\n4\\n3 1 9 4\\n\") == \"0\");\n    assert(solution(\"1\\n3\\n2 3 5\\n\") == \"1\");\n    assert(solution(\"1\\n6\\n1 3 5 7 9 11\\n\") == \"1\");\n    assert(solution(\"1\\n2\\n9 10\\n\") == \"1\");\n    assert(solution(\"1\\n7\\n2 4 6 7 8 9 10\\n\") == \"1\");\n    assert(solution(\"1\\n3\\n1 2 3\\n\") == \"1\");\n    assert(solution(\"1\\n7\\n0 1 2 3 4 5 6\\n\") == \"1\");\n    assert(solution(\"1\\n1\\n10\\n\") == \"1\");\n    assert(solution(\"1\\n8\\n9 8 7 6 5 4 3 2\\n\") == \"1\");\n    assert(solution(\"1\\n3\\n50 60 70\\n\") == \"1\");\n    assert(solution(\"1\\n6\\n1000 900 800 700 650 600\\n\") == \"1\");\n    assert(solution(\"1\\n5\\n5 4 3 2 1\\n\") == \"1\");\n    assert(solution(\"1\\n3\\n7 8 9\\n\") == \"1\");\n    assert(solution(\"1\\n6\\n1 2 3 4 5 6\\n\") == \"1\");\n    assert(solution(\"1\\n2\\n6 5\\n\") == \"1\");\n    assert(solution(\"1\\n5\\n1 2 3 4 5\\n\") == \"1\");\n    assert(solution(\"1\\n3\\n9 8 7\\n\") == \"1\");\n    assert(solution(\"1\\n4\\n4 5 6 7\\n\") == \"1\");\n    assert(solution(\"1\\n5\\n1 1 2 2 3\\n\") == \"1\");\n    assert(solution(\"1\\n8\\n7 6 5 4 3 2 1 0\\n\") == \"1\");\n    assert(solution(\"1\\n10\\n1 2 3 8 7 6 5 4 9 10\\n\") == \"1\");\n    assert(solution(\"1\\n11\\n8 7 6 5 4 3 2 1 9 10 11\\n\") == \"1\");\n    assert(solution(\"1\\n12\\n2 5 8 11 1 4 7 10 3 6 9 12\\n\") == \"1\");\n    assert(solution(\"1\\n13\\n3 3 5 5 7 7 9 9 3 4 6 8 10\\n\") == \"1\");\n    assert(solution(\"1\\n2\\n5 5\\n\") == \"0\");\n    assert(solution(\"1\\n4\\n5 9 2 4\\n\") == \"0\");\n    assert(solution(\"1\\n3\\n2 4 1\\n\") == \"1\");\n    assert(solution(\"1\\n6\\n4 9 2 5 3 1\\n\") == \"1\");\n    assert(solution(\"1\\n5\\n2 9 5 8 4\\n\") == \"1\");\n    assert(solution(\"1\\n6\\n8 7 3 2 4 9\\n\") == \"1\");\n    assert(solution(\"1\\n5\\n3 6 9 1 5\\n\") == \"1\");\n    assert(solution(\"1\\n3\\n8 2 4\\n\") == \"1\");\n    assert(solution(\"1\\n3\\n8 7 4\\n\") == \"1\");\n    assert(solution(\"1\\n2\\n1 1\\n\") == \"0\");\n    assert(solution(\"1\\n5\\n2 4 6 8 10\\n\") == \"1\");\n    assert(solution(\"1\\n4\\n1 1 1 2\\n\") == \"1\");\n    assert(solution(\"1\\n3\\n5 10 15\\n\") == \"1\");\n    assert(solution(\"1\\n2\\n0 0\\n\") == \"0\");\n    assert(solution(\"1\\n6\\n1 3 5 8 10 12\\n\") == \"1\");\n    assert(solution(\"1\\n4\\n2 3 4 5\\n\") == \"1\");\n    assert(solution(\"1\\n3\\n4 3 2\\n\") == \"1\");\n    assert(solution(\"1\\n4\\n4 5 3 2\\n\") == \"1\");\n    assert(solution(\"1\\n1\\n1\\n\") == \"1\");\n    assert(solution(\"1\\n3\\n2 2 2\\n\") == \"1\");\n    assert(solution(\"1\\n2\\n5 10\\n\") == \"1\");\n    assert(solution(\"1\\n5\\n2 2 2 2 2\\n\") == \"1\");\n    return 0; \n}", "prompt": "/*After studying Nim game and various variations, Orez discovered a brand new game of taking stones. The game goes like this:\n\nThere are n piles of stones, arranged in a row. The game is played by two people, taking turns to make moves. Each player can take any number of stones from the leftmost or rightmost pile, including taking all the stones in that pile, but cannot choose to not take any stones. The player who cannot make a move loses.\n\nOrez asks: for any initial situation, does there exist a winning strategy for the first player?\n\ninput_format:\nThe first line of the file is an integer $T$, indicating the number of test cases. For each test case:\n\nThe first line is an integer $n$, indicating the number of stone piles.\n\nThe second line consists of $n$ integers $a_1, a_2, \\ldots , a_n$, representing the number of stones in each pile.\n\noutput_format:\nOutput only an integer $0$or $1$for each set of test data. Where $1 indicates a first-mover strategy and $0 indicates no.\n*/\n\n#include<sstream>\n#include<stdlib.h>\n#include<algorithm>\n#include<math.h>\n#include<stdio.h>\n#include<vector>\n#include<string>\n#include<climits>\n#include<cstring>\n#include<iostream>\nusing namespace std;\n\n             \nstring solution(string std_in){\n    istringstream iss(std_in);\n             ", "constraints": "对于 $30 \\%$ 的数据，$n \\le 5$，$a_i \\le {10}^5$。  \n对于 $100 \\%$ 的数据，$1 \\le T \\le 10$，$1 \\le n \\le 1000$，$1 \\le a_i \\le {10}^9$。", "samples": [["1\n4\n3 1 9 4\n", "0\n"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072]}}
{"task_id": "P8588", "title": "『JROI-8』雷雨天特别行动科", "difficulty": "challenge", "nl": "For a non-negative integer variable $x$, the following is defined as one round of operation:\n\n1. Add $1$ to $x$;\n2. If $x$ is a multiple of $3$, divide $x$ by $3$.\n\nGiven the initial values of $x$ and $k$, find the value of $x$ after $k$ rounds of operations.\n\nNote: The large test case is not provided as an attached file, but directly placed in the input and output examples of Test Case #3.", "code": "#include<bits/stdc++.h>\nusing namespace std;\nlong long x,k;\nint main(){\n    cin>>x>>k;\n    while(k--){\n        x++;\n        if(x%3==0)x/=3;\n        if(x==1){//对1的特判切记莫放在x++前\n            if(k%2==1){\n                cout<<2;\n                return 0;\n            }\n            else{\n                cout<<1;\n                return 0;\n            }\n        }\n    }\n    cout<<x;\n    return 0;\n}", "step": ["Initialize x and k as long long type variables.", "Take x and k as input from the user.", "Start the while loop until k becomes 0.", "Increment x by 1 after each iteration.", "If x is divisible by 3, then divide x by 3.", "If x's value gets to 1 before k becomes 0, then output either 1 or 2 based on the value of k (whether it's odd or even).", "If k equals 0, then output the final value of x."], "nl_cn": "对于**非负整数**变量 $x$，记以下为一轮操作：\n\n1. 将 $x$ 增加 $1$；\n2. 如果 $x$ 是 $3$ 的倍数，则将 $x$ 除以 $3$。\n\n给定初始的 $x,k$，试求 $k$ 轮操作后 $x$ 的值。\n\n**请注意，大样例不以文件附加形式给出，而直接放在题目的 输入输出样例 中的 样例 #3**", "test_cases": [{"input": "1 3", "output": "2"}, {"input": "10 3", "output": "5"}, {"input": "1919810 3", "output": "213313"}, {"input": "0 0", "output": "0"}, {"input": "4 3", "output": "1"}, {"input": "100 0\n", "output": "100"}, {"input": "987654321 0\n", "output": "987654321"}, {"input": "123456789 0\n", "output": "123456789"}, {"input": "999 0\n", "output": "999"}, {"input": "2 1\n", "output": "1"}], "test": "#undef NDEBUG\n#include<assert.h>\nint main(){\n    assert(solution(\"1 3\") == \"2\");\n    assert(solution(\"10 3\") == \"5\");\n    assert(solution(\"1919810 3\") == \"213313\");\n    assert(solution(\"0 0\") == \"0\");\n    assert(solution(\"4 3\") == \"1\");\n    assert(solution(\"100 0\\n\") == \"100\");\n    assert(solution(\"987654321 0\\n\") == \"987654321\");\n    assert(solution(\"123456789 0\\n\") == \"123456789\");\n    assert(solution(\"999 0\\n\") == \"999\");\n    assert(solution(\"2 1\\n\") == \"1\");\n    return 0; \n}", "prompt": "/*For a non-negative integer variable $x$, the following is defined as one round of operation:\n\n1. Add $1$ to $x$;\n2. If $x$ is a multiple of $3$, divide $x$ by $3$.\n\nGiven the initial values of $x$ and $k$, find the value of $x$ after $k$ rounds of operations.\n\nNote: The large test case is not provided as an attached file, but directly placed in the input and output examples of Test Case #3.\n\ninput_format:\nA row of two non-negative integers $x,k$.\n\noutput_format:\nA positive integer in a row represents the value of $x$after the $k$round operation.\n*/\n\n#include<sstream>\n#include<stdlib.h>\n#include<algorithm>\n#include<math.h>\n#include<stdio.h>\n#include<vector>\n#include<string>\n#include<climits>\n#include<cstring>\n#include<iostream>\nusing namespace std;\n\n             \nstring solution(string std_in){\n    istringstream iss(std_in);\n             ", "constraints": "【样例解释】\n\n对于样例一， $x$ 的变化过程如下：$1\\rightarrow 2\\rightarrow (3\\rightarrow 1)\\rightarrow 2$。\n\n其中括号内为一次操作。\n\n【数据范围与提示】\n\n对于全部的测试数据，满足 $0\\leq x,k\\leq 10^{18}$。\n\n**特别的，第 $1\\sim 2$ 测试点中的 $k\\leq 0$ 等价于 $k=0$，$3\\sim 4$ 的 $x$ 同理**。\n\n| 测试点编号 | 分数 | $x\\leq$ | $k\\leq$ |\n| -----------: | -----------: | -----------: | -----------: |\n| $1\\sim 2$ | $20$ | $5$ | $0$ |\n| $3\\sim 4$ | $20$ | $0$ | $10^{18}$ |\n| $5\\sim 6$ | $20$ | $10^{18}$ | $10^6$ |\n| $7 \\sim 10$ | $40$ | $10^{18}$ | $10^{18}$ |", "samples": [["1 3", "2"], ["10 3", "5"], ["1919810 3", "213313"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072]}}
{"task_id": "P8179", "title": "「EZEC-11」Tyres", "difficulty": "advanced", "nl": "There are n sets of tires available, and Didi needs to run m laps using these tires. \n\nUsing the i-th set of tires to run the j-th lap (counted separately for each set of tires) takes ai+bi(j-1)^2 seconds. In this problem, you don't need to worry about tire blowouts, safety cars, red flags or different race strategies. \n\nDidi needs to enter the pit stop to change tires, which takes t seconds. Specifically, the **first set** of tires used by Didi does not need to be changed. \n\nTo help Didi win the WDC, you need to minimize the total time, which equals the sum of the lap times plus the time spent in the pit stop.", "code": "//And in that light,I find deliverance.\n#include<bits/stdc++.h>\nusing namespace std;\n#define int long long\ninline int read(){\n   int s=0,w=1;\n   char ch=getchar();\n   while(ch<'0'||ch>'9'){if(ch=='-')w=-1;ch=getchar();}\n   while(ch>='0'&&ch<='9') s=s*10+ch-'0',ch=getchar();\n   return s*w;\n}\nconst int B=25;\nint f[503][33],g[13003],h[200003],a[503],b[503],c[503];\nstruct cmp\n{\n\tbool operator()(const int&x,const int&y)\n\t{\n\t\treturn (a[x]+b[x]*c[x]*c[x]>a[y]+b[y]*c[y]*c[y])||\n\t\t\t(a[x]+b[x]*c[x]*c[x]==a[y]+b[y]*c[y]*c[y]&&x>y);\n\t}\n};\npriority_queue<int,vector<int>,cmp> q;\nsigned main()\n{\n\tint n=read(),m=read(),d=read(),s=0;\n\tfor(int i=1; i<=n; ++i) \n\t{\n\t\ta[i]=read(),b[i]=read(),c[i]=25,q.push(i);\n\t\tf[i][1]=a[i]+d;\n\t\tfor(int j=2; j<=B; ++j) f[i][j]=f[i][j-1]+a[i]+b[i]*(j-1)*(j-1);\n\t}\n\tmemset(g,0x3f,sizeof(g)),g[0]=0;\n\tfor(int i=1; i<=n; ++i)\n\t{\n\t\ts=min(m,s+B);\n\t\tfor(int j=s; j>=0; --j)\n\t\t\tfor(int k=0; k<=B&&k<=j; ++k)\n\t\t\t\tg[j]=min(g[j],g[j-k]+f[i][k]);\n\t}\n\tfor(int i=1; i<=m; ++i)\n\t{\n\t\tint x=q.top();\n\t\tq.pop(),h[i]=h[i-1]+a[x]+b[x]*c[x]*c[x],\n\t\t++c[x],q.push(x);\n\t}\n\tint ans=0x3f3f3f3f3f3f3f3f;\n\tfor(int i=0; i<=s&&i<=m; ++i) ans=min(ans,g[i]+h[m-i]);\n\tprintf(\"%lld\\n\",ans-d);\n\treturn 0;\n}", "step": ["Read input values for n, m, and d.", "Initialize arrays a, b, c, f, g, h, and a priority queue q.", "Fill up array a, b, and c with input values.", "Push all values of i in q.", "Find the minimum cost for traveling d distance for each i between 1 and n.", "For each i, find the minimum cost for traveling j distance using the first j transport types.", "For each i, find the minimum cost for traveling j distance using the first j-k transport types.", "For each value of i, find the minimum cost for traveling m-i distance.", "Add the cost of traveling one unit of distance for each i with c[i], and add it to h.", "Find the lowest possible cost by adding the sum of g and h.", "Print the result."], "nl_cn": "有 $n$ 套轮胎，滴叉需要用这些轮胎跑 $m$ 圈。\n\n使用第 $i$ 套轮胎跑的第 $j$ 圈（对每套轮胎单独计数）需要 $a_i+b_i(j-1)^2$ 秒。在本题中，你不需要担心爆胎，安全车，红旗或者不同的比赛策略。\n\n滴叉需要进入维修站来更换轮胎，所消耗的时间为 $t$ 秒。特别地，滴叉使用的**第一套**轮胎不需要进站更换。\n\n为了帮助滴叉拿下 WDC，你需要最小化总时间，总时间等于每圈的时间之和加上进站所花费的时间。", "test_cases": [{"input": "2 4 50\n10 100\n100 1", "output": "365"}, {"input": "6 6 10\n90 200\n90 200\n90 200\n92 200\n92 200\n94 200", "output": "598"}, {"input": "3 10 30\n1000 8\n1050 3\n1100 1", "output": "10607"}, {"input": "3 3 0\n0 0\n0 0\n0 0\n", "output": "0"}, {"input": "2 4 0\n0 0\n0 0\n", "output": "0"}, {"input": "2 2 0\n0 0\n0 0\n", "output": "0"}, {"input": "1 1 1\n1 1\n", "output": "1"}], "test": "#undef NDEBUG\n#include<assert.h>\nint main(){\n    assert(solution(\"2 4 50\\n10 100\\n100 1\") == \"365\");\n    assert(solution(\"6 6 10\\n90 200\\n90 200\\n90 200\\n92 200\\n92 200\\n94 200\") == \"598\");\n    assert(solution(\"3 10 30\\n1000 8\\n1050 3\\n1100 1\") == \"10607\");\n    assert(solution(\"3 3 0\\n0 0\\n0 0\\n0 0\\n\") == \"0\");\n    assert(solution(\"2 4 0\\n0 0\\n0 0\\n\") == \"0\");\n    assert(solution(\"2 2 0\\n0 0\\n0 0\\n\") == \"0\");\n    assert(solution(\"1 1 1\\n1 1\\n\") == \"1\");\n    return 0; \n}", "prompt": "/*There are n sets of tires available, and Didi needs to run m laps using these tires. \n\nUsing the i-th set of tires to run the j-th lap (counted separately for each set of tires) takes ai+bi(j-1)^2 seconds. In this problem, you don't need to worry about tire blowouts, safety cars, red flags or different race strategies. \n\nDidi needs to enter the pit stop to change tires, which takes t seconds. Specifically, the **first set** of tires used by Didi does not need to be changed. \n\nTo help Didi win the WDC, you need to minimize the total time, which equals the sum of the lap times plus the time spent in the pit stop.\n\ninput_format:\nEnter three integers $n,m, and t$on the first line.\n\nNext line $n$, enter two integers $a_i,b_i$on each line.\n\noutput_format:\nOutput an integer representing the minimum value of the total time.\n*/\n\n#include<sstream>\n#include<stdlib.h>\n#include<algorithm>\n#include<math.h>\n#include<stdio.h>\n#include<vector>\n#include<string>\n#include<climits>\n#include<cstring>\n#include<iostream>\nusing namespace std;\n\n             \nstring solution(string std_in){\n    istringstream iss(std_in);\n             ", "constraints": "**【样例解释】**\n\n对于第一个样例：\n\n* 你先让滴叉用第一套轮胎跑一圈，消耗 $10$ 秒。\n* 然后进站更换第二套轮胎，消耗 $50$ 秒。\n* 然后用第二套轮胎跑三圈。第一圈消耗 $100$ 秒，第二圈消耗 $100+1\\times 1^2=101$ 秒，第三圈消耗 $100+1\\times 2^2=104$ 秒。\n* 总时间为 $10+50+100+101+104=365$ 秒。\n\n对于第二个样例，滴叉每圈更换一次新轮胎。\n\n注意一套轮胎被卸下后并不会重置它跑的圈数。\n\n对于第三个样例，滴叉先使用第一套轮胎跑 $4$ 圈，然后更换第二套轮胎跑 $6$ 圈。\n\n**【数据范围】**\n\n**本题采用捆绑测试**。\n\n- Subtask 1（7 pts）：$n=1$。\n- Subtask 2（9 pts）：$n\\leq10$，$m\\leq 100$。\n- Subtask 3（13 pts）：$t=0$。\n- Subtask 4（21 pts）：保证 $a_i,b_i$ 随机生成。\n- Subtask 5（50 pts）：无特殊限制。\n\n对于前 $100\\%$ 的数据，$1\\leq n,b_i\\leq 500$，$0\\leq t\\leq 500$，$1\\leq m\\leq 2 \\times 10^5$，$1\\leq a_i\\leq 10^9$。", "samples": [["2 4 50\n10 100\n100 1", "365"], ["6 6 10\n90 200\n90 200\n90 200\n92 200\n92 200\n94 200", "598"], ["3 10 30\n1000 8\n1050 3\n1100 1", "10607"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072]}}
{"task_id": "P2433", "title": "【深基1-2】小学数学 N 合一", "difficulty": "basic", "nl": "### Problem 1\n\nOutput `I love Luogu!`.\n\n### Problem 2\n\nThere are $10$ apples. Xiaoa took $2$ of them, Uim took $4$ of them, and Baye took what was left. We want to know:\n\n1. How many apples did Xiaoa and Uim take in total?\n2. How many apples can Baye take?\n\nWrite a program to output these two numbers, separated by a space.\n\n### Problem 3\n\nThere are $14$ apples. They need to be divided equally among $4$ students, with the leftover apples being put back into the fridge. We want to know:\n\n1. How many apples can each student get?\n2. How many apples are distributed in total?\n3. How many apples are left over?\n\nWrite a program to output these three numbers, each on a new line.\n\n### Problem 4\n\nThere are $500$ milliliters of cola, which needs to be divided equally among $3$ students. How many milliliters of cola can each student get? The answer should be expressed as a number, with $6$ decimal places and without scientific notation.\n\n### Problem 5\n\nTrain A is $260$ meters long and travels at a speed of $12$ meters per second. Train B is $220$ meters long and travels at a speed of $20$ meters per second. The two trains start moving towards each other from their opposite ends. How long will it take for the rear ends of the two trains to meet? The answer is an integer.\n\n### Problem 6\n\nThe length and width of a rectangle are $6$ cm and $9$ cm, respectively. Find the length of the diagonal (in cm) and output the answer with `cout`.\n\n### Problem 7\n\nUim has $100$ yuan in his bank account. After the following operations:\n\n1. Deposit $10$ yuan.\n2. Spend $20$ yuan.\n3. Withdraw all the money in the account.\n\nOutput the balance after each operation, separated by a newline.\n\n### Problem 8\n\nWhen the radius is $r=5$, output the circumference, area and volume of a circle. Take $\\pi=3.141593$. Output each answer on a new line.\n\n### Problem 9\n\nA monkey bought some peaches. On the first day, he ate exactly half of the peaches and one more. On the second day, he ate exactly half of the remaining peaches and one more. On the third day, he ate exactly half of the remaining peaches again and one more. On the fourth day, he woke up and found that there was only one peach left. How many peaches did the monkey buy?\n\n### Problem 10\n\nThe workload of Luogu's testing system increases linearly over time. $8$ machines can finish evaluating all programs in the queue in $30$ minutes, while $10$ machines can finish in $6$ minutes. How many machines are needed to finish the queue exactly in $10$ minutes?\n\n### Problem 11\n\nXiaoa runs at a speed of $5$ m/s, while Baye runs at a speed of $8$ m/s. Baye starts $100$ m behind XiaoA, and they start running at the same time. How long will it take for Baye to catch up to Xiaoa? Output the answer as a number with `cout`.\n\n### Problem 12\n\nAs we all know, there are $26$ letters in English, with A being the first. Now, write a program to find out:\n\n1. What is the position of M in the English alphabet?\n2. What is the $18$th letter in the alphabet?\n\nOutput one number and one letter, separated by a newline.\n\n### Problem 13\n\nXiaoa has two balls of plasticine, one with a radius of $4$ and one with a radius of $10$. He wants to combine the two balls into a cube. What is the edge length of the cube (rounded down to the nearest integer)? Take $\\pi = 3.141593$.\n\n### Problem 14\n\nAccording to GuGoo Online Learning's projections, if a course is priced at $110$ yuan, $10$ people will sign up. If the course price is reduced by $1$ yuan, an additional person will sign up, and vice versa. If we want to collect a total of $3500$ yuan in tuition fees, how much should we charge for the course? It is known that there are two answers that meet the requirements, and the smaller one should be given. If the answer is not an integer, it should be rounded to the nearest integer.", "code": "#include<iostream>\n#include<cstdio>\n#include<cmath>\nusing namespace std;\nint main() {\n    int T;\n    cin >> T;\n    if (T == 1) {\n        cout << \"I love Luogu!\";\n    } else if (T == 2) {\n        cout << 2 + 4 << \" \" << 10 - 2 - 4;\n    } else if (T == 3) {\n    \tcout<<3<<endl<<12<<endl<<2<<endl;\n    } else if (T == 4) {\n    \tprintf(\"%.3lf\\n\",500.0/3.0);\n    } else if (T == 5) {\n    \tcout<<15<<endl;\n    } else if (T == 6) {\n    \tcout<<sqrt(6*6+9*9)<<endl;\n    } else if (T == 7) {\n    \tcout<<110<<endl<<90<<endl<<0<<endl;\n    } else if (T == 8) {\n    \tdouble const pi=3.141593;\n    \tdouble const r=5;\n    \tcout<<pi*r*2<<endl<<pi*r*r<<endl<<4.0/3*pi*r*r*r<<endl;\n    } else if (T == 9) {\n    \tcout<<22<<endl;\n    } else if (T == 10) {\n    \tcout<<9<<endl;\n    } else if (T == 11) {\n    \tcout<<100.0/(8-5)<<endl;\n    } else if (T == 12) {\n    \tcout<<13<<endl<<\"R\"<<endl;\n    } else if (T == 13) {\n    \tdouble const pi=3.141593;\n    \tdouble V=pi*4*4*4*4/3+pi*10*10*10*4/3;\n    \tcout<<floor(pow(V,1.0/3))<<endl;\n    } else if (T == 14) {\n    \tcout<<50<<endl;\n    }\n    return 0;\n}", "step": ["Input the integer value of T", "Check the value of T", "If T is equal to 1, print \"I love Luogu!\" ", "If T is equal to 2, print 6 and 4", "If T is equal to 3, print 3, 12, and 2 on new lines", "If T is equal to 4, print 166.667", "... (continue with remaining conditions)"], "nl_cn": "### 问题 1\n\n请输出 `I love Luogu!`\n\n### 问题 2\n\n这里有 $10$ 个苹果，小 A 拿走了 $2$ 个，Uim 拿走了 $4$ 个，八尾勇拿走剩下的所有的苹果。我们想知道：\n\n1. 小A 和 Uim 两个人一共拿走多少苹果？\n2. 八尾勇能拿走多少苹果？\n\n现在需要编写一个程序，输出两个数字作为答案，中间使用空格分开。\n\n### 问题 3\n\n现在有 $14$ 个苹果。要均分给 $4$ 名同学，分不掉的苹果放回冰箱。请问：\n\n1. 每位同学能分得几个苹果？\n2. 一共分出去多少苹果？\n3. 把几个苹果放回冰箱？\n\n \t现在需要编写一个程序，输出三个数字作为答案，每个数字一行。\n\n### 问题 4\n\n现在有 $500$ 毫升的肥宅快乐水，要均分给 $3$ 名同学，每位同学可以分到多少毫升？请输出一个数字作为输出。保留 $6$ 位有效数字，且不使用科学计数法。\n\n### 问题 5\n\n甲列火车长 $260$ 米，每秒行 $12$ 米；乙列火车长 $220$ 米，每秒行 $20$ 米，两车相向而行，从两车车头相遇时开始计时，多长时间后两车车尾相离？已知答案是整数。\n\n### 问题 6\n\n一个长方形长宽分别是 $6 \\text{ cm}$、$9 \\text{ cm}$，求它的对角线长度（$\\text{cm}$）。直接使用 `cout` 输出。\n\n### 问题 7\n\nUim 银行账户里面有 $100$ 元。经过了下面的操作：\n\n1. 往里面存了 $10$ 元；\n2. 购物花掉了 $20$ 元；\n3. 把里面的钱全部取出。\n\n \t请在每次操作后输出账户余额，并使用换行符隔开。\n\n\n### 问题 8\n\n当半径为 $r=5$，请输出圆的周长、面积和球体积。取 $\\pi=3.141593$。请直接使用 `cout` 输出答案，每行一个数字。\n\n### 问题 9\n\n一只小猴买了若干个桃子。第一天他刚好吃了这些桃子的一半，又贪嘴多吃了一个；第二天他也刚好吃了剩余桃子的一半，贪嘴多吃了一个；第三天他又刚好吃了剩下的桃子的一半，并贪嘴多吃了一个。第四天起来一看，发现桃子只剩下一个了。请问小猴买了几个桃子？\n\n### 问题 10\n\n洛谷的评测任务是单位时间内均匀增加的。$8$ 台评测机 $30$ 分钟可以刚好把评测队列中的程序评测完毕，$10$ 台评测机 $6$ 分钟可以刚好把评测队列中的程序评测完毕，请问几台评测机可以在 $10$ 分钟时刚好把评测队列中的程序评测完毕？\n\n### 问题 11\n\n小 A 跑步速度 $5 \\text{ m/s}$，八尾勇跑步速度 $8 \\text{ m/s}$，八尾勇在小 A 后面 $100 \\text{ m}$，他们同时起跑，请问需要多长时间八尾勇可以追上小 A？输出一个数字表示答案，使用 `cout` 直接输出。\n\n### 问题 12\n\n大家都知道有 $26$ 个英文字母，其中 A 是第一个字母。现在请编程求出：\n\n1. M 是字母表中的第几个字母？\n2. 第 $18$ 个字母是什么？\n\n输出一个数字和一个字母，使用换行隔开。\n\n\n### 问题 13\n\n小 A 有两块球形橡皮泥，一个半径是 $4$，一个半径是 $10$。他想把这两块橡皮泥揉在一起，然后塑造成一个正方体，请问这个正方体的棱长是多少？如果结果不是整数，则舍去小数点之后的数字。取 $\\pi = 3.141593$。\n\n### 问题 14\n\n根据咕咕网校的预测，当课程定价为 $110$ 元时，会有 $10$ 人报名。如果课程价格每降低 $1$ 元，就会多 $1$ 名报名者（反之亦然）。如果希望总共能收到 $3500$ 元学费的话，那么应该定价多少呢？已知本题有两个答案符合要求，则取较小的那一个。如果这个答案不是整数，则需四舍五入精确到整数。\n\n", "test_cases": [{"input": "2", "output": "6 4"}, {"input": "1", "output": "I love Luogu!"}, {"input": "3", "output": "3\n12\n2"}, {"input": "4", "output": "166.667"}, {"input": "5", "output": "15"}, {"input": "6", "output": "10.8167"}, {"input": "7", "output": "110\n90\n0"}, {"input": "8", "output": "31.4159\n78.5398\n523.599"}, {"input": "9", "output": "22"}, {"input": "10", "output": "9"}, {"input": "11", "output": "33.3333"}, {"input": "12", "output": "13\nR"}, {"input": "14", "output": "50"}, {"input": "15", "output": ""}, {"input": "16", "output": ""}, {"input": "17", "output": ""}, {"input": "18", "output": ""}, {"input": "19", "output": ""}, {"input": "20", "output": ""}], "test": "#undef NDEBUG\n#include<assert.h>\nint main(){\n    assert(solution(\"2\") == \"6 4\");\n    assert(solution(\"1\") == \"I love Luogu!\");\n    assert(solution(\"3\") == \"3\\n12\\n2\");\n    assert(solution(\"4\") == \"166.667\");\n    assert(solution(\"5\") == \"15\");\n    assert(solution(\"6\") == \"10.8167\");\n    assert(solution(\"7\") == \"110\\n90\\n0\");\n    assert(solution(\"8\") == \"31.4159\\n78.5398\\n523.599\");\n    assert(solution(\"9\") == \"22\");\n    assert(solution(\"10\") == \"9\");\n    assert(solution(\"11\") == \"33.3333\");\n    assert(solution(\"12\") == \"13\\nR\");\n    assert(solution(\"14\") == \"50\");\n    assert(solution(\"15\") == \"\");\n    assert(solution(\"16\") == \"\");\n    assert(solution(\"17\") == \"\");\n    assert(solution(\"18\") == \"\");\n    assert(solution(\"19\") == \"\");\n    assert(solution(\"20\") == \"\");\n    return 0; \n}", "prompt": "/*### Problem 1\n\nOutput `I love Luogu!`.\n\n### Problem 2\n\nThere are $10$ apples. Xiaoa took $2$ of them, Uim took $4$ of them, and Baye took what was left. We want to know:\n\n1. How many apples did Xiaoa and Uim take in total?\n2. How many apples can Baye take?\n\nWrite a program to output these two numbers, separated by a space.\n\n### Problem 3\n\nThere are $14$ apples. They need to be divided equally among $4$ students, with the leftover apples being put back into the fridge. We want to know:\n\n1. How many apples can each student get?\n2. How many apples are distributed in total?\n3. How many apples are left over?\n\nWrite a program to output these three numbers, each on a new line.\n\n### Problem 4\n\nThere are $500$ milliliters of cola, which needs to be divided equally among $3$ students. How many milliliters of cola can each student get? The answer should be expressed as a number, with $6$ decimal places and without scientific notation.\n\n### Problem 5\n\nTrain A is $260$ meters long and travels at a speed of $12$ meters per second. Train B is $220$ meters long and travels at a speed of $20$ meters per second. The two trains start moving towards each other from their opposite ends. How long will it take for the rear ends of the two trains to meet? The answer is an integer.\n\n### Problem 6\n\nThe length and width of a rectangle are $6$ cm and $9$ cm, respectively. Find the length of the diagonal (in cm) and output the answer with `cout`.\n\n### Problem 7\n\nUim has $100$ yuan in his bank account. After the following operations:\n\n1. Deposit $10$ yuan.\n2. Spend $20$ yuan.\n3. Withdraw all the money in the account.\n\nOutput the balance after each operation, separated by a newline.\n\n### Problem 8\n\nWhen the radius is $r=5$, output the circumference, area and volume of a circle. Take $\\pi=3.141593$. Output each answer on a new line.\n\n### Problem 9\n\nA monkey bought some peaches. On the first day, he ate exactly half of the peaches and one more. On the second day, he ate exactly half of the remaining peaches and one more. On the third day, he ate exactly half of the remaining peaches again and one more. On the fourth day, he woke up and found that there was only one peach left. How many peaches did the monkey buy?\n\n### Problem 10\n\nThe workload of Luogu's testing system increases linearly over time. $8$ machines can finish evaluating all programs in the queue in $30$ minutes, while $10$ machines can finish in $6$ minutes. How many machines are needed to finish the queue exactly in $10$ minutes?\n\n### Problem 11\n\nXiaoa runs at a speed of $5$ m/s, while Baye runs at a speed of $8$ m/s. Baye starts $100$ m behind XiaoA, and they start running at the same time. How long will it take for Baye to catch up to Xiaoa? Output the answer as a number with `cout`.\n\n### Problem 12\n\nAs we all know, there are $26$ letters in English, with A being the first. Now, write a program to find out:\n\n1. What is the position of M in the English alphabet?\n2. What is the $18$th letter in the alphabet?\n\nOutput one number and one letter, separated by a newline.\n\n### Problem 13\n\nXiaoa has two balls of plasticine, one with a radius of $4$ and one with a radius of $10$. He wants to combine the two balls into a cube. What is the edge length of the cube (rounded down to the nearest integer)? Take $\\pi = 3.141593$.\n\n### Problem 14\n\nAccording to GuGoo Online Learning's projections, if a course is priced at $110$ yuan, $10$ people will sign up. If the course price is reduced by $1$ yuan, an additional person will sign up, and vice versa. If we want to collect a total of $3500$ yuan in tuition fees, how much should we charge for the course? It is known that there are two answers that meet the requirements, and the smaller one should be given. If the answer is not an integer, it should be rounded to the nearest integer.\n\ninput_format:\nEnter a positive integer to indicate which problem.\n\noutput_format:\nAccording to the question number entered, output the answer to the corresponding question.\n*/\n\n#include<sstream>\n#include<stdlib.h>\n#include<algorithm>\n#include<math.h>\n#include<stdio.h>\n#include<vector>\n#include<string>\n#include<climits>\n#include<cstring>\n#include<iostream>\nusing namespace std;\n\n             \nstring solution(string std_in){\n    istringstream iss(std_in);\n             ", "constraints": "请解决以下小学数学题。你可以提交答案，也可以写一个程序。\n\n对于本题来说，如果你不知道怎么输入，也可以这么抄：\n\n```cpp\n#include<iostream>\n// 填上你觉得需要的其他头文件\nusing namespace std;\nint main() {\n    int T;\n    cin >> T;\n    if (T == 1) {\n        // 粘贴问题 1 的主函数代码，除了 return 0\n        cout << \"I love Luogu!\";\n    } else if (T == 2) {\n        // 粘贴问题 2 的主函数代码，除了 return 0\n        cout << 2 + 4 << \" \" << 10 - 2 - 4;\n    } else if (T == 3) {\n        // 请自行完成问题 3 的代码\n    } else if (T == 4) {\n        // 请自行完成问题 4 的代码\n    } else if (T == 5) {\n        // 请自行完成问题 5 的代码\n    } else if (T == 6) {\n        // 请自行完成问题 6 的代码\n    } else if (T == 7) {\n        // 请自行完成问题 7 的代码\n    } else if (T == 8) {\n        // 请自行完成问题 8 的代码\n    } else if (T == 9) {\n        // 请自行完成问题 9 的代码\n    } else if (T == 10) {\n        // 请自行完成问题 10 的代码\n    } else if (T == 11) {\n        // 请自行完成问题 11 的代码\n    } else if (T == 12) {\n        // 请自行完成问题 12 的代码\n    } else if (T == 13) {\n        // 请自行完成问题 13 的代码\n    } else if (T == 14) {\n        // 请自行完成问题 14 的代码\n    }\n    return 0;\n}\n```", "samples": [["2", "6 4"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}}
{"task_id": "P2614", "title": "计算器弹琴", "difficulty": "challenge", "nl": "As we all know, calculators can be used for many things they are not supposed to do, such as writing essays. (See Luogu P2549)\n\nLittle A found another hidden feature of a calculator - playing music.\n\n\n\nIf you press a key, say 1, it will produce the middle C.\n\nHere is the table of the notes:\n\n```cpp\n+ Low Fa\n< Low So\n* Low La\n/ Low Xi\n1 Middle Do\n2 Middle Re\n3 Middle Mi\n4 Middle Fa\n5 Middle So\n6 Middle La\n7 High Xi\n8 High Do\n9 High Re\n= High Mi\n% High Fa\nC High So\nM High La\n```\n\nNow Little A has a music sheet - we call it \"calculator sheet\", a variant of Jianpu.\n\nThe duration (i.e. the length of time pressed) is recorded as follows, for example:\n\n1 is a quarter note, which lasts for 1 beat.\n\n1- is a half note, which lasts for 2 beats.\n\n1--- is a whole note, which lasts for 4 beats.\n\nFor notes shorter than the quarter note, we use nested parentheses to represent them, for example\n\n(1(34(56))2)\n\n1 and 2 in a parentheses are eighth notes, which last for 0.5 beats.\n\n3 and 4 in two layers of parentheses are sixteenth notes, which last for 0.25 beats.\n\n5 and 6 in three layers of parentheses are thirty-second notes, which take 1/8 of a beat. Of course they are less common.\n\nThere will be no '-' symbol inside parentheses.\n\nThere will be no parentheses with 4 or more layers.\n\nAdding a dot after a note means the note is extended by half. For example,\n\n1-. lasts for 3 beats, 1. lasts for 1.5 beats, (3.(45.))3 lasts for 3/4 beat, 4 lasts for 1/4 beat, and 5 lasts for 3/8 beat.\n\nDots will not be added continuously two or more times, nor notes that last for more than 4 beats.\n\nOther music symbols are not considered.\n\nIn addition, the entire music sheet will be given a speed, which is an integer meaning beats per minute.\n\nFor aesthetic reasons, the music sheet can be arbitrarily divided into lines and spaces can be added. This can be ignored.\n\nNow Little A wants to know how much time will it take to play this music sheet (in seconds).", "code": "#include <bits/stdc++.h>\nusing namespace std;\nint n,T,st=0,Length;\ndouble itime=0;                                         //乐谱长度\nstring s;\nint main()\n{\n    ios::sync_with_stdio(false);\n    cin>>n>>T;\n    for(;cin>>s;st=0)                                   //读不到就结束了\n    {\n        Length=s.length();\n        for(int i=0;i<Length;i++)\n        {\n            switch(s[i])                                //分析字符\n            {\n                case ' ':\n                case '\\r':\n                case '\\n':break;                        //空字符\n                case '(':st++;break;                    //音符值减半\n                case ')':st--;break;                    //音符值翻倍\n                case '.':itime+=pow(0.5,st+1);break;    //半个音符\n                default:itime+=pow(0.5,st);             //普通音符\n            }\n        }\n    }\n    cout<<(int)itime*60/T<<endl;                        //注意取整\n    return 0;\n}", "step": ["Initialize variables including n, T, st, Length, itime, and s.", "Read in the values of n and T.", "Loop through the input text.", "For each word in the text, loop through its characters.", "For each character, check if it is a space, line break, opening parenthesis, closing parenthesis, period, or other character.", "Update st based on the parentheses count, and update itime based on the period count.", "Print the result of the calculation."], "nl_cn": "总所周知，计算器可以拿来干很多它本不应该干的事情，比如写作文。（参看洛谷P2549）\n\n小A发现了一个计算器的另一个隐藏功能——弹琴。\n\n\n\n\n如果按上一个键，比如说1，就会发出中音“Do”。\n\n这边给出按键音高表\n\n```cpp\n+ 低音Fa\n< 低音So\n* 低音La\n/ 低音Xi\n1 中音Do\n2 中音Re\n3 中音Mi\n4 中音Fa\n5 中音So\n6 中音La\n7 高音Xi\n8 高音Do\n9 高音Re\n= 高音Mi\n% 高音Fa\nC 高音So\nM 高音La\n```\n现在小A搞到了一份乐谱——我们称为计算器谱，一种变形的简谱。\n\n时值（也就是按的时间长度）是这么记录的，例如：\n\n1 是四分音符，占1拍。\n\n1- 是二分音符，占2拍。\n\n1--- 是全音符，占四拍。\n\n对于小于四分音符的音符，我们用嵌套括号表示，例如\n\n(1(34(56))2)\n\n1和2在一层括号中，是八分音符，占0.5拍。\n\n3和4在两层括号中，是16分音符，占0.25拍。\n\n5和6在三层括号中，是32分音符，占1/8拍。当然实际上比较少见。\n\n括号中不会出现‘-’这个符号。\n\n不会出现四层或以上的括号。\n\n在一个音符后面添加一个附点即“.”表示这个音符延长1/2倍。\n\n例如\n1-.是3拍，1.是1.5拍，(3.(45.))3是3/4拍，4是1/4拍，5是3/8拍。\n\n附点不会连续添加两个或以上，也不会出现超过四拍的音符。\n\n不考虑其他的乐理符号。\n\n另外整个乐谱会给一个速度，整数，意思是一分钟多少拍。\n\n\n为了美观，乐谱可以随便换行、添加空格。这个忽略即可。\n\n现在小A想知道，按完这个谱子，需要多少时间（单位：秒）\n", "test_cases": [{"input": "2 60\n3345 5432 1123 322-\n3345 5432 1123 211-", "output": "32"}, {"input": "5 120\n3(1.(3))55 8(7.(6))65 655(3.(1)) (4.(4))32- \n3(1.(2))35 8(7.(6))65 655(4.(3)) (2.(3))21- \n2.(3)44 6(6.(6))(5.(4))3 3.(5)88 (9.(8)7.(6))5-\n=.(=)(9.(8))7 9.(8)(7.(6))5  8(856543) (2.(3))43- \n=.(=)(9.(8))7 9.(8)(7.(6))5  8(857654) (3.(4))21- ", "output": "40"}, {"input": "5 120\n3(1.(3))55 8(7.(6))65 655(3.(1)) (4.(4))32-\n3(1.(2))35 8(7.(6))65 655(4.(3)) (2.(3))21-\n2.(3)44 6(6.(6))(5.(4))3 3.(5)88 (9.(8)7.(6))5-\n=.(=)(9.(8))7 9.(8)(7.(6))5  8(856543) (2.(3))43-\n=.(=)(9.(8))7 9.(8)(7.(6))5  8(857654) (3.(4))21-\n", "output": "40"}], "test": "#undef NDEBUG\n#include<assert.h>\nint main(){\n    assert(solution(\"2 60\\n3345 5432 1123 322-\\n3345 5432 1123 211-\") == \"32\");\n    assert(solution(\"5 120\\n3(1.(3))55 8(7.(6))65 655(3.(1)) (4.(4))32- \\n3(1.(2))35 8(7.(6))65 655(4.(3)) (2.(3))21- \\n2.(3)44 6(6.(6))(5.(4))3 3.(5)88 (9.(8)7.(6))5-\\n=.(=)(9.(8))7 9.(8)(7.(6))5  8(856543) (2.(3))43- \\n=.(=)(9.(8))7 9.(8)(7.(6))5  8(857654) (3.(4))21- \") == \"40\");\n    assert(solution(\"5 120\\n3(1.(3))55 8(7.(6))65 655(3.(1)) (4.(4))32-\\n3(1.(2))35 8(7.(6))65 655(4.(3)) (2.(3))21-\\n2.(3)44 6(6.(6))(5.(4))3 3.(5)88 (9.(8)7.(6))5-\\n=.(=)(9.(8))7 9.(8)(7.(6))5  8(856543) (2.(3))43-\\n=.(=)(9.(8))7 9.(8)(7.(6))5  8(857654) (3.(4))21-\\n\") == \"40\");\n    return 0; \n}", "prompt": "/*As we all know, calculators can be used for many things they are not supposed to do, such as writing essays. (See Luogu P2549)\n\nLittle A found another hidden feature of a calculator - playing music.\n\n\n\nIf you press a key, say 1, it will produce the middle C.\n\nHere is the table of the notes:\n\n```cpp\n+ Low Fa\n< Low So\n* Low La\n/ Low Xi\n1 Middle Do\n2 Middle Re\n3 Middle Mi\n4 Middle Fa\n5 Middle So\n6 Middle La\n7 High Xi\n8 High Do\n9 High Re\n= High Mi\n% High Fa\nC High So\nM High La\n```\n\nNow Little A has a music sheet - we call it \"calculator sheet\", a variant of Jianpu.\n\nThe duration (i.e. the length of time pressed) is recorded as follows, for example:\n\n1 is a quarter note, which lasts for 1 beat.\n\n1- is a half note, which lasts for 2 beats.\n\n1--- is a whole note, which lasts for 4 beats.\n\nFor notes shorter than the quarter note, we use nested parentheses to represent them, for example\n\n(1(34(56))2)\n\n1 and 2 in a parentheses are eighth notes, which last for 0.5 beats.\n\n3 and 4 in two layers of parentheses are sixteenth notes, which last for 0.25 beats.\n\n5 and 6 in three layers of parentheses are thirty-second notes, which take 1/8 of a beat. Of course they are less common.\n\nThere will be no '-' symbol inside parentheses.\n\nThere will be no parentheses with 4 or more layers.\n\nAdding a dot after a note means the note is extended by half. For example,\n\n1-. lasts for 3 beats, 1. lasts for 1.5 beats, (3.(45.))3 lasts for 3/4 beat, 4 lasts for 1/4 beat, and 5 lasts for 3/8 beat.\n\nDots will not be added continuously two or more times, nor notes that last for more than 4 beats.\n\nOther music symbols are not considered.\n\nIn addition, the entire music sheet will be given a speed, which is an integer meaning beats per minute.\n\nFor aesthetic reasons, the music sheet can be arbitrarily divided into lines and spaces can be added. This can be ignored.\n\nNow Little A wants to know how much time will it take to play this music sheet (in seconds).\n\ninput_format:\nFirst line, two integers n and T, representing the number of lines in the music sheet and the speed (beats per minute).\n\nThe next n lines provide the music sheet.\n\noutput_format:\nAn integer indicating the time it takes to play, in seconds, with the decimal part omitted.\n*/\n\n#include<sstream>\n#include<stdlib.h>\n#include<algorithm>\n#include<math.h>\n#include<stdio.h>\n#include<vector>\n#include<string>\n#include<climits>\n#include<cstring>\n#include<iostream>\nusing namespace std;\n\n             \nstring solution(string std_in){\n    istringstream iss(std_in);\n             ", "constraints": "样例1说明：（一共32拍，每分钟60拍，所以是32秒。对了，这是欢乐颂的开头部分）\n\n样例2说明：（一共80拍，别问我怎么数的，一分钟120拍的话，是40秒。至于这是什么曲子？根据相关的法律政策，该部分未予显示。）\n\n\n\nhttp://bd.kuwo.cn/yinyue/4641527\n\n对于40%的数据，没有附点没有括号\n\n对于100%的数据，括号层数不会超过3层，不超过100行，每行不超过100个字符。\n\n对于其中的一个数据，是《千本樱》。\n", "samples": [["2 60\n3345 5432 1123 322-\n3345 5432 1123 211-", "32\n"], ["5 120\n3(1.(3))55 8(7.(6))65 655(3.(1)) (4.(4))32- \n3(1.(2))35 8(7.(6))65 655(4.(3)) (2.(3))21- \n2.(3)44 6(6.(6))(5.(4))3 3.(5)88 (9.(8)7.(6))5-\n=.(=)(9.(8))7 9.(8)(7.(6))5  8(856543) (2.(3))43- \n=.(=)(9.(8))7 9.(8)(7.(6))5  8(857654) (3.(4))21- ", "40\n"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000]}}
{"task_id": "P3951", "title": "[NOIP2017 提高组] 小凯的疑惑 / [蓝桥杯 2013 省] 买不到的数目", "difficulty": "challenge", "nl": "In Xiaokai's hand, there are two types of coins with positive integers as their face values that are mutually prime. Xiaokai has an infinite amount of each coin. Without making change, there are some items that Xiaokai cannot pay for accurately using only these two types of coins. Now Xiaokai wants to know the maximum value of the items that he cannot pay for accurately. Note that the input data guarantees the existence of items that Xiaokai cannot pay for accurately.", "code": "#include<bits/stdc++.h>\nlong long a,b;\nint main()\n{\n    scanf(\"%lld%lld\",&a,&b);\n    printf(\"%lld\\n\",(a-1)*b-a);//其实就是a*b-a-b\n    return 0;\n}", "step": ["Declare variables a and b of data type long long.", "Take inputs a and b through scanf().", "Perform the mathematical calculation using the given formula and store the result.", "Print the output result using printf().", "Return 0 to indicate successful execution of the program."], "nl_cn": "小凯手中有两种面值的金币，两种面值均为正整数且彼此互素。每种金币小凯都有无数个。在不找零的情况下，仅凭这两种金币，有些物品他是无法准确支付的。现在小 凯想知道在无法准确支付的物品中，最贵的价值是多少金币？注意：输入数据保证存在 小凯无法准确支付的商品。\n", "test_cases": [{"input": "3 7", "output": "11"}, {"input": "6 3\n", "output": "9"}, {"input": "25 15\n", "output": "335"}, {"input": "25 10\n", "output": "215"}, {"input": "2 3\n", "output": "1"}, {"input": "4 5\n", "output": "11"}, {"input": "7 2\n", "output": "5"}], "test": "#undef NDEBUG\n#include<assert.h>\nint main(){\n    assert(solution(\"3 7\") == \"11\");\n    assert(solution(\"6 3\\n\") == \"9\");\n    assert(solution(\"25 15\\n\") == \"335\");\n    assert(solution(\"25 10\\n\") == \"215\");\n    assert(solution(\"2 3\\n\") == \"1\");\n    assert(solution(\"4 5\\n\") == \"11\");\n    assert(solution(\"7 2\\n\") == \"5\");\n    return 0; \n}", "prompt": "/*In Xiaokai's hand, there are two types of coins with positive integers as their face values that are mutually prime. Xiaokai has an infinite amount of each coin. Without making change, there are some items that Xiaokai cannot pay for accurately using only these two types of coins. Now Xiaokai wants to know the maximum value of the items that he cannot pay for accurately. Note that the input data guarantees the existence of items that Xiaokai cannot pay for accurately.\n\ninput_format:\nTwo positive integers $a$and $b$, separated by a space, represent the face value of the gold coin.\n\noutput_format:\nA positive integer $N$indicates the value of the most expensive item that Kai cannot accurately pay for with his gold coins without change.\n*/\n\n#include<sstream>\n#include<stdlib.h>\n#include<algorithm>\n#include<math.h>\n#include<stdio.h>\n#include<vector>\n#include<string>\n#include<climits>\n#include<cstring>\n#include<iostream>\nusing namespace std;\n\n             \nstring solution(string std_in){\n    istringstream iss(std_in);\n             ", "constraints": "【输入输出样例 1 说明】\n\n小凯手中有面值为 $3$ 和 $7$ 的金币无数个，在不找零的前提下无法准确支付价值为 $1,2,4,5,8,11$ 的物品，其中最贵的物品价值为 $11$，比 $11$ 贵的物品都能买到，比如：\n\n$12 = 3 \\times 4 + 7 \\times 0$；\n\n$13 = 3 \\times 2 + 7 \\times 1$；\n\n$14 = 3 \\times 0 + 7 \\times 2$；\n\n$15 = 3 \\times 5 + 7 \\times 0 $。\n\n\n【数据范围与约定】\n\n对于 $30\\%$ 的数据： $1 \\le a,b \\le 50 $。\n\n对于 $60\\%$ 的数据： $1 \\le a,b \\le 10^4 $。\n\n对于$ 100\\%$ 的数据：$1 \\le a,b \\le 10^9 $。\n", "samples": [["3 7", "11\n"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000]}}
{"task_id": "P7573", "title": "「PMOI-3」公平の意", "difficulty": "basic", "nl": "There are n people and lhm has a cake with a weight of 1. Everyone wants to eat lhm's cake. In order to maintain fairness and justice, lhm needs to use the minimum number of cuts to divide the cake into n equal parts (each part can contain multiple pieces).\n\nConsider the cake as a circle, note that each cut can only be made along a diameter.\n\nThe number of cake pieces that each person gets in the end can be different, but it must be ensured that each person gets a weight of 1/n.\n\nNow you need to find the minimum number of cuts lhm needs to make.", "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nint t,n;\n\nint main()\n{\n\tscanf(\"%d\",&t);\n\twhile(t--)\n\t{\n\t\tscanf(\"%d\",&n);\n\t\tif(n == 1)\n\t\t\tputchar('0'),putchar('\\n');\n\t\telse printf(\"%d\\n\",(n + 1) >> 1);\n\t}\n\treturn 0;\n}", "step": ["Initialize t and n variables.", "Read input value t.", "Execute a loop for t times.", "Read input value n.", "Check If n is equal to 1, Output 0", "Otherwise, Output (n + 1) / 2"], "nl_cn": "现在有 $n$ 个人，lhm 有一个质量为 $1$ 的蛋糕。所有人都想吃到 lhm 的蛋糕。lhm 为了维持公平正义，他需要用最小的刀数将蛋糕分成相等的 $n$ 份（一份中可以包含多块）。\n\n把蛋糕看作一个圆，注意：每次切蛋糕时只能沿着直径切下。\n\n最终每人得到的蛋糕块数可以不同，但必须保证每人得到的质量为 $\\frac1n$。\n\n现在你需要求出 lhm 切割的最小刀数。", "test_cases": [{"input": "2\n2\n3", "output": "1\n2"}, {"input": "1\n", "output": "0"}], "test": "#undef NDEBUG\n#include<assert.h>\nint main(){\n    assert(solution(\"2\\n2\\n3\") == \"1\\n2\");\n    assert(solution(\"1\\n\") == \"0\");\n    return 0; \n}", "prompt": "/*There are n people and lhm has a cake with a weight of 1. Everyone wants to eat lhm's cake. In order to maintain fairness and justice, lhm needs to use the minimum number of cuts to divide the cake into n equal parts (each part can contain multiple pieces).\n\nConsider the cake as a circle, note that each cut can only be made along a diameter.\n\nThe number of cake pieces that each person gets in the end can be different, but it must be ensured that each person gets a weight of 1/n.\n\nNow you need to find the minimum number of cuts lhm needs to make.\n\ninput_format:\n** This question contains multiple sets of data. **\n\nThe input data is $t+1$rows.\n\nThe first line contains an integer $t$, indicating the number of data groups.\n\nThe next line is $t$, with an integer $n$per line representing the number of people.\n\noutput_format:\nThe output data has a total of $t$lines, and each line has a positive integer to represent the answer.\n*/\n\n#include<sstream>\n#include<stdlib.h>\n#include<algorithm>\n#include<math.h>\n#include<stdio.h>\n#include<vector>\n#include<string>\n#include<climits>\n#include<cstring>\n#include<iostream>\nusing namespace std;\n\n             \nstring solution(string std_in){\n    istringstream iss(std_in);\n             ", "constraints": "【样例解释】\n\n当 $n=2$ 时，我们直接沿直径切下，从而得到了两个质量均为 $\\frac 1 2$ 的蛋糕块，分别将它们分给两个人即可。\n\n当 $n=3$ 时，我们可以先后沿两条夹角为 $60 \\degree$ 的直径切下，从而得到了质量为 $\\frac 1 6$ 的两个蛋糕块 $a,b$ 和质量为 $\\frac 1 3$ 的两个蛋糕块 $c,d$。我们把 $a,b$ 分给第一个人，$c,d$ 分别给第二个人和第三个人，就可以做到公平正义。\n\n【数据范围】\n\n对于 $20\\%$ 的数据满足，$1 \\le n \\le 10$。\n\n对于另 $20\\%$ 的数据满足，$t=1$。\n\n对于 $100\\%$ 的数据满足，$1 \\le t \\le 10^3$，$1 \\le n \\le 10^{9}$。", "samples": [["2\n2\n3", "1\n2"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000], "memory": [131072, 131072, 131072, 131072, 131072]}}
{"task_id": "P7151", "title": "[USACO20DEC] Replication G", "difficulty": "advanced", "nl": "The consequence of watching too many mechanical DIY videos online is that Farmer John accidentally created a robot that can self-replicate on his farm!\n\nThe farm can be represented by an $N × N$ grid ($3 ≤ N ≤ 1000$) where each square is either empty or contains a rock, and all squares on the boundary contain rocks. Some squares without rocks are designated as possible starting positions for the robot.\n\nInitially, Farmer John places the robot at one of the possible starting positions. Each hour thereafter, all copies of the robot move one square in the same direction, either north, south, east, or west. After every $D$ hours ($1 ≤ D ≤ 10^9$), each copy of the robot replicates itself -- a new copy is created at each of the four adjacent squares (i.e., north, south, east, and west) to the current square; the original copy remains in place. After some time has passed, there may be multiple robots in the same square.\n\nIf any copy of the robot would hit a rock by either moving or replicating, all copies of the robot immediately stop moving. Note that this means that all robots will eventually come to a stop, as the boundary of the farm is composed entirely of rocks.\n\nPlease help the cows determine the number of empty squares that could possibly contain robots at some point in time.", "code": "#include<bits/stdc++.h>\nusing namespace std;\ninline int Read(){\n  \tint s = 0 , w = 1;\n\tchar ch = getchar();\n\twhile(ch > '9' || ch < '0'){\n\t\tif(ch == '-') w = -1;\n\t\tch = getchar();\n\t}\n\twhile(ch >= '0' && ch <= '9'){\n\t\ts = (s << 1) + (s << 3) + ch - '0';\n\t\tch = getchar();\n\t}\n\treturn s * w;\n}\nconst int MAXN = 1e3 + 50;\nint s[MAXN][MAXN],ear[MAXN][MAXN],num[MAXN][MAXN];\nint n,k;\nint mx[4] = {1,0,-1,0};\nint my[4] = {0,1,0,-1};\npriority_queue<pair<int,pair<int,int> > >e,l; \nint main(){\n\tn = Read() , k = Read();\n\tmemset(s,127,sizeof(s));\n\tmemset(ear,127,sizeof(ear));\n\tfor(int i = 1 ; i <= n ; i ++){\n\t\tfor(int j = 1 ; j <= n ; j ++){\n\t\t\tchar ch = getchar();\n\t\t\twhile(ch != 'S' && ch != '#' && ch != '.') ch = getchar();\n\t\t\tif(ch == 'S'){\n\t\t\t\te.push(make_pair(0,make_pair(i,j)));\n\t\t\t\tear[i][j] = 0;\n\t\t\t}\n\t\t\tif(ch == '#') s[i][j] = 0;\n\t\t}\n\t}\n\tpriority_queue<pair<int,pair<int,int> > >rock;\n\tfor(int i = 1 ; i <= n ; i ++){\n\t\tfor(int j = 1 ; j <= n ; j ++){\n\t\t\tif(!s[i][j]) rock.push(make_pair(0,make_pair(i,j)));\n\t\t}\n\t}\n\twhile(!rock.empty()){\n\t\tint i = rock.top().second.first , j = rock.top().second.second;\n\t\trock.pop();\n\t\tfor(int d = 0 ; d < 4 ; d ++){\n\t\t\tif(i + mx[d] <= 0 || i + mx[d] > n || j + my[d] <= 0 || j + my[d] > n) continue;\n\t\t\tif(s[i + mx[d]][j + my[d]] > s[i][j] + 1){\n\t\t\t\ts[i + mx[d]][j + my[d]] = s[i][j] + 1;\n\t\t\t\trock.push(make_pair(- (s[i][j] + 1),make_pair(i + mx[d],j + my[d])));\n\t\t\t}\n\t\t}\n\t}\n\twhile(!e.empty()){\n\t\tint x = e.top().second.first , y = e.top().second.second;\n\t\tint t = - e.top().first;\n\t\te.pop();\n\t\tif(t > ear[x][y]) continue;\n\t\tif(ear[x][y] / k >= s[x][y]) continue;\n\t\tfor(int d = 0 ; d < 4 ; d ++){\n\t\t\tif(!s[x + mx[d]][y + my[d]]) continue;\n \t\t\tif(x + mx[d] <= 0 || x + mx[d] > n || y + my[d] <= 0 || y + my[d] > n) continue;\n\t\t\tif(ear[x + mx[d]][y + my[d]] > t + 1){\n\t\t\t\tear[x + mx[d]][y + my[d]] = t + 1;\n\t\t\t\te.push(make_pair(- (t + 1),make_pair(x + mx[d],y + my[d])));\n\t\t\t}\n\t\t}\n\t}\n\tpriority_queue<pair<int,pair<int,int> > >rb;\n\tfor(int i = 1 ; i <= n ; i ++){\n\t\tfor(int j = 1 ; j <= n ; j ++){\n\t\t\tif(ear[i][j] < 19260817){\n\t\t\t\trb.push(make_pair(1 + min(s[i][j] - 1,ear[i][j] / k),make_pair(i,j)));\n\t\t\t}\n\t\t}\n\t}\n\twhile(!rb.empty()){\n\t\tint x = rb.top().second.first , y = rb.top().second.second;\n\t\tint t = rb.top().first;\n\t\trb.pop();\n\t\tif(t <= num[x][y]) continue;\n\t\tnum[x][y] = t;\n\t\tfor(int d = 0 ; d < 4 ; d ++){\n\t\t\tif(x + mx[d] <= 0 || x + mx[d] > n || y + my[d] <= 0 || y + my[d] > n) continue;\n\t\t\tif(num[x + mx[d]][y + my[d]] <= t - 1){\n\t\t\t\trb.push(make_pair(t - 1,make_pair(x + mx[d],y + my[d])));\n\t\t\t}\n\t\t}\n\t}\n\tint ans = 0;\n\tfor(int i = 1 ; i <= n ; i ++){\n\t\tfor(int j = 1 ; j <= n ; j ++){\n\t\t\tans += (0 != num[i][j]);\n\t\t}\n\t}\n\tcout << ans << endl;\n\treturn 0;\n}", "step": ["Reads the map size n and maximum movement distance d.", "Fills in a grid with obstacles, and initializes BFS queues  for the position of the obstacle and the robot at the beginning.", "BFS is run on the obstacle positions to compute the minimum distance from an empty cell to an obstacle cell.", "BFS is run on the robot positions that haven't reached previously marked cells and whose  distance from an obstacle cell is less than d.", "The grid cells that the robot can reach and have not been already reached are added to a priority queue, where the priority is the distance to the closest obstacle.", "BFS is run on the priority queue to find the cells the robot can reach."], "nl_cn": "在网上观看太多机械 DIY 视频的后果就是，Farmer John 偶然在他的农场上制造了一个可以自我复制的机器人！\n\n农场可以用一个 $N×N$ 的方阵表示（$3≤N≤1000$），其中每个方格是空的或有岩石，并且所有边界上的方格均有岩石。某些没有岩石的方格被指定为机器人可能的起始位置。\n\nFarmer John 初始将机器人放置在可能的起始位置之一。在之后的每一个小时，机器人的所有副本会沿着相同的方向移动一格，向北、向南、向东或向西。每 $D$ 个小时（$1≤D≤10^9$）之后，机器人的每个副本会进行自我复制——在方格 $(x,y)$ 进行自我复制的机器人会在方格 $(x+1,y)$、$(x−1,y)$、$(x,y+1)$ 以及 $(x,y−1)$ 产生机器人的新的副本；原本的机器人仍然位于 $(x,y)$。一段时间过后，同一方格内可能会有多个机器人。\n\n如果移动或复制会使得任何一个机器人撞到岩石，那么所有的机器人均立刻停止行动。注意这意味着所有机器人最终必然会停下，由于农场的边界都是岩石。\n\n请帮助奶牛们求出可能在某个时刻含有机器人的空的方格数量。 ", "test_cases": [{"input": "10 1\n##########\n#........#\n#S.......#\n#........#\n##########\n#S....S..#\n##########\n##########\n##########\n##########", "output": "15"}, {"input": "10 2\n##########\n#.#......#\n#.#......#\n#S.......#\n#.#......#\n#.#......#\n##########\n##########\n##########\n##########", "output": "28"}, {"input": "10 2\n##########\n#.S#.....#\n#..#.....#\n#S.......#\n#..#.....#\n#..#.....#\n##########\n##########\n##########\n##########", "output": "10"}], "test": "#undef NDEBUG\n#include<assert.h>\nint main(){\n    assert(solution(\"10 1\\n##########\\n#........#\\n#S.......#\\n#........#\\n##########\\n#S....S..#\\n##########\\n##########\\n##########\\n##########\") == \"15\");\n    assert(solution(\"10 2\\n##########\\n#.#......#\\n#.#......#\\n#S.......#\\n#.#......#\\n#.#......#\\n##########\\n##########\\n##########\\n##########\") == \"28\");\n    assert(solution(\"10 2\\n##########\\n#.S#.....#\\n#..#.....#\\n#S.......#\\n#..#.....#\\n#..#.....#\\n##########\\n##########\\n##########\\n##########\") == \"10\");\n    return 0; \n}", "prompt": "/*The consequence of watching too many mechanical DIY videos online is that Farmer John accidentally created a robot that can self-replicate on his farm!\n\nThe farm can be represented by an $N × N$ grid ($3 ≤ N ≤ 1000$) where each square is either empty or contains a rock, and all squares on the boundary contain rocks. Some squares without rocks are designated as possible starting positions for the robot.\n\nInitially, Farmer John places the robot at one of the possible starting positions. Each hour thereafter, all copies of the robot move one square in the same direction, either north, south, east, or west. After every $D$ hours ($1 ≤ D ≤ 10^9$), each copy of the robot replicates itself -- a new copy is created at each of the four adjacent squares (i.e., north, south, east, and west) to the current square; the original copy remains in place. After some time has passed, there may be multiple robots in the same square.\n\nIf any copy of the robot would hit a rock by either moving or replicating, all copies of the robot immediately stop moving. Note that this means that all robots will eventually come to a stop, as the boundary of the farm is composed entirely of rocks.\n\nPlease help the cows determine the number of empty squares that could possibly contain robots at some point in time.\n\ninput_format:\nThe first line of input contains two space-separated integers $N$and $D$. The following $N$lines each contain $N$characters. Each character is one of '.', 'S', and '#'. Both '.' and 'S' represent empty squares, and 'S' represents a possible starting position for the robot. '#' means a rock.\n\nAll first row, last row, first column, and last column characters are '#'.\n\noutput_format:\nOutputs an integer representing the number of squares that might contain a robot at some point.\n*/\n\n#include<sstream>\n#include<stdlib.h>\n#include<algorithm>\n#include<math.h>\n#include<stdio.h>\n#include<vector>\n#include<string>\n#include<climits>\n#include<cstring>\n#include<iostream>\nusing namespace std;\n\n             \nstring solution(string std_in){\n    istringstream iss(std_in);\n             ", "constraints": "### 样例 1 解释：\n在以下的图中，x 表示机器人。\n\n可能含有机器人的位置为：\n\n```\n##########\n#xxx.....#\n#xxxx....#\n#xxx.....#\n##########\n#xx..xxx.#\n##########\n##########\n##########\n##########\n```\n以下是一个可能的事件序列：\n\nFJ 将机器人放在了左上的起始位置。\n机器人向右移动一个单位。\n机器人进行自我复制。\n所有机器人向右移动一个单位。\n再一次自我复制会导致存在机器人撞到岩石，所以该过程终止。\n```\n##########    ##########    ##########    ##########\n#........#    #........#    #.x......#    #..x.....#\n#x.......#    #.x......#    #xxx.....#    #.xxx....#\n#........#    #........#    #.x......#    #..x.....#\n########## -> ########## -> ########## -> ##########\n#........#    #........#    #........#    #........#\n##########    ##########    ##########    ##########\n##########    ##########    ##########    ##########\n##########    ##########    ##########    ##########\n##########    ##########    ##########    ##########\n```\n### 样例 2 解释：\n\n可能含有机器人的位置为：\n```\n##########\n#x#.xxx..#\n#x#xxxxx.#\n#xxxxxxxx#\n#x#xxxxx.#\n#x#.xxx..#\n##########\n##########\n##########\n##########\n```\n### 样例 3 解释：\n可能含有机器人的位置为：\n```\n##########\n#xx#.....#\n#xx#.....#\n#xxx.....#\n#xx#.....#\n#x.#.....#\n##########\n##########\n##########\n##########\n```\n### 测试点性质：\n\n - 测试点 4-5 满足 $D=10^9$。\n - 测试点 6-8 满足 $D=1$。\n - 测试点 9-12 满足 $N≤100$。\n - 测试点 13-20 没有额外限制。\n\n供题：Benjamin Qi ", "samples": [["10 1\n##########\n#........#\n#S.......#\n#........#\n##########\n#S....S..#\n##########\n##########\n##########\n##########", "15"], ["10 2\n##########\n#.#......#\n#.#......#\n#S.......#\n#.#......#\n#.#......#\n##########\n##########\n##########\n##########", "28"], ["10 2\n##########\n#.S#.....#\n#..#.....#\n#S.......#\n#..#.....#\n#..#.....#\n##########\n##########\n##########\n##########", "10"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144]}}
{"task_id": "P2102", "title": "地砖铺设", "difficulty": "advanced", "nl": "Little Z, who made a lot of money in the game hall, finally won the furniture he wanted. Taking this opportunity, he wants to tidy up his room.\n\nIn the department store, various square tiles can be bought. For the sake of beauty, Little Z does not want square tiles of the same color to be adjacent. So he found Little C to help solve this problem.\n\nLittle C quickly solved this task. However, due to some obsessive-compulsive disorder, she hopes that after dividing the ground into grids according to the length and width, the color sequence of each piece row by row and column by column will be the smallest in lexicographic order. She wants you to help verify her plan.", "code": "#include<bits/stdc++.h>\nusing namespace std;\n\n#define int short \n\nint n,m;\nint a[105][105];\n\nbool check(int col,int x,int y){\n\tif(x>n||y>m||a[x-1][y]==col||a[x+1][y]==col||a[x][y-1]==col||a[x][y+1]==col) return 0;\n\treturn 1;\n}\n\nbool work(int col,int x,int y){\n\tint nx=x,ny=y;\n\tint f=0;\n\tfor(register int i(1);i<=n;++i){\n\t\tif(!a[nx][y]&&!a[x][ny]&&check(col,nx,y)&&check(col,x,ny)){\n\t\t\tint f2=0;\n\t\t\tfor(register int j(1);j<col;++j){\n\t\t\t\tif(check(j,x,ny)){\n\t\t\t\t\tf2=1;break;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(f2==1) break;\n\t\t\tf=1;\n\t\t\t++nx,++ny;\n\t\t}\n\t\tif(f==0) return 0;\n\t}\n\tfor(register int i(x);i<nx;++i){\n\t\tfor(register int j(y);j<ny;++j){\n\t\t\ta[i][j]=col;\n\t\t}\n\t}\n\treturn 1;\n}\n\n\nsigned main(){\n\tcin>>n>>m;\n\tfor(register int i(1);i<=n;++i){\n\t\tfor(register int j(1);j<=m;++j){\n\t\t\tif(a[i][j]) continue;\n\t\t\tfor(register int k=1;k<=4;k++){\n\t\t\t\tif(work(k,i,j)) break;\n\t\t\t} \n\t\t}\n\t}\n\tfor(register int i(1);i<=n;++i){\n\t\tfor(register int j(1);j<=m;++j){\n\t\t\tputchar(a[i][j]-1+'A');\n\t\t}putchar('\\n');\n\t}\n}", "step": ["Read input n and m", "Create map with [110][110]", "For each cell, get the colour based on neighbours and store in map", "Print output based on colour map"], "nl_cn": "在游戏厅大赚了一笔的小Z终于赢到了他想要的家具。乘此机会，他想把自己的房间好好整理一下。\n\n在百货公司，可以买到各种各样正方形的地砖，为了美观起见，小Z不希望同样颜色的正方形地砖相邻。所以他找到了小C来帮忙解决这件事情。\n\n小C很快解决了这个任务。然而，出于某种强迫症，她希望在地上按照长宽划分成网格后，逐行逐列每一块的颜色组成的序列的字典序最小。她希望你帮忙验证一下她的方案。\n", "test_cases": [{"input": "4 3", "output": "AAA\nAAA\nAAA\nBCB"}, {"input": "1 1\n", "output": "A"}, {"input": "5 5\n", "output": "AAAAA\nAAAAA\nAAAAA\nAAAAA\nAAAAA"}, {"input": "6 6\n", "output": "AAAAAA\nAAAAAA\nAAAAAA\nAAAAAA\nAAAAAA\nAAAAAA"}, {"input": "3 3\n", "output": "AAA\nAAA\nAAA"}, {"input": "4 4\n", "output": "AAAA\nAAAA\nAAAA\nAAAA"}, {"input": "0 0\n", "output": ""}], "test": "#undef NDEBUG\n#include<assert.h>\nint main(){\n    assert(solution(\"4 3\") == \"AAA\\nAAA\\nAAA\\nBCB\");\n    assert(solution(\"1 1\\n\") == \"A\");\n    assert(solution(\"5 5\\n\") == \"AAAAA\\nAAAAA\\nAAAAA\\nAAAAA\\nAAAAA\");\n    assert(solution(\"6 6\\n\") == \"AAAAAA\\nAAAAAA\\nAAAAAA\\nAAAAAA\\nAAAAAA\\nAAAAAA\");\n    assert(solution(\"3 3\\n\") == \"AAA\\nAAA\\nAAA\");\n    assert(solution(\"4 4\\n\") == \"AAAA\\nAAAA\\nAAAA\\nAAAA\");\n    assert(solution(\"0 0\\n\") == \"\");\n    return 0; \n}", "prompt": "/*Little Z, who made a lot of money in the game hall, finally won the furniture he wanted. Taking this opportunity, he wants to tidy up his room.\n\nIn the department store, various square tiles can be bought. For the sake of beauty, Little Z does not want square tiles of the same color to be adjacent. So he found Little C to help solve this problem.\n\nLittle C quickly solved this task. However, due to some obsessive-compulsive disorder, she hopes that after dividing the ground into grids according to the length and width, the color sequence of each piece row by row and column by column will be the smallest in lexicographic order. She wants you to help verify her plan.\n\ninput_format:\nThe first line, containing two integers N and M, represents the length and width of the room.\n\noutput_format:\nN rows, each row M columns, represent the floor tile laying scheme, need this scheme is the minimum lexicographical legal scheme. (It can be considered that the output scheme has the smallest string lexicographic order after removing the carriage return)\n*/\n\n#include<sstream>\n#include<stdlib.h>\n#include<algorithm>\n#include<math.h>\n#include<stdio.h>\n#include<vector>\n#include<string>\n#include<climits>\n#include<cstring>\n#include<iostream>\nusing namespace std;\n\n             \nstring solution(string std_in){\n    istringstream iss(std_in);\n             ", "constraints": "对于 $50\\%$ 的数据，保证 $N,M \\leq 5$。\n\n对于 $100\\%$ 的数据，保证 $1 \\leq N,M \\leq 100$。\n", "samples": [["4 3", "AAA\nAAA\nAAA\nBCB"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}}
{"task_id": "P8823", "title": "[传智杯 #3 初赛] 期末考试成绩", "difficulty": "basic", "nl": "The evaluation system for the Java programming course at Zhongkai University of Agriculture and Engineering is as follows:\n\nFirstly, all students will have a written exam score, which is an integer between 0 and 100.\n\nIf the written exam score is 90 or above, then the student's GPA (Grade Point Average) will be 4.0.\n\nIf the written exam score is between 60 and 89, then for each 1 point lower than 90, the student's score will be reduced by 0.1 based on 4.0.\n\nIf the written exam score is below 60, the kind teacher will give them care. Specifically, if their initial score is x, the teacher will adjust their score to $\\sqrt{x}\\times 10$ (round down), and then calculate their GPA.\n\nIf the student's score is still below 60 after adjustment, then they fail and the GPA will be 0.\n\nNow, given a student's written exam score, please output their final GPA.", "code": "#include<bits/stdc++.h>\nusing namespace std;\nint main(){\n    long long n;\n    double ans=4.0;\n    cin>>n;\n    if(n>=90)return puts(\"4.0\"),0;//大于等于90直接输出\n    else if(n>=60&&n<=89){//分数大于等于60并且小于等于89\n        ans-=(90-n)*0.1;\n        return printf(\"%.1f\",ans),0;\n    }\n    else{//小于60\n        n=sqrt(n)*10;//更新得分\n        if(n<60)return puts(\"0.0\"),0;//还是小于60\n        else{//大于等于60\n            if(n>=90)return puts(\"4.0\"),0;\n            ans-=(90-n)*0.1;\n            printf(\"%.1f\",ans);\n        }\n    }\n}", "step": ["Declare variables and read user input.", "If `n` is greater than or equal to 90, print 4.0 and exit.", "If `n` is between 60 and 89, subtract the difference from 90, multiply by 0.1, subtract that from 4.0, print the result and exit.", "If `n` is less than 60, set `n` equal to the square root of the original value multiplied by 10.", "If `n` is less than 60 after the adjustment, print 0.0 and exit.", "If `n` is between 60 and 89 after the adjustment or greater than or equal to 90 after the adjustment, calculate the score in the same way as step 3 and print the result."], "nl_cn": "传智专修学院的 Java 程序设计课程的评价体系是这样的：\n\n首先，所有学生会有一个卷面得分，这个得分一定是一个 $[0,100]$ 之间的整数。\n\n如果卷面得分在 $90$ 分及以上，那么他的 GPA（加权平均成绩） 就是满分 $4.0$。\n\n如果卷面得分在 $60 \\sim 89$ 之间，那么他每比 $90$ 分少 $1$ 分，那么他的分数就会在 $4.0$ 的基础上减少 $0.1$。\n\n如果卷面得分不到 $60$ 分，那么善良的老师会给他照顾。具体来说，如果他的分数为 $x$ ，那么老师会把他的分数调整为 $\\sqrt{x}\\times 10$（向下取整） ，再计算他的 GPA。\n\n如果经过调整该学生的得分依旧没满 $60$ ，那么他就挂科了，GPA 就是 $0$ 分。\n\n现在给你一个人的期末卷面得分，请你输出他的最终 GPA", "test_cases": [{"input": "99\n", "output": "4.0"}, {"input": "88", "output": "3.8"}, {"input": "12", "output": "0.0"}, {"input": "100\n", "output": "4.0"}, {"input": "91\n", "output": "4.0"}, {"input": "97\n", "output": "4.0"}, {"input": "0\n", "output": "0.0"}, {"input": "23\n", "output": "0.0"}, {"input": "94\n", "output": "4.0"}, {"input": "90", "output": "4.0"}, {"input": "93", "output": "4.0"}, {"input": "80", "output": "3.0"}, {"input": "95", "output": "4.0"}, {"input": "85", "output": "3.5"}, {"input": "92\n", "output": "4.0"}], "test": "#undef NDEBUG\n#include<assert.h>\nint main(){\n    assert(solution(\"99\\n\") == \"4.0\");\n    assert(solution(\"88\") == \"3.8\");\n    assert(solution(\"12\") == \"0.0\");\n    assert(solution(\"100\\n\") == \"4.0\");\n    assert(solution(\"91\\n\") == \"4.0\");\n    assert(solution(\"97\\n\") == \"4.0\");\n    assert(solution(\"0\\n\") == \"0.0\");\n    assert(solution(\"23\\n\") == \"0.0\");\n    assert(solution(\"94\\n\") == \"4.0\");\n    assert(solution(\"90\") == \"4.0\");\n    assert(solution(\"93\") == \"4.0\");\n    assert(solution(\"80\") == \"3.0\");\n    assert(solution(\"95\") == \"4.0\");\n    assert(solution(\"85\") == \"3.5\");\n    assert(solution(\"92\\n\") == \"4.0\");\n    return 0; \n}", "prompt": "/*The evaluation system for the Java programming course at Zhongkai University of Agriculture and Engineering is as follows:\n\nFirstly, all students will have a written exam score, which is an integer between 0 and 100.\n\nIf the written exam score is 90 or above, then the student's GPA (Grade Point Average) will be 4.0.\n\nIf the written exam score is between 60 and 89, then for each 1 point lower than 90, the student's score will be reduced by 0.1 based on 4.0.\n\nIf the written exam score is below 60, the kind teacher will give them care. Specifically, if their initial score is x, the teacher will adjust their score to $\\sqrt{x}\\times 10$ (round down), and then calculate their GPA.\n\nIf the student's score is still below 60 after adjustment, then they fail and the GPA will be 0.\n\nNow, given a student's written exam score, please output their final GPA.\n\ninput_format:\nA line with an integer $x$indicates the person's final score.\n\noutput_format:\nA floating point number with only one decimal place, representing the GPA earned by the student.\n\nPlease note that if you have $.0$please keep it.\n*/\n\n#include<sstream>\n#include<stdlib.h>\n#include<algorithm>\n#include<math.h>\n#include<stdio.h>\n#include<vector>\n#include<string>\n#include<climits>\n#include<cstring>\n#include<iostream>\nusing namespace std;\n\n             \nstring solution(string std_in){\n    istringstream iss(std_in);\n             ", "constraints": "对于 $20\\%$ 的数据，满足 $90 \\leq x \\leq 100$；  \n对于额外 $30\\%$ 的数据，满足 $60 \\leq x \\leq 100$；  \n对于 $100\\%$ 的数据，满足 $0 \\leq x \\leq 100$。", "samples": [["99\n", "4.0"], ["88", "3.8"], ["12", "0.0"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072]}}
{"task_id": "P8546", "title": "小挖的 X 献身", "difficulty": "challenge", "nl": "Given an $n\\times n$ binary matrix, please calculate the number of X's in it.\n\nAn X is defined as a connected block filled with $1$ and in the shape of X, which is composed of left-to-right slash `\\` and right-to-left slash `/`, and it is required to ensure that the left-to-right slash and the right-to-left slash have **equal lengths**, and the X is a figure of central symmetry, and the length of the slashes is greater than 1.\n\nFor example:\n\n```cpp\n101\n010\n101\n```\n\nThere is an X with a slash length of $3$.\n\n```cpp\n1001\n0110\n0110\n1001\n```\n\nThere are two X's with slash lengths of $2$ and $4$, respectively.\n\n```cpp\n10001\n01010\n00100\n01010\n00001\n```\n\nThere is only one X with a slash length of $3$.", "code": "#include<bits/stdc++.h>\nusing namespace std;\n\nbool x[200][200];\nint n;\n\n\nbool c(int i,int j)//判断是否合格。\n{\n\tif(i<0||i>=n||j<0||j>=n)return 0;\n\treturn x[i][j];\n}\n\nint dfso(int i,int j)//搜索长度为奇。\n{\n\tint ans=0;\n\tfor(int k=1;;k++)\n\t\tif(c(i+k,j+k)&&c(i-k,j+k)&&c(i+k,j-k)&&c(i-k,j-k))\n\t\t\tans++;\n\t\telse break;\n\treturn ans;\n}\n\nint dfse(int i,int j)////搜索长度为偶。\n{\n\tint ans=0;\n\tfor(int k=0;;k++)\n\t\tif(c(i+1+k,j+1+k)&&c(i-k,j+1+k)&&c(i+1+k,j-k)&&c(i-k,j-k))\n\t\t\tans++;\n\t\telse break;\n\treturn ans;\n}\n\nint main()\n{\n\t\n\tcin>>n;\n\tfor(int i=0;i<n;i++)\n\t\tfor(int j=0;j<n;j++)\n\t\t{\n\t\t\tchar a;\n\t\t\tcin>>a;\n\t\t\tif(a-'0')x[i][j]=1;\n\t\t\telse x[i][j]=0;\n\t\t}\n\tint ans=0;\n\tfor(int i=0;i<n;i++)\n\t\tfor(int j=0;j<n;j++)\n\t\t\tif(x[i][j])\n\t\t\t\tans+=dfso(i,j);\n\tfor(int i=1;i<n;i++)\n\t\tfor(int j=1;j<n;j++)\n\t\t\tif(x[i][j]&&x[i-1][j]&&x[i][j-1]&&x[i-1][j-1])\n\t\t\t\tans+=dfse(i-1,j-1);\n\tcout<<ans;\n\treturn 0;\n}", "step": ["Scan the input character matrix.", "For each possible square size, check if each square made up of '1's exists in the matrix.", "Count the number of squares that consist of only '1's and return the count."], "nl_cn": "给定一张 $n\\times  n$ 的 $01$ 方阵，请计算其中 X 的数目。\n\nX 定义为用 $1$ 填充且形状为 X 的联通块。具体的，X 由左向斜线 `\\` 和右向斜线 `/` 构成，且需要保证左向斜线和右向斜线**长度相等**，而且 X 是中心对称图形，斜线长度大于 1。\n\n例如：\n\n```cpp\n101\n010\n101\n```\n有一个斜线长度为 $3$ 的 X。\n\n```cpp\n1001\n0110\n0110\n1001\n````\n\n则有两个斜线长度分别为 $2,4$ 的 X。\n\n```cpp\n10001\n01010\n00100\n01010\n00001\n```\n\n仅有一个斜线长度为 $3$ 的 X 。", "test_cases": [{"input": "5\n10001\n01010\n00100\n01011\n00011", "output": "2"}, {"input": "3\n101\n010\n101\n", "output": "1"}, {"input": "4\n1001\n0110\n0110\n1001\n", "output": "2"}, {"input": "2\n00\n00\n", "output": "0"}, {"input": "3\n000\n000\n000\n", "output": "0"}, {"input": "4\n0000\n0000\n0000\n0000\n", "output": "0"}, {"input": "5\n00000\n00000\n00000\n00000\n00000\n", "output": "0"}, {"input": "3\n010\n101\n010\n", "output": "0"}, {"input": "4\n0100\n1001\n1001\n0100\n", "output": "0"}, {"input": "5\n01010\n10001\n11111\n10001\n01010\n", "output": "0"}, {"input": "3\n000\n001\n000\n", "output": "0"}, {"input": "4\n0000\n0001\n0010\n0000\n", "output": "0"}, {"input": "5\n00000\n00001\n00010\n00000\n00000\n", "output": "0"}, {"input": "2\n11\n10\n", "output": "0"}, {"input": "3\n111\n100\n110\n", "output": "0"}, {"input": "5\n10001\n01010\n00100\n01010\n00001\n", "output": "1"}, {"input": "4\n1110\n1001\n1001\n1110\n", "output": "0"}, {"input": "5\n01110\n10001\n00000\n10001\n01110\n", "output": "0"}, {"input": "3\n111\n000\n111\n", "output": "0"}, {"input": "4\n1111\n1001\n1001\n1111\n", "output": "0"}, {"input": "5\n00000\n01110\n10001\n01110\n00000\n", "output": "0"}, {"input": "3\n010\n111\n010\n", "output": "0"}, {"input": "4\n1110\n1001\n1001\n1100\n", "output": "0"}, {"input": "5\n01110\n10001\n00000\n10001\n00000\n", "output": "0"}, {"input": "5\n10000\n01000\n00100\n00010\n00001\n", "output": "0"}, {"input": "6\n100001\n010010\n001100\n010100\n100001\n111111\n", "output": "0"}, {"input": "4\n1001\n0100\n0010\n0101\n", "output": "0"}, {"input": "3\n100\n010\n100\n", "output": "0"}, {"input": "6\n111111\n000000\n111111\n000000\n111111\n000000\n", "output": "0"}, {"input": "5\n10000\n01000\n00100\n01000\n10000\n", "output": "0"}, {"input": "5\n11111\n00000\n11111\n00000\n11111\n", "output": "0"}, {"input": "6\n100001\n010010\n001010\n010010\n100001\n110111\n", "output": "0"}, {"input": "4\n0101\n1010\n1010\n0101\n", "output": "0"}], "test": "#undef NDEBUG\n#include<assert.h>\nint main(){\n    assert(solution(\"5\\n10001\\n01010\\n00100\\n01011\\n00011\") == \"2\");\n    assert(solution(\"3\\n101\\n010\\n101\\n\") == \"1\");\n    assert(solution(\"4\\n1001\\n0110\\n0110\\n1001\\n\") == \"2\");\n    assert(solution(\"2\\n00\\n00\\n\") == \"0\");\n    assert(solution(\"3\\n000\\n000\\n000\\n\") == \"0\");\n    assert(solution(\"4\\n0000\\n0000\\n0000\\n0000\\n\") == \"0\");\n    assert(solution(\"5\\n00000\\n00000\\n00000\\n00000\\n00000\\n\") == \"0\");\n    assert(solution(\"3\\n010\\n101\\n010\\n\") == \"0\");\n    assert(solution(\"4\\n0100\\n1001\\n1001\\n0100\\n\") == \"0\");\n    assert(solution(\"5\\n01010\\n10001\\n11111\\n10001\\n01010\\n\") == \"0\");\n    assert(solution(\"3\\n000\\n001\\n000\\n\") == \"0\");\n    assert(solution(\"4\\n0000\\n0001\\n0010\\n0000\\n\") == \"0\");\n    assert(solution(\"5\\n00000\\n00001\\n00010\\n00000\\n00000\\n\") == \"0\");\n    assert(solution(\"2\\n11\\n10\\n\") == \"0\");\n    assert(solution(\"3\\n111\\n100\\n110\\n\") == \"0\");\n    assert(solution(\"5\\n10001\\n01010\\n00100\\n01010\\n00001\\n\") == \"1\");\n    assert(solution(\"4\\n1110\\n1001\\n1001\\n1110\\n\") == \"0\");\n    assert(solution(\"5\\n01110\\n10001\\n00000\\n10001\\n01110\\n\") == \"0\");\n    assert(solution(\"3\\n111\\n000\\n111\\n\") == \"0\");\n    assert(solution(\"4\\n1111\\n1001\\n1001\\n1111\\n\") == \"0\");\n    assert(solution(\"5\\n00000\\n01110\\n10001\\n01110\\n00000\\n\") == \"0\");\n    assert(solution(\"3\\n010\\n111\\n010\\n\") == \"0\");\n    assert(solution(\"4\\n1110\\n1001\\n1001\\n1100\\n\") == \"0\");\n    assert(solution(\"5\\n01110\\n10001\\n00000\\n10001\\n00000\\n\") == \"0\");\n    assert(solution(\"5\\n10000\\n01000\\n00100\\n00010\\n00001\\n\") == \"0\");\n    assert(solution(\"6\\n100001\\n010010\\n001100\\n010100\\n100001\\n111111\\n\") == \"0\");\n    assert(solution(\"4\\n1001\\n0100\\n0010\\n0101\\n\") == \"0\");\n    assert(solution(\"3\\n100\\n010\\n100\\n\") == \"0\");\n    assert(solution(\"6\\n111111\\n000000\\n111111\\n000000\\n111111\\n000000\\n\") == \"0\");\n    assert(solution(\"5\\n10000\\n01000\\n00100\\n01000\\n10000\\n\") == \"0\");\n    assert(solution(\"5\\n11111\\n00000\\n11111\\n00000\\n11111\\n\") == \"0\");\n    assert(solution(\"6\\n100001\\n010010\\n001010\\n010010\\n100001\\n110111\\n\") == \"0\");\n    assert(solution(\"4\\n0101\\n1010\\n1010\\n0101\\n\") == \"0\");\n    return 0; \n}", "prompt": "/*Given an $n\\times n$ binary matrix, please calculate the number of X's in it.\n\nAn X is defined as a connected block filled with $1$ and in the shape of X, which is composed of left-to-right slash `\\` and right-to-left slash `/`, and it is required to ensure that the left-to-right slash and the right-to-left slash have **equal lengths**, and the X is a figure of central symmetry, and the length of the slashes is greater than 1.\n\nFor example:\n\n```cpp\n101\n010\n101\n```\n\nThere is an X with a slash length of $3$.\n\n```cpp\n1001\n0110\n0110\n1001\n```\n\nThere are two X's with slash lengths of $2$ and $4$, respectively.\n\n```cpp\n10001\n01010\n00100\n01010\n00001\n```\n\nThere is only one X with a slash length of $3$.\n\ninput_format:\nIn the first $1$row, there is a positive integer $n$.\n\nThe next $n$rows each have a $01$string of length $n$, describing a $01$matrix.\n\noutput_format:\nRows of $1$, a non-negative integer, represent the number of X's.\n*/\n\n#include<sstream>\n#include<stdlib.h>\n#include<algorithm>\n#include<math.h>\n#include<stdio.h>\n#include<vector>\n#include<string>\n#include<climits>\n#include<cstring>\n#include<iostream>\nusing namespace std;\n\n             \nstring solution(string std_in){\n    istringstream iss(std_in);\n             ", "constraints": "对于 $20\\%$ 的数据，$1\\leq n\\leq 3$。\n\n对于 $40\\%$ 的数据，$1\\leq n\\leq 10$。\n\n对于 $70\\%$ 的数据，$1\\leq n\\leq 50$。\n\n对于 $100\\%$ 的数据，$1\\leq n\\leq 100$。", "samples": [["5\n10001\n01010\n00100\n01011\n00011", "2"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072]}}
{"task_id": "P7096", "title": "[yLOI2020] 泸沽寻梦", "difficulty": "advanced", "nl": "In the south, there is a mythical land called Mosuo, which has a lake named Lugu. Tea lives in Lugu Lake and is looking for her dreams. In the misty fog, Tea's n dreams form a sequence, and all of her dreams are like Lava. In order to distinguish these Lavas, Tea defines that the beauty value of the i-th Lava from the left to the right is a non-negative integer ai. Faced with these dreams, Tea will perform m operations. Each operation will be given two numbers p and x, and then both ap and ap+1 will be XORed with x. After each operation, Tea wants to know how many subintervals [l, r] in the current dream sequence satisfy l≤r and the XOR sum of the interval is 0. The XOR sum of interval [l, r] is defined as a_l ⊕ a_{l+1} ⊕ … ⊕ a_{r-1} ⊕ a_r, where ⊕ represents the bitwise XOR operation, i.e., the \"^\" operator in the C++ language. Two intervals are different if and only if the left endpoints of the two intervals are different or the right endpoints of the two intervals are different or both endpoints of the two intervals are different. To avoid the output being too large, you only need to output four integers, representing the bitwise XOR sum of all your answers, how many of your answers are odd, the maximum value among all your answers, and the minimum value among all your answers.", "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define rg register\n#define gc() (p1 == p2 ? (p2 = buf + fread(p1 = buf, 1, 1 << 20, stdin), p1 == p2 ? EOF : *p1++) : *p1++)\n#define read() ({ register int x = 0; register char c = gc(); while(!isdigit(c)) c = gc(); while(isdigit(c)) x = x * 10 + (c & 15), c = gc(); x; })\nchar buf[1 << 20], *p1, *p2;\nconst int maxn=1e6+5;\nconst int mod=1e6+3;\nint a[maxn],n,m;\nlong long ans1,ans2,ans3,ans4=0x3f3f3f3f3f3f3f3f,ans;\nint sum[maxn],h[maxn],tot=1;\nstruct asd{\n\tint val,nxt,cnt;\n}b[maxn*8];\nlong long js(int num){\n\treturn 1LL*(num-1)*num/2;\n}\nvoid ad(int num,int val){\n\trg int now=num%mod;\n\tfor(rg int i=h[now];i!=-1;i=b[i].nxt){\n\t\tif(num==b[i].val){\n\t\t\tans-=js(b[i].cnt);\n\t\t\tb[i].cnt+=val;\n\t\t\tans+=js(b[i].cnt);\n\t\t\treturn;\n\t\t}\n\t}\n\tb[tot].nxt=h[now];\n\tb[tot].val=num;\n\tb[tot].cnt=1;\n\th[now]=tot++;\n}\nint main(){\n\tmemset(h,-1,sizeof(h));\n\tn=read(),m=read();\n\tfor(rg int i=1;i<=n;i++){\n\t\ta[i]=read();\n\t}\n\tad(0,1);\n\tfor(rg int i=1;i<=n;i++){\n\t\tsum[i]=sum[i-1]^a[i];\n\t\tad(sum[i],1);\n\t}\n\trg int aa,bb;\n\tfor(rg int i=1;i<=m;i++){\n\t\taa=read(),bb=read();\n\t\tad(sum[aa],-1);\n\t\tsum[aa]^=bb;\n\t\tad(sum[aa],1);\n\t\tans1^=ans;\n\t\tif(ans&1) ans2++;\n\t\tans3=max(ans,ans3);\n\t\tans4=min(ans,ans4);\n\t}\n\tprintf(\"%lld\\n%lld\\n%lld\\n%lld\\n\",ans1,ans2,ans3,ans4);\n\treturn 0;\n}", "step": ["Read the input size.", "Initialize the hash table and add 0 to the table.", "Read the array elements and update the hash table with XOR values.", "Read the update queries and update the hash table.", "Calculate the number of pairs with the same XOR, the number of odd XOR values, the maximum XOR value, and the minimum XOR value.", "Print the calculated values."], "nl_cn": "> 南有仙地，名曰摩梭，摩梭有湖，泸沽是也。\n\n茶茶在泸沽湖中寻找自己的梦。氤氲雾气中，茶茶的 $n$ 个梦排成了一个序列。茶茶的所有梦境都是拉瓦的样子。为了区分这些拉瓦，茶茶规定从左到右第 $i$ 个的拉瓦的美颜值是一个非负整数 $a_i$。面对着这些梦，茶茶会进行 $m$ 次操作，每次操作会给定两个数字 $p,x$，然后将 $a_p$ 和 $a_{p+1}$ 都对 $x$ 做按位异或。每次操作完之后，茶茶都想知道，当前的梦序列中，有多少个子区间 $[l,r]$，满足 $l \\le r$ 且区间的异或和为 $0$，请你回答茶茶的问题。\n\n区间 $[l,r]$ 的异或和定义为 $a_l \\otimes a_{l + 1} \\otimes \\dots a_{r - 1} \\otimes a_r$。其中 $\\otimes$ 代表二进制按位异或运算，即 C++ 语言的「^」运算符。两个区间不同当且仅当两区间左端点不同或两区间右端点不同或两区间左右端点均不同。\n\n为了避免输出过大，你只需要输出四个整数，分别表示你所有回答的按位异或之和、你共有多少次回答的答案是奇数，你的所有答案中的最大值、你的所有答案中的最小值。", "test_cases": [{"input": "5 3\n1 2 3 4 5\n1 3\n2 3\n3 3", "output": "3\n3\n3\n1"}, {"input": "2 1\n10 12\n1 2\n", "output": "0\n0\n0\n0"}, {"input": "1 1\n5\n1 1", "output": "0\n0\n0\n0"}, {"input": "1 1\n0\n1 1", "output": "0\n0\n0\n0"}, {"input": "3 1\n7 9 6\n2 5\n", "output": "0\n0\n0\n0"}, {"input": "2 2\n1 2\n2 1\n1 2\n", "output": "0\n0\n0\n0"}, {"input": "2 1\n10 20\n2 50\n", "output": "0\n0\n0\n0"}, {"input": "1 1\n100\n1 100\n", "output": "1\n1\n1\n1"}], "test": "#undef NDEBUG\n#include<assert.h>\nint main(){\n    assert(solution(\"5 3\\n1 2 3 4 5\\n1 3\\n2 3\\n3 3\") == \"3\\n3\\n3\\n1\");\n    assert(solution(\"2 1\\n10 12\\n1 2\\n\") == \"0\\n0\\n0\\n0\");\n    assert(solution(\"1 1\\n5\\n1 1\") == \"0\\n0\\n0\\n0\");\n    assert(solution(\"1 1\\n0\\n1 1\") == \"0\\n0\\n0\\n0\");\n    assert(solution(\"3 1\\n7 9 6\\n2 5\\n\") == \"0\\n0\\n0\\n0\");\n    assert(solution(\"2 2\\n1 2\\n2 1\\n1 2\\n\") == \"0\\n0\\n0\\n0\");\n    assert(solution(\"2 1\\n10 20\\n2 50\\n\") == \"0\\n0\\n0\\n0\");\n    assert(solution(\"1 1\\n100\\n1 100\\n\") == \"1\\n1\\n1\\n1\");\n    return 0; \n}", "prompt": "/*In the south, there is a mythical land called Mosuo, which has a lake named Lugu. Tea lives in Lugu Lake and is looking for her dreams. In the misty fog, Tea's n dreams form a sequence, and all of her dreams are like Lava. In order to distinguish these Lavas, Tea defines that the beauty value of the i-th Lava from the left to the right is a non-negative integer ai. Faced with these dreams, Tea will perform m operations. Each operation will be given two numbers p and x, and then both ap and ap+1 will be XORed with x. After each operation, Tea wants to know how many subintervals [l, r] in the current dream sequence satisfy l≤r and the XOR sum of the interval is 0. The XOR sum of interval [l, r] is defined as a_l ⊕ a_{l+1} ⊕ … ⊕ a_{r-1} ⊕ a_r, where ⊕ represents the bitwise XOR operation, i.e., the \"^\" operator in the C++ language. Two intervals are different if and only if the left endpoints of the two intervals are different or the right endpoints of the two intervals are different or both endpoints of the two intervals are different. To avoid the output being too large, you only need to output four integers, representing the bitwise XOR sum of all your answers, how many of your answers are odd, the maximum value among all your answers, and the minimum value among all your answers.\n\ninput_format:\nThe first row has two integers representing the number of dreams $n$and the number of operations $m$.\nThe second line has $n$integers separated by Spaces, and the $i$integer represents the $i$Lava's beauty level $a_i$.\nNext comes the $m$line, with two integers per line representing the $p$and $x$of an operation in turn.\n\noutput_format:\nOutput four lines, one integer per line, indicating in turn the sum of all your answers, how many times you answered the answer was odd, the maximum value of all your answers, and the minimum value of all your answers.\n*/\n\n#include<sstream>\n#include<stdlib.h>\n#include<algorithm>\n#include<math.h>\n#include<stdio.h>\n#include<vector>\n#include<string>\n#include<climits>\n#include<cstring>\n#include<iostream>\nusing namespace std;\n\n             \nstring solution(string std_in){\n    istringstream iss(std_in);\n             ", "constraints": "### 样例 1 解释\n\n- 第一次操作后，序列变为 ${2,1,3,4,5}$，有且仅有区间 $[1,3]$ 的异或和为 $0$，故本次询问的答案为 $1$。\n- 第二次操作后，序列变为 ${2,2,0,4,5}$，区间 $[1,2]$、$[1,3]$、$[3,3]$ 的异或和为 $0$，故本次询问的答案为 $3$。\n- 第三次操作后，序列变为 ${2,2,3,7,5}$，有且仅有区间 $[1,2]$ 的异或和为 $0$，故本次询问的答案为 $1$。所有答案的异或和为 $3$，有 $3$ 次回答的答案为奇数，所有答案中的最大值为 $3$，最小值为 $1$。\n\n### 数据规模与约定\n\n**本题采用多测试点捆绑测试**，共有 5 个子任务。\n\n- 子任务 $1$（$10$ 分）：保证 $n,m \\le 100$。\n- 子任务 $2$（$10$ 分）：保证 $n,m \\le 300$。\n- 子任务 $3$（$20$ 分）：保证 $n,m \\le 3000$。\n- 子任务 $4$（$30$ 分）：保证 $n,m \\le 10^5$。\n- 子任务 $5$（$30$ 分）：无特殊限制。\n\n对于前四个子任务，保证 $a_i,x \\le n$；  \n对于全部的测试点，保证 $1 \\le n,m \\le 10^6$，$0 \\le a_i,x \\le 10^9$，$1 \\le p<n$。\n\n### 提示\n\n- 请注意，$a_i,x \\leq Y$ 不能说明 $a_i \\otimes x \\leq Y$。\n-  请注意大量数据读入对程序效率造成的影响。\n- 本题的特殊输出方式只是为了避免输出过大造成程序超时，与本题解法无关。\n- 请注意常数因子对程序效率造成的影响。\n- 本题共有两个样例文件，请见附加文件中的 dream.zip。", "samples": [["5 3\n1 2 3 4 5\n1 3\n2 3\n3 3", "3\n3\n3\n1"]], "limits": {"time": [2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000], "memory": [256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000]}}
{"task_id": "P8744", "title": "[蓝桥杯 2021 省 A] 左孩子右兄弟", "difficulty": "challenge", "nl": "For a multiway tree, we can convert it into a binary tree by using the \"left child-right sibling\" representation.\n\nIf we consider that the children of each node are unordered, the binary tree obtained may not be unique. In other words, each node can choose any child as its left child and connect its right siblings in any order.\n\nGiven a multiway tree with $N$ nodes numbered from $1$ to $N$, where node $1$ is the root and the parent node of each node has a smaller number than itself. Please calculate the maximum height of the binary tree obtained by using the \"left child-right sibling\" representation. (The height of the tree with only one node, the root node, is $0$.)\n\nFor example, for the following multiway tree: \n\n\n\nThere may be the following $3$ (here only $3$ are listed, not all) different representations using \"left child-right sibling\":\n\n\n\nThe last one has the maximum height, which is $4$.", "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\nconst ll N = 1e5 + 10; \nll n, sz[N], head[N], dp[N], cnt, u;\nstruct Edge { ll nxt, to; } e[N << 1];\nvoid add(ll u, ll v) { e[++ cnt] = {head[u], v}; head[u] = cnt; } //链式前向星\nvoid dfs(ll u) {\n\tfor(ll i = head[u], v; i; i = e[i].nxt) {\n\t\tv = e[i].to;\n\t\tdfs(v);\n\t\tdp[u] = max(dp[u], dp[v]);\n\t}\n\tdp[u] += sz[u];\n} //树形 DP\nsigned main() {\n\tcin >> n;\n\tfor(ll i = 2; i <= n; ++ i) cin >> u, add(u, i), ++ sz[u];\n\tdfs(1);\n\tcout << dp[1];\n\treturn 0;\n}", "step": ["Declare variables and arrays required.", "Input the number of nodes in the tree and its structure.", "Perform depth first search recursively to calculate the size of all subtrees in the tree.", "Calculate the maximum number of nodes present in a subtree of the given tree.", "Output the maximum number of nodes present in a subtree of the given tree."], "nl_cn": "对于一棵多叉树，我们可以通过“左孩子右兄弟”表示法，将其转化成一棵二叉树。\n\n如果我们认为每个结点的子结点是无序的，那么得到的二叉树可能不唯一。换句话说，每个结点可以选任意子结点作为左孩子，并按任意顺序连接右兄弟。\n\n给定一棵包含 $N$ 个结点的多叉树，结点从 $1$ 至 $N$ 编号，其中 $1$ 号结点是根，每个结点的父结点的编号比自己的编号小。请你计算其通过\"左孩子右兄弟\"表示法转化成的二叉树，高度最高是多少。（只有根结点这一个结点的树高度为 $0$）\n\n例如如下的多叉树：\n\n\n\n可能有以下 $3$ 种 (这里只列出 $3$ 种, 并不是全部) 不同的 “左孩子右兄弟” 表示: \n\n\n\n其中最后一种高度最高, 为 $4$。", "test_cases": [{"input": "5\n1\n1\n1\n2", "output": "4"}, {"input": "1\n", "output": "0"}, {"input": "10\n1\n1\n1\n1\n1\n1\n1\n1\n1\n", "output": "9"}, {"input": "3\n1\n2\n", "output": "2"}, {"input": "4\n1\n1\n1\n", "output": "3"}, {"input": "8\n1\n2\n2\n3\n4\n5\n5", "output": "6"}, {"input": "4\n1\n1\n2", "output": "3"}, {"input": "3\n1\n1", "output": "2"}, {"input": "5\n1\n2\n3\n4", "output": "4"}, {"input": "4\n1\n2\n3", "output": "3"}, {"input": "6\n1\n2\n1\n3\n4", "output": "4"}, {"input": "6\n1\n1\n1\n1\n1", "output": "5"}, {"input": "7\n1\n1\n1\n1\n1\n1", "output": "6"}, {"input": "8\n1\n1\n1\n1\n1\n1\n1", "output": "7"}, {"input": "9\n1\n1\n1\n1\n1\n1\n1\n1", "output": "8"}], "test": "#undef NDEBUG\n#include<assert.h>\nint main(){\n    assert(solution(\"5\\n1\\n1\\n1\\n2\") == \"4\");\n    assert(solution(\"1\\n\") == \"0\");\n    assert(solution(\"10\\n1\\n1\\n1\\n1\\n1\\n1\\n1\\n1\\n1\\n\") == \"9\");\n    assert(solution(\"3\\n1\\n2\\n\") == \"2\");\n    assert(solution(\"4\\n1\\n1\\n1\\n\") == \"3\");\n    assert(solution(\"8\\n1\\n2\\n2\\n3\\n4\\n5\\n5\") == \"6\");\n    assert(solution(\"4\\n1\\n1\\n2\") == \"3\");\n    assert(solution(\"3\\n1\\n1\") == \"2\");\n    assert(solution(\"5\\n1\\n2\\n3\\n4\") == \"4\");\n    assert(solution(\"4\\n1\\n2\\n3\") == \"3\");\n    assert(solution(\"6\\n1\\n2\\n1\\n3\\n4\") == \"4\");\n    assert(solution(\"6\\n1\\n1\\n1\\n1\\n1\") == \"5\");\n    assert(solution(\"7\\n1\\n1\\n1\\n1\\n1\\n1\") == \"6\");\n    assert(solution(\"8\\n1\\n1\\n1\\n1\\n1\\n1\\n1\") == \"7\");\n    assert(solution(\"9\\n1\\n1\\n1\\n1\\n1\\n1\\n1\\n1\") == \"8\");\n    return 0; \n}", "prompt": "/*For a multiway tree, we can convert it into a binary tree by using the \"left child-right sibling\" representation.\n\nIf we consider that the children of each node are unordered, the binary tree obtained may not be unique. In other words, each node can choose any child as its left child and connect its right siblings in any order.\n\nGiven a multiway tree with $N$ nodes numbered from $1$ to $N$, where node $1$ is the root and the parent node of each node has a smaller number than itself. Please calculate the maximum height of the binary tree obtained by using the \"left child-right sibling\" representation. (The height of the tree with only one node, the root node, is $0$.)\n\nFor example, for the following multiway tree: \n\n\n\nThere may be the following $3$ (here only $3$ are listed, not all) different representations using \"left child-right sibling\":\n\n\n\nThe last one has the maximum height, which is $4$.\n\ninput_format:\nThe first line of input contains an integer $N$.\n\nThe following $N-1$lines, each containing an integer, represent the parent number of nodes $2$to $N$in turn.\n\noutput_format:\nOutput an integer representing the answer.\n*/\n\n#include<sstream>\n#include<stdlib.h>\n#include<algorithm>\n#include<math.h>\n#include<stdio.h>\n#include<vector>\n#include<string>\n#include<climits>\n#include<cstring>\n#include<iostream>\nusing namespace std;\n\n             \nstring solution(string std_in){\n    istringstream iss(std_in);\n             ", "constraints": "对于 $30 \\%$ 的评测用例，$1 \\leq N \\leq 20$;\n\n对于所有评测用例，$1 \\leq N \\leq 10^5$ 。 \n\n蓝桥杯 2021 第一轮省赛 A 组 H 题。", "samples": [["5\n1\n1\n1\n2", "4"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072]}}
{"task_id": "P2814", "title": "家谱", "difficulty": "challenge", "nl": "Given sufficient parent-child relationships, write a program to find the earliest ancestor of a person.", "code": "#include<cstdio>\n#include<iostream>\n#include<map>\nusing namespace std;\nmap<string,string>p;\nstring find(string x)\n{\n    if(x!=p[x]) \n        p[x]=find(p[x]);\n    return  p[x];\n}\nstring s,s1;\nint main()\n{\n    char ch;\n    cin>>ch;\n    while(ch!='$')\n    {\n        cin>>s;\n        if(ch=='#')\n        {\n            s1=s;\n            if(p[s]==\"\") p[s]=s;\n        }\n        else if(ch=='+')\n            p[s]=s1;\n        else \n            cout<<s<<' '<<find(s)<<endl;    \n        cin>>ch;\n    }\n    return 0;\n}", "step": ["Initialize map to store parent of each element.", "Implement find operation to find the parent of an element using recursion.", "Read input character from user.", "Read input string from user depending on input character.", "If input character is +, set parent of s to s1.", "If input character is ?, print s and its parent by calling find function."], "nl_cn": "给出充足的父子关系，请你编写程序找到某个人的最早的祖先。\n", "test_cases": [{"input": "#George\n+Rodney\n#Arthur\n+Gareth\n+Walter\n#Gareth\n+Edward\n?Edward\n?Walter\n?Rodney\n?Arthur\n$", "output": "Edward Arthur\nWalter Arthur\nRodney George\nArthur Arthur"}, {"input": "#William\n+William\n#David\n+David\n+Joseph\n#Joseph\n+Joseph\n+Aiden\n?Aiden\n?Joseph\n?David\n?William\n$", "output": "Aiden Joseph\nJoseph Joseph\nDavid David\nWilliam William"}], "test": "#undef NDEBUG\n#include<assert.h>\nint main(){\n    assert(solution(\"#George\\n+Rodney\\n#Arthur\\n+Gareth\\n+Walter\\n#Gareth\\n+Edward\\n?Edward\\n?Walter\\n?Rodney\\n?Arthur\\n$\") == \"Edward Arthur\\nWalter Arthur\\nRodney George\\nArthur Arthur\");\n    assert(solution(\"#William\\n+William\\n#David\\n+David\\n+Joseph\\n#Joseph\\n+Joseph\\n+Aiden\\n?Aiden\\n?Joseph\\n?David\\n?William\\n$\") == \"Aiden Joseph\\nJoseph Joseph\\nDavid David\\nWilliam William\");\n    return 0; \n}", "prompt": "/*Given sufficient parent-child relationships, write a program to find the earliest ancestor of a person.\n\ninput_format:\nThe input consists of multiple lines. First, there is a series of descriptions about parent-child relationships. Each group of parent-child relationships has one line for the father and several lines for the sons. The father's name in a group of parent-child relationships is described in the format `#name`, and the sons' names are described in the format `+name`. Next, the earliest ancestor of a person is expressed using the format `?name`. Finally, a single `$` is used to signify the end of the file.\n\noutput_format:\nAccording to the order of the input file, find the ancestor of each person who wants to find the ancestor, the format is: my name $+$a space $+$The ancestor's name $+$enter.\n*/\n\n#include<sstream>\n#include<stdlib.h>\n#include<algorithm>\n#include<math.h>\n#include<stdio.h>\n#include<vector>\n#include<string>\n#include<climits>\n#include<cstring>\n#include<iostream>\nusing namespace std;\n\n             \nstring solution(string std_in){\n    istringstream iss(std_in);\n             ", "constraints": "规定每个人的名字都有且只有 $6$ 个字符，而且首字母大写，且没有任意两个人的名字相同。最多可能有 $10^3$ 组父子关系，总人数最多可能达到 $5 \\times 10^4$ 人，家谱中的记载不超过 $30$ 代。", "samples": [["#George\n+Rodney\n#Arthur\n+Gareth\n+Walter\n#Gareth\n+Edward\n?Edward\n?Walter\n?Rodney\n?Arthur\n$", "Edward Arthur\nWalter Arthur\nRodney George\nArthur Arthur"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}}
{"task_id": "P7776", "title": "【模板】特征多项式", "difficulty": "advanced", "nl": "Given an $n\\times n$ matrix $A$, find its characteristic polynomial modulo $998244353$, where $n$ is also given.", "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\nconst int N=502,p=998244353;\nint a[N][N],f[N];\nint n,i,j,k,x,y,r,q;\ntemplate<typename typC> void read(register typC &x)\n{\n\tregister int c=getchar(),fh=1;\n\twhile ((c<48)||(c>57))\n\t{\n\t\tif (c=='-') {c=getchar();fh=-1;break;}\n\t\tc=getchar();\n\t}\n\tx=c^48;c=getchar();\n\twhile ((c>=48)&&(c<=57))\n\t{\n\t\tx=x*10+(c^48);\n\t\tc=getchar();\n\t}\n\tx*=fh;\n}\ninline void inc(register int &x,const int y)\n{\n\tif ((x+=y)>=p) x-=p;\n}\ninline void dec(register int &x,const int y)\n{\n\tif ((x-=y)<0) x+=p;\n}\ninline int ksm(register int x,register int y)\n{\n\tregister int r=1;\n\twhile (y)\n\t{\n\t\tif (y&1) r=(ll)r*x%p;\n\t\tx=(ll)x*x%p;y>>=1;\n\t}\n\treturn r;\n}\nvoid calmatrix(int a[N][N],register int n)\n{\n\tregister int i,j,k,r;\n\tfor (i=2;i<=n;i++)\n\t{\n\t\tfor (j=i;j<=n&&!a[j][i-1];j++);\n\t\tif (j>n) {continue;}\n\t\tif (j>i)\n\t\t{\n\t\t\tswap(a[i],a[j]);//exit(-1);\n\t\t\tfor (k=1;k<=n;k++) swap(a[k][j],a[k][i]);\n\t\t}\n\t\tr=a[i][i-1];\n\t\tfor (j=1;j<=n;j++) a[j][i]=(ll)a[j][i]*r%p;\n\t\tr=ksm(r,p-2);\n\t\tfor (j=i-1;j<=n;j++) a[i][j]=(ll)a[i][j]*r%p;\n\t\tfor (j=i+1;j<=n;j++)\n\t\t{\n\t\t\tr=a[j][i-1];\n\t\t\tfor (k=1;k<=n;k++) a[k][i]=(a[k][i]+(ll)a[k][j]*r)%p;\n\t\t\tr=p-r;\n\t\t\tfor (k=i-1;k<=n;k++) a[j][k]=(a[j][k]+(ll)a[i][k]*r)%p;\n\t\t}\n\t}\n}\nvoid calpoly(int a[N][N],register int n,int *f)\n{\n\tstatic int g[N][N];\n\tmemset(g,0,sizeof(g));\n\tg[0][0]=1;\n\tregister int i,j,k,r,rr;\n\tfor (i=1;i<=n;i++)\n\t{\n\t\tr=p-1;\n\t\tfor (j=i;j;j--)//第 j 行选第 n 列\n\t\t{\n\t\t\trr=(ll)r*a[j][i]%p;\n\t\t\tfor (k=0;k<j;k++) g[i][k]=(g[i][k]+(ll)rr*g[j-1][k])%p;\n\t\t\tr=(ll)r*a[j][j-1]%p;\n\t\t}\n\t\tfor (k=1;k<=i;k++) inc(g[i][k],g[i-1][k-1]);\n\t}\n\tmemcpy(f,g[n],n+1<<2);\n//\tif (n&1) for (i=0;i<=n;i++) if (f[i]) f[i]=p-f[i];//这题特殊（A-kE），否则注释掉\n}\nint main()\n{\n\tread(n);//read(q);\n\tfor (i=1;i<=n;i++) for (j=1;j<=n;j++) read(a[i][j]);\n\tcalmatrix(a,n);calpoly(a,n,f);\n\tfor (i=0;i<=n;i++) printf(\"%d%c\",f[i],\" \\n\"[i==n]);\n}", "step": ["Read the size of the matrix and its elements.", "Calculate the determinant of the matrix using Gaussian elimination.", "Calculate the polynomial of the determinant using the Leibniz formula.", "Print the coefficients of the polynomial."], "nl_cn": "给出 $n$ 和一个 $n\\times n$ 的矩阵 $A$，在模 $998244353$ 意义下求其特征多项式。", "test_cases": [], "test": "#undef NDEBUG\n#include<assert.h>\nint main(){\n    return 0; \n}", "prompt": "/*Given an $n\\times n$ matrix $A$, find its characteristic polynomial modulo $998244353$, where $n$ is also given.\n\ninput_format:\nThe first line is a positive integer $n$. \\\nThe next $n$row has $n$non-negative integers per row, representing the matrix $A$.\n\noutput_format:\nOutput a row of $n+1$positive integers representing the coefficients from low to high of its characteristic polynomial $p_A(x)$.\n*/\n\n#include<sstream>\n#include<stdlib.h>\n#include<algorithm>\n#include<math.h>\n#include<stdio.h>\n#include<vector>\n#include<string>\n#include<climits>\n#include<cstring>\n#include<iostream>\nusing namespace std;\n\n             \nstring solution(string std_in){\n    istringstream iss(std_in);\n             ", "constraints": "对于一个 $n\\times n$ 的矩阵 $A$，设其特征多项式为 $p_A(x)$，满足\n$$p_A(x)=\\det(xI_n-A)$$\n其中，$I_n$ 为一个 $n\\times n$ 的单位矩阵。\n\n对于 $10\\%$ 的数据，$1\\le n\\le 5$；\\\n对于 $40\\%$ 的数据，$1\\le n\\le 50$；\\\n对于另外 $10\\%$ 的数据，$\\forall1\\le i\\le n,1\\le j\\le i-1,A_{i,j}=0$，即 $A$ 为上三角矩阵；\\\n对于另外 $20\\%$ 的数据，$\\forall1\\le i\\le n,1\\le j\\le i-2,A_{i,j}=0$，即 $A$ 为上海森堡矩阵；\\\n对于 $100\\%$ 的数据，$1\\le n\\le 500$，$A_{i,j}\\in[0,998244352]$。", "samples": [["3\n1 2 3\n4 5 6\n7 8 9", "0 998244335 998244338 1 "]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072]}}
{"task_id": "P3313", "title": "[SDOI2014]旅行", "difficulty": "advanced", "nl": "There are $N$ cities in country S, numbered from $1$ to $N$. The cities are connected by $N-1$ bidirectional roads, such that one can travel from any city to any other one. Each city has its own religion, such as Flying Spaghetti Monsterism, Invisible Pink Unicornism, and Jediism.\n\nTo facilitate matters, we use different positive integers to represent different religions. The residents of country S often travel, always taking the shortest path and spending the night only at cities with the same religion as theirs to avoid trouble. Of course, the destination of the travel also has to be a city with the same religion as theirs. Each city in country S is assigned a different travel rating, and travelers often record the sum or maximum of the travel ratings of cities they have spent the night at, including the starting and ending cities.\n\nThe following events often occur in the history of country S:\n\n- `CC x c`: All residents of city $x$ convert to religion $c$.\n- `CW x w`: The rating of city $x$ is adjusted to $w$.\n- `QS x y`: A traveler departs from city $x$, arrives at city $y$, and records the sum of the travel ratings of cities they have spent the night at.\n- `QM x y`: A traveler departs from city $x$, arrives at city $y$, and records the maximum of the travel ratings of cities they have spent the night at.\n\nDue to the passage of time, the numbers recorded by travelers have been lost. However, the information regarding the religions and ratings of each city before the records started and the events themselves are intact. Please restore the numbers recorded by the travelers. For convenience, we assume there is enough time between events that the religion and rating of each city remains unchanged during any travel.", "code": "#include<iostream>\n#include<algorithm>\n#include<cstdio>\n#define MAXN 100010\nusing namespace std;\nint n,m,d=1,e=1,g=1;\nint c[MAXN],w[MAXN],root[MAXN];\nint head[MAXN],id[MAXN],top[MAXN],deep[MAXN],fa[MAXN],son[MAXN],num[MAXN];\nstruct node1{//结构体前向星\n    int next,to;\n}a[MAXN<<1];\nstruct node2{//动态线段树\n    int l,r,data1,data2;\n}b[MAXN*20];\ninline int read(){//弱弱的读优\n    int date=0,w=1;char c=0;\n    while(c<'0'||c>'9'){if(c=='-')w=-1;c=getchar();}\n    while(c>='0'&&c<='9'){date=date*10+c-'0';c=getchar();}\n    return date*w;\n}\ninline int max(const int &x,const int &y){//手写 max ,感觉有点手残。。。\n    if(x>y)return x;\n    return y;\n}\nvoid pushup(int rt){//上传\n    b[rt].data1=b[b[rt].l].data1+b[b[rt].r].data1;\n    b[rt].data2=max(b[b[rt].l].data2,b[b[rt].r].data2);\n}\nvoid pushdown(int rt){//清空\n    b[rt].data1=b[rt].data2=b[rt].l=b[rt].r=0;\n}\nvoid insert(int k,int v,int l,int r,int &rt){//插入\n    int mid;\n    if(!rt)rt=e++;//如上 第3点\n    if(l==v&&v==r){\n        b[rt].data1=b[rt].data2=k;\n        return;\n    }\n    mid=l+r>>1;\n    if(v<=mid)insert(k,v,l,mid,b[rt].l);\n    else insert(k,v,mid+1,r,b[rt].r);\n    pushup(rt);\n}\nvoid remove(int k,int l,int r,int &rt){//删除\n    int mid;\n    if(l==r){\n        pushdown(rt);\n        rt=0;\n        return;\n    }\n    mid=l+r>>1;\n    if(k<=mid)remove(k,l,mid,b[rt].l);\n    else remove(k,mid+1,r,b[rt].r);\n    pushup(rt);\n    if(!b[rt].l&&!b[rt].r){//注意这里，左子树 与 右子树 都空时，节点为空\n        pushdown(rt);\n        rt=0;\n    }\n}\nint query1(int s,int t,int l,int r,int rt){//区间求和\n    if(!rt)return 0;//节点为空，返回\n    int mid;\n    if(l==s&&r==t)\n    return b[rt].data1;\n    mid=l+r>>1;\n    if(t<=mid)return query1(s,t,l,mid,b[rt].l);\n    else if(s>mid)return query1(s,t,mid+1,r,b[rt].r);\n    else return query1(s,mid,l,mid,b[rt].l)+query1(mid+1,t,mid+1,r,b[rt].r);\n}\nint query2(int s,int t,int l,int r,int rt){//区间求最值\n    if(!rt)return 0;\n    int mid;\n    if(l==s&&r==t)\n    return b[rt].data2;\n    mid=l+r>>1;\n    if(t<=mid)return query2(s,t,l,mid,b[rt].l);\n    else if(s>mid)return query2(s,t,mid+1,r,b[rt].r);\n    else return max(query2(s,mid,l,mid,b[rt].l),query2(mid+1,t,mid+1,r,b[rt].r));\n}\nvoid add(int x,int y){//加边\n    a[d].to=y;\n    a[d].next=head[x];\n    head[x]=d++;\n    a[d].to=x;\n    a[d].next=head[y];\n    head[y]=d++;\n}\nvoid buildtree(int rt){//建树+树剖准备1\n    int will;\n    num[rt]=1;\n    for(int i=head[rt];i;i=a[i].next){\n        will=a[i].to;\n        if(!deep[will]){\n            deep[will]=deep[rt]+1;\n            fa[will]=rt;\n            buildtree(will);\n            num[rt]+=num[will];\n            if(num[will]>num[son[rt]])son[rt]=will;\n        }\n    }\n}\nvoid dfs(int rt,int fa){//树剖准备2\n    if(son[rt]){\n        top[son[rt]]=top[rt];\n        id[son[rt]]=++g;\n        dfs(son[rt],rt);\n    }\n    int v;\n    for(int i=head[rt];i;i=a[i].next){\n        v=a[i].to;\n        if(v==fa||v==son[rt])continue;\n        top[v]=v;\n        id[v]=++g;\n        dfs(v,rt);\n    }\n}\nvoid change1(int x,int y){//修改宗教：原宗教中删除，新宗教中插入\n    remove(id[x],1,n,root[c[x]]);\n    c[x]=y;\n    insert(w[x],id[x],1,n,root[c[x]]);\n}\nvoid change2(int x,int y){//修改评价：直接插入\n    w[x]=y;\n    insert(w[x],id[x],1,n,root[c[x]]);\n}\nvoid work1(int x,int y){//求评价和\n    int cs=c[x],s=0;\n    while(top[x]!=top[y]){//树剖搞起\n        if(deep[top[x]]<deep[top[y]])swap(x,y);\n        s+=query1(id[top[x]],id[x],1,n,root[cs]);\n        x=fa[top[x]];\n    }\n    if(deep[x]>deep[y])swap(x,y);\n    s+=query1(id[x],id[y],1,n,root[cs]);//不要忘了这里。。。\n    printf(\"%d\\n\",s);\n}\nvoid work2(int x,int y){//求评价最值\n    int cs=c[x],s=0;\n    while(top[x]!=top[y]){//同上\n        if(deep[top[x]]<deep[top[y]])swap(x,y);\n        s=max(s,query2(id[top[x]],id[x],1,n,root[cs]));\n        x=fa[top[x]];\n    }\n    if(deep[x]>deep[y])swap(x,y);\n    s=max(s,query2(id[x],id[y],1,n,root[cs]));\n    printf(\"%d\\n\",s);\n}\nint main(){\n    int x,y;\n    char ch[3];\n    n=read();m=read();\n    for(int i=1;i<=n;i++){w[i]=read();c[i]=read();}\n    for(int i=1;i<n;i++){\n        x=read();y=read();\n        add(x,y);\n    }\n    deep[1]=id[1]=top[1]=1;//初值\n    buildtree(1);\n    dfs(1,0);\n    for(int i=1;i<=n;i++)insert(w[i],id[i],1,n,root[c[i]]);//建初始线段树\n    while(m--){//主过程\n        scanf(\"%s\",ch);x=read();y=read();\n        if(ch[0]=='C'){\n            if(ch[1]=='C')change1(x,y);\n            if(ch[1]=='W')change2(x,y);\n        }\n        if(ch[0]=='Q'){\n            if(ch[1]=='S')work1(x,y);\n            if(ch[1]=='M')work2(x,y);\n        }\n    }\n    return 0;\n}", "step": ["Read the integer values.", "Add edges to form a tree for the input values.", "Build the tree using recursion.", "Assign tree leaf nodes with ID and their own top node value.", "Work on each query by changing values and extracting information from the tree using segment trees.", "Execute all queries."], "nl_cn": "S 国有 $N$ 个城市，编号从 $1$ 到 $N$。城市间用 $N-1$ 条双向道路连接，满足从一个城市出发可以到达其它所有城市。每个城市信仰不同的宗教，如飞天面条神教、隐形独角兽教、绝地教都是常见的信仰。\n\n为了方便，我们用不同的正整数代表各种宗教，S 国的居民常常旅行。旅行时他们总会走最短路，并且为了避免麻烦，只在信仰和他们相同的城市留宿。当然旅程的终点也是信仰与他相同的城市。S 国为每个城市标定了不同的旅行评级，旅行者们常会记下途中（包括起点和终点）留宿过的城市的评级总和或最大值。\n\n在 S 国的历史上常会发生以下几种事件：\n\n`CC x c`：城市 $x$ 的居民全体改信了 $c$ 教；\n\n`CW x w`：城市 $x$ 的评级调整为 $w$；\n\n`QS x y`：一位旅行者从城市 $x$ 出发，到城市 $y$，并记下了途中留宿过的城市的评级总和；\n\n`QM x y`：一位旅行者从城市 $x$ 出发，到城市 $y$，并记下了途中留宿过的城市的评级最大值。\n\n由于年代久远，旅行者记下的数字已经遗失了，但记录开始之前每座城市的信仰与评级，还有事件记录本身是完好的。请根据这些信息，还原旅行者记下的数字。 为了方便，我们认为事件之间的间隔足够长，以致在任意一次旅行中，所有城市的评级和信仰保持不变。", "test_cases": [{"input": "5 6\n3 1\n2 3\n1 2\n3 3\n5 1\n1 2\n1 3\n3 4\n3 5\nQS 1 5\nCC 3 1\nQS 1 5\nCW 3 3\nQS 1 5\nQM 2 4", "output": "8\n9\n11\n3"}], "test": "#undef NDEBUG\n#include<assert.h>\nint main(){\n    assert(solution(\"5 6\\n3 1\\n2 3\\n1 2\\n3 3\\n5 1\\n1 2\\n1 3\\n3 4\\n3 5\\nQS 1 5\\nCC 3 1\\nQS 1 5\\nCW 3 3\\nQS 1 5\\nQM 2 4\") == \"8\\n9\\n11\\n3\");\n    return 0; \n}", "prompt": "/*There are $N$ cities in country S, numbered from $1$ to $N$. The cities are connected by $N-1$ bidirectional roads, such that one can travel from any city to any other one. Each city has its own religion, such as Flying Spaghetti Monsterism, Invisible Pink Unicornism, and Jediism.\n\nTo facilitate matters, we use different positive integers to represent different religions. The residents of country S often travel, always taking the shortest path and spending the night only at cities with the same religion as theirs to avoid trouble. Of course, the destination of the travel also has to be a city with the same religion as theirs. Each city in country S is assigned a different travel rating, and travelers often record the sum or maximum of the travel ratings of cities they have spent the night at, including the starting and ending cities.\n\nThe following events often occur in the history of country S:\n\n- `CC x c`: All residents of city $x$ convert to religion $c$.\n- `CW x w`: The rating of city $x$ is adjusted to $w$.\n- `QS x y`: A traveler departs from city $x$, arrives at city $y$, and records the sum of the travel ratings of cities they have spent the night at.\n- `QM x y`: A traveler departs from city $x$, arrives at city $y$, and records the maximum of the travel ratings of cities they have spent the night at.\n\nDue to the passage of time, the numbers recorded by travelers have been lost. However, the information regarding the religions and ratings of each city before the records started and the events themselves are intact. Please restore the numbers recorded by the travelers. For convenience, we assume there is enough time between events that the religion and rating of each city remains unchanged during any travel.\n\ninput_format:\nThe first line of input contains the integer $N, with Q$representing the number of cities and the number of events.\n\nThe next $N$line, the first $i+1$two integers $W_i,C_i$in turn represents the rating and belief of the city $i$before the start of the record.\n\nNext $N-1$rows each have two integers $x, with y$representing a two-way road.\n\nNext comes the $Q$line, one action per line, in the format described above.\n\noutput_format:\nFor each 'QS' and 'QM' event, output a line representing the number recorded by the traveler.\n*/\n\n#include<sstream>\n#include<stdlib.h>\n#include<algorithm>\n#include<math.h>\n#include<stdio.h>\n#include<vector>\n#include<string>\n#include<climits>\n#include<cstring>\n#include<iostream>\nusing namespace std;\n\n             \nstring solution(string std_in){\n    istringstream iss(std_in);\n             ", "constraints": "对于 $100\\%$ 的数据，$N,Q \\leq10^5,C \\leq10^5$\n\n数据保证对所有 `QS` 和 `QM` 事件，起点和终点城市的信仰相同；在任意时刻，城市的评级总是不大于 $10^4$ 的正整数，且宗教值不大于 $C$。", "samples": [["5 6\n3 1\n2 3\n1 2\n3 3\n5 1\n1 2\n1 3\n3 4\n3 5\nQS 1 5\nCC 3 1\nQS 1 5\nCW 3 3\nQS 1 5\nQM 2 4", "8\n9\n11\n3"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288]}}
{"task_id": "P1765", "title": "手机", "difficulty": "basic", "nl": "Typical mobile phone keyboards look like this:\n\n\n\nTo input English letters, you have to press a number key multiple times. For example, to input `x`, you need to press 9 twice. The first press will input `w`, and the second press will change `w` to `x`. Pressing the 0 key once will input a space.\n\nYour task is to read a series of sentences containing only lowercase English letters and spaces, and calculate the minimum number of keystrokes required to input each sentence on the mobile phone keyboard.", "code": "#include<iostream>\n#include<cstdio>\n#include<algorithm>\n#include<cstring>\n#include<string>\n#include<cmath>\nusing namespace std;\nint ans;\nstring a;\nint num[26]={1,2,3,1,2,3,1,2,3,1,2,3,1,2,3,1,2,3,4,1,2,3,1,2,3,4};        //26个字母打表需要按几次 \nint main()\n{\n    getline(cin,a);\n    for(int i=0;i<a.length();i++)\n    {\n        if(a[i]>='a'&&a[i]<='z') ans+=num[a[i]-'a'];        //不能写a[i]!=' ',因为还有'\\n'和'\\r' \n        if(a[i]==' ') ans++;    //不能写else因为也有'\\n'和'\\r'，这就是这个题的坑点，我交了好几次，欲哭无泪 \n    }\n    printf(\"%d\",ans);\n    return 0;\n}", "step": ["Read a string from standard input", "Loop through each character in the string", "If the character is a lowercase letter, calculate the number of button presses required for that character using a pre-defined mapping", "If the character is a space, increment a counter to account for the space key", "Output the total number of button presses required"], "nl_cn": "一般的手机的键盘是这样的：\n\n\n\n要按出英文字母就必须要按数字键多下。例如要按出 `x` 就得按 9 两下，第一下会出 `w`，而第二下会把 `w` 变成 `x`。0 键按一下会出一个空格。\n\n你的任务是读取若干句只包含英文小写字母和空格的句子，求出要在手机上打出这个句子至少需要按多少下键盘。\n", "test_cases": [{"input": "i have a dream", "output": "23"}, {"input": "programming languages", "output": "38"}], "test": "#undef NDEBUG\n#include<assert.h>\nint main(){\n    assert(solution(\"i have a dream\") == \"23\");\n    assert(solution(\"programming languages\") == \"38\");\n    return 0; \n}", "prompt": "/*Typical mobile phone keyboards look like this:\n\n\n\nTo input English letters, you have to press a number key multiple times. For example, to input `x`, you need to press 9 twice. The first press will input `w`, and the second press will change `w` to `x`. Pressing the 0 key once will input a space.\n\nYour task is to read a series of sentences containing only lowercase English letters and spaces, and calculate the minimum number of keystrokes required to input each sentence on the mobile phone keyboard.\n\ninput_format:\nA one-line sentence containing only lowercase letters and Spaces and no more than 200 characters.\n\noutput_format:\nOne line, an integer, represents the total number of keyboard presses.\n*/\n\n#include<sstream>\n#include<stdlib.h>\n#include<algorithm>\n#include<math.h>\n#include<stdio.h>\n#include<vector>\n#include<string>\n#include<climits>\n#include<cstring>\n#include<iostream>\nusing namespace std;\n\n             \nstring solution(string std_in){\n    istringstream iss(std_in);\n             ", "constraints": "NOI 导刊 2010 普及（10）\n", "samples": [["i have a dream", "23"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288]}}
{"task_id": "P4341", "title": "[BJWC2010]外星联络", "difficulty": "advanced", "nl": "After being deeply moved by the movie \"Contact\", Xiao P decided to devote himself to the cause of searching for aliens. So every night, he climbed onto the roof with his radio to try to listen to messages from outer space.\n\nAlthough he only heard some noise, he rewrote the received signal consisting of high and low levels of the noise into a string composed of `0`s and `1`s, firmly believing that the information from aliens was hidden in it. He believed that the information sent by aliens would repeat in the 01 string he received. Therefore, he hoped to find all the substrings that appeared more than once with a count greater than $1$ in the 01 string he received.\n\nHowever, the signal string he received was too long, so he hoped that you could write a program to help him.", "code": "#include <cstdio>\n\nint ch[9000000][2]={0}; \nint cnt[9000000]={0};\nint tail=0;\nchar s[4000];\n\nint dfs(int root) {\n    if (cnt[root]>1) printf(\"%d\\n\",cnt[root]);\n    if (ch[root][0]) dfs(ch[root][0]);\n    if (ch[root][1]) dfs(ch[root][1]);\n    return 0;\n}\n\nint main() {\n    int n;\n    scanf(\"%d %s\", &n, &s);\n    for (int i=n;i>=1;--i) s[i]=s[i-1];\n    for (int i=1;i<=n;++i) {\n        int p=0;\n        for (int j=i;j<=n;++j) {\n            if (!ch[p][s[j]-'0']) ch[p][s[j]-'0']=++tail;\n            p=ch[p][s[j]-'0']; cnt[p]++;\n        }\n    }dfs(0);\n    return 0;\n}", "step": ["Read n and s from input.", "Construct trie and count the occurrences of each substring.", "Print the count of each substring that occurs more than once."], "nl_cn": "小 P 在看过电影《超时空接触》(Contact)之后被深深的打动，决心致力于寻找外星人的事业。于是，他每天晚上都爬在屋顶上试图用自己的收音机收听外星人发来的信息。\n\n虽然他收听到的仅仅是一些噪声，但是他还是按照这些噪声的高低电平将接收到的信号改写为由 `0` 和 `1` 构成的串， 并坚信外星人的信息就隐藏在其中。他认为，外星人发来的信息一定会在他接受到的 01 串中重复出现，所以他希望找到他接受到的 01 串中所有重复出现次数大于 $1$ 的子串。\n\n但是他收到的信号串实在是太长了，于是，他希望你能编一个程序来帮助他。", "test_cases": [{"input": "7\n1010101", "output": "3\n3\n2\n2\n4\n3\n3\n2\n2"}, {"input": "0\n", "output": ""}, {"input": "1\n1", "output": ""}], "test": "#undef NDEBUG\n#include<assert.h>\nint main(){\n    assert(solution(\"7\\n1010101\") == \"3\\n3\\n2\\n2\\n4\\n3\\n3\\n2\\n2\");\n    assert(solution(\"0\\n\") == \"\");\n    assert(solution(\"1\\n1\") == \"\");\n    return 0; \n}", "prompt": "/*After being deeply moved by the movie \"Contact\", Xiao P decided to devote himself to the cause of searching for aliens. So every night, he climbed onto the roof with his radio to try to listen to messages from outer space.\n\nAlthough he only heard some noise, he rewrote the received signal consisting of high and low levels of the noise into a string composed of `0`s and `1`s, firmly believing that the information from aliens was hidden in it. He believed that the information sent by aliens would repeat in the 01 string he received. Therefore, he hoped to find all the substrings that appeared more than once with a count greater than $1$ in the 01 string he received.\n\nHowever, the signal string he received was too long, so he hoped that you could write a program to help him.\n\ninput_format:\nThe first line of the input file is an integer $N$, which represents the length of the signal string received by small P.\nThe second line of the input file contains a string of 01 of length $N$, representing the string of signals received by small P.\n\noutput_format:\nEach line of the output file contains the number of occurrences of a substring greater than $1$. The output is in lexicographic order of the corresponding substring.\n*/\n\n#include<sstream>\n#include<stdlib.h>\n#include<algorithm>\n#include<math.h>\n#include<stdio.h>\n#include<vector>\n#include<string>\n#include<climits>\n#include<cstring>\n#include<iostream>\nusing namespace std;\n\n             \nstring solution(string std_in){\n    istringstream iss(std_in);\n             ", "constraints": "对于 100%的数据，满足 $0 \\le N \\le 3000$", "samples": [["7\n1010101", "3\n3\n2\n2\n4\n3\n3\n2\n2"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}}
{"task_id": "P8843", "title": "[传智杯 #4 初赛] 萝卜数据库", "difficulty": "challenge", "nl": "The chipmunk likes to steal carrots from the production team, so the Chipmunk University of Technology is researching a new type of database called the Carrot Database.\n\nSpecifically, it supports k (1 ≤ k ≤ 100) fields, each with an integer field name containing integer values.\n\nNow you support the following operations in the database:\n- Insert a record into the database, which may only contain a part of k fields. See the specific operation format in the \"Input Format\" section.\n- Query how many records in the database meet the conditions.\n\nYou have a total of n (1 ≤ n ≤ 1000) operations. Please output the result for each answer operation.", "code": "#include<bits/stdc++.h>\nusing namespace std;\n//定义区 \nint n,k;\nint m,x,y,op;\nint a[100005],b[100005],num;\n \nint main()\n{\n\tscanf(\"%d%d\",&n,&k);\n\tfor(int T=0;T<n;T++)\n\t{\n\t\tscanf(\"%d\",&op);//输入操作类型\n\t\tif(op==1)//插入操作 \n\t\t{\n\t\t\tscanf(\"%d\",&m);\n\t\t\tfor(int i=1;i<=m;i++)\n\t\t\t{\n\t\t\t\tscanf(\"%d%d\",&x,&y);//x为地址，y为数据\n\t\t\t\ta[++num]=x,b[num]=y;\n                //数组a储存第num个数据的地址\n                //数组b则储存第num个数据\n\t\t\t}\n\t\t}\n\t\telse//询问操作 \n\t\t{\n\t\t\tint ans=0,l,r;//l,r 即 ymin,ymax \n\t\t\tscanf(\"%d%d%d\",&m,&l,&r);\n\t\t\tfor(int i=1;i<=num;i++)//遍历 \n\t\t\t\tif(a[i]==m)//如果第i个数的地址是所询问的地址 \n\t\t\t\t\tif(l<=b[i]&&b[i]<=r)//并且第i个数满足限制条件 \n\t\t\t\t\t\tans++;//答案+1 \n\t\t\tprintf(\"%d\\n\",ans);//输出，千万不要忘记换行！ \n\t\t}\n\t}\n\treturn 0;//The end \n}\n//MXX 2022/11/29", "step": ["Read in n and k.", "While n is non-zero:", "Read in an integer m.", "If m equals one, read in a series of values to store in a vector of size 1005.", "Otherwise, read in an x value, the range values ymin and ymax, and determine the number of elements within the range of ymin and ymax in the vector indexed by x.", "Output the result."], "nl_cn": "花栗鼠很喜欢偷吃生产队的大萝卜，因此花栗鼠科技大学正在研究一种新型的数据库，叫做萝卜数据库。\n\n具体来说，它支持 $k(1 \\leq k \\leq 100)$ 个字段，每个字段名都是整数，里面存储的数值也都是整数。\n\n现在你支持如下操作： \n\n- 向数据库中插入一个记录，它可能只会包含 $k$ 个字段的某一部分。具体的操作格式详见“输入格式”。\n\n- 在数据库中查询有多少条符合条件的记录。\n\n现在你总共有 $n$ 次操作（$1 \\;\\leq n \\leq 1000$）,请你对每个回答操作，输出结果。", "test_cases": [{"input": "4 5\n1 2 1 2 2 4\n2 2 1 5\n1 2 3 5 4 6\n2 4 7 8", "output": "1\n0"}, {"input": "2 2\n1 1 1 1\n2 1 0 1\n", "output": "1"}, {"input": "2 2\n1 1 1 1\n2 1 1 2\n", "output": "1"}, {"input": "2 2\n1 1 1 1\n2 2 2 2\n", "output": "0"}], "test": "#undef NDEBUG\n#include<assert.h>\nint main(){\n    assert(solution(\"4 5\\n1 2 1 2 2 4\\n2 2 1 5\\n1 2 3 5 4 6\\n2 4 7 8\") == \"1\\n0\");\n    assert(solution(\"2 2\\n1 1 1 1\\n2 1 0 1\\n\") == \"1\");\n    assert(solution(\"2 2\\n1 1 1 1\\n2 1 1 2\\n\") == \"1\");\n    assert(solution(\"2 2\\n1 1 1 1\\n2 2 2 2\\n\") == \"0\");\n    return 0; \n}", "prompt": "/*The chipmunk likes to steal carrots from the production team, so the Chipmunk University of Technology is researching a new type of database called the Carrot Database.\n\nSpecifically, it supports k (1 ≤ k ≤ 100) fields, each with an integer field name containing integer values.\n\nNow you support the following operations in the database:\n- Insert a record into the database, which may only contain a part of k fields. See the specific operation format in the \"Input Format\" section.\n- Query how many records in the database meet the conditions.\n\nYou have a total of n (1 ≤ n ≤ 1000) operations. Please output the result for each answer operation.\n\ninput_format:\nThe first row of two integers $n,k$, meaning as described in the question.\n\nThe next few lines, each representing an operation, are as follows:\n\n- $1\\ p\\ x_1\\ \\ y_1,... x_p\\ y_p$: indicates an insert operation with $p$fields. The name of the $i$field is $x_i$and the value is $y_i$. Here we guarantee $1 \\leq x_i \\leq k, 1\\leq y_i \\leq 1000$, and $x_i,y_i$are integers.\n\n- $2\\ x\\ y_{min}\\ y_{max}$: indicates a query operation, which queries the number of records that meet the value of field $x$between $[y_{min},y_{max}]$.\n\noutput_format:\nFor each query operation, output a line with an integer indicating the number of records that meet the conditions.\n*/\n\n#include<sstream>\n#include<stdlib.h>\n#include<algorithm>\n#include<math.h>\n#include<stdio.h>\n#include<vector>\n#include<string>\n#include<climits>\n#include<cstring>\n#include<iostream>\nusing namespace std;\n\n             \nstring solution(string std_in){\n    istringstream iss(std_in);\n             ", "constraints": "", "samples": [["4 5\n1 2 1 2 2 4\n2 2 1 5\n1 2 3 5 4 6\n2 4 7 8", "1\n0"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000], "memory": [131072, 131072, 131072, 131072, 131072]}}
{"task_id": "P5753", "title": "[NOI2000] 瓷片项链", "difficulty": "basic", "nl": "The primitive tribe uses a rare clay to burn round porcelain tiles of the same diameter and string them into necklaces. When stringing, the tiles are connected in sequence along the diameter direction of the tile without gaps or overlaps, and a necklace is composed of at least one tile.\n\nThe figure below shows a necklace made by stringing four equally sized tiles, with a total length of four times the diameter of a single tile.\n\n\n\n\nThe thickness of each fired tile is constant, and the diameter $D$ is related to the volume $V$ of the clay used as follows:\n \n\nwhere $V_0$ is the loss of each firing, with the same units as $V$. When the material is less than or equal to $V_0$, it cannot be fired into tiles.\nExample: $V_{total}=10,V_0=1$. If a single tile is fired, $V=V_{total}=10$, $D=0.9$. If the clay is divided into two equal parts, the volume of each part is $V=\\frac{V_{total}}{2}=5$, and the diameter of a single tile is $D'=0.3\\times\\sqrt{5-1}=0.6$. The total length of the strung necklace is $1.2$.\n\nGiven the total volume of clay and the loss of firing a single tile, the number of fired tiles is different, and the total length of the resulting necklace is also different. Please calculate how many tiles need to be fired to get the longest necklace.", "code": "#include<iostream>\n#include<cstdio>\n#include<cmath>\n#include<algorithm>\n#include<cstring>\nusing namespace std;\ndouble v,c;\n\nint main()\n{\n\tcin>>v>>c;\n\t\n\tif(c>=v)\n\t{\n\t\tcout<<0;\n\t\treturn 0;\n\t}\n\tdouble num=v/c;\n\n\tif(int(num)==num&&int(num)%2!=0)//最优解不唯一\n\t{\n\t\tcout<<0;\n\t\treturn 0;\n\t}\n\tif(c==1)//因为所有整数都能被1整除，所以特判一下\n\t{\n\t\tcout<<v/(2*c);\n\t\treturn 0;\n\t}\n\tcout<<int(v/(2*c)+0.5);\n\treturn 0;\n}", "step": ["Take input of distance to be covered and maximum jump distance", "Check if the maximum jump distance is greater than or equal to the distance to be covered, output 0 if true", "Calculate the number of jumps required to cover the distance with given maximum jump distance", "If the number of jumps required is odd and integer, then output 0", "If the maximum jump distance is 1, output distance divided by 2", "Else output the integer value of distance divided by twice the maximum jump distance, rounded off to the closest integer"], "nl_cn": "原始部落用一种稀有的泥土烧制直径相同的圆瓷片并串成项链，串的时候沿瓷片的直径方向顺次连接，瓷片之间没有空隙也不重叠，一条项链至少由一个瓷片构成。\n\n下图示出四片同样大小的瓷片串接所成的项链，其总长为单个瓷片直径的四倍。\n\n\n\n\n每个烧制的瓷片厚度是一定的，直径 $D$ 和所用泥土的体积 $V$ 有以下关系：\n \n\n其中 $V_0$ 为烧制每一片的损耗，单位与 $V$ 相同。当用料小于等于 $V_0$ 时，不能烧制成瓷片。\n例： $V_总 = 10，V_0 = 1 $，若烧制成一片瓷片，$ V = V_总= 10，D = 0.9 $。如果把泥土均分成 $2$ 份，每份泥土的体积为 $V = \\frac{V_总}{2} = 5 $，单个瓷片的直径为 $ D' = 0.3 \\times \\sqrt{5-1} =0.6 $ ,串起来的总长为 $1.2$ 。\n\n给定了泥土的总体积和烧制单个瓷片的损耗，烧制的瓷片数不同，能够得到的项链总长度也不相同，请计算烧制多少个瓷片能使所得到的项链最长。\n", "test_cases": [{"input": "48\n7\n", "output": "3"}, {"input": "8\n5\n", "output": "1"}, {"input": "10\n1\n", "output": "5"}, {"input": "20\n3\n", "output": "3"}, {"input": "25\n4\n", "output": "3"}, {"input": "30\n5\n", "output": "3"}, {"input": "35\n6\n", "output": "3"}], "test": "#undef NDEBUG\n#include<assert.h>\nint main(){\n    assert(solution(\"48\\n7\\n\") == \"3\");\n    assert(solution(\"8\\n5\\n\") == \"1\");\n    assert(solution(\"10\\n1\\n\") == \"5\");\n    assert(solution(\"20\\n3\\n\") == \"3\");\n    assert(solution(\"25\\n4\\n\") == \"3\");\n    assert(solution(\"30\\n5\\n\") == \"3\");\n    assert(solution(\"35\\n6\\n\") == \"3\");\n    return 0; \n}", "prompt": "/*The primitive tribe uses a rare clay to burn round porcelain tiles of the same diameter and string them into necklaces. When stringing, the tiles are connected in sequence along the diameter direction of the tile without gaps or overlaps, and a necklace is composed of at least one tile.\n\nThe figure below shows a necklace made by stringing four equally sized tiles, with a total length of four times the diameter of a single tile.\n\n\n\n\nThe thickness of each fired tile is constant, and the diameter $D$ is related to the volume $V$ of the clay used as follows:\n \n\nwhere $V_0$ is the loss of each firing, with the same units as $V$. When the material is less than or equal to $V_0$, it cannot be fired into tiles.\nExample: $V_{total}=10,V_0=1$. If a single tile is fired, $V=V_{total}=10$, $D=0.9$. If the clay is divided into two equal parts, the volume of each part is $V=\\frac{V_{total}}{2}=5$, and the diameter of a single tile is $D'=0.3\\times\\sqrt{5-1}=0.6$. The total length of the strung necklace is $1.2$.\n\nGiven the total volume of clay and the loss of firing a single tile, the number of fired tiles is different, and the total length of the resulting necklace is also different. Please calculate how many tiles need to be fired to get the longest necklace.\n\ninput_format:\nThere are two lines, each containing only one integer.\n\nThe number of the first line is the total volume of soil $V_ total $($0 < V_ total < 60,000 $), and the second line is the loss of a single chip $V_0$($0 < V_0 < 600 $).\n\noutput_format:\nOne line, one integer.\n\nThis integer is the number of porcelain pieces fired to obtain the longest necklace. If it cannot be fired into porcelain chips or the optimal solution is not unique (there are two or more solutions to obtain the longest necklace), output '0'.\n*/\n\n#include<sstream>\n#include<stdlib.h>\n#include<algorithm>\n#include<math.h>\n#include<stdio.h>\n#include<vector>\n#include<string>\n#include<climits>\n#include<cstring>\n#include<iostream>\nusing namespace std;\n\n             \nstring solution(string std_in){\n    istringstream iss(std_in);\n             ", "constraints": "", "samples": [["48\n7\n", "3\n"], ["8\n5\n", "1\n"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}}
{"task_id": "P2712", "title": "摄像头", "difficulty": "challenge", "nl": "There are n cameras in a food store, which are clumsy and can only capture the fixed position. There is a group of daring and reckless squirrels who want to rob the store. In order not to let the cameras capture evidence of their crimes, the first thing they do before the robbery is to smash these cameras.\n\nIn order to facilitate the smashing of cameras, the squirrel gang numbered all the cameras and the areas monitored by the cameras. A camera can be smashed if its location is not monitored by other cameras.\n\nYour task is to help the squirrels calculate whether all the cameras can be smashed. If not, output the number of cameras that have not been smashed yet.", "code": "#include<bits/stdc++.h>\n#define INF 0x3f3f3f3f\nusing namespace std;\nint to[200002],ne[200002],head[10002],edge[10002],a[10002];\nint n,tot,ans;\nbool v[50002];\nqueue< int > q;\nvoid add(int x,int y){\n\tto[++tot]=y,ne[tot]=head[x],head[x]=tot,edge[y]++;//edge存入度数量 \n}\nvoid read(int &x) {//快读 \n    int f = 1; x = 0;\n    char ch = getchar();\n    while (ch < '0' || ch > '9')   {if (ch == '-') f = -1; ch = getchar();}\n    while (ch >= '0' && ch <= '9') {x = x * 10 + ch - '0'; ch = getchar();}\n    x *= f;\n}\nint main()\n{\n    read(n);\n    for(int i=1;i<=n;i++){\n    \tint m,y;\n    \tread(a[i]),read(m);\n    \tv[a[i]]=1;//记录a[i]处有摄像头 \n    \tfor(int j=1;j<=m;j++){\n    \t\tread(y);\n    \t\tadd(a[i],y);//建有向森林 \n\t\t}\n\t}\n\tfor(int i=1;i<=n;i++){\n\t\tif(!edge[a[i]]) q.push(a[i]);//过程2，加入入度为0节点 \n\t}\n\twhile(!q.empty()){\n\t\tans++;//计数器 \n\t\tint x=q.front();q.pop();//取出队首 \n\t\tfor(int i=head[x];i;i=ne[i]){\n\t\t\tint y=to[i];\n\t\t\tedge[y]--;//入度减一 \n\t\t\tif(!edge[y]&&v[y]) q.push(y);//如果这个地方有摄像头且入度为0 \n\t\t}\n\t}\n\tif(ans==n) printf(\"YES\\n\");\n\telse printf(\"%d\\n\",n-ans);\n\treturn 0;\n}", "step": ["Initialize arrays to store the graph and its topology", "Read input from the user and populate arrays with the input data", "Add all nodes with no incoming edges to a queue", "Perform BFS on the graph, removing each node with zero incoming edges from the queue, updating its neighbors' incoming edges, and adding them to  the queue if they now have no incoming edges", "Check if all nodes have been visited by the BFS. If yes, print 'YES'. Else, print the number of nodes not visited."], "nl_cn": "食品店里有 $n$ 个摄像头，这种摄像头很笨拙，只能拍摄到固定位置。现有一群胆大妄为的松鼠想要抢劫食品店，为了不让摄像头拍下他们犯罪的证据，他们抢劫前的第一件事就是砸毁这些摄像头。\n\n为了便于砸毁摄像头，松鼠歹徒们把所有摄像头和摄像头能监视到的地方统一编号，一个摄像头能被砸毁的条件是该摄像头所在位置不被其他摄像头监视。\n\n现在你的任务是帮松鼠们计算是否可以砸掉所有摄像头，如不能则输出还没砸掉的摄像头的数量。", "test_cases": [{"input": "5\n1 1 2\n2 1 1\n3 1 7\n4 1 1\n5 0\n", "output": "2"}, {"input": "5\n1 1 2\n2 1 1\n3 1 7\n4 1 1\n5 1 2\n", "output": "2"}, {"input": "5\n1 1 2\n2 0\n3 0\n4 1 5\n5 1 4\n", "output": "2"}, {"input": "6\n1 0\n2 1 3\n3 1 5\n4 1 6\n5 2 4 5\n6 1 4\n", "output": "3"}, {"input": "3\n1 1 2\n2 1 3\n3 1 1\n", "output": "3"}, {"input": "6\n1 1 2\n2 1 1\n3 1 4\n4 1 5\n5 1 6\n6 0\n", "output": "2"}, {"input": "3\n1 1 2\n2 1 1\n3 1 3\n", "output": "3"}, {"input": "4\n1 1 2\n2 1 1\n3 1 4\n4 1 2\n", "output": "2"}, {"input": "2\n1 1 2\n2 1 2\n", "output": "1"}, {"input": "3\n1 1 2\n2 1 3\n3 1 2\n", "output": "2"}, {"input": "6\n1 2 2 3\n2 0\n3 1 1\n4 1 2\n5 1 2\n6 1 3\n", "output": "3"}], "test": "#undef NDEBUG\n#include<assert.h>\nint main(){\n    assert(solution(\"5\\n1 1 2\\n2 1 1\\n3 1 7\\n4 1 1\\n5 0\\n\") == \"2\");\n    assert(solution(\"5\\n1 1 2\\n2 1 1\\n3 1 7\\n4 1 1\\n5 1 2\\n\") == \"2\");\n    assert(solution(\"5\\n1 1 2\\n2 0\\n3 0\\n4 1 5\\n5 1 4\\n\") == \"2\");\n    assert(solution(\"6\\n1 0\\n2 1 3\\n3 1 5\\n4 1 6\\n5 2 4 5\\n6 1 4\\n\") == \"3\");\n    assert(solution(\"3\\n1 1 2\\n2 1 3\\n3 1 1\\n\") == \"3\");\n    assert(solution(\"6\\n1 1 2\\n2 1 1\\n3 1 4\\n4 1 5\\n5 1 6\\n6 0\\n\") == \"2\");\n    assert(solution(\"3\\n1 1 2\\n2 1 1\\n3 1 3\\n\") == \"3\");\n    assert(solution(\"4\\n1 1 2\\n2 1 1\\n3 1 4\\n4 1 2\\n\") == \"2\");\n    assert(solution(\"2\\n1 1 2\\n2 1 2\\n\") == \"1\");\n    assert(solution(\"3\\n1 1 2\\n2 1 3\\n3 1 2\\n\") == \"2\");\n    assert(solution(\"6\\n1 2 2 3\\n2 0\\n3 1 1\\n4 1 2\\n5 1 2\\n6 1 3\\n\") == \"3\");\n    return 0; \n}", "prompt": "/*There are n cameras in a food store, which are clumsy and can only capture the fixed position. There is a group of daring and reckless squirrels who want to rob the store. In order not to let the cameras capture evidence of their crimes, the first thing they do before the robbery is to smash these cameras.\n\nIn order to facilitate the smashing of cameras, the squirrel gang numbered all the cameras and the areas monitored by the cameras. A camera can be smashed if its location is not monitored by other cameras.\n\nYour task is to help the squirrels calculate whether all the cameras can be smashed. If not, output the number of cameras that have not been smashed yet.\n\ninput_format:\nLine 1, an integer $n$, represents the number of cameras.\nLines 2 to $n+1$ are the information of the cameras, including the camera's position $x$ and the number $m$ of positions that the camera can monitor. Following that, $m$ numbers $y$ are the positions that this camera can monitor. (After smashing these cameras, these positions naturally cannot be monitored anymore).\n\noutput_format:\nIf all cameras can be destroyed, output \"$\\texttt{YES}$\", otherwise output the number of cameras that have not been destroyed. (Without quotes)\n*/\n\n#include<sstream>\n#include<stdlib.h>\n#include<algorithm>\n#include<math.h>\n#include<stdio.h>\n#include<vector>\n#include<string>\n#include<climits>\n#include<cstring>\n#include<iostream>\nusing namespace std;\n\n             \nstring solution(string std_in){\n    istringstream iss(std_in);\n             ", "constraints": "$1 \\leq n \\leq 100$。\n\n$0 \\leq m \\leq 100$。\n\n$0 \\leq x,y \\leq 500$。\n", "samples": [["5\n1 1 2\n2 1 1\n3 1 7\n4 1 1\n5 0\n", "2"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}}
{"task_id": "P1459", "title": "[USACO2.1]三值的排序 Sorting a Three-Valued Sequence", "difficulty": "challenge", "nl": "Sorting is a very common computational task. Now consider the sorting problem with at most three values. A practical example is when we sort the winners of a competition by gold, silver, and bronze medals. In this task, there are only three possible values, 1, 2, and 3. We use the method of swapping to sort them in ascending order.\n\nWrite a program to calculate the minimum number of swaps needed to sort a given number sequence consisting of only 1, 2, and 3 in ascending order.", "code": "#include<iostream>\n#include<algorithm> \nusing namespace std;\nint main(){\n\tint n,a[1001],b[1001],i,a1=0,a2=0,a3=0;\n\tcin>>n;\n\tfor(i=1;i<=n;i++){\n\t\tcin>>a[i];\n\t\tif(a[i]==1)a1++;\n\t\tif(a[i]==2)a2++;\n\t\tif(a[i]==3)a3++;\n\t}//第一步\n\tfor(i=1;i<=n;i++){\n\t\tif(a1>=i)b[i]=1-a[i];\n\t\tif(a1+a2>=i&&i>a1)b[i]=2-a[i];\n\t\tif(a1+a2+a3>=i&&i>a2+a1)b[i]=3-a[i];\n\t}//第二部\n\tint q1=0,q2=0,w1=0,w2=0;//q1存1，q2存2，w1存-1，w2存-2\n\tfor(i=1;i<=n;i++){\n\t\tif(b[i]==1)q1++;\n\t\tif(b[i]==-1)w1++;\n\t\tif(b[i]==2)q2++;\n\t\tif(b[i]==-2)w2++;\n\t}//第三部\n\tcout<<max(q1,w1)+min(q2,w2);//第四部\n}", "step": ["Initialize variables and take input of m", "Loop through each character of the two strings", "If the current character is a digit, add it to string a", "If the current character in string 1 is a '1', check the next character to see if it's a '3'.", "Increment the count of '2's if the previous character was a '1' and the next character was a '3'.", "Increment the count of '13's in string 2 if the current character is '3'.", "Count the number of '1's that aren't part of a '13'", "Output the difference between the count of '13's and '1's not part of a '13'."], "nl_cn": "排序是一种很频繁的计算任务。现在考虑最多只有三值的排序问题。一个实际的例子是，当我们给某项竞赛的优胜者按金银铜牌排序的时候。在这个任务中可能的值只有三种 $1,2,3$。我们用交换的方法把他排成升序的。\n\n写一个程序计算出，给定的一个 $1,2,3$ 组成的数字序列，排成升序所需的最少交换次数\n", "test_cases": [{"input": "9\n2\n2\n1\n3\n3\n3\n2\n3\n1", "output": "4"}, {"input": "4\n1\n2\n1\n3", "output": "1"}, {"input": "6\n1\n2\n3\n3\n2\n1", "output": "3"}, {"input": "7\n1\n1\n3\n2\n2\n3\n3", "output": "1"}, {"input": "8\n1\n3\n1\n3\n1\n2\n3\n3", "output": "2"}, {"input": "5\n1\n2\n2\n1\n3", "output": "1"}, {"input": "6\n1\n3\n1\n1\n3\n2", "output": "2"}, {"input": "2 1 3\n", "output": "0"}, {"input": "3 3 2 1 3 3 1\n", "output": "1"}, {"input": "3 2 3 1 3 1 2 3\n", "output": "2"}, {"input": "1\n1\n", "output": "0"}, {"input": "3\n2\n2\n2\n", "output": "0"}, {"input": "5\n1\n1\n1\n1\n1\n", "output": "0"}, {"input": "8\n3\n3\n3\n3\n3\n3\n3\n3\n", "output": "0"}, {"input": "4\n1\n3\n2\n2\n", "output": "1"}, {"input": "2\n3\n1\n", "output": "1"}, {"input": "5\n2\n1\n3\n3\n2\n", "output": "2"}, {"input": "6\n2\n3\n1\n2\n1\n3\n", "output": "2"}, {"input": "1\n2\n", "output": "0"}, {"input": "2\n3\n2\n", "output": "1"}, {"input": "3\n3\n3\n3\n", "output": "0"}, {"input": "4\n1\n1\n1\n1\n", "output": "0"}, {"input": "5\n2\n2\n2\n2\n2\n", "output": "0"}, {"input": "1 2 3 1 2 3 1 2 3 1\n", "output": "0"}, {"input": "1 3 2 1 3 2 1 3 2 1\n", "output": "0"}], "test": "#undef NDEBUG\n#include<assert.h>\nint main(){\n    assert(solution(\"9\\n2\\n2\\n1\\n3\\n3\\n3\\n2\\n3\\n1\") == \"4\");\n    assert(solution(\"4\\n1\\n2\\n1\\n3\") == \"1\");\n    assert(solution(\"6\\n1\\n2\\n3\\n3\\n2\\n1\") == \"3\");\n    assert(solution(\"7\\n1\\n1\\n3\\n2\\n2\\n3\\n3\") == \"1\");\n    assert(solution(\"8\\n1\\n3\\n1\\n3\\n1\\n2\\n3\\n3\") == \"2\");\n    assert(solution(\"5\\n1\\n2\\n2\\n1\\n3\") == \"1\");\n    assert(solution(\"6\\n1\\n3\\n1\\n1\\n3\\n2\") == \"2\");\n    assert(solution(\"2 1 3\\n\") == \"0\");\n    assert(solution(\"3 3 2 1 3 3 1\\n\") == \"1\");\n    assert(solution(\"3 2 3 1 3 1 2 3\\n\") == \"2\");\n    assert(solution(\"1\\n1\\n\") == \"0\");\n    assert(solution(\"3\\n2\\n2\\n2\\n\") == \"0\");\n    assert(solution(\"5\\n1\\n1\\n1\\n1\\n1\\n\") == \"0\");\n    assert(solution(\"8\\n3\\n3\\n3\\n3\\n3\\n3\\n3\\n3\\n\") == \"0\");\n    assert(solution(\"4\\n1\\n3\\n2\\n2\\n\") == \"1\");\n    assert(solution(\"2\\n3\\n1\\n\") == \"1\");\n    assert(solution(\"5\\n2\\n1\\n3\\n3\\n2\\n\") == \"2\");\n    assert(solution(\"6\\n2\\n3\\n1\\n2\\n1\\n3\\n\") == \"2\");\n    assert(solution(\"1\\n2\\n\") == \"0\");\n    assert(solution(\"2\\n3\\n2\\n\") == \"1\");\n    assert(solution(\"3\\n3\\n3\\n3\\n\") == \"0\");\n    assert(solution(\"4\\n1\\n1\\n1\\n1\\n\") == \"0\");\n    assert(solution(\"5\\n2\\n2\\n2\\n2\\n2\\n\") == \"0\");\n    assert(solution(\"1 2 3 1 2 3 1 2 3 1\\n\") == \"0\");\n    assert(solution(\"1 3 2 1 3 2 1 3 2 1\\n\") == \"0\");\n    return 0; \n}", "prompt": "/*Sorting is a very common computational task. Now consider the sorting problem with at most three values. A practical example is when we sort the winners of a competition by gold, silver, and bronze medals. In this task, there are only three possible values, 1, 2, and 3. We use the method of swapping to sort them in ascending order.\n\nWrite a program to calculate the minimum number of swaps needed to sort a given number sequence consisting of only 1, 2, and 3 in ascending order.\n\ninput_format:\nThe first line has a positive integer $n$, indicating the number of MEDALS.\nNext, $n$lines, each with an integer in $[1,3], represent MEDALS.\n\noutput_format:\nOutput a row of an integer that represents the minimum number of swaps required for ascending order.\n*/\n\n#include<sstream>\n#include<stdlib.h>\n#include<algorithm>\n#include<math.h>\n#include<stdio.h>\n#include<vector>\n#include<string>\n#include<climits>\n#include<cstring>\n#include<iostream>\nusing namespace std;\n\n             \nstring solution(string std_in){\n    istringstream iss(std_in);\n             ", "constraints": "【数据范围】  \n对于 $100\\%$ 的数据，$1\\le n \\le 1000$。\n\nUSACO 2.1\n\n翻译来自NOCOW\n", "samples": [["9\n2\n2\n1\n3\n3\n3\n2\n3\n1", "4\n"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}}
{"task_id": "P1789", "title": "【Mc生存】插火把", "difficulty": "basic", "nl": "One day, linyorson created an $n \\times n$ matrix in \"Minecraft\". Now he has $m$ torches and $k$ glowstones, placed at positions $(x_1, y_1) \\sim (x_m, y_m)$ and $(o_1, p_1) \\sim (o_k, p_k)$, respectively. If there is no light or object in a position, a monster will spawn there. How many positions in the matrix will spawn monsters?\n\nP.S. The illumination range of a torch is:\n\n```\n    |Dark|Dark|Light|Dark|Dark|\n    |Dark|Light|Light|Light|Dark|\n    |Light|Light|Torch|Light|Light|\n    |Dark|Light|Light|Light|Dark|\n    |Dark|Dark|Light|Dark|Dark|\n```\nThe illumination range of a glowstone is:\n\n```\n    |Light|Light|Light|Light|Light|\n    |Light|Light|Light|Light|Light|\n    |Light|Light|Glowstone|Light|Light|\n    |Light|Light|Light|Light|Light|\n    |Light|Light|Light|Light|Light|\n```", "code": "#include <bits/stdc++.h> \nusing namespace std;\nint n, m, k, a, b, ans;\nint s[5005][5005];\nbool pd(int x, int y) { //判断是否越界 \n    if(x < 1 || y < 1 || x > n || y > n) return 0;\n    return 1;\n}\nint main() {\n    scanf(\"%d%d%d\", &n, &m, &k); //读入 \n    for(int i = 1; i <= m + k; i++) { //由于计算火把和萤石的步骤很像，所以合并了 \n        scanf(\"%d%d\", &a, &b); //读入坐标 \n        for(int x = -2; x <= 2; x++)\n            for(int y = -2; y <= 2; y++) //枚举5*5的方阵(通过计算距离) \n                if((i > m || abs(x) + abs(y) <= 2) && pd(x + a, b + y))\n                //如果是萤石(i > m)或者x与y的坐标差的和不超过2(想一想为什么)并且\n                //没有越界就标记 \n                    s[x + a][b + y]++;\n    }\n    for(int i = 1; i <= n; i++)\n        for(int j = 1; j <= n; j++)\n            ans += s[i][j] == 0; //枚举每一个方格，看看是不是==0(即没有亮光) \n    printf(\"%d\\n\", ans); //输出结果 \n    return 0;\n}\n//希望我能帮到各位。。 \n//希望大慈大悲的管理员给过。。", "step": ["Initialize variables n, m, k, a, b, ans.", "Check if a point is within the bounds of the grid.", "For each given point, iterate over the cells within a Manhattan distance of 2, marking them as touched in a 2D array.", "Iterate over the entire grid and count the number of untouched cells.", "Print the count of untouched cells.", "End the program."], "nl_cn": "话说有一天 linyorson 在“我的世界”开了一个 $n \\times n$ 的方阵，现在他有 $m$ 个火把和 $k$ 个萤石，分别放在 $(x_1, y_1) \\sim (x_m, y_m)$ 和 $(o_1, p_1) \\sim (o_k, p_k)$ 的位置，没有光并且没放东西的地方会生成怪物。请问在这个方阵中有几个点会生成怪物？\n\nP.S. 火把的照亮范围是：\n\n```\n    |暗|暗| 光 |暗|暗|\n    |暗|光| 光 |光|暗|\n    |光|光|火把|光|光|\n    |暗|光| 光 |光|暗|\n    |暗|暗| 光 |暗|暗|\n```\n\n萤石：\n\n```\n    |光|光| 光 |光|光|\n    |光|光| 光 |光|光|\n    |光|光|萤石|光|光|\n    |光|光| 光 |光|光|\n    |光|光| 光 |光|光|\n```", "test_cases": [{"input": "5 1 0\n3 3\n", "output": "12"}, {"input": "2 2 2\n1 1\n2 2\n1 2\n2 1\n", "output": "0"}, {"input": "2 0 0\n", "output": "4"}, {"input": "7 0 0\n", "output": "49"}, {"input": "4 0 0\n", "output": "16"}, {"input": "6 0 0\n", "output": "36"}, {"input": "5 0 0\n", "output": "25"}, {"input": "3 1 2\n3 3\n1 1\n2 2\n", "output": "0"}, {"input": "2 1 0\n2 1\n", "output": "0"}, {"input": "3 0 1\n2 2\n", "output": "0"}, {"input": "2 1 1\n1 2\n2 1\n", "output": "0"}, {"input": "3 0 0\n", "output": "9"}], "test": "#undef NDEBUG\n#include<assert.h>\nint main(){\n    assert(solution(\"5 1 0\\n3 3\\n\") == \"12\");\n    assert(solution(\"2 2 2\\n1 1\\n2 2\\n1 2\\n2 1\\n\") == \"0\");\n    assert(solution(\"2 0 0\\n\") == \"4\");\n    assert(solution(\"7 0 0\\n\") == \"49\");\n    assert(solution(\"4 0 0\\n\") == \"16\");\n    assert(solution(\"6 0 0\\n\") == \"36\");\n    assert(solution(\"5 0 0\\n\") == \"25\");\n    assert(solution(\"3 1 2\\n3 3\\n1 1\\n2 2\\n\") == \"0\");\n    assert(solution(\"2 1 0\\n2 1\\n\") == \"0\");\n    assert(solution(\"3 0 1\\n2 2\\n\") == \"0\");\n    assert(solution(\"2 1 1\\n1 2\\n2 1\\n\") == \"0\");\n    assert(solution(\"3 0 0\\n\") == \"9\");\n    return 0; \n}", "prompt": "/*One day, linyorson created an $n \\times n$ matrix in \"Minecraft\". Now he has $m$ torches and $k$ glowstones, placed at positions $(x_1, y_1) \\sim (x_m, y_m)$ and $(o_1, p_1) \\sim (o_k, p_k)$, respectively. If there is no light or object in a position, a monster will spawn there. How many positions in the matrix will spawn monsters?\n\nP.S. The illumination range of a torch is:\n\n```\n    |Dark|Dark|Light|Dark|Dark|\n    |Dark|Light|Light|Light|Dark|\n    |Light|Light|Torch|Light|Light|\n    |Dark|Light|Light|Light|Dark|\n    |Dark|Dark|Light|Dark|Dark|\n```\nThe illumination range of a glowstone is:\n\n```\n    |Light|Light|Light|Light|Light|\n    |Light|Light|Light|Light|Light|\n    |Light|Light|Glowstone|Light|Light|\n    |Light|Light|Light|Light|Light|\n    |Light|Light|Light|Light|Light|\n```\n\ninput_format:\nEnter a total of $m + k + 1$rows.\nThe first behavior is $n, m, k.\nLines $2 to $m + 1 are the positions of the torches $x_i, y_i$.\nRows $m + 2$to $m + k + 1$are the locations of fluorite $o_i, p_i$.\n\nNote: There may not be fluorite, but there must be torches.\n\noutput_format:\nThere are a few points that give birth to monsters.\n*/\n\n#include<sstream>\n#include<stdlib.h>\n#include<algorithm>\n#include<math.h>\n#include<stdio.h>\n#include<vector>\n#include<string>\n#include<climits>\n#include<cstring>\n#include<iostream>\nusing namespace std;\n\n             \nstring solution(string std_in){\n    istringstream iss(std_in);\n             ", "constraints": "数据保证，$1 \\le n \\le 100$，$1 \\leq m+k \\leq 25$，$1 \\leq m \\leq 25$，$0 \\leq k \\leq 5$。", "samples": [["5 1 0\n3 3\n", "12\n"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000]}}
{"task_id": "P2616", "title": "[USACO10JAN]Buying Feed, II S", "difficulty": "challenge", "nl": "Farmer John needs to travel to town to pick up K (1 <= K <= 100) pounds of feed. Driving D miles with K pounds of feed in his truck costs D*K cents.\n\nThe county feed lot has N (1 <= N <= 100) stores (conveniently numbered 1..N) that sell feed. Each store is located on a segment of the X axis whose length is E (1 <= E <= 350). Store i is at location X_i (0 < X_i < E) on the number line and can sell FJ as much as F_i (1 <= F_i <= 100) pounds of feed at a cost of C_i (1 <= C_i <= 1,000,000) cents per pound. Amazingly, a given point on the X axis might have more than one store.\n\nFJ starts at location 0 on this number line and can drive only in the positive direction, ultimately arriving at location E, with at least K pounds of feed. He can stop at any of the feed stores along the way and buy any amount of feed up to the the store's limit.\n\nWhat is the minimum amount FJ has to pay to buy and transport the K pounds of feed? FJ knows there is a solution.\n\nConsider a sample where FJ needs two pounds of feed from three stores (locations: 1, 3, and 4) on a number line whose range is 0..5:\n\n```\n0   1   2   3   4   5 \n+---|---+---|---|---+ \n    1       1   1      Available pounds of feed \n    1       2   2      Cents per pound \n```\n\nIt is best for FJ to buy one pound of feed from both the second and third stores. He must pay two cents to buy each pound of feed for a total cost of 4. When FJ travels from 3 to 4 he is moving 1 unit of length and he has 1 pound of feed so he must pay 1*1 = 1 cents.\n\nWhen FJ travels from 4 to 5 he is moving one unit and he has 2 pounds of feed so he must pay 1*2 = 2 cents.\n\nThe total cost is 4+1+2 = 7 cents.", "code": "#include \"cstdio\"\n#include \"algorithm\"\nusing namespace std;\nstruct food{int val,num;}f[102];//num为这个商店的存货,val为在这个商店买一份食物的价钱\nint number,s,n,ans=0;\nbool cmp(food a,food b){return a.val<b.val;}//从小到大排序 \nint Min(int a,int b){return a<b?a:b;}\nint main(){\n    scanf(\"%d%d%d\",&number,&s,&n);//number为总共要买的食物,s为总路程,n为商店数 \n    for(int i=1,a,b;i<=n;i++){\n        scanf(\"%d%d%d\",&a,&f[i].num ,&b);\n        f[i].val=s-a+b;//在这个商店买一份食物的价钱 \n    }\n    sort(f+1,f+1+n,cmp);//排序,取最小值 \n    for(int i=1;i<=n&&number>0;i++){\n        ans+=Min(number,f[i].num)*f[i].val;//每到一个商店就取光光 \n        number-=f[i].num;//剩下需要买的食物 \n    }\n    printf(\"%d\",ans);//输出 \n    return 0;\n}", "step": ["Take input for number of food items, starting money and number of different types of food.", "Take input for each food item's value, quantity and cost of buying them.", "Calculate the total value of each food item based on starting money.", "Sort the food items based on their value.", "Traverse through each food item and calculate the total cost until number of food items is exhausted or all food types are used.", "Print the total cost."], "nl_cn": "Farmer John needs to travel to town to pick up K (1 <= K <= 100) pounds of feed. Driving D miles with K pounds of feed in his truck costs D\\*K cents.\n\nThe county feed lot has N (1 <= N <= 100) stores (conveniently numbered 1..N) that sell feed. Each store is located on a segment of the X axis whose length is E (1 <= E <= 350). Store i is at location X\\_i (0 < X\\_i < E) on the number line and can sell FJ as much as F\\_i (1 <= F\\_i <= 100) pounds of feed at a cost of C\\_i (1 <= C\\_i <= 1,000,000) cents per pound. Amazingly, a given point on the X axis might have more than one store.\n\nFJ starts at location 0 on this number line and can drive only in the positive direction, ultimately arriving at location E, with at least K pounds of feed. He can stop at any of the feed stores along the way and buy any amount of feed up to the the store's limit.\n\nWhat is the minimum amount FJ has to pay to buy and transport the K pounds of feed? FJ knows there is a solution.\n\nConsider a sample where FJ needs two pounds of feed from three stores (locations: 1, 3, and 4) on a number line whose range is 0..5:\n\n```\n0   1   2   3   4   5 \n+---|---+---|---|---+ \n    1       1   1      Available pounds of feed \n    1       2   2      Cents per pound \n```\nIt is best for FJ to buy one pound of feed from both the second and third stores. He must pay two cents to buy each pound of feed for a total cost of 4. When FJ travels from 3 to 4 he is moving 1 unit of length and he has 1 pound of feed so he must pay 1\\*1 = 1 cents.\n\nWhen FJ travels from 4 to 5 he is moving one unit and he has 2 pounds of feed so he must pay 1\\*2 = 2 cents.\n\nThe total cost is 4+1+2 = 7 cents. \n\nFJ 开车去买 $K$ 份食物，如果他的车上有 $X$ 份食物。每走一里就花费 $X$ 元。FJ 的城市是一条线，总共 $E$ 里路，有 $E+1$ 个地方，标号 $0\\sim E$。 FJ 从 $0$ 开始走，到 $E$ 结束（不能往回走），要买 $K$ 份食物。 城里有 $N$ 个商店，每个商店的位置是 $X_i$（一个点上可能有多个商店），有 $F_i$ 份食物，每份 $C_i$ 元。 问到达 $E$ 并买 $K$ 份食物的最小花费。", "test_cases": [{"input": "2 5 3\n3 1 2\n4 1 2\n1 1 1", "output": "7"}, {"input": "1 1 1\n1 1 1\n", "output": "1"}, {"input": "2 2 1\n1 2 1\n", "output": "4"}, {"input": "3 3 1\n2 1 2\n", "output": "3"}, {"input": "2 5 3\n1 1 1\n4 1 2\n3 1 2\n", "output": "7"}], "test": "#undef NDEBUG\n#include<assert.h>\nint main(){\n    assert(solution(\"2 5 3\\n3 1 2\\n4 1 2\\n1 1 1\") == \"7\");\n    assert(solution(\"1 1 1\\n1 1 1\\n\") == \"1\");\n    assert(solution(\"2 2 1\\n1 2 1\\n\") == \"4\");\n    assert(solution(\"3 3 1\\n2 1 2\\n\") == \"3\");\n    assert(solution(\"2 5 3\\n1 1 1\\n4 1 2\\n3 1 2\\n\") == \"7\");\n    return 0; \n}", "prompt": "/*Farmer John needs to travel to town to pick up K (1 <= K <= 100) pounds of feed. Driving D miles with K pounds of feed in his truck costs D*K cents.\n\nThe county feed lot has N (1 <= N <= 100) stores (conveniently numbered 1..N) that sell feed. Each store is located on a segment of the X axis whose length is E (1 <= E <= 350). Store i is at location X_i (0 < X_i < E) on the number line and can sell FJ as much as F_i (1 <= F_i <= 100) pounds of feed at a cost of C_i (1 <= C_i <= 1,000,000) cents per pound. Amazingly, a given point on the X axis might have more than one store.\n\nFJ starts at location 0 on this number line and can drive only in the positive direction, ultimately arriving at location E, with at least K pounds of feed. He can stop at any of the feed stores along the way and buy any amount of feed up to the the store's limit.\n\nWhat is the minimum amount FJ has to pay to buy and transport the K pounds of feed? FJ knows there is a solution.\n\nConsider a sample where FJ needs two pounds of feed from three stores (locations: 1, 3, and 4) on a number line whose range is 0..5:\n\n```\n0   1   2   3   4   5 \n+---|---+---|---|---+ \n    1       1   1      Available pounds of feed \n    1       2   2      Cents per pound \n```\n\nIt is best for FJ to buy one pound of feed from both the second and third stores. He must pay two cents to buy each pound of feed for a total cost of 4. When FJ travels from 3 to 4 he is moving 1 unit of length and he has 1 pound of feed so he must pay 1*1 = 1 cents.\n\nWhen FJ travels from 4 to 5 he is moving one unit and he has 2 pounds of feed so he must pay 1*2 = 2 cents.\n\nThe total cost is 4+1+2 = 7 cents.\n\ninput_format:\n\n\n```markdown\nThis is an image provided by the programming website.\n\n```\n\noutput_format:\n\n*/\n\n#include<sstream>\n#include<stdlib.h>\n#include<algorithm>\n#include<math.h>\n#include<stdio.h>\n#include<vector>\n#include<string>\n#include<climits>\n#include<cstring>\n#include<iostream>\nusing namespace std;\n\n             \nstring solution(string std_in){\n    istringstream iss(std_in);\n             ", "constraints": "![](https://cdn.luogu.com.cn/upload/pic/1720.png)\n", "samples": [["2 5 3\n3 1 2\n4 1 2\n1 1 1", "7"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}}
{"task_id": "P5189", "title": "[COCI2009-2010#5] ZUMA", "difficulty": "advanced", "nl": "Translated from the programming website [COCI 2010.03.06] Problem 4 \"ZUMA\"\n\nMirko lined up $N$ marbles, numbered 1 to $N$, in a row. The color of the $i$th marble is $c_i$. He discovered that if he touches $\\ge K$ consecutive marbles of the same color, magic will make these marbles disappear. Afterwards, the marbles before the $K$ marbles will be adjacent to the marbles after the $K$ marbles.\n\nMirko has many marbles at home and he wants to insert as few marbles as possible between these $N$ marbles (it can also be in front of the first marble or after the last marble) so that all the marbles - the original ones and the added ones - can disappear.", "code": "#include<iostream>\n#include<cstdio>\n#include<algorithm>\n#include<cstring>\n#include<cmath>\n#define ll long long\n#define ri register int\nusing namespace std;\nconst int MAXN = 110;\nint n, k, a[MAXN], dp[MAXN][MAXN][10];\n\n\nint main() {\n\tmemset(dp, 0x3f, sizeof(dp));\n\tscanf(\"%d%d\", &n, &k);\n\tfor (ri i = 1; i <= n; i++) {\n\t\tscanf(\"%d\", &a[i]);\n\t\tfor (int j = 0; j <= k - 1; j++)\n\t\t\tdp[i][i][j] = k - j - 1;\n\t}\n\n\tfor (ri len = 2; len <= n; len++) {\n\t\tfor (ri i = 1; i + len - 1 <= n; i++) {\n\t\t\tint j = i + len - 1;\n\t\t\tfor (ri c = k - 1; c >= 0; c--) {\n\t\t\t\tif (c == k - 1)\n\t\t\t\t\tdp[i][j][c] = min(dp[i][j][c], dp[i + 1][j][0]);\n\t\t\t\telse if (c < k - 1)\n\t\t\t\t\tdp[i][j][c] = min(dp[i][j][c], dp[i][j][c + 1] + 1);\n\t\t\t\tif (a[i] == a[i + 1])\n\t\t\t\t\tdp[i][j][c] = min(dp[i][j][c], dp[i + 1][j][min(k - 1, c + 1)]);\n\t\t\t\tfor (ri l = i + 1; l <= j - 1; l++) {\n\t\t\t\t\tif (a[i] == a[l + 1])\n\t\t\t\t\t\tdp[i][j][c] = min(dp[i][j][c], dp[i + 1][l][0] + dp[l + 1][j][min(k - 1, c + 1)]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tcout << dp[1][n][0];\n\treturn 0;\n}", "step": ["Initialize dp array with a large value", "Scan n numbers of sequence and initialize the initial of dp[i][i] with k-j-1", "Fill in the values for each section of sequence with a dynamic programming approach", "Find the minimum value of dp[1][n][0] and print it as the result"], "nl_cn": " **译自 [COCI 2010.03.06]」**\n\nMirko 将 $N$ 颗弹子排成一排，依次编号为 $1\\ldots N$。$i$ 号弹子的颜色为 $c_i$。他发现，如果他触摸 $\\ge K$ 颗连续的弹子，且这些弹子的颜色相同，魔法会使这些弹子消失；此后，这 $K$ 颗弹子前面的弹子便与这 $K$ 颗弹子后面的弹子相邻。\n\nMirko 家里有很多弹子，他想在这 $N$ 颗弹子之间（也可以在开头的弹子前面或末尾的弹子后面）插入尽可能少的弹子，使得这 $N$ 颗弹子+插入的所有弹子消失。", "test_cases": [{"input": "2 5\n1 1", "output": "3"}, {"input": "5 3\n2 2 3 2 2", "output": "2"}, {"input": "10 4\n3 3 3 3 2 3 1 1 1 3", "output": "4"}, {"input": "1 1\n1", "output": "0"}, {"input": "7 2\n3 4 4 3 3 4 3", "output": "0"}, {"input": "3 1\n1 1 1", "output": "0"}, {"input": "5 5\n1 1 1 1 1", "output": "0"}, {"input": "6 6\n2 2 2 2 2 2", "output": "0"}, {"input": "7 7\n3 3 3 3 3 3 3", "output": "0"}, {"input": "8 4\n1 1 1 1 2 2 2 2", "output": "0"}, {"input": "4 2\n2 2 2 2", "output": "0"}, {"input": "5 3\n1 1 1 1 1", "output": "0"}, {"input": "6 5\n3 3 3 3 3 3", "output": "0"}, {"input": "7 6\n4 4 4 4 4 4 4", "output": "0"}, {"input": "8 1\n1 1 1 1 1 1 1 1", "output": "0"}, {"input": "4 5\n2 2 2 2", "output": "1"}, {"input": "5 2\n1 2 1 2 1", "output": "1"}, {"input": "4 3\n1 1 2 2", "output": "2"}, {"input": "9 3\n1 2 2 1 2 2 1 2 2", "output": "3"}, {"input": "7 3\n1 2 2 1 1 1 2", "output": "2"}, {"input": "4 2\n1 1 1 1", "output": "0"}, {"input": "3 1\n1 2 3\n", "output": "0"}], "test": "#undef NDEBUG\n#include<assert.h>\nint main(){\n    assert(solution(\"2 5\\n1 1\") == \"3\");\n    assert(solution(\"5 3\\n2 2 3 2 2\") == \"2\");\n    assert(solution(\"10 4\\n3 3 3 3 2 3 1 1 1 3\") == \"4\");\n    assert(solution(\"1 1\\n1\") == \"0\");\n    assert(solution(\"7 2\\n3 4 4 3 3 4 3\") == \"0\");\n    assert(solution(\"3 1\\n1 1 1\") == \"0\");\n    assert(solution(\"5 5\\n1 1 1 1 1\") == \"0\");\n    assert(solution(\"6 6\\n2 2 2 2 2 2\") == \"0\");\n    assert(solution(\"7 7\\n3 3 3 3 3 3 3\") == \"0\");\n    assert(solution(\"8 4\\n1 1 1 1 2 2 2 2\") == \"0\");\n    assert(solution(\"4 2\\n2 2 2 2\") == \"0\");\n    assert(solution(\"5 3\\n1 1 1 1 1\") == \"0\");\n    assert(solution(\"6 5\\n3 3 3 3 3 3\") == \"0\");\n    assert(solution(\"7 6\\n4 4 4 4 4 4 4\") == \"0\");\n    assert(solution(\"8 1\\n1 1 1 1 1 1 1 1\") == \"0\");\n    assert(solution(\"4 5\\n2 2 2 2\") == \"1\");\n    assert(solution(\"5 2\\n1 2 1 2 1\") == \"1\");\n    assert(solution(\"4 3\\n1 1 2 2\") == \"2\");\n    assert(solution(\"9 3\\n1 2 2 1 2 2 1 2 2\") == \"3\");\n    assert(solution(\"7 3\\n1 2 2 1 1 1 2\") == \"2\");\n    assert(solution(\"4 2\\n1 1 1 1\") == \"0\");\n    assert(solution(\"3 1\\n1 2 3\\n\") == \"0\");\n    return 0; \n}", "prompt": "/*Translated from the programming website [COCI 2010.03.06] Problem 4 \"ZUMA\"\n\nMirko lined up $N$ marbles, numbered 1 to $N$, in a row. The color of the $i$th marble is $c_i$. He discovered that if he touches $\\ge K$ consecutive marbles of the same color, magic will make these marbles disappear. Afterwards, the marbles before the $K$ marbles will be adjacent to the marbles after the $K$ marbles.\n\nMirko has many marbles at home and he wants to insert as few marbles as possible between these $N$ marbles (it can also be in front of the first marble or after the last marble) so that all the marbles - the original ones and the added ones - can disappear.\n\ninput_format:\nFirst row: $N,K$.\nSecond line: $c_1\\ldots c_N$.\n\noutput_format:\nOne line, an integer, indicates that he must insert at least a few marbles.\n*/\n\n#include<sstream>\n#include<stdlib.h>\n#include<algorithm>\n#include<math.h>\n#include<stdio.h>\n#include<vector>\n#include<string>\n#include<climits>\n#include<cstring>\n#include<iostream>\nusing namespace std;\n\n             \nstring solution(string std_in){\n    istringstream iss(std_in);\n             ", "constraints": "$1\\le N\\le 100,$ $2\\le K\\le 5,$ $1\\le c_i\\le 100$.", "samples": [["2 5\n1 1", "3"], ["5 3\n2 2 3 2 2", "2"], ["10 4\n3 3 3 3 2 3 1 1 1 3", "4"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000]}}
{"task_id": "P8792", "title": "[蓝桥杯 2022 国 A] 最大公约数", "difficulty": "advanced", "nl": "Given an array, each operation can choose any two adjacent elements $x, y$ in the array and replace one of them with $\\gcd(x, y)$, where $\\gcd(x, y)$ represents the greatest common divisor of $x$ and $y$. How many minimum operations are needed to make the entire array contain only $1$?", "code": "#include<bits/stdc++.h>\n#define int long long\n#define lc 2*k\n#define rc 2*k+1\nusing namespace std;\nint n,a[1234567],cnt;\nstruct nord{\n\tint l,r,mx;\n}t[1234567];\nvoid build(int k,int l,int r){//建树\n\tt[k].l=l,t[k].r=r;\n\tif (l==r){\n\t\tt[k].mx=a[l];\n\t\treturn ;\n\t}\n\tint mid=(l+r)/2;\n\tbuild(lc,l,mid);\n\tbuild(rc,mid+1,r);\n\tt[k].mx=__gcd(t[lc].mx,t[rc].mx);\n}\nint ask(int k,int l,int r){//求区间gcd\n\tif (l<=t[k].l&&r>=t[k].r) return t[k].mx;\n\tint ans=0;\n\tint mid=(t[k].l+t[k].r)/2;\n\tif (l<=mid) ans=__gcd(ans,ask(lc,l,r));\n\tif (r>mid) ans=__gcd(ans,ask(rc,l,r));\n\treturn ans;\n}\nmain(){\n\tcin>>n;\n\tfor (int i=1;i<=n;i++) cin>>a[i],cnt+=(a[i]==1?1:0);\n\tbuild(1,1,n);\n\tif (cnt){//特殊情况\n\t\tcout <<n-cnt;\n\t\treturn 0;\n\t}\n\tint ans=1e9;\n\tint i=1;\n\tfor (int j=1;j<=n;j++){//枚举\n\t\twhile (i<j&&ask(1,i+1,j)==1) i++;//一直往前走\n\t\tif (ask(1,i,j)==1) ans=min(ans,j-i);//成功了\n\t}\n\tif (ans==1e9) cout <<-1;//不合法\n\telse cout <<n+ans-1;\n    return 0;\n}", "step": ["Input the size of the array and its elements.", "If there is already a 1 in the array, output the size of the array minus the count of 1s in the array.", "Initialize step as 1e9 and iterate through the array to find the greatest common divisor of the current element and the remaining elements.", "If the current step exceeds the value of step, break the loop.", "If the greatest common divisor of the current element and the remaining elements is 1, store the difference between the current position and the latest position as the new value for 'step'.", "If an optimal step is found, output the sum of the length of the array minus one and the value of step. Otherwise, output -1."], "nl_cn": "给定一个数组，每次操作可以选择数组中任意两个相邻的元素 $x, y$ 并将其中的一个元素替换为 $\\gcd(x, y)$，其中 $\\gcd(x, y)$ 表示 $x$ 和 $y$ 的最大公约数。请问最少需要多少次操作才能让整个数组只含 $1$。", "test_cases": [{"input": "3\n4 6 9", "output": "4"}, {"input": "4\n1 1 1 1\n", "output": "0"}, {"input": "4\n1 2 3 4\n", "output": "3"}, {"input": "6\n1 1 1 1 1 1\n", "output": "0"}, {"input": "4\n1 25 13 7\n", "output": "3"}, {"input": "3\n2 3 4", "output": "3"}, {"input": "3\n5 7 11", "output": "3"}, {"input": "4\n2 3 5 7", "output": "4"}, {"input": "4\n3 3 3 3\n", "output": "-1"}, {"input": "2\n1 1\n", "output": "0"}, {"input": "3\n4 8 16\n", "output": "-1"}, {"input": "6\n1 2 3 4 5 6\n", "output": "5"}, {"input": "3\n3 4 5\n", "output": "3"}, {"input": "5\n2 3 5 7 11\n", "output": "5"}, {"input": "1\n1\n", "output": "0"}, {"input": "4\n15 18 21 25\n", "output": "4"}, {"input": "3\n1 1 1\n", "output": "0"}, {"input": "5\n2 5 7 11 13\n", "output": "5"}, {"input": "4\n1 3 5 7\n", "output": "3"}], "test": "#undef NDEBUG\n#include<assert.h>\nint main(){\n    assert(solution(\"3\\n4 6 9\") == \"4\");\n    assert(solution(\"4\\n1 1 1 1\\n\") == \"0\");\n    assert(solution(\"4\\n1 2 3 4\\n\") == \"3\");\n    assert(solution(\"6\\n1 1 1 1 1 1\\n\") == \"0\");\n    assert(solution(\"4\\n1 25 13 7\\n\") == \"3\");\n    assert(solution(\"3\\n2 3 4\") == \"3\");\n    assert(solution(\"3\\n5 7 11\") == \"3\");\n    assert(solution(\"4\\n2 3 5 7\") == \"4\");\n    assert(solution(\"4\\n3 3 3 3\\n\") == \"-1\");\n    assert(solution(\"2\\n1 1\\n\") == \"0\");\n    assert(solution(\"3\\n4 8 16\\n\") == \"-1\");\n    assert(solution(\"6\\n1 2 3 4 5 6\\n\") == \"5\");\n    assert(solution(\"3\\n3 4 5\\n\") == \"3\");\n    assert(solution(\"5\\n2 3 5 7 11\\n\") == \"5\");\n    assert(solution(\"1\\n1\\n\") == \"0\");\n    assert(solution(\"4\\n15 18 21 25\\n\") == \"4\");\n    assert(solution(\"3\\n1 1 1\\n\") == \"0\");\n    assert(solution(\"5\\n2 5 7 11 13\\n\") == \"5\");\n    assert(solution(\"4\\n1 3 5 7\\n\") == \"3\");\n    return 0; \n}", "prompt": "/*Given an array, each operation can choose any two adjacent elements $x, y$ in the array and replace one of them with $\\gcd(x, y)$, where $\\gcd(x, y)$ represents the greatest common divisor of $x$ and $y$. How many minimum operations are needed to make the entire array contain only $1$?\n\ninput_format:\nThe first line of input contains an integer $n$, which represents the array length.\n\nThe second line contains $n$integers $a_1, a_2,\\dots, a_n$, separated by a space between the two adjacent integers.\n\noutput_format:\nThe output line contains an integer representing the minimum number of operations. If no matter what the operation does not meet the requirements, output $-1$.\n*/\n\n#include<sstream>\n#include<stdlib.h>\n#include<algorithm>\n#include<math.h>\n#include<stdio.h>\n#include<vector>\n#include<string>\n#include<climits>\n#include<cstring>\n#include<iostream>\nusing namespace std;\n\n             \nstring solution(string std_in){\n    istringstream iss(std_in);\n             ", "constraints": "**【评测用例规模与约定】**\n\n- 对于 $30\\%$ 的评测用例，$n \\leq 500$，$a_i \\leq 1000$；\n- 对于 $50\\%$ 的评测用例，$n \\leq 5000$，$a_i \\leq 10^6$；\n- 对于所有评测用例，$1 \\leq n \\leq 10^5$，$1 \\leq a_i \\leq 10^9$。\n\n蓝桥杯 2022 国赛 A 组 D 题。", "samples": [["3\n4 6 9", "4"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288]}}
{"task_id": "P8432", "title": "「WHOI-2」ぽかぽかの星", "difficulty": "advanced", "nl": "How many length-$n$ **positive integer** sequences $a_i$ satisfy the following conditions:\n\n- $0<a_1\\leq a_2\\leq a_3\\dots \\leq a_n\\leq k$.\n- $\\forall i\\not = j,a_i+a_j\\not = k+1$.\n\nAnswer should be modulo $10^9+7$.", "code": "///*****Sellaris*****///\n//#pragma once\n//#pragma GCC optimize(2)\n//#pragma GCC optimize(3)\n#include <bits/stdc++.h>\n//#include <bits/extc++.h>\nusing namespace std;\n#define int long long \n#define endl \"\\n\"\n//using namespace __gnu_pbds;\nconst int maxn=5e6+10;\nconst int mo=1e9+7;\ninline int read(){\n    int ret=0,f=1;char ch=getchar();\n    while(!isdigit(ch)){if(ch=='-')f=-f;ch=getchar();}\n    while(isdigit(ch)){ret=ret*10+ch-'0';ch=getchar();}\n    return ret*f; //x=(x<<1)+(x<<3)+(ch^48);\n}\ninline int mod(int x){return x>=mo? x%mo :x;}\ninline int qpow(int x,int k){\n    int res=1,base=x;\n    while(k){\n        if(k&1) res*=base,res=mod(res);\n        k>>=1; base*=base;base=mod(base);\n    }return res;\n}\nint jc[maxn],jc_inv[maxn];\ninline void preC(){\n    jc[0]=jc_inv[0]=1;//组合数要考虑 n,m,n-m == 0\n    for(int i=1;i<maxn;i++) jc[i]=mod(jc[i-1]*i);\n    jc_inv[maxn-1]=mod(qpow(jc[maxn-1],mo-2));\n    for(int i=maxn-2;i>=1;i--) jc_inv[i]=mod(jc_inv[i+1]*(i+1));\n}\ninline int C(int m,int n){\n    return mod(mod(jc[n]*jc_inv[n-m])*jc_inv[m]);\n}\nint a[maxn]={0};\nint n,m,k,ans;\nint lg2[maxn];\ninline void solve(){\n\t//string s;\n    n=read();k=read();ans=0;\n    if(n==1){\n    \tcout<<k<<endl;\n    \treturn ;//包含了k==1 \n\t}\n\tif(k==1){\n\t\tcout<<0<<endl;\n\t\treturn ;//不包含n==1 \n\t}\n\tif(k%2==0){\n\t\tm=k/2;//两两分组，枚举 m 组当中 **有不为零** 的组数 i。\n\t\tfor(int i=1;i<=min(n,m);i++){\n\t\t\tans+=mod(C(i,m)*C(i-1,n-1))*lg2[i]; //C(i-1,n-1)隔板法 \n\t\t\tans=mod(ans);//(选i组的方案)*(n个元素分配到i组的方案)*(m组内部分配的方案)\n\t\t}\n\t\tcout<<ans<<endl; \n\t}else{\n\t\tm=(k-1)/2;\n\t\t//TONG[m+1]==0\n\t\tfor(int i=1;i<=min(n,m);i++){\n\t\t\tans+=mod(C(i,m)*C(i-1,n-1))*lg2[i]; //C(i-1,n-1)隔板法 \n\t\t\tans=mod(ans);//(选i组的方案)*(n个元素分配到i组的方案)*(m组内部分配的方案)\n\t\t}\n\t\t//TONG[m+1]==1\n\t\tfor(int i=1;i<=min(n-1,m);i++){\n\t\t\tans+=mod(C(i,m)*C(i-1,n-2))*lg2[i]; //C(i-1,n-1)隔板法 \n\t\t\tans=mod(ans);//(选i组的方案)*(n个元素分配到i组的方案)*(m组内部分配的方案)\n\t\t}\n\t\tcout<<ans<<endl; \n\t}\n\treturn;\n}\nsigned main(){\n    //std::ios::sync_with_stdio(false);std::cin.tie(NULL);std::cout.tie(NULL);\n    //freopen(\"in.txt\",\"r\",stdin);\n\t//freopen(\"out.txt\",\"w\",stdout);\n\tint t=read();\n\tpreC();\n\tfor(int i=0;i<maxn;i++) lg2[i]=qpow(2,i);\n\twhile(t--){\n\t\tsolve();\n\t}\n    return 0;\n}", "step": ["The code reads an integer t.", "The pre-C function is called which pre-processes combinatorics formulas to calculate results.", "Loop over test cases.", "The solve function is called which takes input integers, pre-calculates the combinatorics formula using pre-C values, and outputs the result.", "The function uses if statement to obtain an intermediate result based on k value.", "The final result is output."], "nl_cn": "有多少个长度为 $n$ 的**正整数**数列 $a_i$ 满足：\n\n- $0<a_1\\leq a_2\\leq a_3\\dots \\leq a_n\\leq k$。\n- $\\forall i\\not = j,a_i+a_j\\not = k+1$。\n\n答案对 $10^9+7$ 取模。", "test_cases": [{"input": "3\n2 2\n1145 1419\n19198 12321", "output": "2\n66937457\n949924930"}], "test": "#undef NDEBUG\n#include<assert.h>\nint main(){\n    assert(solution(\"3\\n2 2\\n1145 1419\\n19198 12321\") == \"2\\n66937457\\n949924930\");\n    return 0; \n}", "prompt": "/*How many length-$n$ **positive integer** sequences $a_i$ satisfy the following conditions:\n\n- $0<a_1\\leq a_2\\leq a_3\\dots \\leq a_n\\leq k$.\n- $\\forall i\\not = j,a_i+a_j\\not = k+1$.\n\nAnswer should be modulo $10^9+7$.\n\ninput_format:\n** Multiple tests **\n\nA positive integer in the first row represents $T$.\n\nNext comes the $T$line, with two positive integers per line representing $n,k$.\n\noutput_format:\n$T$lines, each with a positive integer representing the answer.\n*/\n\n#include<sstream>\n#include<stdlib.h>\n#include<algorithm>\n#include<math.h>\n#include<stdio.h>\n#include<vector>\n#include<string>\n#include<climits>\n#include<cstring>\n#include<iostream>\nusing namespace std;\n\n             \nstring solution(string std_in){\n    istringstream iss(std_in);\n             ", "constraints": "**本题采用捆绑测试**\n\n- $\\text{subtask1(20pts)}:T=5,1\\leq n,k\\le5$。\n- $\\text{subtask2(80pts)}:$ 无特殊限制。\n\n\n对于 $100\\%$ 的数据，$T\\leq100,1\\le n,k\\le 5\\times 10^6,1\\leq  \\sum n,  \\sum  k\\le6\\times 10^7$。\n\n", "samples": [["3\n2 2\n1145 1419\n19198 12321", "2\n66937457\n949924930"]], "limits": {"time": [2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000], "memory": [262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144]}}
{"task_id": "P3120", "title": "[USACO15FEB]Cow Hopscotch G", "difficulty": "advanced", "nl": "Just like humans enjoy playing the game of Hopscotch, Farmer John's cows have invented a variant of the game for themselves to play. Being played by clumsy animals weighing nearly a ton, Cow Hopscotch almost always ends in disaster, but this has surprisingly not deterred the cows from attempting to play nearly every afternoon.\n\nThe game is played on an R by C grid (2 <= R <= 750, 2 <= C <= 750), where each square is labeled with an integer in the range 1..K (1 <= K <= R*C). Cows start in the top-left square and move to the bottom-right square by a sequence of jumps, where a jump is valid if and only if\n\n1) You are jumping to a square labeled with a different integer than your current square,\n2) The square that you are jumping to is at least one row below the current square that you are on, and\n3) The square that you are jumping to is at least one column to the right of the current square that you are on.\n\nPlease help the cows compute the number of different possible sequences of valid jumps that will take them from the top-left square to the bottom-right square.", "code": "#include <stdio.h> \n\ntypedef long long ll;\n\ntypedef struct {\n\tint id;\n\tint type;\n\tint pos;\n\tint val;\n} Node;\n\nconst int mod = 1e9 + 7;\nint a[757][757], mark[570027], b[570027], dp[757][757];\n\nvoid cdq(int l, int r, int c, int &id){\n\tif (l == r) return;\n\tint mid = (l + r) >> 1, sum = 0;\n\tcdq(l, mid, c, id);\n\tid++;\n\tfor (register int i = 1; i <= c; i++){\n\t\tfor (register int j = mid + 1; j <= r; j++){\n\t\t\tif (mark[a[i][j]] < id){\n\t\t\t\tmark[a[i][j]] = id;\n\t\t\t\tb[a[i][j]] = 0;\n\t\t\t}\n\t\t\tdp[i][j] = ((dp[i][j] + sum - b[a[i][j]]) % mod + mod) % mod;\n\t\t}\n\t\tfor (register int j = l; j <= mid; j++){\n\t\t\tif (mark[a[i][j]] < id){\n\t\t\t\tmark[a[i][j]] = id;\n\t\t\t\tb[a[i][j]] = 0;\n\t\t\t}\n\t\t\tb[a[i][j]] = (b[a[i][j]] + dp[i][j]) % mod;\n\t\t\tsum = (sum + dp[i][j]) % mod;\n\t\t}\n\t}\n\tcdq(mid + 1, r, c, id);\n}\n\nint main(){\n\tint r, c, k, id = 0;\n\tscanf(\"%d %d %d\", &r, &c, &k);\n\tfor (register int i = 1; i <= r; i++){\n\t\tfor (register int j = 1; j <= c; j++){\n\t\t\tscanf(\"%d\", &a[i][j]);\n\t\t}\n\t}\n\tdp[1][1] = 1;\n\tcdq(1, r, c, id);\n\tprintf(\"%d\", dp[r][c]);\n\treturn 0;\n}", "step": ["Initialize variables: R, C, K, dp, a, and v.", "Read in values for a.", "Set dp[1][1] to be 1.", "For i = 2 to R, compute dp values using v and as.", "    - Set v to be an array of zeros.", "    - For j = 2 to C, compute the sum of dp[k][j-1] for k = 1 to i-1 using v and as.", "    - Set dp[i][j] using the computed sum.", "Return dp[R][C]."], "nl_cn": "Just like humans enjoy playing the game of Hopscotch, Farmer John&apos;s cows have invented a variant of the game for themselves to play.  Being played by clumsy animals weighing nearly a ton, Cow Hopscotch almost always ends in disaster, but this has surprisingly not deterred the cows from attempting to play nearly every afternoon.\n\nThe game is played on an R by C grid (2 <= R <= 750, 2 <= C <= 750), where each square is labeled with an integer in the range 1..K (1 <= K <= R\\*C).  Cows start in the top-left square and move to the bottom-right square by a sequence of jumps, where a jump is valid if and only if\n\n1) You are jumping to a square labeled with a different integer than your current square,\n\n2) The square that you are jumping to is at least one row below the current square that you are on, and\n\n3) The square that you are jumping to is at least one column to the right of the current square that you are on.\n\nPlease help the cows compute the number of different possible sequences of valid jumps that will take them from the top-left square to the bottom-right square.\n\n就像人类喜欢跳格子游戏一样，FJ的奶牛们发明了一种新的跳格子游戏。虽然这种接近一吨的笨拙的动物玩跳格子游戏几乎总是不愉快地结束，但是这并没有阻止奶牛们在每天下午参加跳格子游戏\n\n游戏在一个R\\*C的网格上进行，每个格子有一个取值在1-k之间的整数标号，奶牛开始在左上角的格子，目的是通过若干次跳跃后到达右下角的格子，当且仅当格子A和格子B满足如下条件时能从格子A跳到格子B：\n\n1.B格子在A格子的严格右方(B的列号严格大于A的列号)\n\n2.B格子在A格子的严格下方(B的行号严格大于A的行号)\n\n3.B格子的标号和A格子的标号不同\n\n请你帮助奶牛计算出从左上角的格子到右下角的格子一共有多少种不同的方案\n", "test_cases": [{"input": "4 4 4 \n1 1 1 1 \n1 3 2 1 \n1 2 4 1 \n1 1 1 1 \n", "output": "5"}, {"input": "3 3 4 \n1 2 1 \n3 3 2 \n2 3 3 \n", "output": "1"}, {"input": "2 2 4 \n4 3 \n3 4 \n", "output": "0"}, {"input": "2 3 2 \n2 2 2 \n2 1 2 \n", "output": "0"}, {"input": "4 2 2 \n1 1 \n1 2 \n1 2 \n1 1 \n", "output": "0"}, {"input": "2 2 2\n1 1\n1 2\n2 2\n", "output": "1"}, {"input": "2 2 2 \n1 1 \n2 2 \n", "output": "1"}, {"input": "2 3 2 \n1 1 2 \n1 2 1 \n", "output": "0"}, {"input": "2 2 3 \n1 1 \n1 1 \n", "output": "0"}, {"input": "3 3 2 \n1 2 1 \n2 1 2 \n1 2 1 \n", "output": "0"}, {"input": "2 2 2\n1 1\n2 2\n", "output": "1"}, {"input": "2 2 4\n1 1\n2 2\n", "output": "1"}, {"input": "2 5 7\n2 1 1 1 1\n1 2 2 2 2\n", "output": "0"}, {"input": "3 3 4\n1 1 1\n2 2 2\n1 1 1\n", "output": "1"}, {"input": "3 3 9\n2 1 3\n1 2 3\n3 3 3\n", "output": "1"}, {"input": "2 2 4 \n1 2 \n3 4 \n", "output": "1"}, {"input": "2 4 4 \n1 2 3 4 \n1 2 2 1 \n", "output": "0"}, {"input": "5 5 5 \n1 1 1 1 1 \n2 2 2 2 2 \n3 3 3 3 3 \n4 4 4 4 4 \n5 5 5 5 5 \n", "output": "20"}], "test": "#undef NDEBUG\n#include<assert.h>\nint main(){\n    assert(solution(\"4 4 4 \\n1 1 1 1 \\n1 3 2 1 \\n1 2 4 1 \\n1 1 1 1 \\n\") == \"5\");\n    assert(solution(\"3 3 4 \\n1 2 1 \\n3 3 2 \\n2 3 3 \\n\") == \"1\");\n    assert(solution(\"2 2 4 \\n4 3 \\n3 4 \\n\") == \"0\");\n    assert(solution(\"2 3 2 \\n2 2 2 \\n2 1 2 \\n\") == \"0\");\n    assert(solution(\"4 2 2 \\n1 1 \\n1 2 \\n1 2 \\n1 1 \\n\") == \"0\");\n    assert(solution(\"2 2 2\\n1 1\\n1 2\\n2 2\\n\") == \"1\");\n    assert(solution(\"2 2 2 \\n1 1 \\n2 2 \\n\") == \"1\");\n    assert(solution(\"2 3 2 \\n1 1 2 \\n1 2 1 \\n\") == \"0\");\n    assert(solution(\"2 2 3 \\n1 1 \\n1 1 \\n\") == \"0\");\n    assert(solution(\"3 3 2 \\n1 2 1 \\n2 1 2 \\n1 2 1 \\n\") == \"0\");\n    assert(solution(\"2 2 2\\n1 1\\n2 2\\n\") == \"1\");\n    assert(solution(\"2 2 4\\n1 1\\n2 2\\n\") == \"1\");\n    assert(solution(\"2 5 7\\n2 1 1 1 1\\n1 2 2 2 2\\n\") == \"0\");\n    assert(solution(\"3 3 4\\n1 1 1\\n2 2 2\\n1 1 1\\n\") == \"1\");\n    assert(solution(\"3 3 9\\n2 1 3\\n1 2 3\\n3 3 3\\n\") == \"1\");\n    assert(solution(\"2 2 4 \\n1 2 \\n3 4 \\n\") == \"1\");\n    assert(solution(\"2 4 4 \\n1 2 3 4 \\n1 2 2 1 \\n\") == \"0\");\n    assert(solution(\"5 5 5 \\n1 1 1 1 1 \\n2 2 2 2 2 \\n3 3 3 3 3 \\n4 4 4 4 4 \\n5 5 5 5 5 \\n\") == \"20\");\n    return 0; \n}", "prompt": "/*Just like humans enjoy playing the game of Hopscotch, Farmer John's cows have invented a variant of the game for themselves to play. Being played by clumsy animals weighing nearly a ton, Cow Hopscotch almost always ends in disaster, but this has surprisingly not deterred the cows from attempting to play nearly every afternoon.\n\nThe game is played on an R by C grid (2 <= R <= 750, 2 <= C <= 750), where each square is labeled with an integer in the range 1..K (1 <= K <= R*C). Cows start in the top-left square and move to the bottom-right square by a sequence of jumps, where a jump is valid if and only if\n\n1) You are jumping to a square labeled with a different integer than your current square,\n2) The square that you are jumping to is at least one row below the current square that you are on, and\n3) The square that you are jumping to is at least one column to the right of the current square that you are on.\n\nPlease help the cows compute the number of different possible sequences of valid jumps that will take them from the top-left square to the bottom-right square.\n\ninput_format:\nThe first line contains the integers R, C, and K.\n\nThe next R lines will each contain C integers, each in the range 1.. K.\n\noutput_format:\nOutput the number of different ways one can jump from the top-left square to the bottom-right square, mod 1000000007.\n*/\n\n#include<sstream>\n#include<stdlib.h>\n#include<algorithm>\n#include<math.h>\n#include<stdio.h>\n#include<vector>\n#include<string>\n#include<climits>\n#include<cstring>\n#include<iostream>\nusing namespace std;\n\n             \nstring solution(string std_in){\n    istringstream iss(std_in);\n             ", "constraints": "", "samples": [["4 4 4 \n1 1 1 1 \n1 3 2 1 \n1 2 4 1 \n1 1 1 1 \n", "5 \n"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}}
{"task_id": "P2959", "title": "[USACO09OCT]The Leisurely Stroll G", "difficulty": "challenge", "nl": "Bessie looks out the barn door at the beautiful spring day and thinks to herself, 'I'd really like to enjoy my walk out to the pastures for the tender spring grass.' She knows that once she leaves the barn, she will traverse a path for a while, take one of two choices that lead to other paths, follow one of them, take one of two other choices, and continue on until the path leads to a verdant pasture.\n\nShe decides to make the set of path choices that enables her to walk over the greatest number of cow paths on her way to breakfast. Given the description of these paths, determine how many cow paths she traverses, presuming that she commences choosing various paths as soon as she leaves the barn.\n\nThe farm has P (1 <= P <= 1,000) pastures that are lead to by P-1 choice-nodes (range 1..P-1) connected by paths. From the barn (which is node 1), only one set of path traversals exists to reach any choice-node or pasture.\n\nConsider this set of paths (lines), pastures ('%'), and the highlighted ('#') route to a pasture on the right:\n\n```cpp\n\n                 %                             %\n                /                             /\n      2----%   7----8----%          2----%   7####8----%\n     / \\      /      \\             # #      #      #\n    1   5----6        9----%      1   5####6        9----%\n     \\   \\    \\        \\           \\   \\    \\        #\n      \\   %    %        %           \\   %    %        %\n       \\                             \\\n        3-----%                       3-----%\n         \\                             \\\n          4----%                        4----%\n           \\                             \\\n            %                             %\n```\nThe pasture reached from choice-node 9 is one of two that enable Bessie to traverse seven different cowpaths on the way to breakfast. These are the 'furthest' pastures from node 1, the barn.\n\nThree integers describe each node: Cn, D1, and D2. Cn is the\n\nnodenumber (1 <= Cn <= P-1); D1 and D2 are the destinations from that node (0 <= D1 <= P-1; 0 <= D2 <= P-1). If D1 is 0, the node leads to a pasture in that direction; D2 has the same property.\n\nPOINTS: 100", "code": "#include<bits/stdc++.h>//万能头\nusing namespace std;\nint p,a[1010],b[1010],c,n;//a[x],b[x]是分岔节点x通向的两块区域，n是答案 \nvoid dfs(int m,int s)//到达分岔节点m，共走过了s个分岔节点\n{\n\tif(a[m]!=0)dfs(a[m],s+1);//如果不是牧场就前往这个分岔节点\n\tif(b[m]!=0)dfs(b[m],s+1);//同上\n\tn=max(n,s);//更新答案\n}\nint main()\n{\n\tcin>>p;\n\tfor(int x=1;x<p;x++)cin>>c,cin>>a[c]>>b[c];//输入 \n\tdfs(1,1),cout<<n;//输出 \n\treturn 0;\n}", "step": ["Initialize variables and read in input values to create the binary tree", "Call recursive dfs function with starting node 1 and initial depth 0", "In the dfs function, check if current node has any children, and recursively call dfs on them if they exist", "If current node is a leaf node (has no children), calculate and update the maximum depth seen so far in the 'ans' variable", "Return the maximum depth 'ans' from main function"], "nl_cn": "Bessie looks out the barn door at the beautiful spring day and thinks to herself, 'I'd really like to enjoy my walk out to the pastures for the tender spring grass.' She knows that once she leaves the barn, she will traverse a path for a while, take one of two choices that lead to other paths, follow one of them, take one of two other choices, and continue on until the path leads to a verdant pasture.\n\nShe decides to make the set of path choices that enables her to walk over the greatest number of cow paths on her way to breakfast. Given the description of these paths, determine how many cow paths she traverses, presuming that she commences choosing various paths as soon as she leaves the barn.\n\nThe farm has P (1 <= P <= 1,000) pastures that are lead to by P-1 choice-nodes (range 1..P-1) connected by paths. From the barn (which is node 1), only one set of path traversals exists to reach any choice-node or pasture.\n\nConsider this set of paths (lines), pastures ('%'), and the highlighted ('#') route to a pasture on the right:\n\n```cpp\n\n                 %                             %\n                /                             /\n      2----%   7----8----%          2----%   7####8----%\n     / \\      /      \\             # #      #      #\n    1   5----6        9----%      1   5####6        9----%\n     \\   \\    \\        \\           \\   \\    \\        #\n      \\   %    %        %           \\   %    %        %\n       \\                             \\\n        3-----%                       3-----%\n         \\                             \\\n          4----%                        4----%\n           \\                             \\\n            %                             %\n```\nThe pasture reached from choice-node 9 is one of two that enable Bessie to traverse seven different cowpaths on the way to breakfast. These are the 'furthest' pastures from node 1, the barn.\n\nThree integers describe each node: Cn, D1, and D2. Cn is the\n\nnodenumber (1 <= Cn <= P-1); D1 and D2 are the destinations from that node (0 <= D1 <= P-1; 0 <= D2 <= P-1). If D1 is 0, the node leads to a pasture in that direction; D2 has the same property.\n\nPOINTS: 100\n\nBessie透过牛棚的大门向外望去。发现今天是一个美丽的春季早晨。她想，“我真的好想好想沐浴着春风，走在草地之中，感受嫩草温柔地抚摸四蹄地的感觉。”她知道一旦她离开了牛棚，她将沿着一条小径走一段路，然后就会出现一个三岔路口，她必须在两条小径中选择一条继续走下去。然后她又会遇到更多的三岔路口，进行更多的选择，知道她到达一个青翠的牧场为止。\n\n她决定作一个选择使得她在去吃早草的路途中可以走过最多的小径。给你这些小径的描述，求出Bessie最多可以走过多少条小径。假定Bessie一出牛棚就有2条路径，Bessie需要从中选择一条。\n\n农场中有P-1 (1 <= P <= 1,000) 个分岔节点（范围是1..P），引向P片草地，它们之间由小径连接。对任意一个节点来说，只有一条从牛棚（被标记为节点1）开始的路径可以到达。\n\n考虑下面的图。线段表示小径，\"%\"表示草地。右边的图中的\"#\"表示一条到达草地的高亮的路径。\n\n从分岔节点9到达的草地是两个可以让Bessie走过最多小径的草地之一。在去吃早草的路上Bessie将走过7条不同的小径。这些草地是离牛棚也就是节点1最“远”的。\n\n由3个整数来表示每一个节点：Cn, D1和D2，Cn是节点的编号(1 <= Cn <= P-1); D1和D2是由该节点引出的两条小径的终点(0 <= D1 <= P-1; 0 <= D2 <= P-1)。如果D1为0，表示这条小径引向的是一片牧草地；D2也一样。\n", "test_cases": [{"input": "10 \n7 8 0 \n5 0 6 \n9 0 0 \n6 0 7 \n3 4 0 \n2 5 0 \n8 0 9 \n4 0 0 \n1 2 3 \n", "output": "7"}, {"input": "6 \n2 0 0 \n1 3 0 \n3 0 4 \n4 5 0 \n5 6 0 \n", "output": "5"}, {"input": "6 \n2 0 0 \n5 0 4 \n4 0 0 \n1 3 0 \n3 0 5 \n", "output": "4"}, {"input": "10\n7 8 0\n5 0 6\n9 0 0\n6 0 7\n3 4 0\n2 5 0\n8 0 9\n4 0 0\n1 2 3\n", "output": "7"}, {"input": "8\n0 6 0\n2 0 3\n6 7 8\n5 0 0\n3 4 5\n4 0 0\n1 2 6\n", "output": "4"}, {"input": "4\n3 4 0\n0 0 0\n2 3 0\n1 2 0\n", "output": "1"}, {"input": "10\n4 5 0\n9 0 0\n0 0 0\n3 4 0\n1 2 3\n2 0 4\n8 0 9\n6 7 0\n7 8 0\n5 6 0\n", "output": "4"}, {"input": "6\n3 5 0\n0 4 0\n5 6 0\n1 2 5\n6 0 0\n4 0 5\n", "output": "3"}, {"input": "5\n0 4 5\n4 0 0\n1 2 4\n2 0 0\n3 0 0\n", "output": "2"}, {"input": "8\n7 0 8\n6 7 0\n2 4 0\n8 0 9\n3 4 0\n1 2 0\n9 0 0\n4 5 0\n", "output": "3"}, {"input": "6 \n2 3 0 \n1 0 2 \n4 5 0 \n3 4 0 \n5 6 0 \n6 0 1 \n", "output": "6"}, {"input": "10 \n7 8 0 \n5 0 6 \n9 0 0 \n6 0 7 \n3 4 0 \n2 5 0 \n8 0 9 \n4 0 0 \n1 2 0 \n", "output": "7"}, {"input": "13 \n9 12 0 \n7 0 8 \n11 0 0 \n8 9 0 \n3 7 0 \n10 0 11 \n5 6 0 \n6 0 7 \n2 0 3 \n1 4 0 \n4 5 0 \n12 0 0 \n", "output": "8"}, {"input": "6 \n5 0 6 \n4 5 0 \n2 3 0 \n1 2 0 \n6 0 0 \n", "output": "3"}, {"input": "4 \n2 0 3 \n3 0 0 \n1 4 0 \n", "output": "2"}, {"input": "4 \n1 3 0 \n2 0 4 \n3 0 0 \n", "output": "2"}, {"input": "6 \n1 3 0 \n3 0 4 \n2 5 6 \n4 0 0 \n5 0 0 \n", "output": "3"}, {"input": "6 \n2 0 4 \n5 6 0 \n1 3 5 \n4 0 0 \n6 0 0 \n", "output": "3"}, {"input": "5 \n2 4 0 \n3 0 0 \n1 5 0 \n4 0 0 \n", "output": "2"}], "test": "#undef NDEBUG\n#include<assert.h>\nint main(){\n    assert(solution(\"10 \\n7 8 0 \\n5 0 6 \\n9 0 0 \\n6 0 7 \\n3 4 0 \\n2 5 0 \\n8 0 9 \\n4 0 0 \\n1 2 3 \\n\") == \"7\");\n    assert(solution(\"6 \\n2 0 0 \\n1 3 0 \\n3 0 4 \\n4 5 0 \\n5 6 0 \\n\") == \"5\");\n    assert(solution(\"6 \\n2 0 0 \\n5 0 4 \\n4 0 0 \\n1 3 0 \\n3 0 5 \\n\") == \"4\");\n    assert(solution(\"10\\n7 8 0\\n5 0 6\\n9 0 0\\n6 0 7\\n3 4 0\\n2 5 0\\n8 0 9\\n4 0 0\\n1 2 3\\n\") == \"7\");\n    assert(solution(\"8\\n0 6 0\\n2 0 3\\n6 7 8\\n5 0 0\\n3 4 5\\n4 0 0\\n1 2 6\\n\") == \"4\");\n    assert(solution(\"4\\n3 4 0\\n0 0 0\\n2 3 0\\n1 2 0\\n\") == \"1\");\n    assert(solution(\"10\\n4 5 0\\n9 0 0\\n0 0 0\\n3 4 0\\n1 2 3\\n2 0 4\\n8 0 9\\n6 7 0\\n7 8 0\\n5 6 0\\n\") == \"4\");\n    assert(solution(\"6\\n3 5 0\\n0 4 0\\n5 6 0\\n1 2 5\\n6 0 0\\n4 0 5\\n\") == \"3\");\n    assert(solution(\"5\\n0 4 5\\n4 0 0\\n1 2 4\\n2 0 0\\n3 0 0\\n\") == \"2\");\n    assert(solution(\"8\\n7 0 8\\n6 7 0\\n2 4 0\\n8 0 9\\n3 4 0\\n1 2 0\\n9 0 0\\n4 5 0\\n\") == \"3\");\n    assert(solution(\"6 \\n2 3 0 \\n1 0 2 \\n4 5 0 \\n3 4 0 \\n5 6 0 \\n6 0 1 \\n\") == \"6\");\n    assert(solution(\"10 \\n7 8 0 \\n5 0 6 \\n9 0 0 \\n6 0 7 \\n3 4 0 \\n2 5 0 \\n8 0 9 \\n4 0 0 \\n1 2 0 \\n\") == \"7\");\n    assert(solution(\"13 \\n9 12 0 \\n7 0 8 \\n11 0 0 \\n8 9 0 \\n3 7 0 \\n10 0 11 \\n5 6 0 \\n6 0 7 \\n2 0 3 \\n1 4 0 \\n4 5 0 \\n12 0 0 \\n\") == \"8\");\n    assert(solution(\"6 \\n5 0 6 \\n4 5 0 \\n2 3 0 \\n1 2 0 \\n6 0 0 \\n\") == \"3\");\n    assert(solution(\"4 \\n2 0 3 \\n3 0 0 \\n1 4 0 \\n\") == \"2\");\n    assert(solution(\"4 \\n1 3 0 \\n2 0 4 \\n3 0 0 \\n\") == \"2\");\n    assert(solution(\"6 \\n1 3 0 \\n3 0 4 \\n2 5 6 \\n4 0 0 \\n5 0 0 \\n\") == \"3\");\n    assert(solution(\"6 \\n2 0 4 \\n5 6 0 \\n1 3 5 \\n4 0 0 \\n6 0 0 \\n\") == \"3\");\n    assert(solution(\"5 \\n2 4 0 \\n3 0 0 \\n1 5 0 \\n4 0 0 \\n\") == \"2\");\n    return 0; \n}", "prompt": "/*Bessie looks out the barn door at the beautiful spring day and thinks to herself, 'I'd really like to enjoy my walk out to the pastures for the tender spring grass.' She knows that once she leaves the barn, she will traverse a path for a while, take one of two choices that lead to other paths, follow one of them, take one of two other choices, and continue on until the path leads to a verdant pasture.\n\nShe decides to make the set of path choices that enables her to walk over the greatest number of cow paths on her way to breakfast. Given the description of these paths, determine how many cow paths she traverses, presuming that she commences choosing various paths as soon as she leaves the barn.\n\nThe farm has P (1 <= P <= 1,000) pastures that are lead to by P-1 choice-nodes (range 1..P-1) connected by paths. From the barn (which is node 1), only one set of path traversals exists to reach any choice-node or pasture.\n\nConsider this set of paths (lines), pastures ('%'), and the highlighted ('#') route to a pasture on the right:\n\n```cpp\n\n                 %                             %\n                /                             /\n      2----%   7----8----%          2----%   7####8----%\n     / \\      /      \\             # #      #      #\n    1   5----6        9----%      1   5####6        9----%\n     \\   \\    \\        \\           \\   \\    \\        #\n      \\   %    %        %           \\   %    %        %\n       \\                             \\\n        3-----%                       3-----%\n         \\                             \\\n          4----%                        4----%\n           \\                             \\\n            %                             %\n```\nThe pasture reached from choice-node 9 is one of two that enable Bessie to traverse seven different cowpaths on the way to breakfast. These are the 'furthest' pastures from node 1, the barn.\n\nThree integers describe each node: Cn, D1, and D2. Cn is the\n\nnodenumber (1 <= Cn <= P-1); D1 and D2 are the destinations from that node (0 <= D1 <= P-1; 0 <= D2 <= P-1). If D1 is 0, the node leads to a pasture in that direction; D2 has the same property.\n\nPOINTS: 100\n\ninput_format:\n```\n\\* Line 1: A single integer: P\n\n\\* Lines 2..P: Line i+1 contains three space-separated integers that describe a choice-node: Cn, D1, and D2\n```\n\n```\n\\* Line 1: A single integer: P\n\n\\* Lines 2..P: Each line contains three space-separated integers that represent a choice-node: Cn, D1, and D2\n```\n\nNote: The translation may vary depending on the context.\n\noutput_format:\n\\* Line 1: A single integer that is the largest number of paths Bessie can traverse on the way to the furthest pasture.\n*/\n\n#include<sstream>\n#include<stdlib.h>\n#include<algorithm>\n#include<math.h>\n#include<stdio.h>\n#include<vector>\n#include<string>\n#include<climits>\n#include<cstring>\n#include<iostream>\nusing namespace std;\n\n             \nstring solution(string std_in){\n    istringstream iss(std_in);\n             ", "constraints": "This input describes the example farm layout in the task description.\n\n\n1-2-5-6-7-8-9-P is one of the longest routes.\n", "samples": [["10 \n7 8 0 \n5 0 6 \n9 0 0 \n6 0 7 \n3 4 0 \n2 5 0 \n8 0 9 \n4 0 0 \n1 2 3 \n", "7 \n"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}}
{"task_id": "P8199", "title": "[传智杯 #4 决赛] 游戏", "difficulty": "challenge", "nl": "PUBG Backpack\n\nPentium has just landed with a parachute, surrounded by danger. He has an initial backpack in his hand, and all the supplies he picks up will be placed in this backpack. The game map is simplified to an $n \\times m$ grid, where each grid contains either supplies or enemies.\n\nSupplies include primary/secondary weapons and ammunition, which are further divided into bullets and throwable items. Each weapon corresponds to a certain type of bullet. For example, Beryl M762 assault rifle uses 7.62mm bullets, M416 assault rifle uses 5.56mm bullets, and AKM assault rifle also uses 7.62mm bullets.\n\nWhen Pentium reaches a grid containing supplies, he will pick up what is on the ground and put it in the backpack. However, the backpack has limited capacity, so when it is full, he will have to discard some supplies to make room for new ones. He will discard the supplies according to the following rules:\n1. If what he picks up is a weapon, he will replace it based on the priorities: shotgun > assault rifle > marksman rifle > bolt-action rifle > empty hands. He will prioritize replacing the primary weapon, and the priority of primary weapons must be strictly higher than that of the secondary weapons. If he replaces the primary weapon, the replaced primary weapon will be **discarded directly** and will not be used to replace the secondary weapon.\n2. If there are unnecessary bullets (i.e. bullets that are not used in either the primary or the secondary weapon), he will discard these bullets first, until there is enough space for new supplies.\n3. If after discarding all unnecessary bullets there is still not enough space, or there are multiple types of unnecessary bullets, he will discard the ammunition (including bullets and throwable items) picked up the latest but with the earliest pick-up time, until there is enough space for new supplies (it should be noted that even if the new supplies are \"unnecessary bullets\", Pentium will still discard other ammunition until all \"unnecessary bullets\" have been picked up if there is not enough space after discarding all original \"unnecessary bullets\").\n4. Regardless of whether what he picks up is a new supply or an existing one, the pick-up time of the supply will be updated to the current time.\n5. A maximum of two types of weapons, i.e. primary/secondary weapons, can be held at the same time, and weapons with the same priority will not be replaced.\n\nEach supply in a grid can only be picked up once. When Pentium enters a grid for the second time, the supplies will not refresh. That is, he will neither pick up the discarded supplies from the last time he was there, nor will he pick up the initial supplies again.\n\nWhen Pentium enters a grid containing an enemy, he will engage in battle. His combat power is very strong, and he only needs enough bullets to eliminate the enemy. Each enemy has two parameters $a,b$, which represent the consumption of $a$ primary weapon bullets. If there are not enough primary weapon bullets, the primary weapon will not be consumed, and $b$ secondary weapon bullets will be consumed instead. If there are not enough bullets in both the primary and the secondary weapon, Pentium will be counterkilled by the enemy, and then the enemy will mock him by squatting on Pentium's box.\n\nEach grid containing an enemy will only appear once. If Pentium enters a grid containing an enemy for the second time, nothing will happen.\n\nNow, Pentium has landed on the grid in the first row and first column, and ATA_Radio_STN has figured out the map situation for him, while sltheen will give Pentium instructions. Pentium wants to know whether he will still be alive after completing the last instruction. If he survives, output the types and quantities of supplies in the backpack in the order of the pick-up time from latest to earliest. If he dies, output the coordinates of the grid where he dies.\n\nThe table below shows the possible supplies, their categories, the types of bullets used, the space they occupy, and their corresponding numbers.\n\nWeapons:\n| Weapon | Type | Type of Bullet | Number |\n| --- | --- | ---  | ---|\n| Empty hands |  Empty hands | N/A | 0|\n| Beryl M762 | assault rifle | 7.62mm bullets | 1 |\n| AKM | assault rifle | 7.62mm bullets | 2 |\n| SKS | marksman rifle | 7.62mm bullets | 3 |\n| Kar98K | bolt-action rifle | 7.62mm bullets | 4 |\n| M416 | assault rifle | 5.56mm bullets | 5 |\n| MK12 | marksman rifle | 5.56mm bullets | 6 |\n| Mini14 | marksman rifle | 5.56mm bullets | 7 |\n| S686 | shotgun | 12 gauge shotgun shells | 8 |\n| DBS | shotgun | 12 gauge shotgun shells | 9 |\n\nAmmunition\n| Name | Type | Space | Number |\n| - | - | - | - |\n| Frag Grenade | throwable item | 5 | 10 |\n| Smoke Grenade | throwable item | 4 | 11 |\n| Molotov Cocktail | throwable item | 3 | 12 |\n| Flashbang | throwable item | 2 | 13 |\n| 7.62mm | bullet | 0.2 | 14 |\n| 5.56mm | bullet | 0.1 | 15 |\n| 3in (12 gauge shotgun shells) | bullet | 0.5 | 16 |\n\nNote that the \"space\" of a bullet in the table above refers to the space occupied by a bullet.\n\nIn addition, enemies on the map have the number 17.", "code": "#include <array>\n#include <iostream>\n#include <algorithm>\n\nconst int maxn = 105;\n\nint n, m, s, t, w1, w2, lst;\n\nstd::array<std::array<int, maxn>, maxn> type, a, b, vis;\nstd::array<int, maxn> tm, arr, cnt;\nconst std::array<int, 5> dx{0, -1, 1, 0, 0}, dy{0, 0, 0, -1, 1};\nconst std::array<int, 10> use{0,  14, 14, 14, 14, 15, 15, 15, 16, 16}, level{5, 2, 2, 3, 4, 2, 3, 3, 1, 1};\nconst std::array<int, 17> weight{0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 50, 40, 30, 20, 2, 1, 5};\n\ninline bool used(int x) { return x && ((x <= 13) ? true : (use[w1] == x || use[w2] == x)); }\ninline bool cmp(const int x, const int y) { return tm[x] > tm[y]; }\n\nvoid work(int curx, int cury) {\n  vis[curx][cury] = true;\n  if (type[curx][cury] == 17) {\n    if (cnt[use[w1]] >= a[curx][cury]) {\n      cnt[use[w1]] -= a[curx][cury];\n      lst += a[curx][cury] * weight[use[w1]];\n    } else if (cnt[use[w2]] >= b[curx][cury]) {\n      cnt[use[w2]] -= b[curx][cury];\n      lst += b[curx][cury] * weight[use[w2]];\n    } else {\n      std::cout << curx << ' ' << cury << '\\n';\n      exit(0);\n    }\n  } else if (type[curx][cury] < 10) {\n    if (level[w1] > level[type[curx][cury]]) w1 = type[curx][cury];\n    else if (level[w1] < level[type[curx][cury]] && level[w2] > level[type[curx][cury]]) w2 = type[curx][cury];\n  } else {\n    lst -= a[curx][cury] * weight[type[curx][cury]];\n    for (int i = 0; lst < 0; i = 0) {\n      for (int p = 10; p < 17; ++p) if (cnt[p]) \n        if ((!cnt[i]) || (used(p) < used(i)) || ((used(p) == used(i)) && (tm[p] > tm[i]))) i = p;\n      int tmp = std::min(cnt[i], (-lst) / weight[i] + ((lst % weight[i]) ? 1 : 0));\n      lst += tmp * weight[i];\n      cnt[i] -= tmp;\n    }\n    tm[type[curx][cury]] = t;\n    cnt[type[curx][cury]] += a[curx][cury];\n  }\n}\n\nint main() {\n  std::cin >> n >> m >> s >> t; lst = s *= 10;\n  for (int i = 1; i <= n; ++i) \n    for (int j = 1; j <= m; ++j) {\n      std::cin >> type[i][j] >> a[i][j];\n      if (type[i][j] == 17) \n        std::cin >> b[i][j];\n    }\n  tm.fill(998244353); \n  work(1, 1);\n  --t;\n  for (int op, curx = 1, cury = 1; ~t; --t) {\n    std::cin >> op;\n    if (vis[curx += dx[op]][cury += dy[op]]) continue;\n    work(curx, cury);\n  }\n  for (int i = 10; i < 17; ++i) arr[i] = i;\n  std::sort(arr.begin() + 10, arr.begin() + 17, cmp);\n  std::cout << w1 << '\\n' << w2  << '\\n';\n  for (int i = 1; i < 17; ++i) if (cnt[arr[i]] != 0) \n    std::cout << arr[i] << ' ' << cnt[arr[i]] << '\\n';\n}", "step": ["Read input: the map, player inventory, and time limit.", "Work on the starting cell and every other cell", "Handle events that happen during each move until the time runs out", "Sort the inventory based on priority and print the final inventory"], "nl_cn": "喷火刚刚跳伞落地，周围危机四伏，他的手中有一个初始背包，他捡到的所有物资都会装在这个背包里，游戏地图被简化为一个 $n \\times m$ 的网格图，每个格子里要么是物资，要么是敌人。\n\n物资分为主/副武器和弹药，其中弹药又分为子弹与投掷物。每种武器会对应使用某种子弹。例如：Beryl M762 突击步枪使用 7.62mm 子弹，M416 突击步枪使用 5.56mm 子弹，而 AKM 突击步枪也使用 7.62mm 子弹。\n\n当喷火走到一个含有物资的格子的时候，他会拾起地上的物资并放入背包。但背包容量有限，因此当背包装满的时候，他将会扔掉一部分物资以装下新的物资。他将按照以下规则丢弃物资：\n1.\t如果捡到的是武器，那么按照霰弹枪>突击步枪>射手步枪>栓动步枪>空手的优先级进行替换。优先替换主武器，且主武器优先级必须严格高于副武器。如果替换主武器，那么替换下来的主武器被**直接丢弃**，不再用其替换副武器。\n2.\t若有不需要的子弹（指主副武器均不使用的子弹），最优先丢掉这些子弹，直至空间足够装下新的物资。\n3.\t若丢掉全部不需要子弹后空间仍旧不足，或有多种不需要的子弹，优先丢掉最晚拾取时间最早的弹药（包括主副武器使用的子弹和投掷物），直至空间足够装下新的物资（需要注意的是，即使新物资是「不需要的子弹」，在丢掉所有原有的「不需要的子弹」后如果背包空间还是不够，则喷火依然会丢掉其他弹药直到捡起所有「不需要的子弹」）。\n4.\t无论捡到的是新物资，还是已经有的物资，该物资的最晚拾取时间都将被更新为当前时间点。\n5.\t武器最多同时持有两种，即主/副武器，同优先级的主/副武器不进行替换。\n\n每个格子的物资只会拾取一次。当第二次进入某个格子的时候，物品不会刷新，即不会捡起上次在这个格子丢掉的物品，也不会再次捡到初始时的物品。\n\n当喷火走到含有敌人的格子的时候，他会与敌人进行战斗，他的战斗力很强悍，只需要有足够的子弹即可消灭敌人。每个敌人有两个参数 $a,b$，代表需要消耗 $a$ 发主武器子弹，若主武器子弹不够，则不消耗主武器子弹，而消耗 $b$ 发副武器子弹。若主副武器均没有足够子弹，则喷火被敌人反杀，然后敌人会在喷火的盒子上做蹲起嘲讽他。\n\n每个格子的敌人只会出现一次。如果第二次进入某一个有敌人的格子，则什么都不会发生。\n\n现在，喷火跳在了第一行第一列的格子上，ATA_Radio_STN 已经为喷火摸清了地图形势，而 sltheen 会给喷火下指示，喷火想知道，当他执行完最后一条指示之后，他是否还存活，若存活，按照最晚拾取时间时间从早到晚，输出背包内物品种类和数量，若死亡，输出他死亡格子的坐标。\n\n下附可能出现的物资、物资类别、物资使用的子弹种类、物资所需空间以及物资对应编号。\n\n武器：\n| 武器名称 | 武器类型| 使用的子弹类型 | 编号 |\n| --- | --- | ---  | ---|\n| 空手 | 空手 | N/A | 0|\n|BerylM762|突击步枪|7.62mm子弹|1|\n|AKM|突击步枪|7.62mm子弹|2|\n|SKS|射手步枪|7.62mm子弹|3|\n|Kar98K|栓动步枪|7.62mm子弹|4|\n|M416|突击步枪|5.56mm子弹|5|\n|MK12|射手步枪|5.56mm子弹|6|\n|Mini14|射手步枪|5.56mm子弹|7|\n|S686|霰弹枪|12号霰弹|8|\n|DBS|霰弹枪|12号霰弹|9|\n\n弹药\n|弹药名称| 类型 | 占用空间 | 编号 |\n| - | - | - | - |\n|FragGrenade|投掷物| 5  |   10|\n|SmokeGrenade| 投掷物 |    4|    11|\n|MolotovCocktail |投掷物  | 3 |    12|\n|Flashbang |投掷物        | 2    | 13|\n|7.62mm |子弹 |0.2|                14|\n|5.56mm| 子弹| 0.1                |15|\n|3in（12号霰弹）| 子弹| 0.5|                     16|\n\n请注意，上表中子弹的「占用空间」表示一发子弹所占用的空间。\n\n另外，敌人在地图上的编号为 17。\n\n", "test_cases": [{"input": "3 3 60 8\n1 1\n14 300\n15 30\n5 1\n10 1\n17 11 10\n17 10 10\n17 10 10\n15 10\n4\n4\n2\n3\n3\n2\n4\n4\n", "output": "1\n0\n14 254\n10 1\n15 12"}], "test": "#undef NDEBUG\n#include<assert.h>\nint main(){\n    assert(solution(\"3 3 60 8\\n1 1\\n14 300\\n15 30\\n5 1\\n10 1\\n17 11 10\\n17 10 10\\n17 10 10\\n15 10\\n4\\n4\\n2\\n3\\n3\\n2\\n4\\n4\\n\") == \"1\\n0\\n14 254\\n10 1\\n15 12\");\n    return 0; \n}", "prompt": "/*PUBG Backpack\n\nPentium has just landed with a parachute, surrounded by danger. He has an initial backpack in his hand, and all the supplies he picks up will be placed in this backpack. The game map is simplified to an $n \\times m$ grid, where each grid contains either supplies or enemies.\n\nSupplies include primary/secondary weapons and ammunition, which are further divided into bullets and throwable items. Each weapon corresponds to a certain type of bullet. For example, Beryl M762 assault rifle uses 7.62mm bullets, M416 assault rifle uses 5.56mm bullets, and AKM assault rifle also uses 7.62mm bullets.\n\nWhen Pentium reaches a grid containing supplies, he will pick up what is on the ground and put it in the backpack. However, the backpack has limited capacity, so when it is full, he will have to discard some supplies to make room for new ones. He will discard the supplies according to the following rules:\n1. If what he picks up is a weapon, he will replace it based on the priorities: shotgun > assault rifle > marksman rifle > bolt-action rifle > empty hands. He will prioritize replacing the primary weapon, and the priority of primary weapons must be strictly higher than that of the secondary weapons. If he replaces the primary weapon, the replaced primary weapon will be **discarded directly** and will not be used to replace the secondary weapon.\n2. If there are unnecessary bullets (i.e. bullets that are not used in either the primary or the secondary weapon), he will discard these bullets first, until there is enough space for new supplies.\n3. If after discarding all unnecessary bullets there is still not enough space, or there are multiple types of unnecessary bullets, he will discard the ammunition (including bullets and throwable items) picked up the latest but with the earliest pick-up time, until there is enough space for new supplies (it should be noted that even if the new supplies are \"unnecessary bullets\", Pentium will still discard other ammunition until all \"unnecessary bullets\" have been picked up if there is not enough space after discarding all original \"unnecessary bullets\").\n4. Regardless of whether what he picks up is a new supply or an existing one, the pick-up time of the supply will be updated to the current time.\n5. A maximum of two types of weapons, i.e. primary/secondary weapons, can be held at the same time, and weapons with the same priority will not be replaced.\n\nEach supply in a grid can only be picked up once. When Pentium enters a grid for the second time, the supplies will not refresh. That is, he will neither pick up the discarded supplies from the last time he was there, nor will he pick up the initial supplies again.\n\nWhen Pentium enters a grid containing an enemy, he will engage in battle. His combat power is very strong, and he only needs enough bullets to eliminate the enemy. Each enemy has two parameters $a,b$, which represent the consumption of $a$ primary weapon bullets. If there are not enough primary weapon bullets, the primary weapon will not be consumed, and $b$ secondary weapon bullets will be consumed instead. If there are not enough bullets in both the primary and the secondary weapon, Pentium will be counterkilled by the enemy, and then the enemy will mock him by squatting on Pentium's box.\n\nEach grid containing an enemy will only appear once. If Pentium enters a grid containing an enemy for the second time, nothing will happen.\n\nNow, Pentium has landed on the grid in the first row and first column, and ATA_Radio_STN has figured out the map situation for him, while sltheen will give Pentium instructions. Pentium wants to know whether he will still be alive after completing the last instruction. If he survives, output the types and quantities of supplies in the backpack in the order of the pick-up time from latest to earliest. If he dies, output the coordinates of the grid where he dies.\n\nThe table below shows the possible supplies, their categories, the types of bullets used, the space they occupy, and their corresponding numbers.\n\nWeapons:\n| Weapon | Type | Type of Bullet | Number |\n| --- | --- | ---  | ---|\n| Empty hands |  Empty hands | N/A | 0|\n| Beryl M762 | assault rifle | 7.62mm bullets | 1 |\n| AKM | assault rifle | 7.62mm bullets | 2 |\n| SKS | marksman rifle | 7.62mm bullets | 3 |\n| Kar98K | bolt-action rifle | 7.62mm bullets | 4 |\n| M416 | assault rifle | 5.56mm bullets | 5 |\n| MK12 | marksman rifle | 5.56mm bullets | 6 |\n| Mini14 | marksman rifle | 5.56mm bullets | 7 |\n| S686 | shotgun | 12 gauge shotgun shells | 8 |\n| DBS | shotgun | 12 gauge shotgun shells | 9 |\n\nAmmunition\n| Name | Type | Space | Number |\n| - | - | - | - |\n| Frag Grenade | throwable item | 5 | 10 |\n| Smoke Grenade | throwable item | 4 | 11 |\n| Molotov Cocktail | throwable item | 3 | 12 |\n| Flashbang | throwable item | 2 | 13 |\n| 7.62mm | bullet | 0.2 | 14 |\n| 5.56mm | bullet | 0.1 | 15 |\n| 3in (12 gauge shotgun shells) | bullet | 0.5 | 16 |\n\nNote that the \"space\" of a bullet in the table above refers to the space occupied by a bullet.\n\nIn addition, enemies on the map have the number 17.\n\ninput_format:\nThe first row has four integers, which in turn represent the number of map rows $n$, the number of columns $m$, the backpack capacity $k$, and the number of commands sltheen will issue $t$.\nIn the next $n\\times m$line, the $i$line represents the map of the $\\lfloor\\frac{i-1}{n}\\rfloor+1$line, and the $(i-1)\\%n+1$column. Where $i \\% n$represents the remainder of $i$divided by $n$:\n- If the material is here, there is an integer in this line separated by two Spaces, the material number is $x$and the quantity of the material is $y$, the material number is shown in the last column of the table in the \"Description of the topic\" (if the material is a gun, $y = 1$is guaranteed);\n- If the field is an enemy, the line contains three integers separated by Spaces. The first integer is $17$, indicating the enemy, and the next two integers indicate the enemy's $a and b$parameters.\n\nThe next $t$line, with an integer $op$on each line, indicates the direction sltheen's instructions for Spitfire move: 1 for up, 2 for down, 3 for left, and 4 for right. (The first column of the first row is the upper left corner of the map, and the first column of the last row is the lower left corner of the map)\n\noutput_format:\nIf the Spitfire dies, two numbers $u, v$are printed, representing the death of the Spitfire in row $u, column $v$.\n\nIf the spitfire does not die, first output two lines, the first line of the main weapon number, the second act of the secondary weapon number, and then output several lines, each act of two integer integers, separated by a space, the first integer is the name of the material, the second integer is its number, according to the last picked up time from morning to night.\n*/\n\n#include<sstream>\n#include<stdlib.h>\n#include<algorithm>\n#include<math.h>\n#include<stdio.h>\n#include<vector>\n#include<string>\n#include<climits>\n#include<cstring>\n#include<iostream>\nusing namespace std;\n\n             \nstring solution(string std_in){\n    istringstream iss(std_in);\n             ", "constraints": "### 数据规模与约定\n\n对于全部的测试点，保证：\n- $1 \\leq n, m \\leq 100$，且 $1 \\leq  n \\times m \\leq 100$。\n- $1 \\leq k \\leq 500$，$1 \\leq t,a,b  \\leq 200$。\n- $1 \\leq x \\leq 16$，$1 \\leq y \\leq 5000$。\n- $1 \\leq op \\leq 4$。\n- 数据保证每个格子内只有一种物资（或一个敌人），且背包能够装下任意一格的物资。", "samples": [["3 3 60 8\n1 1\n14 300\n15 30\n5 1\n10 1\n17 11 10\n17 10 10\n17 10 10\n15 10\n4\n4\n2\n3\n3\n2\n4\n4\n", "1\n0\n14 254\n10 1\n15 12\n"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288]}}
{"task_id": "P6368", "title": "[COCI2006-2007#6] MAGIJA", "difficulty": "challenge", "nl": "It is well-known that the back of a poker card is a rectangle, which can be divided into four equal parts through the perpendicular bisectors of its sides.\n\nAl'Dimi Kartimi first drew the pattern of the upper left corner, which contains $r$ rows and $m$ columns of characters `#` and `.`. Then he reflected the pattern along the perpendicular bisector of the right side of the rectangle to draw the upper right corner. Finally, he reflected the pattern along the perpendicular bisector of the bottom side of the rectangle to draw the lower half of the rectangle.\n\nAfter drawing, Al'Dimi Kartimi intentionally makes a small mistake to help him recognize which card it is. Specifically, he will choose the character at row $x$ and column $y$, and if this character is `#`, he will change it to `.`, otherwise he will change it to `#`.\n\nHere are three examples of back patterns of poker cards (the wrong characters are highlighted in gray).\n\n\n\nGiven the pattern of the upper left corner and the values of $x$ and $y$, please output the entire back pattern of the poker card.", "code": "#include <string>\n#include <iostream>\n#include <algorithm>\n\nconst int maxn = 105;\n\nint n, m, x, y;\nstd::string ans[maxn];\n\nint main() {\n  std::cin >> n >> m;\n  for (int i = 1; i <= n; ++i) {\n    std::cin >> ans[i];\n    std::string tmp = ans[i];\n    std::reverse(tmp.begin(), tmp.end());\n    ans[i] += tmp;\n  }\n  for (int i = n << 1, j = 1; i > n; --i) {\n    ans[i] = ans[j++];\n  }\n  std::cin >> x >> y;\n  --y;\n  ans[x][y] = (ans[x][y] == '#') ? '.' : '#';\n  for (int i = 1, dn = n << 1; i <= dn; ++i) {\n    std::cout << ans[i] << std::endl;\n  }\n  return 0;\n}", "step": ["Read in values for n and m from user input.", "For each i from 1 to n, read in a string and make a new string by reversing the original string and adding it to the end of the original string.", "Duplicate the first n strings at the end of the array.", "Read in values for x and y from user input and update the character at position y in string x to '#' if it was '.' and '.' if it was '#'.", "Print out all the strings in the array.", "Return 0."], "nl_cn": "众所周知，扑克牌的背面是一个矩形，通过做两边的中垂线可以将矩形分成相等的四部分。\n\nAl'Dimi Kartimi 首先绘制了左上角部分的图案，图案共有 $r$ 行 $m$ 列，由字符 `#` 和字符 `.` 组成。绘制完后，他将该图案沿矩形垂直方向的中垂线镜面对称地绘制了矩形右上角的部分。然后他沿矩形水平方向的中垂线镜面对称地绘制了矩形的下半部分。\n\n在绘制后，Al'Dimi Kartimi 会故意犯一个小错误，以此来帮助他识别这是哪张扑克牌的背面。具体的，他会选择第 $x$ 行第 $y$ 列的字符，若该字符是 `#`，则将其改成 `.`，否则将其改成 `#`。\n\n下面是三个背面图案的例子（错误的字符以灰色高亮）。\n\n\n\n给定左上角的图案以及 $x, y$，请输出整张扑克牌背面的图案。", "test_cases": [{"input": "2 2\n#.\n.#\n3 3\n", "output": "#..#\n.##.\n.#..\n#..#"}, {"input": "3 3\n###\n###\n###\n1 4\n", "output": "###.##\n######\n######\n######\n######\n######"}, {"input": "5 4\n#.#.\n#.##\n#.##\n....\n.#.#\n10 5\n", "output": "#.#..#.#\n#.####.#\n#.####.#\n........\n.#.##.#.\n.#.##.#.\n........\n#.####.#\n#.####.#\n#.#.##.#"}], "test": "#undef NDEBUG\n#include<assert.h>\nint main(){\n    assert(solution(\"2 2\\n#.\\n.#\\n3 3\\n\") == \"#..#\\n.##.\\n.#..\\n#..#\");\n    assert(solution(\"3 3\\n###\\n###\\n###\\n1 4\\n\") == \"###.##\\n######\\n######\\n######\\n######\\n######\");\n    assert(solution(\"5 4\\n#.#.\\n#.##\\n#.##\\n....\\n.#.#\\n10 5\\n\") == \"#.#..#.#\\n#.####.#\\n#.####.#\\n........\\n.#.##.#.\\n.#.##.#.\\n........\\n#.####.#\\n#.####.#\\n#.#.##.#\");\n    return 0; \n}", "prompt": "/*It is well-known that the back of a poker card is a rectangle, which can be divided into four equal parts through the perpendicular bisectors of its sides.\n\nAl'Dimi Kartimi first drew the pattern of the upper left corner, which contains $r$ rows and $m$ columns of characters `#` and `.`. Then he reflected the pattern along the perpendicular bisector of the right side of the rectangle to draw the upper right corner. Finally, he reflected the pattern along the perpendicular bisector of the bottom side of the rectangle to draw the lower half of the rectangle.\n\nAfter drawing, Al'Dimi Kartimi intentionally makes a small mistake to help him recognize which card it is. Specifically, he will choose the character at row $x$ and column $y$, and if this character is `#`, he will change it to `.`, otherwise he will change it to `#`.\n\nHere are three examples of back patterns of poker cards (the wrong characters are highlighted in gray).\n\n\n\nGiven the pattern of the upper left corner and the values of $x$ and $y$, please output the entire back pattern of the poker card.\n\ninput_format:\nThe first row has two integers representing the number of rows $r$and the number of columns $c$of the upper-left pattern.\n\nLines $2$to $(r + 1)$, each line a string of length $c$, $s_{i, j}$represents the character of the $j$column of the $i$row of the pattern.\n\nRow $(r + 2)$has two integers representing the number of rows $x$and the number of columns $y$where the small error is located.\n\noutput_format:\nOutput a $2r$line, each line a string of $2c$, representing the entire back pattern.\n*/\n\n#include<sstream>\n#include<stdlib.h>\n#include<algorithm>\n#include<math.h>\n#include<stdio.h>\n#include<vector>\n#include<string>\n#include<climits>\n#include<cstring>\n#include<iostream>\nusing namespace std;\n\n             \nstring solution(string std_in){\n    istringstream iss(std_in);\n             ", "constraints": "#### 数据规模与约定\n\n对于全部的测试点，保证：\n\n- $1 \\leq r, c \\leq 50$。\n- $1 \\leq x \\leq 2r$，$1 \\leq y \\leq 2c$。\n- $s_{i, j} \\in \\{\\texttt \\#, \\texttt . \\}$\n\n#### 说明\n\n**题目译自 [COCI2006-2007](https://hsin.hr/coci/archive/2006_2007/) [CONTEST #6](https://hsin.hr/coci/archive/2006_2007/contest6_tasks.pdf) *T2   MAGIJA***。", "samples": [["2 2\n#.\n.#\n3 3\n", "#..#\n.##.\n.#..\n#..#"], ["3 3\n###\n###\n###\n1 4\n", "###.##\n######\n######\n######\n######\n######"], ["5 4\n#.#.\n#.##\n#.##\n....\n.#.#\n10 5\n", "#.#..#.#\n#.####.#\n#.####.#\n........\n.#.##.#.\n.#.##.#.\n........\n#.####.#\n#.####.#\n#.#.##.#"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [32000, 32000, 32000, 32000, 32000, 32000, 32000, 32000, 32000, 32000]}}
{"task_id": "P2069", "title": "松鼠吃果子", "difficulty": "challenge", "nl": "There are n fruits that a squirrel likes to eat, arranged in a column from bottom to top and numbered from 1 to n. A squirrel jumps from the bottom to the top and can jump over (i^3 mod 5 + 1) fruits in the i-th jump, and eats the fruit it is on. If there is a fruit above, it will fall down one position due to gravity. For example, in the first jump, it can jump over 2 fruits starting from the first fruit, and eats the third fruit. In the second jump, it can jump over 4 fruits starting from the fourth fruit (which is the position of the third fruit after it falls down), and eats the eighth fruit. This continues until the squirrel jumps out of the front of the fruits every k jumps, without eating any fruit. Then it goes back to the bottom and does its k-th jump again to try to eat a fruit. What is the number of the m-th fruit it eats (i.e. the fruit it eats in the m-th jump)?", "code": "#include<iostream>\n#include<cmath>\n#include<algorithm>\n#include<cstdio>\n#include<cstring>\nusing namespace std;\nint mark[10010]; \nint main()\n{\n\tint n,m;\n\tint high=1;//初始位置是1 \n\tcin>>n>>m;\n\tfor(int i=1;i<=n;i++) mark[i]=i;//标记果子编号 \n\tfor(int i=1;i<=m;i++)//枚举m个果子 \n\t{\n\t\tint jump=(i*i*i)%5+1;//公式 \n\t\thigh+=jump;//当前位置加上跳跃的位置 \n\t\tif(high>n-i+1) high=jump+1;//加上位置完后如果长度超过n-i+1(总长度-之前跳的长度+1)，那么返回最下面 \n\t\tif(i!=m)//如果此时吃到的果子不是想要的第m枚 \n\t\t{\n\t\t\tfor(int j=high+1;j<=n-i+1;j++)//它位置之后的果子全部往下落一个 \n\t\t\t{\n\t\t\t\tmark[j-1]=mark[j];\n\t\t\t}\n\t\t}\n\t}\n\tcout<<mark[high]<<endl;//输出 \n\treturn 0;\n}", "step": ["Declare an integer array mark with size 10010.", "Read input integers n and m.", "Set high as 1.", "Initialize mark array from 1 to n with consecutive integer values.", "For each iteration of i from 1 to m, do the following:", "a. Calculate jump as (i^3) % 5 + 1.", "b. Update high as high + jump.", "c. If high > n - i + 1, update high as jump + 1.", "d. If i is not equal to m, then for each iteration of j from high + 1 to n - i + 1, shift mark[j] to mark[j-1].", "Print the value of mark[high]."], "nl_cn": "有 $n$ 个一种松鼠喜欢吃的果子由下向上串排成一列，并标号 $1\\sim n$。一只松鼠从最下果子开始向上跳，并且第 $i$ 次跳可以一次跳过 $(i^3 \\bmod 5 + 1)$ 个果子，并把脚下的果子吃了，如果上面有果子，在重力作用下，都将向下掉下一格。如第 $1$ 次跳从第一个果子上跳过 $(1^3 \\bmod 5 + 1 = ) 2$ 个果子，可跳到第 $3$ 个果子上，并把第 $3$ 个果子吃了；第 $2$ 次从第 $4$ 个果子上(落在原来第三个果子位置)跳过 $(2^3\\bmod 5 + 1 = ) 4$ 个到第 $8$ 个果子上，并把第 $8$ 个吃了；如此反复。\n\n当然，总有一次松鼠会跳出这串果子的最前面，设为每 $k$ 次，它吃不到任何果子了。这时它回到最下面的果子上，重做它的第 $k$ 次跳，以求吃到果子。如此，问它吃的第 $m$ 只果子(即第 $m$ 跳吃到的果子)的标号是什么？", "test_cases": [{"input": "10 \r\n4\r\n", "output": "9"}, {"input": "8 \r\n3\r\n", "output": "5"}, {"input": "20 \r\n10\r\n", "output": "13"}, {"input": "11 \r\n7\r\n", "output": "10"}], "test": "#undef NDEBUG\n#include<assert.h>\nint main(){\n    assert(solution(\"10 \\r\\n4\\r\\n\") == \"9\");\n    assert(solution(\"8 \\r\\n3\\r\\n\") == \"5\");\n    assert(solution(\"20 \\r\\n10\\r\\n\") == \"13\");\n    assert(solution(\"11 \\r\\n7\\r\\n\") == \"10\");\n    return 0; \n}", "prompt": "/*There are n fruits that a squirrel likes to eat, arranged in a column from bottom to top and numbered from 1 to n. A squirrel jumps from the bottom to the top and can jump over (i^3 mod 5 + 1) fruits in the i-th jump, and eats the fruit it is on. If there is a fruit above, it will fall down one position due to gravity. For example, in the first jump, it can jump over 2 fruits starting from the first fruit, and eats the third fruit. In the second jump, it can jump over 4 fruits starting from the fourth fruit (which is the position of the third fruit after it falls down), and eats the eighth fruit. This continues until the squirrel jumps out of the front of the fruits every k jumps, without eating any fruit. Then it goes back to the bottom and does its k-th jump again to try to eat a fruit. What is the number of the m-th fruit it eats (i.e. the fruit it eats in the m-th jump)?\n\ninput_format:\nThere are two lines, $n$and $m$($1\\le m\\le n\\le 200$, and can skip to the first $m$).\n\noutput_format:\nA number, that is, the label of the $m$fruit it eats.\n*/\n\n#include<sstream>\n#include<stdlib.h>\n#include<algorithm>\n#include<math.h>\n#include<stdio.h>\n#include<vector>\n#include<string>\n#include<climits>\n#include<cstring>\n#include<iostream>\nusing namespace std;\n\n             \nstring solution(string std_in){\n    istringstream iss(std_in);\n             ", "constraints": "注：吃掉的果子依次为 $3$，$8$，$4$（回到下面重做第 $3$ 跳），$9$（回到下面重做第 $4$ 跳）。", "samples": [["10 \r\n4\r\n", "9"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}}
{"task_id": "P1397", "title": "[NOI2013] 矩阵游戏", "difficulty": "advanced", "nl": "Tingting is a kid who loves matrices. One day she wants to generate a huge $n$-by-$m$ matrix using a computer (you don't need to worry about how she stores it). The matrix she generates satisfies a magic property: if $F[i][j]$ represents the element in the $i$th row and $j$th column of the matrix, then $F[i][j]$ satisfies the following recurrence relations:\n\n$$\nF[1][1]=1\n$$\n$$\nF[i,j]=a\\times F[i][j-1]+b (j\\neq 1)\n$$\n$$\nF[i,1]=c\\times F[i-1][m]+d (i\\neq 1)\n$$\n\nIn the recurrence relations, constants $a$, $b$, $c$ and $d$ are given.\n\nNow Tingting wants to know the value of $F[n][m]$. Please help her. The final result may be very large, so you only need to output the remainder of $F[n][m]$ divided by $1,000,000,007$.", "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef int ll;\ntypedef long long int li;\nconst ll MAXN=1e6+51,MOD=1e9+7;\nstruct Matrix{\n\tll num[3][3];\n\tMatrix()\n\t{\n\t\tmemset(num,0,sizeof(num));\n\t}\n\tinline ll* operator [](const ll &x)\n\t{\n\t\treturn num[x];\n\t}\n\tinline const ll* operator [](const ll &x)const\n\t{\n\t\treturn num[x];\n\t}\n};\nMatrix matx,maty,invl;\nll x;\nchar n[MAXN],m[MAXN];\ninline ll read()\n{\n    register ll num=0,neg=1;\n    register char ch=getchar();\n    while(!isdigit(ch)&&ch!='-')\n    {\n        ch=getchar();\n    }\n    if(ch=='-')\n    {\n        neg=-1;\n        ch=getchar();\n    }\n    while(isdigit(ch))\n    {\n        num=(num<<3)+(num<<1)+(ch-'0');\n        ch=getchar();\n    }\n    return num*neg;\n}\ninline ll qpow(ll base,ll exponent)\n{\n    ll res=1;\n    while(exponent)\n    {\n        if(exponent&1)\n        {\n            res=(li)res*base%MOD;\n        }\n        base=(li)base*base%MOD,exponent>>=1;\n    }\n    return res;\n}\ninline Matrix operator *(Matrix x,Matrix y)\n{\n\tMatrix res;\n\tfor(register int i=1;i<=2;i++)\n\t{\n\t\tfor(register int j=1;j<=2;j++)\n\t\t{\n\t\t\tfor(register int k=1;k<=2;k++)\n\t\t\t{\n\t\t\t\tres[i][j]=(res[i][j]+(li)x[i][k]*y[k][j])%MOD;\n\t\t\t}\n\t\t}\n\t}\n\treturn res;\n}\ninline Matrix qpow(Matrix base,ll len,char *exponent)\n{\n\tMatrix res,pw[4];\n\tres[1][1]=res[2][2]=1;\n\tfor(register int i=len;i;i--)\n\t{\n\t\tpw[0]=base,pw[1]=pw[0]*pw[0],pw[2]=pw[1]*pw[1],pw[3]=pw[2]*pw[2];\n\t\tfor(register int j=4;j>=0;j--)\n\t\t{\n\t\t\t(exponent[i]-48)&(1<<j)?res=res*pw[j],1:1;\n\t\t}\n\t\tbase=pw[3]*pw[1];\n\t}\n\treturn res;\n}\nint main()\n{\n    scanf(\"%s%s\",n+1,m+1),invl[1][1]=qpow(matx[1][1]=read(),MOD-2);\n\tmatx[2][1]=read(),matx[2][2]=invl[2][2]=1;\n\tinvl[2][1]=(MOD-(li)matx[2][1]*invl[1][1])%MOD;\n\tmatx=qpow(matx,strlen(m+1),m),matx=matx*invl;\n\tmaty[1][1]=read(),maty[2][1]=read(),maty[2][2]=1,matx=matx*maty;\n\tmatx=qpow(matx,strlen(n+1),n),x=(matx[1][1]+matx[2][1])%MOD;\n    printf(\"%d\\n\",(li)(x-maty[2][1]+MOD)%MOD*qpow(maty[1][1],MOD-2)%MOD);\n}", "step": ["Read in input including the difference and input strings.", "Modify the input strings to handle 0 index.", "Calculate the power sequence matrix raised to the power of the input strings.", "Using matrix multiplication, calculate the final sum of the arithmetic sequence with special difference.", "Print the answer."], "nl_cn": "婷婷是个喜欢矩阵的小朋友，有一天她想用电脑生成一个巨大的 $n$ 行 $m$ 列的矩阵(你不用担心她如何存储)。她生成的这个矩阵满足一个神奇的性质：若用 $F[i][j]$ 来表示矩阵中第 $i$ 行第 $j$ 列的元素，则 $F[i][j]$ 满足下面的递推式:\n\n$$\nF[1][1]=1\n$$\n$$\nF[i,j]=a\\times F[i][j-1]+b (j\\neq 1)\n$$\n$$\nF[i,1]=c\\times F[i-1][m]+d (i\\neq 1)\n$$\n\n递推式中 $a,b,c,d$ 都是给定的常数。\n\n现在婷婷想知道 $F[n][m]$ 的值是多少，请你帮助她。由于最终结果可能很大，你只需要输出 $F[n][m]$ 除以 $1,000,000,007$ 的余数。\n", "test_cases": [{"input": "3 4 1 3 2 6\n", "output": "85"}, {"input": "1 1 1 1 1 1\n", "output": "1"}], "test": "#undef NDEBUG\n#include<assert.h>\nint main(){\n    assert(solution(\"3 4 1 3 2 6\\n\") == \"85\");\n    assert(solution(\"1 1 1 1 1 1\\n\") == \"1\");\n    return 0; \n}", "prompt": "/*Tingting is a kid who loves matrices. One day she wants to generate a huge $n$-by-$m$ matrix using a computer (you don't need to worry about how she stores it). The matrix she generates satisfies a magic property: if $F[i][j]$ represents the element in the $i$th row and $j$th column of the matrix, then $F[i][j]$ satisfies the following recurrence relations:\n\n$$\nF[1][1]=1\n$$\n$$\nF[i,j]=a\\times F[i][j-1]+b (j\\neq 1)\n$$\n$$\nF[i,1]=c\\times F[i-1][m]+d (i\\neq 1)\n$$\n\nIn the recurrence relations, constants $a$, $b$, $c$ and $d$ are given.\n\nNow Tingting wants to know the value of $F[n][m]$. Please help her. The final result may be very large, so you only need to output the remainder of $F[n][m]$ divided by $1,000,000,007$.\n\ninput_format:\nContains a row with six integers $n,m,a,b,c,d$. The meaning is as described in the title.\n\noutput_format:\nContains an integer that represents the remainder of $F[n][m]$divided by $1,000,000,007.\n*/\n\n#include<sstream>\n#include<stdlib.h>\n#include<algorithm>\n#include<math.h>\n#include<stdio.h>\n#include<vector>\n#include<string>\n#include<climits>\n#include<cstring>\n#include<iostream>\nusing namespace std;\n\n             \nstring solution(string std_in){\n    istringstream iss(std_in);\n             ", "constraints": "【样例1说明】\n\n样例中的矩阵为：\n\n$$\\begin{pmatrix}\n 1 &  4 &  7 & 10 \\\\\n26 & 29 & 32 & 35 \\\\\n76 & 79 & 82 & 85 \\\\\n\\end{pmatrix}$$\n\n### 数据范围\n\n| 测试点编号 | 数据范围 |\n| :-: | :-: |\n| 1 | $1 \\le n,m \\le 10$；$1 \\le a,b,c,d \\le 1000$ |\n| 2 | $1 \\le n,m \\le 100$；$1 \\le a,b,c,d \\le 1000$ |\n| 3 | $1 \\le n,m \\le 10^3$；$1 \\le a,b,c,d \\le 10^9$ |\n| 4 | $1 \\le n,m \\le 10^3$；$1 \\le a,b,c,d \\le 10^9$ |\n| 5 | $1 \\le n,m \\le 10^9$；$1 \\le a = c \\le 10^9$；$1 \\le b = d \\le 10^9$ |\n| 6 | $1 \\le n,m \\le 10^9$；$a = c = 1$；$1 \\le b,d \\le 10^9$ |\n| 7 | $1 \\le n,m,a,b,c,d \\le 10^9$ |\n| 8 | $1 \\le n,m,a,b,c,d \\le 10^9$ |\n| 9 | $1 \\le n,m,a,b,c,d \\le 10^9$ |\n| 10 | $1 \\le n,m,a,b,c,d \\le 10^9$ |\n| 11 | $1 \\le n,m \\le 10^{1\\,000}$；$a = c = 1$；$1 \\le b,d \\le 10^9$ |\n| 12 | $1 \\le n,m \\le 10^{1\\,000}$；$1 \\le a = c \\le 10^9$；$1 \\le b = d \\le 10^9$ |\n| 13 | $1 \\le n,m \\le 10^{1\\,000}$；$1 \\le a,b,c,d \\le 10^9$ |\n| 14 | $1 \\le n,m \\le 10^{1\\,000}$；$1 \\le a,b,c,d \\le 10^9$ |\n| 15 | $1 \\le n,m \\le 10^{20\\,000}$；$1 \\le a,b,c,d \\le 10^9$ |\n| 16 | $1 \\le n,m \\le 10^{20\\,000}$；$1 \\le a,b,c,d \\le 10^9$ |\n| 17 | $1 \\le n,m \\le 10^{1\\,000\\,000}$；$a = c = 1$；$1 \\le b,d \\le 10^9$ |\n| 18 | $1 \\le n,m \\le 10^{1\\,000\\,000}$；$1 \\le a = c \\le 10^9$；$1 \\le b = d \\le 10^9$ |\n| 19 | $1 \\le n,m \\le 10^{1\\,000\\,000}$；$1 \\le a,b,c,d \\le 10^9$ |\n| 20 | $1 \\le n,m \\le 10^{1\\,000\\,000}$；$1 \\le a,b,c,d \\le 10^9$ |", "samples": [["3 4 1 3 2 6\n", "85\n"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144]}}
{"task_id": "P7724", "title": "远古档案馆（Ancient Archive）", "difficulty": "basic", "nl": "The center of the ancient archive is a puzzle:\n\n- There is a $2\\times 2$ grid with either a positive integer or empty space in each cell.\n\n- You can perform certain operations: each time, you choose a cell with a positive integer and an adjacent empty cell, and move the integer to the empty cell.\n\n- Given the initial and final states of the grid, where both contain the same number of positive integers (denoted as $k$), which are the first $k$ distinct positive integers, can you reach the final state from the initial state with a finite number of operations?\n\nThe following image shows an example of a grid with three positive integers after two operations:\n\n\n\nYou can only obtain forgotten knowledge after completing the puzzle, so you hope to solve the problem as soon as possible.\n\nNote: the grid may not contain any positive integers or any empty spaces.", "code": "#include<iostream>\n#include<cstdio>\nusing namespace std;\nint a[5],b[5],num=0,k;\nbool judge1(){\n    if(a[1]==b[3]&&a[2]==b[4]){ //a的第一行与b的第二行相同 \n        if(a[1]!=0&&a[2]!=0) return 1;\n    }\n    if(a[3]==b[1]&&a[4]==b[2]){ //a的第二行与b的第一行相同 \n        if(a[3]!=0&&a[4]!=0) return 1;\n    }\n    if(a[1]==b[2]&&a[3]==b[4]){ //a的第一列与b的第二列相同\n        if(a[1]!=0&&a[3]!=0) return 1;\n    }\n    if(a[2]==b[1]&&a[4]==b[3]){ //a的第二列与b的第一列相同 \n        if(a[2]!=0&&a[4]!=0) return 1;\n    }\n    return 0;\n}\nbool judge2(){\n    if(a[1]==b[1]&&a[2]==b[2]){ //a的第一行与b的第一行相同 \n    \tif(a[1]==0||a[2]==0) return 1;\n    }\n    if(a[3]==b[3]&&a[4]==b[4]){ //a的第二行与b的第二行相同 \n    \tif(a[3]==0||a[4]==0) return 1;\n    }\n    if(a[1]==b[1]&&a[3]==b[3]){ //a的第一列与b的第一列相同 \n    \tif(a[1]==0||a[3]==0) return 1;\n    }\n    if(a[2]==b[2]&&a[4]==b[4]){ //a的第二列与b的第二列相同 \n    \tif(a[2]==0||a[4]==0) return 1;\n    }\n    return 0;\n}\nbool judge3(){\n    if(a[1]==b[1]&&a[4]==b[4]|| //a,b左上与右下相同 \n       a[2]==b[2]&&a[3]==b[3]){ //a,b右上与左下相同 \n         return 1;\t\n    }\n    return 0;\n}\nbool same(){ //a,b四个格完全相同 \n    if(a[1]==b[1]&&a[2]==b[2]&&a[3]==b[3]&&a[4]==b[4]) return 1;\n\t return 0;\n}\nbool move(int x){\n    swap(a[k],a[x]); //x格中数字移到空格位置 \n    if((judge1()||judge2()||judge3())&&!same()) return 1;\n    else swap(a[k],a[x]); //判断不成立，数字回到x格\n    return 0;\n}\nint main(){\n    scanf(\"%d %d %d %d\",&a[1],&a[2],&a[3],&a[4]);\n    scanf(\"%d %d %d %d\",&b[1],&b[2],&b[3],&b[4]);\n    for(int i=1;i<=4;i++){\n    \tif(a[i]==0){\n    \t\tnum++; //记录空格个数 \n    \t\tk=i; //记录空格出现位置 \n    \t}\n    }\n    if(same()){ //四个格全部相同\n        printf(\"Yes\"); \n        return 0;\n    }\n    if(num==0){ //四个格全部不为空\n        printf(\"No\"); \n        return 0;\n    }\n    if(num>=2){ //空格个数两个及以上 \n    \tprintf(\"Yes\");\n    \treturn 0;\n    }\n    //以下均为只存在一个空格的情况 \n    if(judge1()||judge2()||judge3()){ //判断\n    \tprintf(\"No\");\n    \treturn 0;\n    }\n    if(k==2||k==3){ //空格位置为2或3时 \n\tif(move(1)||move(4)){ //判断1,4格中数字移到空格位置时 \n\t\tprintf(\"No\");\n    \treturn 0;\n\t\t}\n\t}\n    if(k==1||k==4){ //空格位置为1或4时\n\tif(move(2)||move(3)){ //判断2,3格中数字移到空格位置时  \n\t\tprintf(\"No\");\n    \treturn 0;\n\t\t} \n\t}\n    printf(\"Yes\"); //全部不成立，结束 \n    return 0;\n}", "step": ["Read input arrays.", "Check if the arrays are already equal. If yes, output 'Yes' and return.", "Check if the arrays cannot be made equal by swapping any of the non-zero elements. If yes, output 'No' and return.", "If there are two or more 0's in the array, output 'Yes' and return.", "Try swapping any 0 with its adjacent element. If any of the swaps make the arrays equal and only requires one move, output 'No' and return. Otherwise, output 'Yes' and return."], "nl_cn": "远古档案馆的中心是一个解谜：\n\n- 有一个 $2\\times 2$ 的网格，每个格子中要么有一个正整数，要么是空的；\n\n- 你可以进行若干次操作：每次操作中，你选择一个**有正整数的格子**和一个**与之相邻的空格子**，将正整数移到那个空格子中；\n\n- 给定网格的初始状态和最终状态，保证初始状态和最终状态中包含的正整数个数相同（设为 $k$ 个），且它们就是前 $k$ 个不同的正整数，问是否可以通过有限次操作从初始状态到达最终状态？\n\n下图展示了一个包含三个正整数的网格经过两次操作的情况：\n\n\n\n只有完成解谜，才能获得遗忘的知识，因此你希望尽快解决这个问题。\n\n**注意：网格中可能没有正整数，也可能没有空格。**", "test_cases": [{"input": "2 1\n3 0\n0 2\n3 1\n", "output": "Yes"}, {"input": "2 1\n4 3\n3 4\n2 1\n", "output": "No"}, {"input": "1 4\n3 2\n1 4\n3 2\n", "output": "Yes"}, {"input": "7 2\n4 1\n7 2\n4 1\n", "output": "Yes"}, {"input": "8 3\n0 0\n8 3\n0 0\n", "output": "Yes"}, {"input": "1 0\n0 1\n1 0\n0 1\n", "output": "Yes"}, {"input": "4 2\n0 2\n4 2\n0 2\n", "output": "Yes"}, {"input": "9 8\n8 9\n9 8\n8 9\n", "output": "Yes"}, {"input": "9 7\n1 8\n9 7\n1 8\n", "output": "Yes"}, {"input": "5 6\n0 0\n5 6\n0 0\n", "output": "Yes"}, {"input": "2 3\n1 2\n2 3\n1 2\n", "output": "Yes"}, {"input": "3 3\n0 3\n0 3\n0 3\n", "output": "No"}, {"input": "6 6\n6 6\n6 6\n6 6\n", "output": "Yes"}, {"input": "1 0\n0 0\n1 0\n0 0\n", "output": "Yes"}, {"input": "3 2\n3 4\n2 4\n3 2\n", "output": "No"}, {"input": "0 0\n4 3\n0 0\n4 3\n", "output": "Yes"}, {"input": "3 2\n0 0\n2 0\n3 2\n", "output": "Yes"}, {"input": "1 0\n2 0\n1 2\n0 0\n", "output": "Yes"}, {"input": "1 2\n0 0\n2 1\n0 0\n", "output": "Yes"}, {"input": "0 0\n3 1\n3 1\n0 0\n", "output": "Yes"}, {"input": "4 3\n2 0\n4 3\n2 0\n", "output": "Yes"}, {"input": "0 3\n0 4\n0 0\n4 3\n", "output": "Yes"}, {"input": "2 1\n0 0\n0 0\n3 1\n", "output": "Yes"}, {"input": "3 4\n0 0\n3 4\n0 0\n", "output": "Yes"}, {"input": "0 2\n3 0\n0 0\n3 2\n", "output": "Yes"}, {"input": "0 0\n4 3\n0 0\n0 0\n", "output": "Yes"}, {"input": "3 2\n2 0\n3 2\n0 0\n", "output": "No"}, {"input": "0 0\n0 0\n0 0\n0 0\n", "output": "Yes"}, {"input": "1 2\n1 2\n2 1\n2 1\n", "output": "No"}, {"input": "3 4\n0 0\n0 0\n3 4\n", "output": "Yes"}, {"input": "3 4\n1 1\n1 1\n3 4\n", "output": "No"}, {"input": "0 0\n0 0\n0 0\n1 1\n", "output": "Yes"}, {"input": "1 2\n2 1\n0 0\n3 4\n", "output": "No"}, {"input": "1 2\n2 1\n3 4\n0 0\n", "output": "No"}, {"input": "1 0\n1 0\n0 1\n0 1\n", "output": "Yes"}, {"input": "1 0\n0 1\n0 1\n1 0\n", "output": "Yes"}, {"input": "1 1\n1 1\n1 1\n1 1\n", "output": "Yes"}, {"input": "1 1\n0 0\n0 0\n1 1\n", "output": "Yes"}, {"input": "2 1\n1 2\n1 2\n2 1\n", "output": "No"}, {"input": "1 2\n0 0\n0 2\n0 1\n", "output": "Yes"}, {"input": "0 1\n0 0\n0 0\n1 0\n", "output": "Yes"}, {"input": "1 2\n0 0\n0 1\n0 2\n", "output": "Yes"}, {"input": "3 2\n0 1\n0 0\n0 2\n1 0\n", "output": "Yes"}, {"input": "4 3\n0 0\n0 4\n0 3\n4 0\n", "output": "Yes"}, {"input": "3 4\n3 0\n0 0\n0 0\n0 4\n", "output": "Yes"}, {"input": "2 2\n2 0\n0 0\n0 2\n0 0\n", "output": "No"}, {"input": "3 2\n0 1\n0 0\n0 0\n1 0\n", "output": "Yes"}, {"input": "2 1\n2 0\n0 1\n0 0\n1 0\n", "output": "No"}], "test": "#undef NDEBUG\n#include<assert.h>\nint main(){\n    assert(solution(\"2 1\\n3 0\\n0 2\\n3 1\\n\") == \"Yes\");\n    assert(solution(\"2 1\\n4 3\\n3 4\\n2 1\\n\") == \"No\");\n    assert(solution(\"1 4\\n3 2\\n1 4\\n3 2\\n\") == \"Yes\");\n    assert(solution(\"7 2\\n4 1\\n7 2\\n4 1\\n\") == \"Yes\");\n    assert(solution(\"8 3\\n0 0\\n8 3\\n0 0\\n\") == \"Yes\");\n    assert(solution(\"1 0\\n0 1\\n1 0\\n0 1\\n\") == \"Yes\");\n    assert(solution(\"4 2\\n0 2\\n4 2\\n0 2\\n\") == \"Yes\");\n    assert(solution(\"9 8\\n8 9\\n9 8\\n8 9\\n\") == \"Yes\");\n    assert(solution(\"9 7\\n1 8\\n9 7\\n1 8\\n\") == \"Yes\");\n    assert(solution(\"5 6\\n0 0\\n5 6\\n0 0\\n\") == \"Yes\");\n    assert(solution(\"2 3\\n1 2\\n2 3\\n1 2\\n\") == \"Yes\");\n    assert(solution(\"3 3\\n0 3\\n0 3\\n0 3\\n\") == \"No\");\n    assert(solution(\"6 6\\n6 6\\n6 6\\n6 6\\n\") == \"Yes\");\n    assert(solution(\"1 0\\n0 0\\n1 0\\n0 0\\n\") == \"Yes\");\n    assert(solution(\"3 2\\n3 4\\n2 4\\n3 2\\n\") == \"No\");\n    assert(solution(\"0 0\\n4 3\\n0 0\\n4 3\\n\") == \"Yes\");\n    assert(solution(\"3 2\\n0 0\\n2 0\\n3 2\\n\") == \"Yes\");\n    assert(solution(\"1 0\\n2 0\\n1 2\\n0 0\\n\") == \"Yes\");\n    assert(solution(\"1 2\\n0 0\\n2 1\\n0 0\\n\") == \"Yes\");\n    assert(solution(\"0 0\\n3 1\\n3 1\\n0 0\\n\") == \"Yes\");\n    assert(solution(\"4 3\\n2 0\\n4 3\\n2 0\\n\") == \"Yes\");\n    assert(solution(\"0 3\\n0 4\\n0 0\\n4 3\\n\") == \"Yes\");\n    assert(solution(\"2 1\\n0 0\\n0 0\\n3 1\\n\") == \"Yes\");\n    assert(solution(\"3 4\\n0 0\\n3 4\\n0 0\\n\") == \"Yes\");\n    assert(solution(\"0 2\\n3 0\\n0 0\\n3 2\\n\") == \"Yes\");\n    assert(solution(\"0 0\\n4 3\\n0 0\\n0 0\\n\") == \"Yes\");\n    assert(solution(\"3 2\\n2 0\\n3 2\\n0 0\\n\") == \"No\");\n    assert(solution(\"0 0\\n0 0\\n0 0\\n0 0\\n\") == \"Yes\");\n    assert(solution(\"1 2\\n1 2\\n2 1\\n2 1\\n\") == \"No\");\n    assert(solution(\"3 4\\n0 0\\n0 0\\n3 4\\n\") == \"Yes\");\n    assert(solution(\"3 4\\n1 1\\n1 1\\n3 4\\n\") == \"No\");\n    assert(solution(\"0 0\\n0 0\\n0 0\\n1 1\\n\") == \"Yes\");\n    assert(solution(\"1 2\\n2 1\\n0 0\\n3 4\\n\") == \"No\");\n    assert(solution(\"1 2\\n2 1\\n3 4\\n0 0\\n\") == \"No\");\n    assert(solution(\"1 0\\n1 0\\n0 1\\n0 1\\n\") == \"Yes\");\n    assert(solution(\"1 0\\n0 1\\n0 1\\n1 0\\n\") == \"Yes\");\n    assert(solution(\"1 1\\n1 1\\n1 1\\n1 1\\n\") == \"Yes\");\n    assert(solution(\"1 1\\n0 0\\n0 0\\n1 1\\n\") == \"Yes\");\n    assert(solution(\"2 1\\n1 2\\n1 2\\n2 1\\n\") == \"No\");\n    assert(solution(\"1 2\\n0 0\\n0 2\\n0 1\\n\") == \"Yes\");\n    assert(solution(\"0 1\\n0 0\\n0 0\\n1 0\\n\") == \"Yes\");\n    assert(solution(\"1 2\\n0 0\\n0 1\\n0 2\\n\") == \"Yes\");\n    assert(solution(\"3 2\\n0 1\\n0 0\\n0 2\\n1 0\\n\") == \"Yes\");\n    assert(solution(\"4 3\\n0 0\\n0 4\\n0 3\\n4 0\\n\") == \"Yes\");\n    assert(solution(\"3 4\\n3 0\\n0 0\\n0 0\\n0 4\\n\") == \"Yes\");\n    assert(solution(\"2 2\\n2 0\\n0 0\\n0 2\\n0 0\\n\") == \"No\");\n    assert(solution(\"3 2\\n0 1\\n0 0\\n0 0\\n1 0\\n\") == \"Yes\");\n    assert(solution(\"2 1\\n2 0\\n0 1\\n0 0\\n1 0\\n\") == \"No\");\n    return 0; \n}", "prompt": "/*The center of the ancient archive is a puzzle:\n\n- There is a $2\\times 2$ grid with either a positive integer or empty space in each cell.\n\n- You can perform certain operations: each time, you choose a cell with a positive integer and an adjacent empty cell, and move the integer to the empty cell.\n\n- Given the initial and final states of the grid, where both contain the same number of positive integers (denoted as $k$), which are the first $k$ distinct positive integers, can you reach the final state from the initial state with a finite number of operations?\n\nThe following image shows an example of a grid with three positive integers after two operations:\n\n\n\nYou can only obtain forgotten knowledge after completing the puzzle, so you hope to solve the problem as soon as possible.\n\nNote: the grid may not contain any positive integers or any empty spaces.\n\ninput_format:\nThe input consists of four lines of two integers each.\n\nThe first two lines describe the initial state, and the last two lines describe the final state, with $0$representing Spaces.\n\noutput_format:\nOutput 'Yes' if the initial state can be reached from the final state, otherwise output' No '.\n*/\n\n#include<sstream>\n#include<stdlib.h>\n#include<algorithm>\n#include<math.h>\n#include<stdio.h>\n#include<vector>\n#include<string>\n#include<climits>\n#include<cstring>\n#include<iostream>\nusing namespace std;\n\n             \nstring solution(string std_in){\n    istringstream iss(std_in);\n             ", "constraints": "**【样例 1 解释】**\n\n如题目描述中图所示。\n\n---\n\n**【样例 2 解释】**\n\n没有可移动的正整数，所以无法从初始状态到达与之不相等的最终状态。\n\n---\n\n**【数据范围】**\n\n**本题采用捆绑测试。**\n\n所有数据符合题目描述所述。\n\n- Subtask 1（40 points）：不存在空格。\n- Subtask 2（60 points）：无特殊限制。\n\n---\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/rz2eg0ca.png)", "samples": [["2 1\n3 0\n0 2\n3 1\n", "Yes\n"], ["2 1\n4 3\n3 4\n2 1\n", "No\n"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144]}}
{"task_id": "P3998", "title": "[SHOI2013]发微博", "difficulty": "advanced", "nl": "The newly opened SH Weibo has $n$ users (numbered from 1 to n). In just one month, the users were very active and there were a total of $m$ records in chronological order:\n\n```plain\n! x represents that user x posted a Weibo;\n+ x y represents that user x and user y became friends;\n- x y represents that user x and user y ended their friendship.\n```\n\nWhen a user posts a Weibo, all of his/her friends (direct relationships) will see the message.\n\nAssume that at the beginning, no one was friends with each other and all records were valid (i.e., when `+ x y` is given, x and y are not friends, and when `- x y` is given, x and y are friends).\n\nAfter these $m$ records have been processed, ask how many messages each user has seen.", "code": "#include<iostream>\n    #include<cstdio>\n    #include<set>\n    using namespace std;\n    const int N=200009;\n    int n,m,cnt[N],ans[N];\n    set<int>s[N];\n    set<int>::iterator it;\n    int main(){\n        ios::sync_with_stdio(0);\n        cin>>n>>m;\n        for(int i=1;i<=m;++i){\n            char opt;cin>>opt;\n            if(opt=='!'){\n                int x;cin>>x;\n                ++cnt[x];\n            }\n            if(opt=='+'){\n                int x,y;cin>>x>>y;\n                ans[x]-=cnt[y];ans[y]-=cnt[x];\n                s[x].insert(y);s[y].insert(x);\n            }\n            if(opt=='-'){\n                int x,y;cin>>x>>y;\n                ans[x]+=cnt[y];ans[y]+=cnt[x];\n                s[x].erase(y);s[y].erase(x);\n            }\n        }\n        for(int i=1;i<=n;++i)\n        for(it=s[i].begin();it!=s[i].end();++it){\n            ans[i]+=cnt[*it];\n        }\n        for(int i=1;i<=n;++i)cout<<ans[i]<<\" \";\n        return 0;\n    }", "step": ["Initialize the required variables and set.", "Take inputs and based on the option value letters, perform corresponding operations.", "For '!' option, increment 'cnt' variable for that index.", "For '+' option, decrement 'cnt' value for the matched indices and insert them into set.", "For '-' option, increment 'cnt' value for the matched indices and erase them from the set.", "Finally, add the remaining values of 'cnt' to the answer, print the result and exit."], "nl_cn": "刚开通的 SH 微博共有 $n$ 个用户（$1\\sim n$ 标号），在这短短一个月的时间内，用户们活动频繁，共有 $m$ 条按时间顺序的记录：\n\n```plain\n! x 表示用户 x 发了一条微博；\n+ x y 表示用户 x 和用户 y 成为了好友\n− x y 表示用户 x 和用户 y 解除了好友关系\n```\n当一个用户发微博的时候，所有他的好友（直接关系）都会看到他的消息。\n\n假设最开始所有人之间都不是好友关系，记录也都是合法的（即 `+ x y` 时 $x$ 和 $y$ 一定不是好友，而 `− x y` 时 $x$ 和 $y$ 一定是好友）。\n\n问这 $m$ 条记录发生之后，每个用户分别看到了多少条消息。\n", "test_cases": [{"input": "2 8\n! 1\n! 2\n+ 1 2\n! 1\n! 2\n- 1 2\n! 1\n! 2", "output": "1 1"}, {"input": "1 4\n! 1\n! 1\n! 1\n! 1\n", "output": "0"}, {"input": "2 5\n! 1\n! 2\n+ 1 2\n! 1\n! 2\n", "output": "1 1"}, {"input": "2 9\n! 1\n! 2\n+ 1 2\n+ 2 1\n! 1\n! 2\n- 1 2\n! 1\n! 2\n", "output": "0 0"}, {"input": "1 3\n! 1\n! 1\n! 1\n", "output": "0"}, {"input": "3 8\n! 1\n! 2\n+ 1 2\n! 1\n! 2\n- 1 2\n! 1\n! 2\n", "output": "1 1 0"}, {"input": "4 11\n! 1\n! 2\n+ 1 2\n! 1\n! 2\n- 1 2\n! 1\n! 2\n! 3\n! 4\n", "output": "1 1 0 0"}, {"input": "5 11\n! 1\n! 2\n+ 1 2\n! 1\n! 2\n- 1 2\n! 1\n! 2\n! 3\n! 4\n", "output": "1 1 0 0 0"}, {"input": "5 10\n! 1\n! 2\n+ 1 2\n! 1\n! 2\n- 1 2\n! 1\n! 2\n! 3\n! 4\n", "output": "1 1 0 0 0"}, {"input": "1 0", "output": "0"}, {"input": "2 2\n! 1\n! 2\n", "output": "0 0"}, {"input": "4 5\n! 1\n+ 1 2\n+ 1 3\n- 2 3\n", "output": "0 0 0 0"}], "test": "#undef NDEBUG\n#include<assert.h>\nint main(){\n    assert(solution(\"2 8\\n! 1\\n! 2\\n+ 1 2\\n! 1\\n! 2\\n- 1 2\\n! 1\\n! 2\") == \"1 1\");\n    assert(solution(\"1 4\\n! 1\\n! 1\\n! 1\\n! 1\\n\") == \"0\");\n    assert(solution(\"2 5\\n! 1\\n! 2\\n+ 1 2\\n! 1\\n! 2\\n\") == \"1 1\");\n    assert(solution(\"2 9\\n! 1\\n! 2\\n+ 1 2\\n+ 2 1\\n! 1\\n! 2\\n- 1 2\\n! 1\\n! 2\\n\") == \"0 0\");\n    assert(solution(\"1 3\\n! 1\\n! 1\\n! 1\\n\") == \"0\");\n    assert(solution(\"3 8\\n! 1\\n! 2\\n+ 1 2\\n! 1\\n! 2\\n- 1 2\\n! 1\\n! 2\\n\") == \"1 1 0\");\n    assert(solution(\"4 11\\n! 1\\n! 2\\n+ 1 2\\n! 1\\n! 2\\n- 1 2\\n! 1\\n! 2\\n! 3\\n! 4\\n\") == \"1 1 0 0\");\n    assert(solution(\"5 11\\n! 1\\n! 2\\n+ 1 2\\n! 1\\n! 2\\n- 1 2\\n! 1\\n! 2\\n! 3\\n! 4\\n\") == \"1 1 0 0 0\");\n    assert(solution(\"5 10\\n! 1\\n! 2\\n+ 1 2\\n! 1\\n! 2\\n- 1 2\\n! 1\\n! 2\\n! 3\\n! 4\\n\") == \"1 1 0 0 0\");\n    assert(solution(\"1 0\") == \"0\");\n    assert(solution(\"2 2\\n! 1\\n! 2\\n\") == \"0 0\");\n    assert(solution(\"4 5\\n! 1\\n+ 1 2\\n+ 1 3\\n- 2 3\\n\") == \"0 0 0 0\");\n    return 0; \n}", "prompt": "/*The newly opened SH Weibo has $n$ users (numbered from 1 to n). In just one month, the users were very active and there were a total of $m$ records in chronological order:\n\n```plain\n! x represents that user x posted a Weibo;\n+ x y represents that user x and user y became friends;\n- x y represents that user x and user y ended their friendship.\n```\n\nWhen a user posts a Weibo, all of his/her friends (direct relationships) will see the message.\n\nAssume that at the beginning, no one was friends with each other and all records were valid (i.e., when `+ x y` is given, x and y are not friends, and when `- x y` is given, x and y are friends).\n\nAfter these $m$ records have been processed, ask how many messages each user has seen.\n\ninput_format:\nRow $1$two integers $n$, $m$.\n\nNext, the $m$line reads $m$records in chronological order, each record in the format described in the title, separated by Spaces.\n\noutput_format:\nOutput a line of $n$separated by Spaces (no Spaces at the end of the line), the number of $i$indicates how many messages the user $i$saw last.\n*/\n\n#include<sstream>\n#include<stdlib.h>\n#include<algorithm>\n#include<math.h>\n#include<stdio.h>\n#include<vector>\n#include<string>\n#include<climits>\n#include<cstring>\n#include<iostream>\nusing namespace std;\n\n             \nstring solution(string std_in){\n    istringstream iss(std_in);\n             ", "constraints": "对于 $100\\%$ 的数据，$n\\leq 200000$, $m\\leq 500000$", "samples": [["2 8\n! 1\n! 2\n+ 1 2\n! 1\n! 2\n- 1 2\n! 1\n! 2", "1 1"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000]}}
{"task_id": "P2840", "title": "纸币问题 2", "difficulty": "challenge", "nl": "You have n types of coins with different face values, the face value of the i-th coin is ai and there are infinite number of them. Now you need to pay an amount of w, and you want to know how many ways there are to pay the face value of w. The answer should be taken modulo 10^9+7.\nNote that here, if the same combination of coins is used but in different payment order, it will be considered as a different way. For example, if you pay 3 yuan, using a coin with face value of 1 yuan and a coin with face value of 2 yuan will produce two ways ($ 1+2 $ and $ 2+1 $).", "code": "#include<iostream>\nusing namespace std;\nint n,w,a[1005],f[10005];\nconst int mod=1e9+7;\nint main(){\n    cin>>n>>w;\n    for(int i=1;i<=n;i++){\n        cin>>a[i];\n    }\n    f[0]=1;\n    for(int i=1;i<=w;i++){\n        for(int j=1;j<=n;j++){\n            if(i-a[j]>=0){\n                f[i]=(f[i]+f[i-a[j]])%mod;\n            }\n        }\n    }\n    cout<<(f[w]%mod)<<endl;\n    return 0;\n}", "step": ["Get input values for N and W", "Get input values for weights of N items", "Initialize f[0] = 1", "Loop through 1 to W and 1 to N, checking if i - a[j] is greater than or equal to 0, then update f[i] with f[i] + f[i-a[j]] with modulo arithmetic", "Output the result modulo 1e9+7"], "nl_cn": "你有 $n$ 种面额互不相同的纸币，第 $i$ 种纸币的面额为 $a_i$ 并且有无限张，现在你需要支付 $w$ 的金额，求问有多少种方式可以支付面额 $w$，答案对 $10^9+7$ 取模。  \n注意在这里，同样的纸币组合如果支付顺序不同，会被视作不同的方式。例如支付 $3$ 元，使用一张面值 $1$ 的纸币和一张面值 $2$ 的纸币会产生两种方式（$1+2$ 和 $2+1$）。", "test_cases": [{"input": "6 15\n1 5 10 20 50 100", "output": "42"}, {"input": "3 15\n1 5 11", "output": "39"}, {"input": "1 1\n1\n", "output": "1"}, {"input": "1 100\n100\n", "output": "1"}, {"input": "1 50\n50\n", "output": "1"}, {"input": "0 0\n\n", "output": "1"}, {"input": "2 1\n1 2\n", "output": "1"}, {"input": "2 2\n1 2\n", "output": "2"}, {"input": "2 3\n1 2\n", "output": "3"}, {"input": "3 3\n1 2 3\n", "output": "4"}, {"input": "2 10\n3 5\n", "output": "1"}, {"input": "2 5\n2 3\n", "output": "2"}, {"input": "2 12\n3 5\n", "output": "1"}], "test": "#undef NDEBUG\n#include<assert.h>\nint main(){\n    assert(solution(\"6 15\\n1 5 10 20 50 100\") == \"42\");\n    assert(solution(\"3 15\\n1 5 11\") == \"39\");\n    assert(solution(\"1 1\\n1\\n\") == \"1\");\n    assert(solution(\"1 100\\n100\\n\") == \"1\");\n    assert(solution(\"1 50\\n50\\n\") == \"1\");\n    assert(solution(\"0 0\\n\\n\") == \"1\");\n    assert(solution(\"2 1\\n1 2\\n\") == \"1\");\n    assert(solution(\"2 2\\n1 2\\n\") == \"2\");\n    assert(solution(\"2 3\\n1 2\\n\") == \"3\");\n    assert(solution(\"3 3\\n1 2 3\\n\") == \"4\");\n    assert(solution(\"2 10\\n3 5\\n\") == \"1\");\n    assert(solution(\"2 5\\n2 3\\n\") == \"2\");\n    assert(solution(\"2 12\\n3 5\\n\") == \"1\");\n    return 0; \n}", "prompt": "/*You have n types of coins with different face values, the face value of the i-th coin is ai and there are infinite number of them. Now you need to pay an amount of w, and you want to know how many ways there are to pay the face value of w. The answer should be taken modulo 10^9+7.\nNote that here, if the same combination of coins is used but in different payment order, it will be considered as a different way. For example, if you pay 3 yuan, using a coin with face value of 1 yuan and a coin with face value of 2 yuan will produce two ways ($ 1+2 $ and $ 2+1 $).\n\ninput_format:\nThe first line consists of two positive integers, $n$ and $w$, representing the number of types of paper currency and the amount to be achieved.\n\nThe second line consists of $n$ positive integers $a_1, a_2, \\dots, a_n$ separated by spaces, representing the denominations of the $n$ types of paper currency.\n\noutput_format:\nA line with an integer indicates the number of payment methods.\n*/\n\n#include<sstream>\n#include<stdlib.h>\n#include<algorithm>\n#include<math.h>\n#include<stdio.h>\n#include<vector>\n#include<string>\n#include<climits>\n#include<cstring>\n#include<iostream>\nusing namespace std;\n\n             \nstring solution(string std_in){\n    istringstream iss(std_in);\n             ", "constraints": "对于 $40\\%$ 的数据，满足 $n\\le 10$，$w\\le 100$；  \n对于 $100\\%$ 的数据，满足 $1\\le n\\le 10^3$，$1\\le a_i \\le  w\\le 10^4$。  \n\n其实小朋友并不有钱。", "samples": [["6 15\n1 5 10 20 50 100", "42"], ["3 15\n1 5 11", "39"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288]}}
{"task_id": "P2652", "title": "同花顺", "difficulty": "advanced", "nl": "I have n poker cards in my hand, but they may not be able to form a straight flush. Now I want to know the minimum number of cards I need to replace, so that these n cards can all form a straight flush.", "code": "#include<algorithm>\n#include<iostream>\n#include<iomanip>\n#include<cstring>\n#include<cstdio>\n#include<cmath>\nusing namespace std;\nint n,cnt=0,ans,temp=0;\nstruct node\n{\n    int x;\n    int y;\n}a[100003],b[100003]; \nbool rule(const node &s1,const node &s2)\n{\n    if(s1.x==s2.x) return s1.y<s2.y;\n//这里把同色的排在一起，方便后续操作 \n    else return s1.x<s2.x;\n} \nint main()\n{\n    cin>>n;\n    for(int i=1;i<=n;i++)\n    {\n        cin>>a[i].x>>a[i].y;\n    }\n    sort(a+1,a+n+1,rule);\n    for(int i=1;i<=n;i++)\n    {\n        if(a[i-1].x!=a[i].x||a[i-1].y!=a[i].y)\n        {\n            b[++cnt]=a[i];\n        } \n        //这里我们通过if语句来筛去同色牌中数值相同的牌 \n    }\n    for(int i=1;i<=cnt;i++)//枚举区间右端点 \n    {\n        temp=0;\n        //注意此处一定要写在第一个循环和第二个循环之间 \n        for(int j=i;j>=1;j--)//枚举区间左端点 \n        {\n            if(b[i].x==b[j].x&&b[i].y-b[j].y+1<=n)\n            //如果是同色牌并且张数差小于等于n则一定能够通过换牌实现同花顺 \n            {\n                temp++; \n            }\n            else break;//不符合条件则退出 \n        }\n        if(temp>ans) ans=temp;//取所有可行方案中最大值 \n    }\n    cout<<n-ans<<endl; \n    return 0;\n}", "step": ["Get the number of points 'n'", "Input coordinates of the points", "Sort the points in ascending order of x coordinates and then y coordinates", "Remove duplicate points", "Find the maximum number of points that share the same x coordinate, and take this as the number of points to remove", "Print the minimum number of points needed to be eliminated"], "nl_cn": "现在我手里有 $n$ 张扑克牌，但它们可能并不能凑成同花顺。我现在想知道，最少更换其中的多少张牌，我能让这 $n$ 张牌都凑成同花顺？", "test_cases": [{"input": "5\n1 1\n1 2\n1 3\n1 4\n1 5", "output": "0"}, {"input": "5\n1 9\n1 10\n2 11\n2 12\n2 13", "output": "2"}, {"input": "10\n1 1\n1 2\n1 3\n1 4\n1 5\n2 6\n2 7\n2 8\n2 9\n2 10\n", "output": "5"}, {"input": "7\n3 1\n3 2\n3 3\n3 4\n3 5\n3 6\n3 7\n", "output": "0"}, {"input": "8\n1 2\n1 3\n2 4\n3 5\n4 6\n5 7\n5 8\n5 9\n", "output": "5"}, {"input": "3\n1 1\n1 2\n1 3\n", "output": "0"}, {"input": "5\n1 1\n1 2\n2 3\n2 4\n2 5\n", "output": "2"}, {"input": "6\n1 1\n1 2\n1 3\n1 4\n2 5\n3 6\n", "output": "2"}, {"input": "6\n2 3\n2 4\n2 5\n2 6\n2 7\n2 8", "output": "0"}, {"input": "3\n5 9\n5 10\n5 11", "output": "0"}, {"input": "5\n3 2\n3 3\n3 4\n3 5\n3 6", "output": "0"}, {"input": "6\n1 2\n1 3\n4 4\n4 5\n4 6\n4 7", "output": "2"}, {"input": "3\n3 2\n3 3\n3 4", "output": "0"}, {"input": "2\n4 9\n4 10", "output": "0"}, {"input": "4\n3 9\n3 10\n3 11\n3 12", "output": "0"}, {"input": "3\n4 2\n4 3\n4 4", "output": "0"}, {"input": "5\n2 6\n2 7\n2 8\n2 9\n2 10", "output": "0"}, {"input": "7\n5 6\n5 7\n5 8\n5 9\n5 10\n5 11\n5 12\n", "output": "0"}, {"input": "4\n10 10\n10 11\n10 12\n10 13\n", "output": "0"}, {"input": "6\n1 6\n1 7\n1 8\n1 9\n1 10\n1 11\n", "output": "0"}, {"input": "4\n4 1\n4 3\n4 5\n4 7\n", "output": "2"}, {"input": "7\n5 1\n5 2\n5 3\n5 4\n5 5\n5 6\n5 7\n", "output": "0"}, {"input": "4\n9 9\n9 11\n10 1\n10 3\n", "output": "2"}, {"input": "3\n3 7\n3 8\n3 9\n", "output": "0"}, {"input": "3\n1 2\n1 3\n1 4\n", "output": "0"}, {"input": "1\n1 1\n", "output": "0"}, {"input": "2\n1 1\n1 2\n", "output": "0"}, {"input": "8\n1 1\n1 2\n1 3\n1 4\n2 4\n3 4\n4 4\n5 4\n", "output": "4"}, {"input": "3\n4 7\n4 8\n4 9\n", "output": "0"}, {"input": "2\n2 3\n2 4\n", "output": "0"}, {"input": "4\n5 1\n5 2\n5 3\n5 4\n", "output": "0"}, {"input": "3\n4 3\n5 3\n5 1\n", "output": "1"}, {"input": "4\n2 4\n2 5\n3 6\n3 3\n", "output": "2"}, {"input": "3\n5 1\n1 2\n2 3\n", "output": "2"}, {"input": "4\n1 4\n2 4\n3 4\n4 4\n", "output": "3"}, {"input": "2\n3 4\n3 5\n", "output": "0"}, {"input": "2\n1 2\n1 3\n", "output": "0"}, {"input": "5\n2 5\n2 6\n3 7\n3 8\n3 9\n", "output": "2"}, {"input": "4\n3 3\n4 4\n4 5\n5 6\n", "output": "2"}], "test": "#undef NDEBUG\n#include<assert.h>\nint main(){\n    assert(solution(\"5\\n1 1\\n1 2\\n1 3\\n1 4\\n1 5\") == \"0\");\n    assert(solution(\"5\\n1 9\\n1 10\\n2 11\\n2 12\\n2 13\") == \"2\");\n    assert(solution(\"10\\n1 1\\n1 2\\n1 3\\n1 4\\n1 5\\n2 6\\n2 7\\n2 8\\n2 9\\n2 10\\n\") == \"5\");\n    assert(solution(\"7\\n3 1\\n3 2\\n3 3\\n3 4\\n3 5\\n3 6\\n3 7\\n\") == \"0\");\n    assert(solution(\"8\\n1 2\\n1 3\\n2 4\\n3 5\\n4 6\\n5 7\\n5 8\\n5 9\\n\") == \"5\");\n    assert(solution(\"3\\n1 1\\n1 2\\n1 3\\n\") == \"0\");\n    assert(solution(\"5\\n1 1\\n1 2\\n2 3\\n2 4\\n2 5\\n\") == \"2\");\n    assert(solution(\"6\\n1 1\\n1 2\\n1 3\\n1 4\\n2 5\\n3 6\\n\") == \"2\");\n    assert(solution(\"6\\n2 3\\n2 4\\n2 5\\n2 6\\n2 7\\n2 8\") == \"0\");\n    assert(solution(\"3\\n5 9\\n5 10\\n5 11\") == \"0\");\n    assert(solution(\"5\\n3 2\\n3 3\\n3 4\\n3 5\\n3 6\") == \"0\");\n    assert(solution(\"6\\n1 2\\n1 3\\n4 4\\n4 5\\n4 6\\n4 7\") == \"2\");\n    assert(solution(\"3\\n3 2\\n3 3\\n3 4\") == \"0\");\n    assert(solution(\"2\\n4 9\\n4 10\") == \"0\");\n    assert(solution(\"4\\n3 9\\n3 10\\n3 11\\n3 12\") == \"0\");\n    assert(solution(\"3\\n4 2\\n4 3\\n4 4\") == \"0\");\n    assert(solution(\"5\\n2 6\\n2 7\\n2 8\\n2 9\\n2 10\") == \"0\");\n    assert(solution(\"7\\n5 6\\n5 7\\n5 8\\n5 9\\n5 10\\n5 11\\n5 12\\n\") == \"0\");\n    assert(solution(\"4\\n10 10\\n10 11\\n10 12\\n10 13\\n\") == \"0\");\n    assert(solution(\"6\\n1 6\\n1 7\\n1 8\\n1 9\\n1 10\\n1 11\\n\") == \"0\");\n    assert(solution(\"4\\n4 1\\n4 3\\n4 5\\n4 7\\n\") == \"2\");\n    assert(solution(\"7\\n5 1\\n5 2\\n5 3\\n5 4\\n5 5\\n5 6\\n5 7\\n\") == \"0\");\n    assert(solution(\"4\\n9 9\\n9 11\\n10 1\\n10 3\\n\") == \"2\");\n    assert(solution(\"3\\n3 7\\n3 8\\n3 9\\n\") == \"0\");\n    assert(solution(\"3\\n1 2\\n1 3\\n1 4\\n\") == \"0\");\n    assert(solution(\"1\\n1 1\\n\") == \"0\");\n    assert(solution(\"2\\n1 1\\n1 2\\n\") == \"0\");\n    assert(solution(\"8\\n1 1\\n1 2\\n1 3\\n1 4\\n2 4\\n3 4\\n4 4\\n5 4\\n\") == \"4\");\n    assert(solution(\"3\\n4 7\\n4 8\\n4 9\\n\") == \"0\");\n    assert(solution(\"2\\n2 3\\n2 4\\n\") == \"0\");\n    assert(solution(\"4\\n5 1\\n5 2\\n5 3\\n5 4\\n\") == \"0\");\n    assert(solution(\"3\\n4 3\\n5 3\\n5 1\\n\") == \"1\");\n    assert(solution(\"4\\n2 4\\n2 5\\n3 6\\n3 3\\n\") == \"2\");\n    assert(solution(\"3\\n5 1\\n1 2\\n2 3\\n\") == \"2\");\n    assert(solution(\"4\\n1 4\\n2 4\\n3 4\\n4 4\\n\") == \"3\");\n    assert(solution(\"2\\n3 4\\n3 5\\n\") == \"0\");\n    assert(solution(\"2\\n1 2\\n1 3\\n\") == \"0\");\n    assert(solution(\"5\\n2 5\\n2 6\\n3 7\\n3 8\\n3 9\\n\") == \"2\");\n    assert(solution(\"4\\n3 3\\n4 4\\n4 5\\n5 6\\n\") == \"2\");\n    return 0; \n}", "prompt": "/*I have n poker cards in my hand, but they may not be able to form a straight flush. Now I want to know the minimum number of cards I need to replace, so that these n cards can all form a straight flush.\n\ninput_format:\nThe first line contains an integer $n$, which represents the number of playing cards.\n\nNext, there are $n$ lines, each containing two integers $a_{i}$ and $b_{i}$. Here, $a_{i}$ represents the suit of the $i$-th card, and $b_{i}$ represents the number of the $i$-th card.\n\noutput_format:\nA row of integers indicates the minimum number of cards to replace to achieve the goal.\n*/\n\n#include<sstream>\n#include<stdlib.h>\n#include<algorithm>\n#include<math.h>\n#include<stdio.h>\n#include<vector>\n#include<string>\n#include<climits>\n#include<cstring>\n#include<iostream>\nusing namespace std;\n\n             \nstring solution(string std_in){\n    istringstream iss(std_in);\n             ", "constraints": "- 对于 $30\\%$ 的数据，$n \\le 10$；\n- 对于 $60\\%$ 的数据，$n \\le 10^{5}$，$ 1 \\le a_{i} \\le 10^{5}$，$1 \\le b_{i} \\le n$；\n- 对于 $100\\%$ 的数据，$n \\le 10^{5}$，$1 \\le a_{i}, b_{i} \\le 10^{9}$；", "samples": [["5\n1 1\n1 2\n1 3\n1 4\n1 5", "0"], ["5\n1 9\n1 10\n2 11\n2 12\n2 13", "2"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}}
{"task_id": "P1299", "title": "切孔机", "difficulty": "advanced", "nl": "The assistant at the headquarters often needs to cut holes of various shapes on large paper. They have just purchased a new hole-cutting machine, which is much more convenient and flexible than the one they used before. They want to write a program to calculate the number of holes formed on the paper after a series of complex cuts, especially the ones shown in the figure which has two or one hole(s) formed after the cutting.", "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\nconst ll xx[4]={-1,1,0,0},yy[4]={0,0,-1,1};\nstruct point\n{\n\tll number,x,y;\n\tpoint() {}\n\tpoint(ll a,ll b):x(a),y(b) {}\n};\nstruct picture\n{\n\tbool can_go[4],visit;\n\tpicture()\n\t{\n\t\tcan_go[0]=can_go[1]=can_go[2]=can_go[3]=1;\n\t\tvisit=1;\n\t}\n};\nll n;\npoint a[205];\npicture b[205][205];\ninline bool cmpx(point a,point b)\n{\n\treturn a.x<b.x;\n}\ninline bool cmpy(point a,point b)\n{\n\treturn a.y<b.y;\n}\ninline bool cmp(point a,point b)\n{\n\tif(a.number!=b.number) return a.number<b.number;\n\tif(a.x!=b.x) return a.x<b.x;\n\treturn a.y<b.y;\n}\ninline void ready()\n{\n\tscanf(\"%lld\",&n);\n\tfor(int i=1;i<=n*2;i++)\n\t{\n\t\ta[i].number=(i+1)/2;\n\t\tscanf(\"%lld%lld\",&a[i].x,&a[i].y);\n\t}\n}\ninline void lisan()\n{\n\tll now,u;\n\tnow=-10000005;\n\tu=0;\n\tsort(a+1,a+n*2+1,cmpx);\n\tfor(ll i=1;i<=n*2;i++)\n\t{\n\t\tif(a[i].x!=now)\n\t\t{\n\t\t\tnow=a[i].x;\n\t\t\tu++;\n\t\t\ta[i].x=u;\n\t\t}\n\t\telse a[i].x=u;\n\t}\n\tnow=-10000005;\n\tu=0;\n\tsort(a+1,a+n*2+1,cmpy);\n\tfor(ll i=1;i<=n*2;i++)\n\t{\n\t\tif(a[i].y!=now)\n\t\t{\n\t\t\tnow=a[i].y;\n\t\t\tu++;\n\t\t\ta[i].y=u;\n\t\t}\n\t\telse a[i].y=u;\n\t}\n}\ninline void build_wall()\n{\n\tsort(a+1,a+n*2+1,cmp);\n\tfor(ll i=1;i<=n;i++)\n\t{\n\t\tpoint s=a[i*2-1],e=a[i*2];\n\t\tfor(ll j=s.x+1;j<=e.x;j++)\n\t\t{\n\t\t\tb[j][s.y].can_go[3]=0;\n\t\t\tb[j][s.y+1].can_go[2]=0;\n\t\t}\n\t\tfor(ll j=s.y+1;j<=e.y;j++)\n\t\t{\n\t\t\tb[s.x][j].can_go[1]=0;\n\t\t\tb[s.x+1][j].can_go[0]=0;\n\t\t}\n\t}\n}\ninline void cut_paper()\n{\n\tqueue<point>q;\n\tq.push(point(0,0));\n\twhile(!q.empty())\n\t{\n\t\tpoint now=q.front();\n\t\tq.pop();\n\t\tfor(int i=0;i<4;i++)\n\t\t{\n\t\t\tll x=now.x+xx[i],y=now.y+yy[i];\n\t\t\tif(x<0||x>200||y<0||y>200) continue;\n\t\t\tif(!b[x][y].visit) continue;\n\t\t\tif(!b[now.x][now.y].can_go[i]) continue;\n\t\t\tb[x][y].visit=0;\n\t\t\tq.push(point(x,y));\n\t\t}\n\t}\n}\ninline void bfs(ll dx,ll dy)\n{\n\tqueue<point>q;\n\tb[dx][dy].visit=0;\n\tq.push(point(dx,dy));\n\twhile(!q.empty())\n\t{\n\t\tpoint now=q.front();\n\t\tq.pop();\n\t\tfor(int i=0;i<4;i++)\n\t\t{\n\t\t\tll x=now.x+xx[i],y=now.y+yy[i];\n\t\t\tif(x<0||x>200||y<0||y>200) continue;\n\t\t\tif(!b[x][y].visit) continue;\n\t\t\tb[x][y].visit=0;\n\t\t\tq.push(point(x,y));\n\t\t}\n\t}\n}\ninline ll count_hole()\n{\n\tll ans=0;\n\tfor(ll i=0;i<=200;i++)\n\t\tfor(ll j=0;j<=200;j++)\n\t\t{\n\t\t\tif(!b[i][j].visit) continue;\n\t\t\tans++;\n\t\t\tbfs(i,j);\n\t\t}\n\treturn ans;\n}\nint main()\n{\n\tready();\n\tlisan();\n\tbuild_wall();\n\tcut_paper();\n\tll ans=count_hole();\n\tprintf(\"%lld\\n\",ans);\n\treturn 0;\n}", "step": ["Input the number of vertices and their coordinate information of the picture.", "Compress the length and width of the picture and rename the vertices according to the compressed value.", "Build the edges of the picture and define the visiting privileges.", "Use BFS to traverse all the connected unvisited edges and mark them as visited.", "Count and output the number of unvisited connected areas."], "nl_cn": "司令部的助理经常需要在大纸上切割各种形状的孔。他们刚刚购买了一台新的切孔机，该机比他们以前使用的要方便自由的多。他们想编写一个程序来求出经过一系列复杂的切孔后会发生什么情况，他们特别想知道纸上形成的孔的数量。\n\n下图列出了经过切割后形成的一些图样。\n\n  \n\nTwo holes              Two holes                     one hole                     one hole\n", "test_cases": [{"input": "4\n0 1 1 1\n1 1 1 0\n1 0 0 0\n0 0 0 1\n", "output": "1"}, {"input": "2\n0 1 1 1\n1 1 1 0\n", "output": "0"}, {"input": "2\n0 0 1 1\n1 1 1 0\n", "output": "0"}, {"input": "3\n0 0 1 1\n1 0 1 1\n1 1 1 0\n", "output": "0"}, {"input": "5\n0 0 1 1\n1 0 1 1\n1 1 1 0\n0 1 1 1\n0 0 0 1\n", "output": "1"}, {"input": "5\n0 1 1 1\n1 1 1 0\n1 0 0 0\n0 0 0 1\n1 2 2 2\n", "output": "1"}, {"input": "1\n0 0 0 0\n", "output": "0"}, {"input": "4\n0 0 0 0\n0 0 0 0\n0 0 0 0\n0 0 0 0\n", "output": "0"}, {"input": "5\n0 1 1 1\n1 1 1 0\n1 0 0 0\n0 0 0 1\n0 2 0 2\n", "output": "1"}, {"input": "10\n0 1 1 1\n1 1 1 0\n1 0 0 0\n0 0 0 1\n0 1 1 1\n1 1 1 0\n1 0 0 0\n0 0 0 1\n0 1 1 1\n1 1 1 0\n", "output": "1"}], "test": "#undef NDEBUG\n#include<assert.h>\nint main(){\n    assert(solution(\"4\\n0 1 1 1\\n1 1 1 0\\n1 0 0 0\\n0 0 0 1\\n\") == \"1\");\n    assert(solution(\"2\\n0 1 1 1\\n1 1 1 0\\n\") == \"0\");\n    assert(solution(\"2\\n0 0 1 1\\n1 1 1 0\\n\") == \"0\");\n    assert(solution(\"3\\n0 0 1 1\\n1 0 1 1\\n1 1 1 0\\n\") == \"0\");\n    assert(solution(\"5\\n0 0 1 1\\n1 0 1 1\\n1 1 1 0\\n0 1 1 1\\n0 0 0 1\\n\") == \"1\");\n    assert(solution(\"5\\n0 1 1 1\\n1 1 1 0\\n1 0 0 0\\n0 0 0 1\\n1 2 2 2\\n\") == \"1\");\n    assert(solution(\"1\\n0 0 0 0\\n\") == \"0\");\n    assert(solution(\"4\\n0 0 0 0\\n0 0 0 0\\n0 0 0 0\\n0 0 0 0\\n\") == \"0\");\n    assert(solution(\"5\\n0 1 1 1\\n1 1 1 0\\n1 0 0 0\\n0 0 0 1\\n0 2 0 2\\n\") == \"1\");\n    assert(solution(\"10\\n0 1 1 1\\n1 1 1 0\\n1 0 0 0\\n0 0 0 1\\n0 1 1 1\\n1 1 1 0\\n1 0 0 0\\n0 0 0 1\\n0 1 1 1\\n1 1 1 0\\n\") == \"1\");\n    return 0; \n}", "prompt": "/*The assistant at the headquarters often needs to cut holes of various shapes on large paper. They have just purchased a new hole-cutting machine, which is much more convenient and flexible than the one they used before. They want to write a program to calculate the number of holes formed on the paper after a series of complex cuts, especially the ones shown in the figure which has two or one hole(s) formed after the cutting.\n\ninput_format:\nThe first line of the input file is an integer N, indicating the number of paper cutting operations, 1≤N≤100. Each of the next N lines gives an exact cut operation, and each cut gives four integers separated by Spaces, x1, y1, x2, y2, -1000≤x1, y1, x2, y2≤1000. x1 and y1 are the coordinates at the beginning of the cut line, x2 and y2 are the coordinates at the end of the cut line. You can assume that all the cut points are on the paper and will not go out of bounds. Each cut is parallel to the x and y axes on the paper.\n\noutput_format:\nFor each cutting operation, the number of individual holes left on the paper is required to be output. Note that the minimum area of any hole is not less than 1 square unit.\n*/\n\n#include<sstream>\n#include<stdlib.h>\n#include<algorithm>\n#include<math.h>\n#include<stdio.h>\n#include<vector>\n#include<string>\n#include<climits>\n#include<cstring>\n#include<iostream>\nusing namespace std;\n\n             \nstring solution(string std_in){\n    istringstream iss(std_in);\n             ", "constraints": "", "samples": [["4\n0 1 1 1\n1 1 1 0\n1 0 0 0\n0 0 0 1\n", "1\n"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}}
{"task_id": "P3193", "title": "[HNOI2008]GT考试", "difficulty": "advanced", "nl": "Ashen is preparing to apply for GT exam, and his admission ticket number is an N-digit number $X_1,X_2…X_n(0 \\leq X_i \\leq 9)$. He doesn't want unlucky numbers to appear on his admission ticket number. \nHe has M unlucky numbers $A_1,A_2…A_m(0 \\leq A_i \\leq 9)$. Not appearing means that $X_1,X_2…X_n$ does not contain a segment exactly equal to $A_1,A_2…A_m$. $A_1$ and $X_1$ can be 0.", "code": "#include <cstdio>\n#include <cstring>\n#include <algorithm>\n\nconst int N=21;\nint n,m,mod,nxt[N];\nchar s[N];\n\nvoid upd(int &x,int y) {\n\t(x+=y)>=mod&&(x-=mod);\n}\nstruct Matrix {\n\tint n,A[N][N];\n\tMatrix(int _n=0) {n=_n,memset(A,0,sizeof(A));}\n\tvoid operator ~ () {\n\t\tfor(int i=0;i<n;++i) A[i][i]=1;\n\t}\n\tMatrix operator * (const Matrix &b) const {\n\t\tMatrix ret(n);\n\t\tfor(int i=0;i<n;++i) for(int j=0;j<n;++j) for(int k=0;k<n;++k) {\n\t\t\tupd(ret.A[i][k],1LL*A[i][j]*b.A[j][k]%mod);\n\t\t}\n\t\treturn ret;\n\t}\n\tMatrix operator ^ (const long long &b) const {\n\t\tMatrix ret(n),x=*this; ~ret;\n\t\tfor(long long p=b;p;p>>=1,x=x*x) if(p&1) ret=ret*x;\n\t\treturn ret;\n\t}\n};\n\nMatrix kmp() {\n\tnxt[1]=0;\n\tfor(int i=2,j=0;i<=m;++i) {\n\t\twhile(j&&s[j+1]!=s[i]) j=nxt[j];\n\t\tif(s[j+1]==s[i]) ++j;\n\t\tnxt[i]=j;\n\t}\n\tMatrix a(m);\n\tfor(int i=0;i<m;++i) {\n\t\tfor(char ch='0';ch<='9';++ch) {\n\t\t\tint j=i;\n\t\t\twhile(j&&s[j+1]!=ch) j=nxt[j];\n\t\t\tif(s[j+1]==ch) ++j;\n\t\t\t++a.A[i][j];\n\t\t}\n\t}\n\treturn a;\n}\nint main() {\n\tscanf(\"%d%d%d%s\",&n,&m,&mod,s+1);\n\tMatrix a=kmp();\n\ta=a^n;\n\tint ans=0;\n\tfor(int i=0;i<m;++i) upd(ans,a.A[0][i]);\n\tprintf(\"%d\\n\",ans);\n\treturn 0;\n}", "step": ["Compute the KMP matrix for s", "Raise the KMP matrix to the power of n using matrix exponentiation", "Compute the sum of the first row of the resulting matrix", "Output the answer"], "nl_cn": "阿申准备报名参加 GT 考试，准考证号为 $N$ 位数$X_1,X_2…X_n(0\\le X_i\\le9)$，他不希望准考证号上出现不吉利的数字。\n他的不吉利数字$A_1,A_2…A_m(0\\le A_i\\le 9)$ 有 $M$ 位，不出现是指 $X_1,X_2…X_n$ 中没有恰好一段等于 $A_1,A_2…A_m$，$A_1$ 和$X_1$ 可以为 $0$", "test_cases": [{"input": "4 3 100\n111", "output": "81"}], "test": "#undef NDEBUG\n#include<assert.h>\nint main(){\n    assert(solution(\"4 3 100\\n111\") == \"81\");\n    return 0; \n}", "prompt": "/*Ashen is preparing to apply for GT exam, and his admission ticket number is an N-digit number $X_1,X_2…X_n(0 \\leq X_i \\leq 9)$. He doesn't want unlucky numbers to appear on his admission ticket number. \nHe has M unlucky numbers $A_1,A_2…A_m(0 \\leq A_i \\leq 9)$. Not appearing means that $X_1,X_2…X_n$ does not contain a segment exactly equal to $A_1,A_2…A_m$. $A_1$ and $X_1$ can be 0.\n\ninput_format:\nOn the first line, enter N,M,K. On the next line, enter the number of M bits.\n\noutput_format:\nAshin wants to know how many kinds of numbers do not appear unlucky digits, and output the result of taking the remainder of the module $K$.\n*/\n\n#include<sstream>\n#include<stdlib.h>\n#include<algorithm>\n#include<math.h>\n#include<stdio.h>\n#include<vector>\n#include<string>\n#include<climits>\n#include<cstring>\n#include<iostream>\nusing namespace std;\n\n             \nstring solution(string std_in){\n    istringstream iss(std_in);\n             ", "constraints": "### 数据范围及约定\n\n对于全部数据，$N\\leq10^9$，$M\\leq 20$，$K\\leq1000$。", "samples": [["4 3 100\n111", "81"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}}
{"task_id": "P1550", "title": "[USACO08OCT]Watering Hole G", "difficulty": "advanced", "nl": "Farmer John's farm is experiencing a water shortage.\n\nHe decides to introduce water to his $n$ pastures by digging wells and building pipelines to connect them all for water supply. Digging a well in pasture $i$ costs $W_i$ dollars. Connecting pasture $i$ with pasture $j$ costs $P_{i,j}$ dollars ($P_{j,i}=P_{i,j}$).\n\nWhat is the minimum amount of money FJ needs to spend to ensure that all pastures are either directly connected with a pasture with water or have a well?", "code": "#include <iostream>\n#include <cstdio>\n#include <queue>\nusing namespace std;\nstruct edge{\n    int from,to,len;\n    const bool operator < (edge b) const{\n        return this->len>b.len;\n    }\n}e[100000];\npriority_queue <edge> que;\nint n,a[302][302],w[301],fa[302],ans;\nint find(int x)\n{\n    if(fa[x]==x)return x;\n    return fa[x]=find(fa[x]);\n}\nint mst()\n{\n    while(!que.empty()){\n        edge p=que.top();\n        if(find(p.from)!=find(p.to))\n        {\n            fa[fa[p.to]]=fa[p.from];\n            ans+=p.len;\n        }\n        que.pop();\n    }\n    return ans;\n}\nint main()\n{\n    scanf(\"%d\",&n);\n    for(int i=1;i<=n;i++)scanf(\"%d\",&w[i]);\n    for(int i=1;i<=n;i++)\n    {\n        for(int j=1;j<=n;j++)\n        {\n            scanf(\"%d\",&a[i][j]);\n            if(i!=j)que.push((edge){i,j,a[i][j]});\n        }\n    }\n    n++;\n    for(int i=1;i<n;i++){\n        que.push((edge){i,n,w[i]});\n        que.push((edge){n,i,w[i]});\n    }\n    for(int i=1;i<=n;i++)fa[i]=i;\n    printf(\"%d\",mst());\n    return 0;\n}", "step": ["Initialize the priority queue to store edge structure by descending order.", "Read an integer n and an array w of length n.", "Read an n×n adjacency matrix and push all non-self-loops into the priority queue.", "Add a new vertex and connect it with all other vertices with the weight of w[i].", "For every vertex, initialize its father as itself.", "Pop edges from the priority queue and update the father of each vertex, calculate the weight sum."], "nl_cn": "Farmer John 的农场缺水了。\n\n他决定将水引入到他的 $n$ 个牧场。他准备通过挖若干井，并在各块田中修筑水道来连通各块田地以供水。在第 $i$ 号田中挖一口井需要花费 $W_i$ 元。连接 $i$ 号田与 $j$ 号田需要 $P_{i,j}$（$P_{j,i}=P_{i,j}$）元。\n\n请求出 FJ 需要为使所有农场都与有水的农场相连或拥有水井所需要的最少钱数。", "test_cases": [{"input": "4\n5\n4\n4\n3\n0 2 2 2\n2 0 3 3\n2 3 0 4\n2 3 4 0", "output": "9"}, {"input": "1\n1\n0", "output": "1"}, {"input": "2\n1\n1\n0 1\n1 0", "output": "2"}, {"input": "5\n5\n5\n5\n5\n5\n0 1 2 3 4\n1 0 2 3 4\n2 2 0 3 4\n3 3 3 0 4\n4 4 4 4 0", "output": "15"}, {"input": "3\n2\n2\n2\n0 2 2\n2 0 2\n2 2 0", "output": "6"}, {"input": "3\n1\n2\n3\n0 1 1\n1 0 1\n1 1 0", "output": "3"}, {"input": "2\n5\n2\n0 3\n3 0", "output": "5"}, {"input": "3\n2\n3\n1\n0 1 1\n1 0 1\n1 1 0\n", "output": "3"}, {"input": "2\n2\n3\n0 1\n1 0\n", "output": "3"}, {"input": "2\n1\n2\n0 2\n2 0\n", "output": "3"}, {"input": "1\n5\n0\n", "output": "5"}, {"input": "3\n2\n3\n1\n0 1 2\n1 0 3\n2 3 0\n", "output": "4"}, {"input": "1\n2\n0\n", "output": "2"}, {"input": "4\n3\n2\n5\n4\n0 2 2 3\n2 0 4 5\n2 4 0 6\n3 5 6 0\n", "output": "9"}, {"input": "3\n3\n2\n4\n0 1 2\n1 0 3\n2 3 0\n", "output": "5"}, {"input": "1\n5\n3\n5", "output": "5"}, {"input": "3\n1\n1\n1\n0 2 2\n2 0 1\n2 1 0", "output": "3"}, {"input": "3\n2\n3\n5\n0 1 3\n1 0 2\n3 2 0", "output": "5"}, {"input": "2\n5\n5\n0 5\n5 0", "output": "10"}, {"input": "4\n5\n4\n3\n2\n0 2 2 2\n2 0 3 3\n2 3 0 4\n2 3 4 0", "output": "8"}], "test": "#undef NDEBUG\n#include<assert.h>\nint main(){\n    assert(solution(\"4\\n5\\n4\\n4\\n3\\n0 2 2 2\\n2 0 3 3\\n2 3 0 4\\n2 3 4 0\") == \"9\");\n    assert(solution(\"1\\n1\\n0\") == \"1\");\n    assert(solution(\"2\\n1\\n1\\n0 1\\n1 0\") == \"2\");\n    assert(solution(\"5\\n5\\n5\\n5\\n5\\n5\\n0 1 2 3 4\\n1 0 2 3 4\\n2 2 0 3 4\\n3 3 3 0 4\\n4 4 4 4 0\") == \"15\");\n    assert(solution(\"3\\n2\\n2\\n2\\n0 2 2\\n2 0 2\\n2 2 0\") == \"6\");\n    assert(solution(\"3\\n1\\n2\\n3\\n0 1 1\\n1 0 1\\n1 1 0\") == \"3\");\n    assert(solution(\"2\\n5\\n2\\n0 3\\n3 0\") == \"5\");\n    assert(solution(\"3\\n2\\n3\\n1\\n0 1 1\\n1 0 1\\n1 1 0\\n\") == \"3\");\n    assert(solution(\"2\\n2\\n3\\n0 1\\n1 0\\n\") == \"3\");\n    assert(solution(\"2\\n1\\n2\\n0 2\\n2 0\\n\") == \"3\");\n    assert(solution(\"1\\n5\\n0\\n\") == \"5\");\n    assert(solution(\"3\\n2\\n3\\n1\\n0 1 2\\n1 0 3\\n2 3 0\\n\") == \"4\");\n    assert(solution(\"1\\n2\\n0\\n\") == \"2\");\n    assert(solution(\"4\\n3\\n2\\n5\\n4\\n0 2 2 3\\n2 0 4 5\\n2 4 0 6\\n3 5 6 0\\n\") == \"9\");\n    assert(solution(\"3\\n3\\n2\\n4\\n0 1 2\\n1 0 3\\n2 3 0\\n\") == \"5\");\n    assert(solution(\"1\\n5\\n3\\n5\") == \"5\");\n    assert(solution(\"3\\n1\\n1\\n1\\n0 2 2\\n2 0 1\\n2 1 0\") == \"3\");\n    assert(solution(\"3\\n2\\n3\\n5\\n0 1 3\\n1 0 2\\n3 2 0\") == \"5\");\n    assert(solution(\"2\\n5\\n5\\n0 5\\n5 0\") == \"10\");\n    assert(solution(\"4\\n5\\n4\\n3\\n2\\n0 2 2 2\\n2 0 3 3\\n2 3 0 4\\n2 3 4 0\") == \"8\");\n    return 0; \n}", "prompt": "/*Farmer John's farm is experiencing a water shortage.\n\nHe decides to introduce water to his $n$ pastures by digging wells and building pipelines to connect them all for water supply. Digging a well in pasture $i$ costs $W_i$ dollars. Connecting pasture $i$ with pasture $j$ costs $P_{i,j}$ dollars ($P_{j,i}=P_{i,j}$).\n\nWhat is the minimum amount of money FJ needs to spend to ensure that all pastures are either directly connected with a pasture with water or have a well?\n\ninput_format:\nThe first action is an integer $n$.\n\nNext $n$lines, each with an integer $W_i$.\n\nThe next $n$line, each line $n$integer, the number of $j$in the first $i$line indicates the cost of connecting $i$field and $j$field $P_{i,j}$.\n\noutput_format:\nOutput minimum overhead.\n*/\n\n#include<sstream>\n#include<stdlib.h>\n#include<algorithm>\n#include<math.h>\n#include<stdio.h>\n#include<vector>\n#include<string>\n#include<climits>\n#include<cstring>\n#include<iostream>\nusing namespace std;\n\n             \nstring solution(string std_in){\n    istringstream iss(std_in);\n             ", "constraints": "对于 $100\\%$ 的数据，$1 \\leq n \\leq 300$，$1 \\leq W_i \\leq 10^5$，$0 \\leq P_{i,j} \\leq 10^5$。", "samples": [["4\n5\n4\n4\n3\n0 2 2 2\n2 0 3 3\n2 3 0 4\n2 3 4 0", "9"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}}
{"task_id": "P6352", "title": "[COCI2007-2008#3] CETIRI", "difficulty": "basic", "nl": "You originally have four numbers, which form an arithmetic sequence when sorted in ascending order.\n\nBut now one of the numbers is lost, and the order of the remaining three numbers is also shuffled.\n\nPlease find the fourth number.", "code": "#include<bits/stdc++.h>\nint n[3],c1,c2,c3;\nint main()\n{\n\tscanf(\"%d%d%d\",n,n+1,n+2); //读入 n[0],n[1],n[2]。\n\tstd::sort(n,n+3);//排序一下，因为我们是从下标 0 使用到下标 2 的，所以排序的起始位置是 n (或 n+0 )，结束位置是 n+3。\n\tc1=n[1]-n[0],c2=n[2]-n[1]; //计算差。\n\tprintf(\"%d\",c1==c2?n[2]+c1:(c1>c2?n[1]-c2:n[2]-c1));\n    \t//这里用了三目运算符，我们先判断是否是第 1 种情况，执行计算；如果不是，在判断是否是第二种情况。最后计算出表达式的值，输出即可。\n\treturn 0;\n}", "step": ["Initialize an array of three integers and three integer variables c1,c2,c3.", "Read in three integers and sort them in ascending order.", "Calculate the difference between the two smallest integers and assign the result to c1.", "Calculate the difference between the largest and second largest integers and assign the result to c2.", "Output the largest integer added to c1 if c1 is equal to c2, or output the second smallest integer subtracted by c2 if c1 is greater than c2, or output the largest integer subtracted by c1."], "nl_cn": "你原本有 $4$ 个数，它们从小到大排序后构成了等差数列。\n\n但是现在丢失了一个数，并且其余的三个数的顺序也被打乱了。\n\n请你找出第四个数。", "test_cases": [{"input": "4 6 8", "output": "10"}, {"input": "10 1 4", "output": "7"}, {"input": "-5 -2 1\n", "output": "4"}, {"input": "0 0 0\n", "output": "0"}, {"input": "20 20 20\n", "output": "20"}, {"input": "-10 0 10\n", "output": "20"}, {"input": "12 15 18\n", "output": "21"}, {"input": "6 8 10\n", "output": "12"}, {"input": "57 57 57\n", "output": "57"}, {"input": "1 2 3\n", "output": "4"}, {"input": "3 1 2\n", "output": "4"}, {"input": "25 50 75\n", "output": "100"}, {"input": "20 30 40", "output": "50"}, {"input": "100 200 300", "output": "400"}, {"input": "11 13 15", "output": "17"}, {"input": "25 27 29", "output": "31"}, {"input": "5 9 13", "output": "17"}, {"input": "16 20 24", "output": "28"}, {"input": "-1 0 2\n", "output": "1"}, {"input": "5 9 7\n", "output": "11"}, {"input": "1 1 1\n", "output": "1"}, {"input": "200 300 400\n", "output": "500"}, {"input": "2 5 8\n", "output": "11"}, {"input": "15 25 35\n", "output": "45"}, {"input": "-50 -40 -30\n", "output": "-20"}, {"input": "0 5 10\n", "output": "15"}, {"input": "-2 -2 -2\n", "output": "-2"}, {"input": "1000 2000 3000\n", "output": "4000"}, {"input": "1 9 7\n", "output": "5"}, {"input": "12 9 3\n", "output": "6"}, {"input": "20 40 60\n", "output": "80"}, {"input": "-1 0 1\n", "output": "2"}, {"input": "7 7 7\n", "output": "7"}, {"input": "-10 -5 0\n", "output": "5"}, {"input": "3 6 9\n", "output": "12"}, {"input": "111 222 333\n", "output": "444"}, {"input": "1 3 5\n", "output": "7"}, {"input": "-5 -4 -3\n", "output": "-2"}, {"input": "0 100 200\n", "output": "300"}], "test": "#undef NDEBUG\n#include<assert.h>\nint main(){\n    assert(solution(\"4 6 8\") == \"10\");\n    assert(solution(\"10 1 4\") == \"7\");\n    assert(solution(\"-5 -2 1\\n\") == \"4\");\n    assert(solution(\"0 0 0\\n\") == \"0\");\n    assert(solution(\"20 20 20\\n\") == \"20\");\n    assert(solution(\"-10 0 10\\n\") == \"20\");\n    assert(solution(\"12 15 18\\n\") == \"21\");\n    assert(solution(\"6 8 10\\n\") == \"12\");\n    assert(solution(\"57 57 57\\n\") == \"57\");\n    assert(solution(\"1 2 3\\n\") == \"4\");\n    assert(solution(\"3 1 2\\n\") == \"4\");\n    assert(solution(\"25 50 75\\n\") == \"100\");\n    assert(solution(\"20 30 40\") == \"50\");\n    assert(solution(\"100 200 300\") == \"400\");\n    assert(solution(\"11 13 15\") == \"17\");\n    assert(solution(\"25 27 29\") == \"31\");\n    assert(solution(\"5 9 13\") == \"17\");\n    assert(solution(\"16 20 24\") == \"28\");\n    assert(solution(\"-1 0 2\\n\") == \"1\");\n    assert(solution(\"5 9 7\\n\") == \"11\");\n    assert(solution(\"1 1 1\\n\") == \"1\");\n    assert(solution(\"200 300 400\\n\") == \"500\");\n    assert(solution(\"2 5 8\\n\") == \"11\");\n    assert(solution(\"15 25 35\\n\") == \"45\");\n    assert(solution(\"-50 -40 -30\\n\") == \"-20\");\n    assert(solution(\"0 5 10\\n\") == \"15\");\n    assert(solution(\"-2 -2 -2\\n\") == \"-2\");\n    assert(solution(\"1000 2000 3000\\n\") == \"4000\");\n    assert(solution(\"1 9 7\\n\") == \"5\");\n    assert(solution(\"12 9 3\\n\") == \"6\");\n    assert(solution(\"20 40 60\\n\") == \"80\");\n    assert(solution(\"-1 0 1\\n\") == \"2\");\n    assert(solution(\"7 7 7\\n\") == \"7\");\n    assert(solution(\"-10 -5 0\\n\") == \"5\");\n    assert(solution(\"3 6 9\\n\") == \"12\");\n    assert(solution(\"111 222 333\\n\") == \"444\");\n    assert(solution(\"1 3 5\\n\") == \"7\");\n    assert(solution(\"-5 -4 -3\\n\") == \"-2\");\n    assert(solution(\"0 100 200\\n\") == \"300\");\n    return 0; \n}", "prompt": "/*You originally have four numbers, which form an arithmetic sequence when sorted in ascending order.\n\nBut now one of the numbers is lost, and the order of the remaining three numbers is also shuffled.\n\nPlease find the fourth number.\n\ninput_format:\nEnter a line of three integers. Make sure these numbers are between $-100\\sim 100$.\n\noutput_format:\nOutput a line with a number, which is the fourth number.\n\n** solution may not be unique, but it is guaranteed to exist. In this case, SPJ is used. **\n*/\n\n#include<sstream>\n#include<stdlib.h>\n#include<algorithm>\n#include<math.h>\n#include<stdio.h>\n#include<vector>\n#include<string>\n#include<climits>\n#include<cstring>\n#include<iostream>\nusing namespace std;\n\n             \nstring solution(string std_in){\n    istringstream iss(std_in);\n             ", "constraints": "#### 说明\n\n**题目译自 [COCI2007-2008](https://hsin.hr/coci/archive/2007_2008/) [CONTEST #3](https://hsin.hr/coci/archive/2007_2008/contest3_tasks.pdf) *T1 CETIRI***。", "samples": [["4 6 8", "10"], ["10 1 4", "7"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000], "memory": [32000, 32000, 32000, 32000, 32000]}}
{"task_id": "P5723", "title": "【深基4.例13】质数口袋", "difficulty": "challenge", "nl": "Little A has a prime pocket that can hold various prime numbers. He starts from 2 and checks whether each natural number is a prime number in turn. If it is a prime number, he will put the number into the pocket.\n\nThe payload of the pocket is the sum of all the numbers in the pocket.\n\nHowever, the pocket's load capacity is limited, and the sum of the prime numbers it contains cannot exceed L. Given L, how many prime numbers can the pocket hold? Output these prime numbers from small to large, then output the maximum number of prime numbers that can be held, separated by line breaks.", "code": "#include<bits/stdc++.h>\nusing namespace std;\nint n,x;\nlong long sum=0;\nint pd(int y) {\n\tfor(int i=2; i*i<=y; ++i) {\n\t\tif(y%i==0) return 0;\n\t}\n\treturn 1;\n}\nint main() {\n\tscanf(\"%d\",&n);\n\tif(n<2) {\n\t\tprintf(\"0\\n\");\n\t\treturn 0;\n\t} else if(n==2) {\n\t\tprintf(\"2\\n1\\n\");\n\t\treturn 0;\n\t}\n\tfor(int i=2; i<=n; ++i) {\n\t\tif(i%2==0&&i!=2) continue;\n\t\tif(sum+i>n) {\n\t\t\tprintf(\"%d\\n\",x);\n\t\t\treturn 0;\n\t\t}\n\t\tif(pd(i)) {\n\t\t\tprintf(\"%d\\n\",i);\n\t\t\tsum+=i;\n\t\t\tx++;\n\t\t}\n\t}\n\treturn 0;\n}", "step": ["Initialize variables n,x,sum to 0.", "Read in input n from user.", "Loop through numbers 2 to n inclusive, checking if each number is prime.", "If a number is prime and its sum and x are less than or equal to n, print the number and increment the sum and x.", "If the sum and the current number exceed n, print x and exit the program."], "nl_cn": "小 A 有一个质数口袋，里面可以装各个质数。他从 $2$ 开始，依次判断各个自然数是不是质数，如果是质数就会把这个数字装入口袋。\n\n口袋的负载量就是口袋里的所有数字之和。\n\n但是口袋的承重量有限，装的质数的和不能超过 $L$。给出 $L$，请问口袋里能装下几个质数？将这些质数从小往大输出，然后输出最多能装下的质数的个数，数字之间用换行隔开。", "test_cases": [{"input": "100", "output": "2\n3\n5\n7\n11\n13\n17\n19\n23\n9"}, {"input": "5", "output": "2\n3\n2"}, {"input": "11", "output": "2\n3\n5\n3"}, {"input": "7", "output": "2\n3\n2"}, {"input": "6", "output": "2\n3\n2"}], "test": "#undef NDEBUG\n#include<assert.h>\nint main(){\n    assert(solution(\"100\") == \"2\\n3\\n5\\n7\\n11\\n13\\n17\\n19\\n23\\n9\");\n    assert(solution(\"5\") == \"2\\n3\\n2\");\n    assert(solution(\"11\") == \"2\\n3\\n5\\n3\");\n    assert(solution(\"7\") == \"2\\n3\\n2\");\n    assert(solution(\"6\") == \"2\\n3\\n2\");\n    return 0; \n}", "prompt": "/*Little A has a prime pocket that can hold various prime numbers. He starts from 2 and checks whether each natural number is a prime number in turn. If it is a prime number, he will put the number into the pocket.\n\nThe payload of the pocket is the sum of all the numbers in the pocket.\n\nHowever, the pocket's load capacity is limited, and the sum of the prime numbers it contains cannot exceed L. Given L, how many prime numbers can the pocket hold? Output these prime numbers from small to large, then output the maximum number of prime numbers that can be held, separated by line breaks.\n\ninput_format:\nOne line is a positive integer $L$.\n\noutput_format:\nOutput these primes from small to large, and then output the maximum number of primes that can fit, with empty lines between all the numbers.\n*/\n\n#include<sstream>\n#include<stdlib.h>\n#include<algorithm>\n#include<math.h>\n#include<stdio.h>\n#include<vector>\n#include<string>\n#include<climits>\n#include<cstring>\n#include<iostream>\nusing namespace std;\n\n             \nstring solution(string std_in){\n    istringstream iss(std_in);\n             ", "constraints": "数据保证，$1 \\le L \\le {10}^5$。", "samples": [["100", "2\n3\n5\n7\n11\n13\n17\n19\n23\n9"], ["5", "2\n3\n2"], ["11", "2\n3\n5\n3"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000]}}
{"task_id": "P7633", "title": "[COCI2010-2011#5] BRODOVI", "difficulty": "challenge", "nl": "Mirko lives in a small town with a port that rarely has any ships passing by. However, he still remembers the day when every ship that has ever visited the port appeared. He denotes that day as day 1.\n\nMany days have passed and Mirko has noted down all the days when at least one ship visited the port, calling them entertainment days. Additionally, Mirko noticed that each ship visits the port at regular intervals. For example, an interval of length 3 means that a ship visits the port on days 1, 4, 7, 10, and so on.\n\nGiven Mirko's list of entertainment days (which includes today and today is an entertainment day), calculate the minimum possible number of ships that have visited his port. Note that all entertainment days appear on Mirko's list and there is always a possible solution.", "code": "#include<bits/stdc++.h>\nusing namespace std;\nconst int N=5005;\nint n,ans,cur,a[N];\nbool vis[N];\nbool break_;\nint main() {\n\tcin>>n;\n\tfor(int i=1; i<=n; i++) {\n\t\tcin>>a[i];\n\t\ta[i]--;//先减一\n\t}\n\tcur=2;//初始化\n\twhile(1) {\n\t\tfor(int i=cur; i<=n; i++) {//找第一个没标记的点\n\t\t\tif(!vis[i]) {\n\t\t\t\tcur=i;\n\t\t\t\t++ans;\n\t\t\t\tbreak;\n\t\t\t} else if(i==n) {\n\t\t\t\tbreak_=1;//标记结束while\n\t\t\t}\n\t\t}\n\t\tif(break_){//退出while\n\t\t\tbreak;\n\t\t}\n\t\tfor(int i=cur; i<=n; i++) {//标记倍数\n\t\t\tif(a[i]%a[cur]==0) {\n\t\t\t\tvis[i]=1;\n\t\t\t}\n\t\t}\n\t}\n\tcout<<ans;\n\treturn 0;\n}", "step": ["Read in the first element, subtract one from the input size, read in the rest of the array, and then start counting unique elements", "Loop through each element, skipping previously visited elements", "Increment the count of unique elements and set all elements divisible by the current element as visited", "Print the count of unique elements"], "nl_cn": "Mirko 住在一个难得有船经过的有港口的小镇上。然而，直到今天，Mirko 还记得那天所有造访过这个港口的船只都出现了。他用索引 $1$ 表示这一天。\n\n许多天过去了，Mirko 记下了至少有一艘船访问港口的日子，把这些日子命名为娱乐日。\n\n此外，Mirko 注意到每艘船都定期访问港口。例如，长度为 $3$ 的间隔表示某艘船在第 $1$ 天、第 $4$ 天、第 $7$ 天、第 $10$ 天等时间访问港口。\n\n给出 Mirko 的娱乐日列表（包括今天，且今天也是一个娱乐日），计算访问他的港口的最小可能的船只数量。\n\n注:所有娱乐日都出现在 Mirko 的列表上，保证永远存在答案。", "test_cases": [{"input": "3\n1\n3\n4 ", "output": "2"}, {"input": "5\n1\n7\n10\n13\n19 \n", "output": "2"}, {"input": "3\n1\n500000000\n999999999", "output": "1"}, {"input": "2\n1\n2\n", "output": "1"}, {"input": "4\n1\n2\n3\n4\n", "output": "1"}, {"input": "3\n1\n2\n1000000000\n", "output": "1"}, {"input": "6\n1\n10\n100\n1000\n10000\n100000\n", "output": "1"}, {"input": "2\n1\n1000000000\n", "output": "1"}, {"input": "4\n1\n100\n10000\n1000000\n", "output": "1"}, {"input": "5\n1\n2\n4\n6\n8\n", "output": "1"}, {"input": "2\n1\n999999999\n", "output": "1"}, {"input": "3\n1\n10\n100\n", "output": "1"}, {"input": "3\n1\n2\n3\n", "output": "1"}, {"input": "3\n1\n5\n15\n", "output": "2"}, {"input": "3\n1\n7\n14\n", "output": "2"}, {"input": "2\n1\n1000000\n", "output": "1"}, {"input": "5\n1\n3\n8\n12\n15\n", "output": "3"}, {"input": "2\n1\n10000\n", "output": "1"}, {"input": "2\n1\n3 \n", "output": "1"}, {"input": "2\n1\n19 \n", "output": "1"}, {"input": "3\n1\n4\n7 \n", "output": "1"}, {"input": "4\n1\n4\n7\n10 \n", "output": "1"}], "test": "#undef NDEBUG\n#include<assert.h>\nint main(){\n    assert(solution(\"3\\n1\\n3\\n4 \") == \"2\");\n    assert(solution(\"5\\n1\\n7\\n10\\n13\\n19 \\n\") == \"2\");\n    assert(solution(\"3\\n1\\n500000000\\n999999999\") == \"1\");\n    assert(solution(\"2\\n1\\n2\\n\") == \"1\");\n    assert(solution(\"4\\n1\\n2\\n3\\n4\\n\") == \"1\");\n    assert(solution(\"3\\n1\\n2\\n1000000000\\n\") == \"1\");\n    assert(solution(\"6\\n1\\n10\\n100\\n1000\\n10000\\n100000\\n\") == \"1\");\n    assert(solution(\"2\\n1\\n1000000000\\n\") == \"1\");\n    assert(solution(\"4\\n1\\n100\\n10000\\n1000000\\n\") == \"1\");\n    assert(solution(\"5\\n1\\n2\\n4\\n6\\n8\\n\") == \"1\");\n    assert(solution(\"2\\n1\\n999999999\\n\") == \"1\");\n    assert(solution(\"3\\n1\\n10\\n100\\n\") == \"1\");\n    assert(solution(\"3\\n1\\n2\\n3\\n\") == \"1\");\n    assert(solution(\"3\\n1\\n5\\n15\\n\") == \"2\");\n    assert(solution(\"3\\n1\\n7\\n14\\n\") == \"2\");\n    assert(solution(\"2\\n1\\n1000000\\n\") == \"1\");\n    assert(solution(\"5\\n1\\n3\\n8\\n12\\n15\\n\") == \"3\");\n    assert(solution(\"2\\n1\\n10000\\n\") == \"1\");\n    assert(solution(\"2\\n1\\n3 \\n\") == \"1\");\n    assert(solution(\"2\\n1\\n19 \\n\") == \"1\");\n    assert(solution(\"3\\n1\\n4\\n7 \\n\") == \"1\");\n    assert(solution(\"4\\n1\\n4\\n7\\n10 \\n\") == \"1\");\n    return 0; \n}", "prompt": "/*Mirko lives in a small town with a port that rarely has any ships passing by. However, he still remembers the day when every ship that has ever visited the port appeared. He denotes that day as day 1.\n\nMany days have passed and Mirko has noted down all the days when at least one ship visited the port, calling them entertainment days. Additionally, Mirko noticed that each ship visits the port at regular intervals. For example, an interval of length 3 means that a ship visits the port on days 1, 4, 7, 10, and so on.\n\nGiven Mirko's list of entertainment days (which includes today and today is an entertainment day), calculate the minimum possible number of ships that have visited his port. Note that all entertainment days appear on Mirko's list and there is always a possible solution.\n\ninput_format:\nThe first $1$line entered contains an integer $N$, which is the number of entertainment days.\n\nThe following $N$rows, each with an integer $A_i$, represent the number of entertainment days on the table, arranged in ascending order. The first and last entertainment days are the date and today respectively when Mirko started monitoring port traffic. Today will always be on the list. The first index is always $1$.\n\noutput_format:\nOutput a total line, an integer, for the minimum number of ships visiting Mirko's port.\n*/\n\n#include<sstream>\n#include<stdlib.h>\n#include<algorithm>\n#include<math.h>\n#include<stdio.h>\n#include<vector>\n#include<string>\n#include<climits>\n#include<cstring>\n#include<iostream>\nusing namespace std;\n\n             \nstring solution(string std_in){\n    istringstream iss(std_in);\n             ", "constraints": "**【样例说明#1】**\n\n最少需要两条船，第一条每 $2$ 天来一次，第二条每 $3$ 天来一次。\n\n**【数据范围】**\n\n对于 $70\\%$ 的数据，$A_i\\le 5\\times 10^6$\n\n对于 $100\\%$ 的数据，$2\\le N\\le 5000$，$1 \\le A_i\\le 10^9$\n\n**【说明】**\n\n**【说明】**\n\n本题分值按 COCI 原题设置，满分 $70$。\n\n题目译自 [COCI2010-2011](https://hsin.hr/coci/archive/2010_2011/) [CONTEST #5](https://hsin.hr/coci/archive/2010_2011/contest5_tasks.pdf)  _**T3 BRODOVI**_。", "samples": [["3\n1\n3\n4 ", "2"], ["5\n1\n7\n10\n13\n19 \n", "2"], ["3\n1\n500000000\n999999999", "1"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [32768, 32768, 32768, 32768, 32768, 32768, 32768, 32768, 32768, 32768, 32768, 32768, 32768]}}
{"task_id": "P6140", "title": "[USACO07NOV]Best Cow Line S", "difficulty": "challenge", "nl": "Farmer John is planning to lead N (1≤N≤2000) cows to participate in the annual \"American Farmer's Grand Prix\". In this competition, each participant must line up his cows and lead them to pass the judge one by one.\n\nThis year, the organizing committee adopted a new registration rule when accepting applications: take the first letter of each cow's name and arrange them in order according to their order in the team. Sort the names of all teams in alphabetical order to get the order of appearance.\n\nBecause FJ is busy with his affairs, he hopes to appear as soon as possible. Therefore, he decided to rearrange the queue.\n\nHis adjustment method is as follows: each time, he pulls out a cow from the front or back of the original queue and arranges her at the end of the new queue. Repeat this operation until all cows are inserted into the new queue.\n\nNow please help FJ calculate the queue with the smallest lexicographic order that can be arranged according to the above method.", "code": "#include<iostream>\n#include<stdio.h>\n#include<cstring>\n#include<string>\nusing namespace std;\nchar a[2005];\nint n;\n\nint main(){\n\tcin>>n;\n\tfor(int i=1;i<=n;i++){\n\t\tcin>>a[i];\n\t}\n\tstring s;\n\tint l=1,r=n,t=0;\n\twhile(l<=r){\n\t\tif(a[l]<a[r]){\n\t\t\tcout<<a[l];\n\t\t\tl++;\n\t\t} else {\n\t\t\tif(a[l]>a[r]){\n\t\t\t\tcout<<a[r];\n\t\t\t\tr--;\n\t\t\t} else {\n\t\t\t\tint ll=l,rr=r;\n\t\t\t\twhile(ll<=rr&&a[ll]==a[rr]){\n\t\t\t\t\tll++;\n\t\t\t\t\trr--;\n\t\t\t\t}\n\t\t\t\tif(a[ll]<=a[rr]){\n\t\t\t\t\tcout<<a[l];\n\t\t\t\t\tl++;\n\t\t\t\t} else {\n\t\t\t\t\tcout<<a[r];\n\t\t\t\t\tr--;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tt++;\n\t\tif(t%80==0){\n\t\t\tcout<<endl;\n\t\t}\n\t}\n\treturn 0;\n}", "step": ["Take input size of string", "Take string as input", "Perform palindrome algorithm on string to compare first and last elements", "If elements match, compare subsequent substring elements, print the element having lower ASCII value and move to next index", "If elements don't match, print the element having lower ASCII value and move to next index", "Print output string"], "nl_cn": "Farmer John 打算带领 $N$（$1 \\leq N \\leq 2\\,000$）头奶牛参加一年一度的”全美农场主大奖赛“。在这场比赛中，每个参赛者必须让他的奶牛排成一列，然后带领这些奶牛从裁判面前依此走过。\n\n今年，竞赛委员会在接受报名时，采用了一种新的登记规则：取每头奶牛名字的首字母，按照它们在队伍中的次序排成一列。将所有队伍的名字按字典序升序排序，从而得到出场顺序。\n\nFJ 由于事务繁忙，他希望能够尽早出场。因此他决定重排队列。\n\n他的调整方式是这样的：每次，他从原队列的首端或尾端牵出一头奶牛，将她安排到新队列尾部。重复这一操作直到所有奶牛都插入新队列为止。\n\n现在请你帮 FJ 算出按照上面这种方法能排出的字典序最小的队列。", "test_cases": [{"input": "6\nA\nC\nD\nB\nC\nB", "output": "ABCBCD"}, {"input": "4\nX\nY\nZ\nW\n", "output": "WXYZ"}, {"input": "2\nC\nC\n", "output": "CC"}, {"input": "1\nA\n", "output": "A"}, {"input": "2\nS\nA\n", "output": "AS"}, {"input": "1\nQ\n", "output": "Q"}, {"input": "2\nE\nE\n", "output": "EE"}, {"input": "5\nD\nE\nC\nB\nA\n", "output": "ABCDE"}, {"input": "1\nE\n", "output": "E"}, {"input": "2\nE\nD\n", "output": "DE"}, {"input": "3\nA\nC\nB\n", "output": "ABC"}, {"input": "1\nZ\n", "output": "Z"}, {"input": "4\nM\nN\nO\nP\n", "output": "MNOP"}, {"input": "2\nY\nX\n", "output": "XY"}, {"input": "7\nL\nK\nJ\nI\nH\nG\nF\n", "output": "FGHIJKL"}, {"input": "3\nB\nB\nB\n", "output": "BBB"}, {"input": "2\nC\nD\n", "output": "CD"}, {"input": "4\nA\nA\nA\nA\n", "output": "AAAA"}, {"input": "8\nP\nT\nS\nR\nQ\nO\nN\nM\n", "output": "MNOPQRST"}, {"input": "5\nH\nI\nG\nF\nE\n", "output": "EFGHI"}, {"input": "3\nZ\nY\nX\n", "output": "XYZ"}, {"input": "4\nO\nP\nQ\nR\n", "output": "OPQR"}, {"input": "2\nU\nV\n", "output": "UV"}, {"input": "3\nC\nB\nA\n", "output": "ABC"}, {"input": "5\nE\nF\nG\nH\nI\n", "output": "EFGHI"}, {"input": "5\nA\nB\nC\nD\nE\n", "output": "ABCDE"}, {"input": "3\nD\nE\nF\n", "output": "DEF"}, {"input": "2\nB\nA\n", "output": "AB"}, {"input": "3\nJ\nI\nH\n", "output": "HIJ"}], "test": "#undef NDEBUG\n#include<assert.h>\nint main(){\n    assert(solution(\"6\\nA\\nC\\nD\\nB\\nC\\nB\") == \"ABCBCD\");\n    assert(solution(\"4\\nX\\nY\\nZ\\nW\\n\") == \"WXYZ\");\n    assert(solution(\"2\\nC\\nC\\n\") == \"CC\");\n    assert(solution(\"1\\nA\\n\") == \"A\");\n    assert(solution(\"2\\nS\\nA\\n\") == \"AS\");\n    assert(solution(\"1\\nQ\\n\") == \"Q\");\n    assert(solution(\"2\\nE\\nE\\n\") == \"EE\");\n    assert(solution(\"5\\nD\\nE\\nC\\nB\\nA\\n\") == \"ABCDE\");\n    assert(solution(\"1\\nE\\n\") == \"E\");\n    assert(solution(\"2\\nE\\nD\\n\") == \"DE\");\n    assert(solution(\"3\\nA\\nC\\nB\\n\") == \"ABC\");\n    assert(solution(\"1\\nZ\\n\") == \"Z\");\n    assert(solution(\"4\\nM\\nN\\nO\\nP\\n\") == \"MNOP\");\n    assert(solution(\"2\\nY\\nX\\n\") == \"XY\");\n    assert(solution(\"7\\nL\\nK\\nJ\\nI\\nH\\nG\\nF\\n\") == \"FGHIJKL\");\n    assert(solution(\"3\\nB\\nB\\nB\\n\") == \"BBB\");\n    assert(solution(\"2\\nC\\nD\\n\") == \"CD\");\n    assert(solution(\"4\\nA\\nA\\nA\\nA\\n\") == \"AAAA\");\n    assert(solution(\"8\\nP\\nT\\nS\\nR\\nQ\\nO\\nN\\nM\\n\") == \"MNOPQRST\");\n    assert(solution(\"5\\nH\\nI\\nG\\nF\\nE\\n\") == \"EFGHI\");\n    assert(solution(\"3\\nZ\\nY\\nX\\n\") == \"XYZ\");\n    assert(solution(\"4\\nO\\nP\\nQ\\nR\\n\") == \"OPQR\");\n    assert(solution(\"2\\nU\\nV\\n\") == \"UV\");\n    assert(solution(\"3\\nC\\nB\\nA\\n\") == \"ABC\");\n    assert(solution(\"5\\nE\\nF\\nG\\nH\\nI\\n\") == \"EFGHI\");\n    assert(solution(\"5\\nA\\nB\\nC\\nD\\nE\\n\") == \"ABCDE\");\n    assert(solution(\"3\\nD\\nE\\nF\\n\") == \"DEF\");\n    assert(solution(\"2\\nB\\nA\\n\") == \"AB\");\n    assert(solution(\"3\\nJ\\nI\\nH\\n\") == \"HIJ\");\n    return 0; \n}", "prompt": "/*Farmer John is planning to lead N (1≤N≤2000) cows to participate in the annual \"American Farmer's Grand Prix\". In this competition, each participant must line up his cows and lead them to pass the judge one by one.\n\nThis year, the organizing committee adopted a new registration rule when accepting applications: take the first letter of each cow's name and arrange them in order according to their order in the team. Sort the names of all teams in alphabetical order to get the order of appearance.\n\nBecause FJ is busy with his affairs, he hopes to appear as soon as possible. Therefore, he decided to rearrange the queue.\n\nHis adjustment method is as follows: each time, he pulls out a cow from the front or back of the original queue and arranges her at the end of the new queue. Repeat this operation until all cows are inserted into the new queue.\n\nNow please help FJ calculate the queue with the smallest lexicographic order that can be arranged according to the above method.\n\ninput_format:\nThe first line is an integer $N$.\n\nThe next $N$line is one capital letter per line, indicating the initial queue.\n\noutput_format:\nOutput a string of length $N$, representing the smallest possible lexicographic queue.\n\nA newline is required for each $80 letter output.\n*/\n\n#include<sstream>\n#include<stdlib.h>\n#include<algorithm>\n#include<math.h>\n#include<stdio.h>\n#include<vector>\n#include<string>\n#include<climits>\n#include<cstring>\n#include<iostream>\nusing namespace std;\n\n             \nstring solution(string std_in){\n    istringstream iss(std_in);\n             ", "constraints": "", "samples": [["6\nA\nC\nD\nB\nC\nB", "ABCBCD"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}}
{"task_id": "P1218", "title": "[USACO1.5]特殊的质数肋骨 Superprime Rib", "difficulty": "challenge", "nl": "Farmer John's cows always produce the best ribs. You can recognize them by the numbers marked on each rib by farmer John and the US Department of Agriculture.\n\nFarmer John ensures that he sells genuine prime rib by slicing the rib from right to left, and each remaining number on the rib forms a prime number. \n\nFor example, if the rib number is $7\\ 3\\ 3\\ 1$, all the numbers on the rib, $7331$, are prime; the three remaining numbers on the rib, $733$, are prime; the two remaining numbers on the rib, $73$, are prime; and of course, the last remaining number on the rib, $7$, is also prime. $7331$ is called a special prime of length $4$. \n\nWrite a program to find all the special primes for a given number of ribs $n$. $1$ is not a prime number.", "code": "#include<cstdio>\n#include<iostream>\n#include<cstring>\n#include<string>\n#include<algorithm>\n#include<queue>\n#include<cmath>\n#include<set>\n#include<list>\n#include<stack>\n#include<vector>\n#include<cstdlib>\n#include<iterator>\n#include<deque>\n#include<ctime>\n#include<iomanip>\n#include<map>\n#include<bitset>\n#include<utility>\n#include<sstream>\nusing namespace std;\nbool prime(int n)\n{\n    if(n==1)return false;\n    for(int i=2;i*i<=n;i++)\n    {\n    \tif(n%i==0)return false;\n    }\n    return true;\n}\ninline void write(int x)\n{\n     if(x<0) putchar('-'),x=-x;\n     if(x>9) write(x/10);\n     putchar(x%10+'0');\n    \n}\nint a[5]={0,2,3,5,7};\nint b[6]={0,1,3,5,7,9};\nint main()\n{\n\tint n,i,j,k,q,w,e,r,t;\n\tscanf(\"%d\",&n);\n\tif(n==1)\n\t\tfor(i=1;i<=4;i++)\n\t\t\tif(prime(a[i]))\n\t\t\t\t{write(a[i]);putchar('\\n');}\n\tif(n==2)\n\t\tfor(i=1;i<=4;i++)\n\t\t\tfor(j=1;j<=5;j++)\n\t\t\t\tif(prime(a[i]*10+b[j]))\n\t\t\t\t\t{write(a[i]*10+b[j]);putchar('\\n');}\n\tif(n==3)\n\t\tfor(i=1;i<=4;i++)\n\t\t\tfor(j=1;j<=5;j++)\n\t\t\t\tfor(k=1;k<=5;k++)\n\t\t\t\t\tif(prime(a[i]*100+b[j]*10+b[k])&&prime(a[i]*10+b[j])&&prime(a[i]))\n\t\t\t\t\t\t{write(a[i]*100+b[j]*10+b[k]);putchar('\\n');}\n\tif(n==4)\n\t\tfor(i=1;i<=4;i++)\n\t\t\t\tfor(j=1;j<=5;j++)\n\t\t\t\t\tfor(k=1;k<=5;k++)\n\t\t\t\t\t\tfor(q=1;q<=5;q++)\n\t\t\t\t\t\t\tif(prime(a[i]*1000+b[j]*100+b[k]*10+b[q])&&prime(a[i]*100+b[j]*10+b[k])&&prime(a[i]*10+b[j])&&prime(a[i]))\n\t\t\t\t\t\t\t\t{write(a[i]*1000+b[j]*100+b[k]*10+b[q]);putchar('\\n');}\n\tif(n==5)\n\t\tfor(i=1;i<=4;i++)\n\t\t\tfor(j=1;j<=5;j++)\n\t\t\t\tfor(k=1;k<=5;k++)\n\t\t\t\t\tfor(q=1;q<=5;q++)\n\t\t\t\t\t\tfor(w=1;w<=5;w++)\n\t\t\t\t\t\t\tif(prime(a[i]*10000+b[j]*1000+b[k]*100+b[q]*10+b[w])&&prime(a[i]*1000+b[j]*100+b[k]*10+b[q])&&prime(a[i]*100+b[j]*10+b[k])&&prime(a[i]*10+b[j])&&prime(a[i]))\n\t\t\t\t\t\t\t\t{write(a[i]*10000+b[j]*1000+b[k]*100+b[q]*10+b[w]);putchar('\\n');}\n\tif(n==6)\n\t\tfor(i=1;i<=4;i++)\n\t\t\tfor(j=1;j<=5;j++)\n\t\t\t\tfor(k=1;k<=5;k++)\n\t\t\t\t\tfor(q=1;q<=5;q++)\n\t\t\t\t\t\tfor(w=1;w<=5;w++)\n\t\t\t\t\t\t\tfor(e=1;e<=5;e++)\n\t\t\t\t\t\t\t\tif(prime(a[i]*100000+b[j]*10000+b[k]*1000+b[q]*100+b[w]*10+b[e])&&prime(a[i]*10000+b[j]*1000+b[k]*100+b[q]*10+b[w])&&prime(a[i]*1000+b[j]*100+b[k]*10+b[q])&&prime(a[i]*100+b[j]*10+b[k])&&prime(a[i]*10+b[j])&&prime(a[i]))\n\t\t\t\t\t\t\t\t\t{write(a[i]*100000+b[j]*10000+b[k]*1000+b[q]*100+b[w]*10+b[e]);putchar('\\n');}\n\tif(n==7)\n\t\tfor(i=1;i<=4;i++)\n\t\t\tfor(j=1;j<=5;j++)\n\t\t\t\tfor(k=1;k<=5;k++)\n\t\t\t\t\tfor(q=1;q<=5;q++)\n\t\t\t\t\t\tfor(w=1;w<=5;w++)\n\t\t\t\t\t\t\tfor(e=1;e<=5;e++)\n\t\t\t\t\t\t\t\tfor(r=1;r<=5;r++)\n\t\t\t\t\t\t\t\t\tif(prime(a[i]*1000000+b[j]*100000+b[k]*10000+b[q]*1000+b[w]*100+b[e]*10+b[r])&&prime(a[i]*100000+b[j]*10000+b[k]*1000+b[q]*100+b[w]*10+b[e])&&prime(a[i]*10000+b[j]*1000+b[k]*100+b[q]*10+b[w])&&prime(a[i]*1000+b[j]*100+b[k]*10+b[q])&&prime(a[i]*100+b[j]*10+b[k])&&prime(a[i]*10+b[j])&&prime(a[i]))\n\t\t\t\t\t\t\t\t\t\t{write(a[i]*1000000+b[j]*100000+b[k]*10000+b[q]*1000+b[w]*100+b[e]*10+b[r]);putchar('\\n');}\n\tif(n==8)\n\t\tfor(i=1;i<=4;i++)\n\t\t\tfor(j=1;j<=5;j++)\n\t\t\t\tfor(k=1;k<=5;k++)\n\t\t\t\t\tfor(q=1;q<=5;q++)\n\t\t\t\t\t\tfor(w=1;w<=5;w++)\n\t\t\t\t\t\t\tfor(e=1;e<=5;e++)\n\t\t\t\t\t\t\t\tfor(r=1;r<=5;r++)\n\t\t\t\t\t\t\t\t\tfor(t=1;t<=5;t++)\n\t\t\t\t\t\t\t\t\t\tif(prime(a[i]*10000000+b[j]*1000000+b[k]*100000+b[q]*10000+b[w]*1000+b[e]*100+b[r]*10+b[t])&&prime(a[i]*1000000+b[j]*100000+b[k]*10000+b[q]*1000+b[w]*100+b[e]*10+b[r])&&prime(a[i]*100000+b[j]*10000+b[k]*1000+b[q]*100+b[w]*10+b[e])&&prime(a[i]*10000+b[j]*1000+b[k]*100+b[q]*10+b[w])&&prime(a[i]*1000+b[j]*100+b[k]*10+b[q])&&prime(a[i]*100+b[j]*10+b[k])&&prime(a[i]*10+b[j])&&prime(a[i]))\n\t\t\t\t\t\t\t\t\t\t\t{write(a[i]*10000000+b[j]*1000000+b[k]*100000+b[q]*10000+b[w]*1000+b[e]*100+b[r]*10+b[t]);putchar('\\n');}\n\treturn 0;\n}", "step": ["Input an integer n.", "For each n, generate the prime numbers with n digits.", "Print the primes generated in step 2."], "nl_cn": "农民约翰的母牛总是产生最好的肋骨。你能通过农民约翰和美国农业部标记在每根肋骨上的数字认出它们。 \n\n农民约翰确定他卖给买方的是真正的质数肋骨，是因为从右边开始切下肋骨，每次还剩下的肋骨上的数字都组成一个质数。  \n\n举例来说：$7\\ 3\\ 3\\ 1$ 全部肋骨上的数字 $7331$ 是质数；三根肋骨 $733$ 是质数；二根肋骨 $73$ 是质数；当然,最后一根肋骨 $7$ 也是质数。$7331$ 被叫做长度 $4$ 的特殊质数。  \n\n写一个程序对给定的肋骨的数目 $n$，求出所有的特殊质数。$1$ 不是质数。", "test_cases": [{"input": "4\n", "output": "2333\n2339\n2393\n2399\n2939\n3119\n3137\n3733\n3739\n3793\n3797\n5939\n7193\n7331\n7333\n7393"}, {"input": "1\n", "output": "2\n3\n5\n7"}, {"input": "2\n", "output": "23\n29\n31\n37\n53\n59\n71\n73\n79"}, {"input": "9\n", "output": ""}, {"input": "10\n", "output": ""}, {"input": "11\n", "output": ""}, {"input": "12\n", "output": ""}, {"input": "13\n", "output": ""}, {"input": "14\n", "output": ""}, {"input": "15\n", "output": ""}, {"input": "16\n", "output": ""}, {"input": "17\n", "output": ""}, {"input": "18\n", "output": ""}, {"input": "19\n", "output": ""}, {"input": "20\n", "output": ""}], "test": "#undef NDEBUG\n#include<assert.h>\nint main(){\n    assert(solution(\"4\\n\") == \"2333\\n2339\\n2393\\n2399\\n2939\\n3119\\n3137\\n3733\\n3739\\n3793\\n3797\\n5939\\n7193\\n7331\\n7333\\n7393\");\n    assert(solution(\"1\\n\") == \"2\\n3\\n5\\n7\");\n    assert(solution(\"2\\n\") == \"23\\n29\\n31\\n37\\n53\\n59\\n71\\n73\\n79\");\n    assert(solution(\"9\\n\") == \"\");\n    assert(solution(\"10\\n\") == \"\");\n    assert(solution(\"11\\n\") == \"\");\n    assert(solution(\"12\\n\") == \"\");\n    assert(solution(\"13\\n\") == \"\");\n    assert(solution(\"14\\n\") == \"\");\n    assert(solution(\"15\\n\") == \"\");\n    assert(solution(\"16\\n\") == \"\");\n    assert(solution(\"17\\n\") == \"\");\n    assert(solution(\"18\\n\") == \"\");\n    assert(solution(\"19\\n\") == \"\");\n    assert(solution(\"20\\n\") == \"\");\n    return 0; \n}", "prompt": "/*Farmer John's cows always produce the best ribs. You can recognize them by the numbers marked on each rib by farmer John and the US Department of Agriculture.\n\nFarmer John ensures that he sells genuine prime rib by slicing the rib from right to left, and each remaining number on the rib forms a prime number. \n\nFor example, if the rib number is $7\\ 3\\ 3\\ 1$, all the numbers on the rib, $7331$, are prime; the three remaining numbers on the rib, $733$, are prime; the two remaining numbers on the rib, $73$, are prime; and of course, the last remaining number on the rib, $7$, is also prime. $7331$ is called a special prime of length $4$. \n\nWrite a program to find all the special primes for a given number of ribs $n$. $1$ is not a prime number.\n\ninput_format:\nOne positive integer $n$ per line.\n\noutput_format:\nOutput special prime numbers of length $n$in order, one per line.\n*/\n\n#include<sstream>\n#include<stdlib.h>\n#include<algorithm>\n#include<math.h>\n#include<stdio.h>\n#include<vector>\n#include<string>\n#include<climits>\n#include<cstring>\n#include<iostream>\nusing namespace std;\n\n             \nstring solution(string std_in){\n    istringstream iss(std_in);\n             ", "constraints": "【数据范围】  \n对于 $100\\%$ 的数据，$1\\le n \\le 8$。\n\n题目翻译来自NOCOW。\n\nUSACO Training Section 1.5\n", "samples": [["4\n", "2333\n2339\n2393\n2399\n2939\n3119\n3137\n3733\n3739\n3793\n3797\n5939\n7193\n7331\n7333\n7393\n"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000]}}
{"task_id": "P1140", "title": "相似基因", "difficulty": "challenge", "nl": "The method of calculating the similarity between two genes is as follows:\n\nFor two known genes, such as $AGTGATG$ and $GTTAG$, their base pairs correspond to each other. Of course, some empty base pairs can be added in between, for example:\n\n  \n\nIn this way, the similarity between two genes can be described by the sum of the similarity between base pairs. The similarity between base pairs is shown in the following table:\n\n   \n\nThen the similarity between two genes is: $(-3)+5+5+(-2)+(-3)+5+(-3)+5=9$. Because the correspondence between two genes is not unique, for example:\n\n  \n\nThe similarity is: $(-3)+5+5+(-2)+5+(-1)+5=14$. It is stipulated that the similarity between two genes is the maximum of all correspondence methods.", "code": "#include<iostream>\n#include<algorithm>\nusing namespace std;\nint la,lb,a[110],b[110],f[110][110];//状态定义\nint d[6][6]=\n{\n\t{0,0,0,0,0,0},\n\t{0,5,-1,-2,-1,-3},\n\t{0,-1,5,-3,-2,-4},\n\t{0,-2,-3,5,-2,-2},\n\t{0,-1,-2,-2,5,-1},\n\t{0,-3,-4,-2,-1,0}\n};\nint main()\n{\n\t//开始输入 \n\tcin>>la;\n\tfor(int i=1;i<=la;i++)\n\t{\n\t\tchar t;\n\t\tcin>>t;\n\t\tswitch(t)\n\t\t{\n\t\tcase'A':\n\t\t\ta[i]=1;break;\n\t\tcase'C':\n\t\t\ta[i]=2;break;\n\t\tcase'G':\n\t\t\ta[i]=3;break;\n\t\tcase'T':\n\t\t\ta[i]=4;break;\n\t\t}\n\t}\n\tcin>>lb;\n\tfor(int i=1;i<=lb;i++)\n\t{\n\t\tchar t;\n\t\tcin>>t;\n\t\tswitch(t)\n\t\t{\n\t\tcase'A':\n\t\t\tb[i]=1;break;\n\t\tcase'C':\n\t\t\tb[i]=2;break;\n\t\tcase'G':\n\t\t\tb[i]=3;break;\n\t\tcase'T':\n\t\t\tb[i]=4;break;\n\t\t}\n\t}\n\t//输入结束 \n\t\n\t//开始处理边界 \n\tf[0][0]=0;//全局变量自动初始化为0，但是作为题解，还是写上好。\n\tfor(int i=1;i<=la;i++)\n\t\tf[i][0]=f[i-1][0]+d[a[i]][5];\n\tfor(int i=1;i<=lb;i++)\n\t\tf[0][i]=f[0][i-1]+d[5][b[i]];\n\t//边界处理结束\n\t\n\t//开始 dp\n\tfor(int i=1;i<=la;i++)\n\t\tfor(int j=1;j<=lb;j++)\n\t\t\tf[i][j]=max(f[i-1][j-1]+d[a[i]][b[j]],max(f[i-1][j]+d[a[i]][5],f[i][j-1]+d[5][b[j]]));\n\t//dp 结束 \n\t\n\t//开始输出结果 \n\tcout<<f[la][lb]<<endl;\n\t//输出结果结束\n\treturn 0;\n}", "step": ["Read in two DNA sequences and store them as arrays of integers.", "Initialize a score array with dynamic programming.", "Calculate the score for the optimal alignment by comparing the two sequences.", "Output the optimal alignment score."], "nl_cn": "两个基因的相似度的计算方法如下：\n\n对于两个已知基因，例如$AGTGATG$和$GTTAG$，将它们的碱基互相对应。当然，中间可以加入一些空碱基-，例如：\n\n  \n\n这样,两个基因之间的相似度就可以用碱基之间相似度的总和来描述，碱基之间的相似度如下表所示：\n\n   \n\n那么相似度就是：$(-3)+5+5+(-2)+(-3)+5+(-3)+5=9$。因为两个基因的对应方法不唯一，例如又有：\n\n  \n\n相似度为：$(-3)+5+5+(-2)+5+(-1)+5=14$。规定两个基因的相似度为所有对应方法中，相似度最大的那个。\n", "test_cases": [{"input": "7 AGTGATG\n5 GTTAG\n", "output": "14"}, {"input": "3 AAA\n3 CCC\n", "output": "-3"}, {"input": "5 GTAGT\n4 AGCT\n", "output": "8"}, {"input": "1 A\n1 A\n", "output": "5"}, {"input": "4 AGAT\n4 GACG\n", "output": "3"}, {"input": "3 AGG\n3 AGG\n", "output": "15"}, {"input": "4 ACGT\n4 ACGT\n", "output": "20"}, {"input": "4 CATA\n4 CATA\n", "output": "20"}, {"input": "3 CTG\n3 CTG\n", "output": "15"}, {"input": "4 GATG\n4 GATG\n", "output": "20"}, {"input": "8 ATCTCTAC\n5 TTTAT\n\n", "output": "7"}], "test": "#undef NDEBUG\n#include<assert.h>\nint main(){\n    assert(solution(\"7 AGTGATG\\n5 GTTAG\\n\") == \"14\");\n    assert(solution(\"3 AAA\\n3 CCC\\n\") == \"-3\");\n    assert(solution(\"5 GTAGT\\n4 AGCT\\n\") == \"8\");\n    assert(solution(\"1 A\\n1 A\\n\") == \"5\");\n    assert(solution(\"4 AGAT\\n4 GACG\\n\") == \"3\");\n    assert(solution(\"3 AGG\\n3 AGG\\n\") == \"15\");\n    assert(solution(\"4 ACGT\\n4 ACGT\\n\") == \"20\");\n    assert(solution(\"4 CATA\\n4 CATA\\n\") == \"20\");\n    assert(solution(\"3 CTG\\n3 CTG\\n\") == \"15\");\n    assert(solution(\"4 GATG\\n4 GATG\\n\") == \"20\");\n    assert(solution(\"8 ATCTCTAC\\n5 TTTAT\\n\\n\") == \"7\");\n    return 0; \n}", "prompt": "/*The method of calculating the similarity between two genes is as follows:\n\nFor two known genes, such as $AGTGATG$ and $GTTAG$, their base pairs correspond to each other. Of course, some empty base pairs can be added in between, for example:\n\n  \n\nIn this way, the similarity between two genes can be described by the sum of the similarity between base pairs. The similarity between base pairs is shown in the following table:\n\n   \n\nThen the similarity between two genes is: $(-3)+5+5+(-2)+(-3)+5+(-3)+5=9$. Because the correspondence between two genes is not unique, for example:\n\n  \n\nThe similarity is: $(-3)+5+5+(-2)+5+(-1)+5=14$. It is stipulated that the similarity between two genes is the maximum of all correspondence methods.\n\ninput_format:\nTwo lines in total. The first line begins with an integer, representing the length of a gene sequence, followed by a space and the gene sequence. The sequence consists of only four letters, $A, C, G,$ and $T$. The length of the sequence is between $1$ and $100$.\n\noutput_format:\nJust one line, the similarity of the input gene.\n*/\n\n#include<sstream>\n#include<stdlib.h>\n#include<algorithm>\n#include<math.h>\n#include<stdio.h>\n#include<vector>\n#include<string>\n#include<climits>\n#include<cstring>\n#include<iostream>\nusing namespace std;\n\n             \nstring solution(string std_in){\n    istringstream iss(std_in);\n             ", "constraints": "", "samples": [["7 AGTGATG\n5 GTTAG\n", "14\n"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}}
{"task_id": "P3131", "title": "[USACO16JAN]Subsequences Summing to Sevens S", "difficulty": "challenge", "nl": "Farmer John has a row of N cows, with each cow having a unique integer ID number. He wants to take a photo of a continuous group of cows, but due to his childhood trauma related to the numbers 1 through 6, he requires that the sum of the cows' ID numbers in the photo be a multiple of 7.\n\nHelp FJ determine the maximum size of the group of cows he can photograph.\n\nGiven n numbers a[1], a[2], ..., a[n], find the longest interval [x, y] such that the sum of the numbers in the interval (a[x], a[x+1], a[x+2], ..., a[y-1], a[y]) is divisible by 7. Output the length of the interval. If there is no such interval, output 0.", "code": "#include<bits/stdc++.h>\nusing namespace std;\nconst int maxn=50010;\nint pre[maxn];\nint n,len,mx=-1;\nint first[7],last[7];//%7的余数为0~6,所以开7的数组就可以了； \nint main(){\n\tcin>>n;\n\tfor(int i=1;i<=n;i++)\n\t{\n\t\tcin>>pre[i];\n\t\tpre[i]=(pre[i]+pre[i-1])%7; //%7意义下的前缀和 ，就变成了前缀和%7的余数；\t\t\n\t}\n\tfor(int i=n;i>=1;i--)//(pre[i]是当位置为i时 前缀和%7的余数） \n\t\tfirst[pre[i]]=i;   //第一次出现pre[i]这个余数的时候的位置为i ；\n\t//倒着扫一遍 不断更新最后就是这个余数第一次出现； \n\tfirst[0]=0;//从头加到i是7的倍数的情况下，需要把0的第一次出现设为0，即把整个区间[1,i]选上了。\n\tfor(int i=1;i<=n;i++)\n\t\tlast[pre[i]]=i;//最后一次出现pre[i]这个余数时位置为i； \n\t\t\n\tfor(int i=0;i<=6;i++)   //这里是看哪个余数的长度最大，last[i]-first[i]就是余数i的最大长度\n\t//(最后一次出现减第一次出现 显然是最长的)\n\t//两个位置相减就是长度；因为是前缀和(前缀和为【i+1，j】的区间,所以j-i即为区间的长度） \n\t//这里不是一般的 j-i+1(末位置 减 首位置+1） 为长度，紧扣前缀和的定义！！ \n\tmx=max(last[i]-first[i],mx);\n\t//前缀和求原区间长度是 j-i；一般的区间长度是 j-i+1； \n\tcout<<mx<<endl;\n}", "step": ["Declare variables", "Read input sequence and calculate prefix sum modulo 7", "Find the first occurrence of each value of the prefix sum modulo 7 by iterating backward through the input", "Find the last occurrence of each value of the prefix sum modulo 7 by iterating forward through the input", "Find the maximum difference between first and last occurrence of the same prefix sum modulo 7", "Print the maximum difference"], "nl_cn": "Farmer John's $N$ cows are standing in a row, as they have a tendency to do from time to time.  Each cow is labeled with a distinct integer ID number so FJ can tell them apart. FJ would like to take a photo of a contiguous group of cows but, due to a traumatic  childhood incident involving the numbers $1 \\ldots 6$, he only wants to take a picture of a group of cows if their IDs add up to a multiple of 7.\n\n\nPlease help FJ determine the size of the largest group he can photograph.\n\n给你n个数，分别是a[1],a[2],...,a[n]。求一个最长的区间[x,y]，使得区间中的数(a[x],a[x+1],a[x+2],...,a[y-1],a[y])的和能被7整除。输出区间长度。若没有符合要求的区间，输出0。\n\n", "test_cases": [{"input": "7\n3\n5\n1\n6\n2\n14\n10", "output": "5"}, {"input": "6\n1\n2\n3\n4\n5\n6\n", "output": "6"}, {"input": "9\n1\n2\n3\n4\n5\n6\n7\n8\n9\n", "output": "7"}, {"input": "15\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n", "output": "14"}, {"input": "2\n7\n14\n", "output": "2"}, {"input": "3\n8\n15\n22\n", "output": "0"}, {"input": "10\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n", "output": "7"}, {"input": "5\n7\n14\n21\n28\n35\n", "output": "5"}, {"input": "8\n3\n6\n1\n7\n9\n5\n2\n4\n", "output": "6"}, {"input": "5\n1\n3\n5\n1\n3\n", "output": "0"}, {"input": "3\n2\n3\n5\n", "output": "0"}, {"input": "6\n3\n5\n1\n2\n4\n6\n", "output": "6"}, {"input": "13\n1\n1\n2\n2\n3\n3\n4\n4\n5\n5\n6\n6\n7\n", "output": "13"}, {"input": "7\n1\n2\n3\n4\n5\n6\n7\n", "output": "7"}], "test": "#undef NDEBUG\n#include<assert.h>\nint main(){\n    assert(solution(\"7\\n3\\n5\\n1\\n6\\n2\\n14\\n10\") == \"5\");\n    assert(solution(\"6\\n1\\n2\\n3\\n4\\n5\\n6\\n\") == \"6\");\n    assert(solution(\"9\\n1\\n2\\n3\\n4\\n5\\n6\\n7\\n8\\n9\\n\") == \"7\");\n    assert(solution(\"15\\n1\\n2\\n3\\n4\\n5\\n6\\n7\\n8\\n9\\n10\\n11\\n12\\n13\\n14\\n15\\n\") == \"14\");\n    assert(solution(\"2\\n7\\n14\\n\") == \"2\");\n    assert(solution(\"3\\n8\\n15\\n22\\n\") == \"0\");\n    assert(solution(\"10\\n1\\n2\\n3\\n4\\n5\\n6\\n7\\n8\\n9\\n10\\n\") == \"7\");\n    assert(solution(\"5\\n7\\n14\\n21\\n28\\n35\\n\") == \"5\");\n    assert(solution(\"8\\n3\\n6\\n1\\n7\\n9\\n5\\n2\\n4\\n\") == \"6\");\n    assert(solution(\"5\\n1\\n3\\n5\\n1\\n3\\n\") == \"0\");\n    assert(solution(\"3\\n2\\n3\\n5\\n\") == \"0\");\n    assert(solution(\"6\\n3\\n5\\n1\\n2\\n4\\n6\\n\") == \"6\");\n    assert(solution(\"13\\n1\\n1\\n2\\n2\\n3\\n3\\n4\\n4\\n5\\n5\\n6\\n6\\n7\\n\") == \"13\");\n    assert(solution(\"7\\n1\\n2\\n3\\n4\\n5\\n6\\n7\\n\") == \"7\");\n    return 0; \n}", "prompt": "/*Farmer John has a row of N cows, with each cow having a unique integer ID number. He wants to take a photo of a continuous group of cows, but due to his childhood trauma related to the numbers 1 through 6, he requires that the sum of the cows' ID numbers in the photo be a multiple of 7.\n\nHelp FJ determine the maximum size of the group of cows he can photograph.\n\nGiven n numbers a[1], a[2], ..., a[n], find the longest interval [x, y] such that the sum of the numbers in the interval (a[x], a[x+1], a[x+2], ..., a[y-1], a[y]) is divisible by 7. Output the length of the interval. If there is no such interval, output 0.\n\ninput_format:\nThe first line of input contains $N$($1 \\leq N \\leq 50,000$). The next $N$\n\nlines each contain the $N$ integer IDs of the cows (all are in the range\n\n$0 \\ldots $1,000,000).\n\noutput_format:\nPlease output the number of cows in the largest consecutive group whose IDs sum\n\nto a multiple of 7.  If no such group exists, output 0.\n*/\n\n#include<sstream>\n#include<stdlib.h>\n#include<algorithm>\n#include<math.h>\n#include<stdio.h>\n#include<vector>\n#include<string>\n#include<climits>\n#include<cstring>\n#include<iostream>\nusing namespace std;\n\n             \nstring solution(string std_in){\n    istringstream iss(std_in);\n             ", "constraints": "In this example, 5+1+6+2+14 = 28.\n", "samples": [["7\n3\n5\n1\n6\n2\n14\n10", "5"]], "limits": {"time": [500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500], "memory": [524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288]}}
{"task_id": "P3029", "title": "[USACO11NOV]Cow Lineup S", "difficulty": "advanced", "nl": "Farmer John hired a professional photographer to take pictures of his cows. Since FJ's cows represent various different breeds, he wants the photo to include at least one cow of each different breed in his herd.\n\nN cows of FJ stand at various positions along a line, each position described by an integer position (its x-coordinate) and an integer breed ID. FJ plans to take a photo of a contiguous range of cows along this line. The cost of this photo is its size -- that is, the difference between the maximum and minimum x-coordinate of cows within the range.\n\nPlease help FJ calculate the minimum cost of a photo that includes at least one cow of different breed appearing in FJ's herd.", "code": "#include<bits/stdc++.h>\nusing namespace std;\nint n,i,num,minn=1000000000,kc,ff,c[50001],t,w;\nmap<int,int> a;\nstruct node\n{\n\tint k,id;\n}f[50001],q[50001];\nint comp(const node&a,const node&b){return a.k<b.k;}\nint main()\n{\n\tscanf(\"%d\",&n);\n\tfor(i=1;i<=n;i++)//离散化，将牛的品种转为一串有序的数 \n\t{\n\t  scanf(\"%d%d\",&f[i].k,&kc);\n\t  if(!a.count(kc)) ff++,a[kc]=ff;//ff表示牛的品种总数 \n\t  f[i].id=a[kc];\n    }\n\tsort(f+1,f+n+1,comp);\n\tq[1].k=f[1].k;q[1].id=f[1].id;\n\tc[f[1].id]++;num=1;t=1;w=1;//num表示head(t)~tail(w)中牛的总数 \n\tfor(i=2;i<=n;i++)\n\t{\n\t\tif(!c[f[i].id]){num++;c[f[i].id]=1;}\n\t\telse c[f[i].id]++;\n\t\tw++;\n\t\tq[w].k=f[i].k;q[w].id=f[i].id;//入队处理 \n\t\twhile(c[q[t].id]>1){c[q[t].id]--;t++;}//出队处理 \n\t\tif(num==ff) minn=min(minn,q[w].k-q[t].k); \n\t}\n\tprintf(\"%d\",minn);\n}", "step": ["Take an integer n as input.", "Read n pairs of integers and put their first values in k and second values in kc.", "Sort the pairs f based on their first values.", "Create an empty map a to store the unique second values.", "Create a counter array c with size 50001 to store the frequency of each second value.", "Initialize num, minn, t, w and ff to 1.", "Put the first pair in q[1] and increase the corresponding value in c by 1.", "Iterate through each pair of f starting from the second element.", "If the second value of the current pair f[i] is not in the map a, add it to the map and update the corresponding value in f[i].id.", "If the second value of the current pair f[i] is in the map a, update the corresponding value in f[i].id.", "Increase the frequency of the second value in c.", "Put the current pair in q[w] and increase w.", "If the frequency of the second value of the pair q[t] is greater than 1, decrease its frequency in c and increase t.", "If the number of unique second values is equal to ff, update minn to be the minimum of its current value and the difference of k values between q[t] and q[w-1].", "Print the value of minn."], "nl_cn": "Farmer John has hired a professional photographer to take a picture of some of his cows.  Since FJ's cows represent a variety of different breeds, he would like the photo to contain at least one cow from each distinct breed present in his herd.\n\nFJ's N cows are all standing at various positions along a line, each described by an integer position (i.e., its x coordinate) as well as an integer breed ID.  FJ plans to take a photograph of a contiguous range of cows along the line.  The cost of this photograph is equal its size -- that is, the difference between the maximum and minimum x coordinates of the cows in the range of the photograph.\n\nPlease help FJ by computing the minimum cost of a photograph in which there is at least one cow of each distinct breed appearing in FJ's herd.\n\n依次给出N头牛的位置及种类，要求找出连续一段，使其中包含所有种类的牛，问：这连续的一段最小长度是多少？\n", "test_cases": [{"input": "6 \n25 7 \n26 1 \n15 1 \n22 3 \n20 1 \n30 1 \n", "output": "4"}, {"input": "4 \n10 1 \n20 2 \n30 3 \n40 4 \n", "output": "30"}, {"input": "7 \n5 1 \n10 2 \n15 3 \n20 4 \n25 5 \n30 6 \n35 7 \n", "output": "30"}, {"input": "2 \n10 1 \n15 2 \n", "output": "5"}, {"input": "4 \n20 1 \n10 2 \n25 3 \n15 1 \n", "output": "15"}, {"input": "3 \n10 1 \n25 2 \n20 3 \n", "output": "15"}, {"input": "8 \n10 1 \n15 2 \n5 2 \n25 3 \n20 3 \n30 4 \n35 5 \n40 6 \n", "output": "30"}, {"input": "4 \n20 1 \n15 2 \n10 3 \n25 4 \n", "output": "15"}, {"input": "5 \n25 1 \n20 2 \n15 2 \n10 3 \n5 4 \n", "output": "20"}, {"input": "6 \n20 1 \n25 2 \n15 2 \n10 3 \n5 3 \n30 4 \n", "output": "20"}, {"input": "7 \n15 1 \n10 2 \n20 2 \n5 3 \n25 4 \n35 5 \n30 6 \n", "output": "30"}, {"input": "3 \n25 1 \n10 2 \n15 3 \n", "output": "15"}, {"input": "8 \n30 1 \n20 2 \n15 3 \n12 1 \n25 4 \n18 1 \n22 2 \n28 3 \n", "output": "8"}, {"input": "5 \n12 1 \n14 1 \n10 2 \n11 2 \n13 3 \n", "output": "2"}, {"input": "3 \n10 2 \n20 3 \n30 1 \n", "output": "20"}, {"input": "3 \n5 2 \n10 1 \n15 3 \n", "output": "10"}, {"input": "2 \n5 1 \n10 2 \n", "output": "5"}, {"input": "4 \n15 2 \n10 3 \n20 2 \n25 1 \n", "output": "15"}, {"input": "2 \n10 2 \n20 3 \n", "output": "10"}, {"input": "3 \n5 1 \n10 2 \n15 3 \n", "output": "10"}, {"input": "3 \n10 3 \n20 1 \n30 2 \n", "output": "20"}, {"input": "3 \n5 1 \n10 1 \n15 1 \n", "output": "0"}, {"input": "5 \n-10 4 \n-5 3 \n0 2 \n5 1 \n10 5 \n", "output": "20"}, {"input": "2 \n100 1 \n200 2 \n", "output": "100"}, {"input": "4 \n-5 1 \n-4 1 \n-2 1 \n0 1 \n", "output": "0"}, {"input": "3 \n-10 1 \n-7 2 \n-5 3 \n", "output": "5"}, {"input": "6 \n1 1 \n2 2 \n3 3 \n4 4 \n5 5 \n6 6 \n", "output": "5"}, {"input": "2 \n1 1 \n100 3 \n", "output": "99"}, {"input": "5 \n5 1 \n5 2 \n5 3 \n5 4 \n5 5 \n", "output": "0"}, {"input": "2 \n0 1 \n0 2 \n", "output": "0"}, {"input": "3 \n0 1 \n0 2 \n0 3 \n", "output": "0"}, {"input": "5 \n-1 1 \n-1 2 \n-1 3 \n-1 4 \n-1 5 \n", "output": "0"}, {"input": "5 \n10 1 \n20 2 \n30 3 \n40 4 \n50 5 \n", "output": "40"}, {"input": "3 \n10 1 \n10 2 \n10 3 \n", "output": "0"}, {"input": "4 \n1 1 \n2 2 \n3 1 \n4 2 \n", "output": "1"}, {"input": "2 \n100 2 \n200 1 \n", "output": "100"}, {"input": "5 \n1 1 \n2 2 \n3 3 \n4 4 \n5 5 \n", "output": "4"}, {"input": "5 \n10 1 \n20 3 \n30 2 \n40 4 \n50 5 \n", "output": "40"}, {"input": "3 \n10 1 \n20 2 \n30 3 \n", "output": "20"}, {"input": "2 \n10 1 \n20 2 \n", "output": "10"}, {"input": "6 \n5 1 \n10 2 \n15 3 \n20 4 \n25 5 \n30 6 \n", "output": "25"}, {"input": "5 \n1 1 \n2 2 \n3 3 \n4 4 \n4 5 \n", "output": "3"}, {"input": "4 \n1 1 \n3 2 \n5 3 \n7 4 \n", "output": "6"}], "test": "#undef NDEBUG\n#include<assert.h>\nint main(){\n    assert(solution(\"6 \\n25 7 \\n26 1 \\n15 1 \\n22 3 \\n20 1 \\n30 1 \\n\") == \"4\");\n    assert(solution(\"4 \\n10 1 \\n20 2 \\n30 3 \\n40 4 \\n\") == \"30\");\n    assert(solution(\"7 \\n5 1 \\n10 2 \\n15 3 \\n20 4 \\n25 5 \\n30 6 \\n35 7 \\n\") == \"30\");\n    assert(solution(\"2 \\n10 1 \\n15 2 \\n\") == \"5\");\n    assert(solution(\"4 \\n20 1 \\n10 2 \\n25 3 \\n15 1 \\n\") == \"15\");\n    assert(solution(\"3 \\n10 1 \\n25 2 \\n20 3 \\n\") == \"15\");\n    assert(solution(\"8 \\n10 1 \\n15 2 \\n5 2 \\n25 3 \\n20 3 \\n30 4 \\n35 5 \\n40 6 \\n\") == \"30\");\n    assert(solution(\"4 \\n20 1 \\n15 2 \\n10 3 \\n25 4 \\n\") == \"15\");\n    assert(solution(\"5 \\n25 1 \\n20 2 \\n15 2 \\n10 3 \\n5 4 \\n\") == \"20\");\n    assert(solution(\"6 \\n20 1 \\n25 2 \\n15 2 \\n10 3 \\n5 3 \\n30 4 \\n\") == \"20\");\n    assert(solution(\"7 \\n15 1 \\n10 2 \\n20 2 \\n5 3 \\n25 4 \\n35 5 \\n30 6 \\n\") == \"30\");\n    assert(solution(\"3 \\n25 1 \\n10 2 \\n15 3 \\n\") == \"15\");\n    assert(solution(\"8 \\n30 1 \\n20 2 \\n15 3 \\n12 1 \\n25 4 \\n18 1 \\n22 2 \\n28 3 \\n\") == \"8\");\n    assert(solution(\"5 \\n12 1 \\n14 1 \\n10 2 \\n11 2 \\n13 3 \\n\") == \"2\");\n    assert(solution(\"3 \\n10 2 \\n20 3 \\n30 1 \\n\") == \"20\");\n    assert(solution(\"3 \\n5 2 \\n10 1 \\n15 3 \\n\") == \"10\");\n    assert(solution(\"2 \\n5 1 \\n10 2 \\n\") == \"5\");\n    assert(solution(\"4 \\n15 2 \\n10 3 \\n20 2 \\n25 1 \\n\") == \"15\");\n    assert(solution(\"2 \\n10 2 \\n20 3 \\n\") == \"10\");\n    assert(solution(\"3 \\n5 1 \\n10 2 \\n15 3 \\n\") == \"10\");\n    assert(solution(\"3 \\n10 3 \\n20 1 \\n30 2 \\n\") == \"20\");\n    assert(solution(\"3 \\n5 1 \\n10 1 \\n15 1 \\n\") == \"0\");\n    assert(solution(\"5 \\n-10 4 \\n-5 3 \\n0 2 \\n5 1 \\n10 5 \\n\") == \"20\");\n    assert(solution(\"2 \\n100 1 \\n200 2 \\n\") == \"100\");\n    assert(solution(\"4 \\n-5 1 \\n-4 1 \\n-2 1 \\n0 1 \\n\") == \"0\");\n    assert(solution(\"3 \\n-10 1 \\n-7 2 \\n-5 3 \\n\") == \"5\");\n    assert(solution(\"6 \\n1 1 \\n2 2 \\n3 3 \\n4 4 \\n5 5 \\n6 6 \\n\") == \"5\");\n    assert(solution(\"2 \\n1 1 \\n100 3 \\n\") == \"99\");\n    assert(solution(\"5 \\n5 1 \\n5 2 \\n5 3 \\n5 4 \\n5 5 \\n\") == \"0\");\n    assert(solution(\"2 \\n0 1 \\n0 2 \\n\") == \"0\");\n    assert(solution(\"3 \\n0 1 \\n0 2 \\n0 3 \\n\") == \"0\");\n    assert(solution(\"5 \\n-1 1 \\n-1 2 \\n-1 3 \\n-1 4 \\n-1 5 \\n\") == \"0\");\n    assert(solution(\"5 \\n10 1 \\n20 2 \\n30 3 \\n40 4 \\n50 5 \\n\") == \"40\");\n    assert(solution(\"3 \\n10 1 \\n10 2 \\n10 3 \\n\") == \"0\");\n    assert(solution(\"4 \\n1 1 \\n2 2 \\n3 1 \\n4 2 \\n\") == \"1\");\n    assert(solution(\"2 \\n100 2 \\n200 1 \\n\") == \"100\");\n    assert(solution(\"5 \\n1 1 \\n2 2 \\n3 3 \\n4 4 \\n5 5 \\n\") == \"4\");\n    assert(solution(\"5 \\n10 1 \\n20 3 \\n30 2 \\n40 4 \\n50 5 \\n\") == \"40\");\n    assert(solution(\"3 \\n10 1 \\n20 2 \\n30 3 \\n\") == \"20\");\n    assert(solution(\"2 \\n10 1 \\n20 2 \\n\") == \"10\");\n    assert(solution(\"6 \\n5 1 \\n10 2 \\n15 3 \\n20 4 \\n25 5 \\n30 6 \\n\") == \"25\");\n    assert(solution(\"5 \\n1 1 \\n2 2 \\n3 3 \\n4 4 \\n4 5 \\n\") == \"3\");\n    assert(solution(\"4 \\n1 1 \\n3 2 \\n5 3 \\n7 4 \\n\") == \"6\");\n    return 0; \n}", "prompt": "/*Farmer John hired a professional photographer to take pictures of his cows. Since FJ's cows represent various different breeds, he wants the photo to include at least one cow of each different breed in his herd.\n\nN cows of FJ stand at various positions along a line, each position described by an integer position (its x-coordinate) and an integer breed ID. FJ plans to take a photo of a contiguous range of cows along this line. The cost of this photo is its size -- that is, the difference between the maximum and minimum x-coordinate of cows within the range.\n\nPlease help FJ calculate the minimum cost of a photo that includes at least one cow of different breed appearing in FJ's herd.\n\ninput_format:\n\\* Line 1: The number of cows, N (1 <= N <= 50,000).\n\n\\* Lines 2..1+N: Each line contains two space-separated positive integers specifying the x coordinate and breed ID of a single cow. Both numbers are at most 1 billion.\n\nTranslated:\n\\* Line 1: The number of cows, N (1 <= N <= 50,000).\n\n\\* Lines 2..1+N: Each line consists of two positive integers separated by a space. The first integer represents the x coordinate, and the second integer represents the breed ID of a single cow. Both numbers are at most 1 billion.\n\noutput_format:\n\\* Line 1: The smallest cost of a photograph containing each distinct breed ID.\n*/\n\n#include<sstream>\n#include<stdlib.h>\n#include<algorithm>\n#include<math.h>\n#include<stdio.h>\n#include<vector>\n#include<string>\n#include<climits>\n#include<cstring>\n#include<iostream>\nusing namespace std;\n\n             \nstring solution(string std_in){\n    istringstream iss(std_in);\n             ", "constraints": "There are 6 cows, at positions 25,26,15,22,20,30, with respective breed IDs 7,1,1,3,1,1.\n\n\nThe range from x=22 up through x=26 (of total size 4) contains each of the distinct breed IDs 1, 3, and 7 represented in FJ's herd.\n", "samples": [["6 \n25 7 \n26 1 \n15 1 \n22 3 \n20 1 \n30 1 \n", "4 \n"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}}
{"task_id": "P7917", "title": "[Kubic] Addition", "difficulty": "basic", "nl": "There is an initial sequence $a$ of length $n$. You need to perform $n-1$ operations. Each operation selects two adjacent numbers $x$ and $y$ from the current sequence (where $x$ is on the left of $y$), removes them, and inserts either $x+y$ or $x-y$ at the original position. After $n-1$ operations, there will be only one number left in the sequence. Find the maximum value of this number.", "code": "#include <bits/stdc++.h>\n#define int long long//记得开 long long\nusing namespace std;\nconst int N = 1e5 + 10;\nint n, x, ans;\nsigned main()\n{\n    scanf(\"%lld%lld\", &n, &x);\n    ans = x;\n    for (int i = 2; i <= n; i++)\n    {\n        scanf(\"%lld\", &x);\n        ans += x < 0 ? -x : x;\n    }\n    printf(\"%lld\\n\", ans);\n    return 0;\n}", "step": ["Read the value of n", "Read the first integer and initialize the sum as its value", "Read the remaining n-1 integers and add their absolute value to the sum", "Print the calculated sum"], "nl_cn": "有一个初始长度为 $n$ 的序列 $a$。你需要进行 $n-1$ 次操作。每一次操作先在当前序列中选出两个相邻的数 $x,y$ 并删除（原序列中 $x$ 在 $y$ 左边），再往原位置插入一个 $x+y$ 或一个 $x-y$。$n-1$ 次操作之后最终只会剩下恰好一个数，求这个剩下的数的最大值。", "test_cases": [{"input": "5\n-1 1 1 -1 1", "output": "3"}, {"input": "3\n8 -4 2", "output": "14"}, {"input": "5\n0 0 0 0 0", "output": "0"}, {"input": "4\n4 4 4 4", "output": "16"}, {"input": "3\n9 3 -8", "output": "20"}, {"input": "4\n10 10 -10 -10", "output": "40"}, {"input": "6\n10 5 -2 8 -3 4\n", "output": "32"}, {"input": "1\n100\n", "output": "100"}, {"input": "3\n-1 -2 -3\n", "output": "4"}, {"input": "5\n-1 2 -2 -1 2\n", "output": "6"}, {"input": "3\n3 -2 1\n", "output": "6"}, {"input": "4\n7 8 9 10\n", "output": "34"}, {"input": "5\n5 -5 -5 5 5\n", "output": "25"}, {"input": "6\n1 2 3 4 5 6\n", "output": "21"}, {"input": "5\n-5 -4 -3 -2 -1\n", "output": "5"}, {"input": "2\n0 0\n", "output": "0"}, {"input": "5\n10 -20 30 -40 50\n", "output": "150"}, {"input": "3\n10 20 30\n", "output": "60"}, {"input": "3\n0 0 0\n", "output": "0"}, {"input": "6\n2 4 6 8 10 12\n", "output": "42"}, {"input": "4\n100 200 300 400\n", "output": "1000"}, {"input": "2\n1 1\n", "output": "2"}], "test": "#undef NDEBUG\n#include<assert.h>\nint main(){\n    assert(solution(\"5\\n-1 1 1 -1 1\") == \"3\");\n    assert(solution(\"3\\n8 -4 2\") == \"14\");\n    assert(solution(\"5\\n0 0 0 0 0\") == \"0\");\n    assert(solution(\"4\\n4 4 4 4\") == \"16\");\n    assert(solution(\"3\\n9 3 -8\") == \"20\");\n    assert(solution(\"4\\n10 10 -10 -10\") == \"40\");\n    assert(solution(\"6\\n10 5 -2 8 -3 4\\n\") == \"32\");\n    assert(solution(\"1\\n100\\n\") == \"100\");\n    assert(solution(\"3\\n-1 -2 -3\\n\") == \"4\");\n    assert(solution(\"5\\n-1 2 -2 -1 2\\n\") == \"6\");\n    assert(solution(\"3\\n3 -2 1\\n\") == \"6\");\n    assert(solution(\"4\\n7 8 9 10\\n\") == \"34\");\n    assert(solution(\"5\\n5 -5 -5 5 5\\n\") == \"25\");\n    assert(solution(\"6\\n1 2 3 4 5 6\\n\") == \"21\");\n    assert(solution(\"5\\n-5 -4 -3 -2 -1\\n\") == \"5\");\n    assert(solution(\"2\\n0 0\\n\") == \"0\");\n    assert(solution(\"5\\n10 -20 30 -40 50\\n\") == \"150\");\n    assert(solution(\"3\\n10 20 30\\n\") == \"60\");\n    assert(solution(\"3\\n0 0 0\\n\") == \"0\");\n    assert(solution(\"6\\n2 4 6 8 10 12\\n\") == \"42\");\n    assert(solution(\"4\\n100 200 300 400\\n\") == \"1000\");\n    assert(solution(\"2\\n1 1\\n\") == \"2\");\n    return 0; \n}", "prompt": "/*There is an initial sequence $a$ of length $n$. You need to perform $n-1$ operations. Each operation selects two adjacent numbers $x$ and $y$ from the current sequence (where $x$ is on the left of $y$), removes them, and inserts either $x+y$ or $x-y$ at the original position. After $n-1$ operations, there will be only one number left in the sequence. Find the maximum value of this number.\n\ninput_format:\nThe first line, an integer $n$.\n\nIn the second row, there are $n$integers $i$integers representing $a_i$.\n\noutput_format:\nA single line, an integer, represents the answer.\n*/\n\n#include<sstream>\n#include<stdlib.h>\n#include<algorithm>\n#include<math.h>\n#include<stdio.h>\n#include<vector>\n#include<string>\n#include<climits>\n#include<cstring>\n#include<iostream>\nusing namespace std;\n\n             \nstring solution(string std_in){\n    istringstream iss(std_in);\n             ", "constraints": "对于 $100\\%$ 的数据，$1\\le n\\le 10^5,|a_i|\\le 10^9$。\n\n||分值|$n$|$\\vert a_i\\vert$|特殊性质|\n|:-:|:-:|:-:|:-:|:-:|\n|$\\operatorname{Subtask}1$|$10$|$\\le 2$|无特殊限制|无|\n|$\\operatorname{Subtask}2$|$20$|$\\le 100$|无特殊限制|无|\n|$\\operatorname{Subtask}3$|$5$|无特殊限制|无特殊限制|$a_i\\ge 0$|\n|$\\operatorname{Subtask}4$|$30$|无特殊限制|$\\le 1$|无|\n|$\\operatorname{Subtask}5$|$35$|无特殊限制|无特殊限制|无|\n\n### 样例解释\n\n一种操作过程如下：\n\n`-1 1 1 -1 1`\n\n`-1 1 1 -2`\n\n`-1 1 3`\n\n`-1 4`\n\n`3`\n\n可以证明没有更优的方案。", "samples": [["5\n-1 1 1 -1 1", "3"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072]}}
{"task_id": "P7754", "title": "[COCI2012-2013#3] SAHOVNICA", "difficulty": "basic", "nl": "The chessboard consists of red and white squares. The square at the top left corner is red. The remaining squares are displayed alternately in white and red. In this problem, we use `X` to represent the red area and `.` to represent the white area. Mirko's chessboard should consist of $r\\times c$ squares, and each square is a $a\\times b$ character matrix composed of characters `X` and `.`. Please help him draw this chessboard.", "code": "#include<bits/stdc++.h>\nusing namespace std;\nint r,c,a,b,i,j;\nchar x[15][15];\nint main(){\n\tcin >> r >> c >> a >> b;\n\tfor(i = 1; i <= r; i++){\n\t\tfor(j = 1; j <= c; j++){\n\t\t\tx[i][j] = ((i + j) % 2? '.' : 'X');//用三目表达式判断当前位置上是哪个字符。 \n\t\t}\n\t}\n\tfor(i = 1; i <= r * a; i++){\n\t\tfor(j = 1; j <= c * b; j++){\n\t\t\tcout<< x[(i - 1) / a + 1][(j - 1) / b + 1] ;//核心公式！ \n\t\t}\n\t\tcout<< endl;\n\t}\n    return 0;\n}", "step": ["Reads in the values of r, c, a and b.", "Creates a checkerboard matrix with 'X' and '.' by checking for i+j modulo 2.", "Prints the created matrix on the console by looping through the rows and columns and printing a[i][j] every time with a new line for each row."], "nl_cn": "棋盘由红色格子和白色格子组成。棋盘左上角的格子是红色。其余的格子在棋盘中交替显示成白色和红色。我们在本题中用 `X` 表示红色区域，用 `.` 表示白色区域。Mirko 的棋盘应该由 $r\\times c$ 的格子组成，并且每个格子是由字符 `X` 和 `.` 组成的 $a\\times b$ 的字符矩阵。请你帮助他画出这个棋盘。", "test_cases": [{"input": "2 4\n2 2", "output": "XX..XX..\nXX..XX..\n..XX..XX\n..XX..XX"}, {"input": "5 5\n2 3", "output": "XXX...XXX...XXX\nXXX...XXX...XXX\n...XXX...XXX...\n...XXX...XXX...\nXXX...XXX...XXX\nXXX...XXX...XXX\n...XXX...XXX...\n...XXX...XXX...\nXXX...XXX...XXX\nXXX...XXX...XXX"}, {"input": "2 4 2 2\n", "output": "XX..XX..\nXX..XX..\n..XX..XX\n..XX..XX"}, {"input": "5 5 2 3\n", "output": "XXX...XXX...XXX\nXXX...XXX...XXX\n...XXX...XXX...\n...XXX...XXX...\nXXX...XXX...XXX\nXXX...XXX...XXX\n...XXX...XXX...\n...XXX...XXX...\nXXX...XXX...XXX\nXXX...XXX...XXX"}, {"input": "1 1 1 1\n", "output": "X"}, {"input": "3 3 1 1\n", "output": "X.X\n.X.\nX.X"}, {"input": "1 1\n1 1", "output": "X"}, {"input": "4 4\n2 2", "output": "XX..XX..\nXX..XX..\n..XX..XX\n..XX..XX\nXX..XX..\nXX..XX..\n..XX..XX\n..XX..XX"}, {"input": "3 5\n2 3", "output": "XXX...XXX...XXX\nXXX...XXX...XXX\n...XXX...XXX...\n...XXX...XXX...\nXXX...XXX...XXX\nXXX...XXX...XXX"}, {"input": "3 3\n1 1\n", "output": "X.X\n.X.\nX.X"}, {"input": "7 7\n1 1\n", "output": "X.X.X.X\n.X.X.X.\nX.X.X.X\n.X.X.X.\nX.X.X.X\n.X.X.X.\nX.X.X.X"}], "test": "#undef NDEBUG\n#include<assert.h>\nint main(){\n    assert(solution(\"2 4\\n2 2\") == \"XX..XX..\\nXX..XX..\\n..XX..XX\\n..XX..XX\");\n    assert(solution(\"5 5\\n2 3\") == \"XXX...XXX...XXX\\nXXX...XXX...XXX\\n...XXX...XXX...\\n...XXX...XXX...\\nXXX...XXX...XXX\\nXXX...XXX...XXX\\n...XXX...XXX...\\n...XXX...XXX...\\nXXX...XXX...XXX\\nXXX...XXX...XXX\");\n    assert(solution(\"2 4 2 2\\n\") == \"XX..XX..\\nXX..XX..\\n..XX..XX\\n..XX..XX\");\n    assert(solution(\"5 5 2 3\\n\") == \"XXX...XXX...XXX\\nXXX...XXX...XXX\\n...XXX...XXX...\\n...XXX...XXX...\\nXXX...XXX...XXX\\nXXX...XXX...XXX\\n...XXX...XXX...\\n...XXX...XXX...\\nXXX...XXX...XXX\\nXXX...XXX...XXX\");\n    assert(solution(\"1 1 1 1\\n\") == \"X\");\n    assert(solution(\"3 3 1 1\\n\") == \"X.X\\n.X.\\nX.X\");\n    assert(solution(\"1 1\\n1 1\") == \"X\");\n    assert(solution(\"4 4\\n2 2\") == \"XX..XX..\\nXX..XX..\\n..XX..XX\\n..XX..XX\\nXX..XX..\\nXX..XX..\\n..XX..XX\\n..XX..XX\");\n    assert(solution(\"3 5\\n2 3\") == \"XXX...XXX...XXX\\nXXX...XXX...XXX\\n...XXX...XXX...\\n...XXX...XXX...\\nXXX...XXX...XXX\\nXXX...XXX...XXX\");\n    assert(solution(\"3 3\\n1 1\\n\") == \"X.X\\n.X.\\nX.X\");\n    assert(solution(\"7 7\\n1 1\\n\") == \"X.X.X.X\\n.X.X.X.\\nX.X.X.X\\n.X.X.X.\\nX.X.X.X\\n.X.X.X.\\nX.X.X.X\");\n    return 0; \n}", "prompt": "/*The chessboard consists of red and white squares. The square at the top left corner is red. The remaining squares are displayed alternately in white and red. In this problem, we use `X` to represent the red area and `.` to represent the white area. Mirko's chessboard should consist of $r\\times c$ squares, and each square is a $a\\times b$ character matrix composed of characters `X` and `.`. Please help him draw this chessboard.\n\ninput_format:\nThere are two lines of input.\n\nThe first row has two integers, $r and c$, representing the number of rows and columns of the board, respectively.\nThe second row has two integers $a and b$, representing the number of character matrix rows and columns in each cell, respectively.\n\noutput_format:\nOutput a total of $r\\times a$lines, each line of $c\\times b$characters, describing the final drawn board.\n*/\n\n#include<sstream>\n#include<stdlib.h>\n#include<algorithm>\n#include<math.h>\n#include<stdio.h>\n#include<vector>\n#include<string>\n#include<climits>\n#include<cstring>\n#include<iostream>\nusing namespace std;\n\n             \nstring solution(string std_in){\n    istringstream iss(std_in);\n             ", "constraints": "**【数据范围】**\n\n对于所有数据，$1\\leqslant r,c,a,b\\leqslant 10$。\n\n**【题目来源】**\n\n本题来源自 **_[COCI 2012-2013](https://hsin.hr/coci/archive/2012_2013/) [CONTEST 3](https://hsin.hr/coci/archive/2012_2013/contest3_tasks.pdf) T1 SAHOVNICA_**，按照原题数据配置，满分 $50$ 分。\n\n由 [Eason_AC](https://www.luogu.com.cn/user/112917) 翻译整理提供。", "samples": [["2 4\n2 2", "XX..XX..\nXX..XX..\n..XX..XX\n..XX..XX"], ["5 5\n2 3", "XXX...XXX...XXX\nXXX...XXX...XXX\n...XXX...XXX...\n...XXX...XXX...\nXXX...XXX...XXX\nXXX...XXX...XXX\n...XXX...XXX...\n...XXX...XXX...\nXXX...XXX...XXX\nXXX...XXX...XXX"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [32768, 32768, 32768, 32768, 32768, 32768, 32768, 32768, 32768, 32768]}}
{"task_id": "P3299", "title": "[SDOI2013]保护出题人", "difficulty": "advanced", "nl": "The problem description on a coding website is separated by \"`````\", and you need to translate it into English. The following requirements must be met:\n1. The content of the formula format cannot be deleted or modified.\n2. Return the translated English results directly, and do not return any other content.\n\n`````\nThe problem setter Mingming thinks it's too scary to set problems for SDOI2012, because they will always be criticized, so he set problems for SDOI2013 again.\n\n\nThe children who participated in SDOI2012 released a large number of zombies, intending to attack Mingming's home. As a participant in SDOI2013, you need to protect the problem setter Mingming.\n\n\nThe zombies approached from the only straight road, and you need to place plants in front of Mingming's door to attack the zombies and prevent them from touching the house.\n\n\nIn level one, a zombie with $a_1$ health points approached at a speed from a distance of $x_1$ meters from the house. You placed a plant with an attack power of $y_1$ points per second for defense; in level two, based on the previous level, the zombie queue added a zombie with $a_2$ health points, separated by a distance of $d$ meters from the next zombie, and approached at a constant speed from a distance of $x_2$ meters from the house. You placed a plant with an attack power of $y_2$ points per second again;...; In level $n$, there are a total of $n$ zombies in the queue, with a distance of $d$ meters between adjacent zombies. The head zombie has health points of $a_n$, the second zombie has $a_{n-1}$ health points, and so on. The head zombie approaches at a constant speed from a distance of $x_n$ meters from the house, and the other zombies follow the head. You placed a plant with an attack power of $y_n$ points per second again.\n\n\nThe linear movement speed of each zombie is 1 meter/second. Since the firing speed of the plant is much faster than the zombie's movement speed, the time that the plant's bullets spend in the air can be ignored. All zombies appear and approach at the same time, so when one zombie dies, the next zombie immediately starts to be damaged by the plant's bullets.\n\n\nThe game score depends on the total attack power of the plants you placed $\\sum \\limits _{i=1} ^{n} y_i$. The smaller the score, the higher the score. In order to pursue the upper bound of the score, you need to place plants with the smallest attack power possible in each level.\n\n\nAs a participant in SDOI2013, can you protect the problem setter?", "code": "#include <bits/stdc++.h>\n#define maxn 100010\n#define int long long\nusing namespace std;\nstruct data{\n\tint x, y;\n}stk[maxn];\nint n, D, sum[maxn], top;\ndouble Ans;\n\ninline int read(){\n\tint s = 0, w = 1;\n\tchar c = getchar();\n\tfor (; !isdigit(c); c = getchar()) if (c == '-') w = -1;\n\tfor (; isdigit(c); c = getchar()) s = (s << 1) + (s << 3) + (c ^ 48);\n\treturn s * w;\n}\n\ndouble slope(data x, data y){ return 1.0 * (x.y - y.y) / (x.x - y.x); }\n\nsigned main(){\n\tn = read(), D = read();\n\tstk[0] = (data){0, 0};\n\tfor (int i = 1; i <= n; ++i){\n\t\tint x = read(), y = read(); sum[i] = sum[i - 1] + x;\n\t\tdata tmp = {i * D, sum[i - 1]};\n\t\twhile (top && slope(stk[top - 1], stk[top]) > slope(stk[top], tmp)) --top;\n\t\tstk[++top] = tmp;\n\t\ttmp = (data){y + i * D, sum[i]};\n\t\tint l = 1, r = top, ans = 0;\n\t\twhile (l <= r){\n\t\t\tint mid = (l + r) >> 1;\n\t\t\tif (slope(stk[mid], tmp) > slope(stk[mid - 1], tmp)) ans = mid, l = mid + 1; else r = mid - 1;\n\t\t}\n\t\tAns += slope(stk[ans], tmp);\n\t}\n\tprintf(\"%.0f\\n\", Ans);\n\treturn 0;\n}", "step": ["Initialize variables including a struct data for a pair of x-y coordinates, n and D for the size of the curve and the distance between each point on the X-axis respectively, sum array to hold the sum of the ith to the first point values on the X-axis, and top variable for the stack.", "In the main function, read in values for n and D and set the first point on the stack to 0,0.", "For each point on the curve, read in its x and y values. Calculate the sum of the ith to the first point values on the X-axis and store the result in the sum array. Make a new data struct for this point and set the x value to i*D and the y value to sum[i-1].", "While there are two points on the stack and the new slope between the second last point and the last point is less than the new slope with the current point, remove the last point on the stack. Add the current point to the top of the stack.", "Create a new data struct for the current point, updating its x value to y + i*D and y value to sum[i]. Initialize variables l, r, and ans to 1, top, and 0 respectively. Using binary search, find the maximum slope between the current point and any other point on the stack. Store the index of the point with the maximum slope in the ans variable. Add the slope of the line between that point and the current point to the total Ans.", "Finally, print the value of Ans."], "nl_cn": "出题人铭铭认为给SDOI2012出题太可怕了，因为总要被骂，于是他又给SDOI2013出题了。\n\n\n参加SDOI2012的小朋友们释放出大量的僵尸，企图攻击铭铭的家。而你作为SDOI2013的参赛者，你需要保护出题人铭铭。\n\n\n僵尸从唯一一条笔直道路接近，你们需要在铭铭的房门前放置植物攻击僵尸，避免僵尸碰到房子。\n\n\n第一关，一只血量为$a_1$点的墦尸从距离房子$x_1$米处速接近，你们放置了攻击力为$y_1$点/秒的植物进行防御；第二关，在上一关基础上，僵尸队列排头增加一只血量为$a_2$点的僵尸，与后一只僵尸距离$d$米，从距离房$x_2$米处匀速接近，你们重新放置攻击力为$y_2$点/秒的植物；……；第$n$关，僵尸队列共有$n$只僵尸，相邻两只僵尸距离$d$米，排头僵尸血量为$a_n$点，排第二的 僵尸血量$a_{n-1}$，以此类推，排头僵尸从距离房子$x_n$米处匀速接近，其余僵尸跟随排头同时接近，你们重新放置攻击力为$y_n$点/秒的植物。\n\n\n每只僵尸直线移动速度均为$1$米/秒，由于植物射击速度远大于僵尸移动速度，可忽略植物子弹在空中的时间。所有僵尸同时出现并接近，因此当一只僵尸死亡后，下一只僵尸立刻开始受到植物子弹的伤害。\n\n\n游戏得分取决于你们放置的植物攻击力的总和$\\sum \\limits _{i=1} ^{n} y_i$，和越小分数越高，为了追求分数上界，你们每关都要放置攻击力尽量小的植物。\n\n\n作为SDOI2013的参赛选手，你们能保护出题人么？\n", "test_cases": [{"input": "5  2\n3  3\n1  1\n10 8\n4  8\n2  3", "output": "7"}, {"input": "1 1\n1 1", "output": "1"}, {"input": "5 2\n3 3\n1 1\n10 8\n4 8\n2 3", "output": "7"}], "test": "#undef NDEBUG\n#include<assert.h>\nint main(){\n    assert(solution(\"5  2\\n3  3\\n1  1\\n10 8\\n4  8\\n2  3\") == \"7\");\n    assert(solution(\"1 1\\n1 1\") == \"1\");\n    assert(solution(\"5 2\\n3 3\\n1 1\\n10 8\\n4 8\\n2 3\") == \"7\");\n    return 0; \n}", "prompt": "/*The problem description on a coding website is separated by \"`````\", and you need to translate it into English. The following requirements must be met:\n1. The content of the formula format cannot be deleted or modified.\n2. Return the translated English results directly, and do not return any other content.\n\n`````\nThe problem setter Mingming thinks it's too scary to set problems for SDOI2012, because they will always be criticized, so he set problems for SDOI2013 again.\n\n\nThe children who participated in SDOI2012 released a large number of zombies, intending to attack Mingming's home. As a participant in SDOI2013, you need to protect the problem setter Mingming.\n\n\nThe zombies approached from the only straight road, and you need to place plants in front of Mingming's door to attack the zombies and prevent them from touching the house.\n\n\nIn level one, a zombie with $a_1$ health points approached at a speed from a distance of $x_1$ meters from the house. You placed a plant with an attack power of $y_1$ points per second for defense; in level two, based on the previous level, the zombie queue added a zombie with $a_2$ health points, separated by a distance of $d$ meters from the next zombie, and approached at a constant speed from a distance of $x_2$ meters from the house. You placed a plant with an attack power of $y_2$ points per second again;...; In level $n$, there are a total of $n$ zombies in the queue, with a distance of $d$ meters between adjacent zombies. The head zombie has health points of $a_n$, the second zombie has $a_{n-1}$ health points, and so on. The head zombie approaches at a constant speed from a distance of $x_n$ meters from the house, and the other zombies follow the head. You placed a plant with an attack power of $y_n$ points per second again.\n\n\nThe linear movement speed of each zombie is 1 meter/second. Since the firing speed of the plant is much faster than the zombie's movement speed, the time that the plant's bullets spend in the air can be ignored. All zombies appear and approach at the same time, so when one zombie dies, the next zombie immediately starts to be damaged by the plant's bullets.\n\n\nThe game score depends on the total attack power of the plants you placed $\\sum \\limits _{i=1} ^{n} y_i$. The smaller the score, the higher the score. In order to pursue the upper bound of the score, you need to place plants with the smallest attack power possible in each level.\n\n\nAs a participant in SDOI2013, can you protect the problem setter?\n\ninput_format:\nThe positive integers n and d separated by two Spaces in the first line indicate the number of switches and the distance between neighboring zombies.\n\n\n\noutput_format:\nA number, n is the minimum sum of a plant's attack power, reserved to an integer.\n*/\n\n#include<sstream>\n#include<stdlib.h>\n#include<algorithm>\n#include<math.h>\n#include<stdio.h>\n#include<vector>\n#include<string>\n#include<climits>\n#include<cstring>\n#include<iostream>\nusing namespace std;\n\n             \nstring solution(string std_in){\n    istringstream iss(std_in);\n             ", "constraints": "第一关：距离房子3米处有一只血量3点的僵尸，植物最小攻击力为1.00000；  \n第二关：距离房子1米处有一只血量1点的僵尸、3米处有血量3点的僵尸，植物最小攻击力为1.33333；  \n第三关：距离房子8米处有一只血量10点的僵尸、10米处有血量1点的僵尸、12米处有血量3点的僵尸，植物最小攻击力为1.25000；  \n第四关：距离房子8米处有一只血量4点的僵尸、10米处有血量10点的僵尸、12米处有血量1点的僵尸、14米处有血量3点的僵尸，植物最小攻击力为1.40000；  \n第五关：距离房子3米处有一只血量2点的僵尸、5米处有血量4点的僵尸、7米处有 血量10点的僵尸、9米处有血量1点的僵尸、11米处有血量3点的僵尸，植物最小攻击力 为2.28571。  \n植物攻击力的最小总和为7.26905。\n\n对于100%的数据， $ 1\\le n \\le 10^5  ,1 \\le d,x,a \\le 10^{12} $ 。\n", "samples": [["5  2\n3  3\n1  1\n10 8\n4  8\n2  3", "7"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}}
{"task_id": "P7499", "title": "「HMOI R1」概率", "difficulty": "basic", "nl": "Fz is studying cultural courses after retiring. He saw a problem like this:\n\nGiven two intervals $[a, b]$ and $[c, d]$, find the probability that selecting an integer randomly from each interval would result in a sum of $e$.\n\nInitially, Fz wanted to change \"equal to $e$\" to \"$\\in [e,f]$\", but he decided not to do so to prevent becoming a bad problem setter. \n\nFor convenience, you only need to output the result multiplied by $(b-a+1)(d-c+1)$. It can be proved that this number is an integer.", "code": "#include <iostream>\n\nusing namespace std;\n\nint t;\nlong long a,b,c,d,e;\n\nint main()\n{\n    int i,j,k;\n    cin>>t;\n    while(t--)\n    {\n        cin>>a>>b>>c>>d>>e;\n        cout<<max(min(e-a,d)-max(e-b,c)+1,(long long)0)<<endl;\n    }\n    return 0;\n}", "step": ["Declare integers t, a, b, c, d, and e.", "Take input for t.", "Use while loop to iterate through the input values.", "Take input for a, b, c, d, and e.", "Calculate a value based on the input values using max, min, and arithmetic operators.", "Print the resulting value."], "nl_cn": "fz 退役之后正在学文化课。\n\nfz 见到一个题，这个题是这样的：\n\n给定区间 $[a, b]$ 和 $[c, d]$，求从其中各等概率选择一个整数，和等于 $e$ 的概率。\n\nfz 本来想把 “等于 $e$” 改成 “$\\in [e,f]$”，但是这样他就会变成辣鸡分类讨论出题人，所以他决定不改。\n\n为了方便，你只需输出答案乘 $(b-a+1)(d-c+1)$ 的结果。可以证明这个数是一个整数。", "test_cases": [{"input": "1\n1 2 3 4 5\n", "output": "2"}, {"input": "1\n10 15 5 10 12\n", "output": "0"}, {"input": "1\n-10 -5 -20 -15 -17\n", "output": "0"}, {"input": "1\n-5 5 -10 10 0\n", "output": "11"}, {"input": "1\n-3 3 -2 2 -2\n", "output": "4"}, {"input": "1\n0 0 0 0 0\n", "output": "1"}, {"input": "1\n-5 -1 -10 -5 -5\n", "output": "0"}, {"input": "1\n-10 0 0 10 -5\n", "output": "6"}, {"input": "1\n-1000 -500 -700 -400 -600\n", "output": "0"}, {"input": "1\n1000 2000 1500 2500 1700\n", "output": "0"}, {"input": "1\n6 10 -10 10 9\n", "output": "5"}, {"input": "1\n-50 50 -100 100 0\n", "output": "101"}, {"input": "1\n-50 50 -100 100 100\n", "output": "51"}, {"input": "1\n-1000000 1000000 -2000000 2000000 1000000\n", "output": "2000001"}], "test": "#undef NDEBUG\n#include<assert.h>\nint main(){\n    assert(solution(\"1\\n1 2 3 4 5\\n\") == \"2\");\n    assert(solution(\"1\\n10 15 5 10 12\\n\") == \"0\");\n    assert(solution(\"1\\n-10 -5 -20 -15 -17\\n\") == \"0\");\n    assert(solution(\"1\\n-5 5 -10 10 0\\n\") == \"11\");\n    assert(solution(\"1\\n-3 3 -2 2 -2\\n\") == \"4\");\n    assert(solution(\"1\\n0 0 0 0 0\\n\") == \"1\");\n    assert(solution(\"1\\n-5 -1 -10 -5 -5\\n\") == \"0\");\n    assert(solution(\"1\\n-10 0 0 10 -5\\n\") == \"6\");\n    assert(solution(\"1\\n-1000 -500 -700 -400 -600\\n\") == \"0\");\n    assert(solution(\"1\\n1000 2000 1500 2500 1700\\n\") == \"0\");\n    assert(solution(\"1\\n6 10 -10 10 9\\n\") == \"5\");\n    assert(solution(\"1\\n-50 50 -100 100 0\\n\") == \"101\");\n    assert(solution(\"1\\n-50 50 -100 100 100\\n\") == \"51\");\n    assert(solution(\"1\\n-1000000 1000000 -2000000 2000000 1000000\\n\") == \"2000001\");\n    return 0; \n}", "prompt": "/*Fz is studying cultural courses after retiring. He saw a problem like this:\n\nGiven two intervals $[a, b]$ and $[c, d]$, find the probability that selecting an integer randomly from each interval would result in a sum of $e$.\n\nInitially, Fz wanted to change \"equal to $e$\" to \"$\\in [e,f]$\", but he decided not to do so to prevent becoming a bad problem setter. \n\nFor convenience, you only need to output the result multiplied by $(b-a+1)(d-c+1)$. It can be proved that this number is an integer.\n\ninput_format:\nThe first row contains an integer $T$, representing a total of $T$group data.\n\nNext, line $T$, with five integers per line $a, b, c, d, e$.\n\noutput_format:\nA total of $T$lines, each set of data row one natural number, representing the corresponding answer.\n*/\n\n#include<sstream>\n#include<stdlib.h>\n#include<algorithm>\n#include<math.h>\n#include<stdio.h>\n#include<vector>\n#include<string>\n#include<climits>\n#include<cstring>\n#include<iostream>\nusing namespace std;\n\n             \nstring solution(string std_in){\n    istringstream iss(std_in);\n             ", "constraints": "样例解释：\n\n对于样例的第一组数据，从 $[1,2]$ 和 $[3,4]$ 中各随机选出一个整数的方案共有 $4$ 种，其中只有 $\\{1,4\\}$ 和 $\\{2,3\\}$ 两种方案和为 $5$，故概率为 $\\dfrac12$。\n\n---------\n\n令 $N=\\max\\{|a|,|b|,|c|,|d|,|e|\\}$。\n\n对于所有数据：\n\n- $1 \\le T \\le 1000$；\n\n- $0 \\le N \\le 10^{18}$。\n\n-----------------\n\n**本题不采用捆绑测试。**\n\n| No.  | Constraints            | Score |\n| ---- | ---------------------- | ----- |\n| $1$  | 与样例相同             | $10$  |\n| $2$  | $N \\le 300$            | $10$  |\n| $3$  | $N \\le 5000$           | $30$  |\n| $4$  | $N \\le 10^9$           | $20$  |\n| $5$  | No further constraints | $30$  |\n\n---------\n\n- Idea: FZzzz  \n- Solution: FZzzz  \n- Code: FZzzz  \n- Data: FZzzz", "samples": [["1\n1 2 3 4 5\n", "2"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072]}}
{"task_id": "P3556", "title": "[POI2013]MOR-Tales of seafaring", "difficulty": "advanced", "nl": "Young Bytensson likes to hang out in the harbor pub and often listens to the sailors telling their sea stories.\n\nAt first, he believed these stories no matter how incredible they sounded.\n\nHowever, over time, he became suspicious.\n\nHe decided to write a program to verify if there was any truth in these bizarre stories.\n\nBytensson believes that although he cannot be sure if the sailors actually experienced those storms, he can at least determine if their travel itinerary is reasonable.\n\nThis is a programmer's task, but unfortunately, Bytensson is not a programmer.\n\nPlease help him!\n\nThere are $n$ ports and $m$ waterways connecting them in the sea area where sailors often come and go.\n\nIf there is a waterway between two ports, it is possible to sail from either port to the other. Any waterway can be navigated back and forth.\n\nBytensson has heard of $k$ sea stories.\n\nEach story tells of a sailor starting his journey from a port, sailing through some waterways, and finally reaching another port, which may be the one he started from.\n\nThe sailor in the story may pass through the same waterway multiple times, each time navigating in any direction.\n\nIn this case, queries are made on whether there exists a path of length $d$ between two ports (the path may not be a simple path).", "code": "#include <iostream>\n#include <cstdio>\n#include <vector>\n#include <cstring>\n#include <queue>\nusing namespace std;\nconst int N = 5005, K = 1e6 + 5;\nstruct Edge {int now, nxt;} e[N << 1];\nint head[N], cur;\nvoid add(int u, int v)\n{\n\te[++cur].now = v, e[cur].nxt = head[u];\n\thead[u] = cur;\n}\nint dis[N][2]; //分奇偶\nbool inque[N];\nvoid spfa(int s)\n{\n\tmemset(dis, 0x3f, sizeof dis);\n\tmemset(inque, false, sizeof inque);\n\tqueue <int> q;\n\tq.push(s), inque[s] = true, dis[s][0] = 0;\n\twhile (!q.empty())\n\t{\n\t\tint u = q.front();\n\t\tq.pop(), inque[u] = false;\n\t\tfor (int i = head[u]; i; i = e[i].nxt)\n\t\t{\n\t\t\tint v = e[i].now;\n\t\t\tif (dis[u][0] + 1 < dis[v][1])\n\t\t\t{\n\t\t\t\tdis[v][1] = dis[u][0] + 1;\n\t\t\t\tif (!inque[v]) inque[v] = true, q.push(v);\n\t\t\t}\n\t\t\tif (dis[u][1] + 1 < dis[v][0])\n\t\t\t{\n\t\t\t\tdis[v][0] = dis[u][1] + 1;\n\t\t\t\tif (!inque[v]) inque[v] = true, q.push(v);\n\t\t\t}\n\t\t}\n\t}\n}\nstruct Query {int id, v, w;};\nvector <Query> query[N];\nbool ans[K];\nint main()\n{\n\t//ios::sync_with_stdio(false);\n\tint n, m, k;\n\tscanf(\"%d%d%d\", &n, &m, &k);\n\twhile (m--)\n\t{\n\t\tint u, v;\n\t\tscanf(\"%d%d\", &u, &v);\n\t\tadd(u, v), add(v, u);\n\t}\n\tfor (int i = 1; i <= k; i++)\n\t{\n\t\tint u, v, w;\n\t\tscanf(\"%d%d%d\", &u, &v, &w);\n\t\tquery[u].push_back((Query){i, v, w});\n\t}\n\tfor (int u = 1; u <= n; u++)\n\t\tif (!query[u].empty() && head[u]) //特别注意！如果这个点是孤立的，怎么走都是无解\n\t\t{\n\t\t\tspfa(u);\n\t\t\tfor (Query t : query[u]) ans[t.id] = (t.w >= dis[t.v][t.w & 1]);\n\t\t}\n\tfor (int i = 1; i <= k; i++)\n\t\tif (ans[i]) puts(\"TAK\"); else puts(\"NIE\");\n\treturn 0;\n}", "step": ["Establish connections between vertex pairs", "Take input of the source vertex, the target vertex and the edge weight", "Compute the distance of each vertex from the source vertex", "Answer based on whether the condition of query is satisfying or not"], "nl_cn": "Young Bytensson loves to hang out in the port tavern, where he often    listens to the sea dogs telling their tales of seafaring.\n\nInitially, he believed them all, however incredible they sounded.\n\nOver time though, he became suspicious.\n\nHe has decided to write a program that will verify if there may be    any grain of truth in those tall stories.\n\nBytensson reasoned that while he cannot tell if the sailors indeed    weathered all those storms, he can at least find out if their travel    itineraries make sense.\n\nThis is a task for a programmer, which Bytensson, unfortunately, is not.\n\nHelp him out!\n\nThere are $n$ ports and $m$ waterways connecting them in the waters    frequented by the sailors Bytensson listened to.\n\nIf there is a waterway between two ports, then sailing from one to the    other is possible.  Any waterway can be sailed in both    directions.\n\nBytensson got to know $k$ seafaring tales.\n\nEach tells of a sailor who began his journey in one port,    sailed a number of waterways, and ended up in another port,    which may have been the one he initially set sail from.\n\nThe sailor in question may have sailed through the same waterway    many times, each time in any direction.\n\n给n个点m条边无向图，每次询问两个点之间是否有长度为d的路径（不一定是简单路径）\n", "test_cases": [{"input": "8 7 4\n1 2\n2 3\n3 4\n5 6\n6 7\n7 8\n8 5\n2 3 1\n1 4 1\n5 5 8\n1 8 10\n", "output": "TAK\nNIE\nTAK\nNIE"}, {"input": "3 2 1\n1 2\n2 3\n1 3 1\n", "output": "NIE"}, {"input": "7 8 4\n1 2\n2 3\n3 4\n4 5\n5 6\n6 7\n7 1\n2 4\n3 5\n4 6\n5 7\n2 7 2\n1 4 2\n7 3 1\n1 6 3\n", "output": "TAK\nTAK\nTAK\nTAK"}, {"input": "3 3 1\n1 2\n2 3\n3 1\n3 1 1\n", "output": "TAK"}, {"input": "6 8 5\n1 2\n2 3\n3 4\n4 5\n5 6\n6 1\n1 2\n1 3\n2 5\n3 5\n4 6\n5 6 1\n2 4 2\n3 6 3\n1 6 4\n", "output": "TAK\nTAK\nTAK\nTAK\nTAK"}, {"input": "2 1 1\n1 2\n1 2 1\n", "output": "TAK"}, {"input": "8 9 5\n1 2\n2 3\n3 4\n4 5\n1 6\n6 7\n7 8\n8 5\n6 5\n2 7 1\n1 4 1\n3 6 1\n4 8 1\n5 1 1\n", "output": "NIE\nNIE\nNIE\nNIE\nNIE"}, {"input": "3 2 2\n1 2\n2 3\n1 3 2\n2 3 1\n", "output": "TAK\nTAK"}, {"input": "5 5 3\n1 2\n2 3\n3 4\n4 5\n5 1\n2 4\n1 3\n5 3 1\n", "output": "NIE\nTAK\nTAK"}, {"input": "5 3 2\n1 2\n3 4\n3 5\n1 4 1\n3 5 2\n", "output": "NIE\nNIE"}, {"input": "3 3 2\n1 2\n2 3\n3 1\n1 3 1\n2 3 1\n", "output": "TAK\nTAK"}, {"input": "3 1 1\n1 2\n1 2 2\n", "output": "NIE"}, {"input": "4 3 2\n1 2\n2 3\n3 4\n1 4 1\n2 4 2\n", "output": "NIE\nTAK"}, {"input": "4 3 2\n1 2\n1 3\n2 4\n1 4 2\n2 4 1\n", "output": "TAK\nTAK"}, {"input": "3 2 1\n1 2\n1 3\n2 3 1\n", "output": "NIE"}, {"input": "4 3 2\n1 2\n1 4\n2 3\n2 3 1\n1 4 1\n", "output": "TAK\nTAK"}], "test": "#undef NDEBUG\n#include<assert.h>\nint main(){\n    assert(solution(\"8 7 4\\n1 2\\n2 3\\n3 4\\n5 6\\n6 7\\n7 8\\n8 5\\n2 3 1\\n1 4 1\\n5 5 8\\n1 8 10\\n\") == \"TAK\\nNIE\\nTAK\\nNIE\");\n    assert(solution(\"3 2 1\\n1 2\\n2 3\\n1 3 1\\n\") == \"NIE\");\n    assert(solution(\"7 8 4\\n1 2\\n2 3\\n3 4\\n4 5\\n5 6\\n6 7\\n7 1\\n2 4\\n3 5\\n4 6\\n5 7\\n2 7 2\\n1 4 2\\n7 3 1\\n1 6 3\\n\") == \"TAK\\nTAK\\nTAK\\nTAK\");\n    assert(solution(\"3 3 1\\n1 2\\n2 3\\n3 1\\n3 1 1\\n\") == \"TAK\");\n    assert(solution(\"6 8 5\\n1 2\\n2 3\\n3 4\\n4 5\\n5 6\\n6 1\\n1 2\\n1 3\\n2 5\\n3 5\\n4 6\\n5 6 1\\n2 4 2\\n3 6 3\\n1 6 4\\n\") == \"TAK\\nTAK\\nTAK\\nTAK\\nTAK\");\n    assert(solution(\"2 1 1\\n1 2\\n1 2 1\\n\") == \"TAK\");\n    assert(solution(\"8 9 5\\n1 2\\n2 3\\n3 4\\n4 5\\n1 6\\n6 7\\n7 8\\n8 5\\n6 5\\n2 7 1\\n1 4 1\\n3 6 1\\n4 8 1\\n5 1 1\\n\") == \"NIE\\nNIE\\nNIE\\nNIE\\nNIE\");\n    assert(solution(\"3 2 2\\n1 2\\n2 3\\n1 3 2\\n2 3 1\\n\") == \"TAK\\nTAK\");\n    assert(solution(\"5 5 3\\n1 2\\n2 3\\n3 4\\n4 5\\n5 1\\n2 4\\n1 3\\n5 3 1\\n\") == \"NIE\\nTAK\\nTAK\");\n    assert(solution(\"5 3 2\\n1 2\\n3 4\\n3 5\\n1 4 1\\n3 5 2\\n\") == \"NIE\\nNIE\");\n    assert(solution(\"3 3 2\\n1 2\\n2 3\\n3 1\\n1 3 1\\n2 3 1\\n\") == \"TAK\\nTAK\");\n    assert(solution(\"3 1 1\\n1 2\\n1 2 2\\n\") == \"NIE\");\n    assert(solution(\"4 3 2\\n1 2\\n2 3\\n3 4\\n1 4 1\\n2 4 2\\n\") == \"NIE\\nTAK\");\n    assert(solution(\"4 3 2\\n1 2\\n1 3\\n2 4\\n1 4 2\\n2 4 1\\n\") == \"TAK\\nTAK\");\n    assert(solution(\"3 2 1\\n1 2\\n1 3\\n2 3 1\\n\") == \"NIE\");\n    assert(solution(\"4 3 2\\n1 2\\n1 4\\n2 3\\n2 3 1\\n1 4 1\\n\") == \"TAK\\nTAK\");\n    return 0; \n}", "prompt": "/*Young Bytensson likes to hang out in the harbor pub and often listens to the sailors telling their sea stories.\n\nAt first, he believed these stories no matter how incredible they sounded.\n\nHowever, over time, he became suspicious.\n\nHe decided to write a program to verify if there was any truth in these bizarre stories.\n\nBytensson believes that although he cannot be sure if the sailors actually experienced those storms, he can at least determine if their travel itinerary is reasonable.\n\nThis is a programmer's task, but unfortunately, Bytensson is not a programmer.\n\nPlease help him!\n\nThere are $n$ ports and $m$ waterways connecting them in the sea area where sailors often come and go.\n\nIf there is a waterway between two ports, it is possible to sail from either port to the other. Any waterway can be navigated back and forth.\n\nBytensson has heard of $k$ sea stories.\n\nEach story tells of a sailor starting his journey from a port, sailing through some waterways, and finally reaching another port, which may be the one he started from.\n\nThe sailor in the story may pass through the same waterway multiple times, each time navigating in any direction.\n\nIn this case, queries are made on whether there exists a path of length $d$ between two ports (the path may not be a simple path).\n\ninput_format:\nIn the first line of the standard input, there are three integers, $n$,$m$ and $k$ ($2\\le n\\le 5\\ 000$, $1\\le m\\le 5\\ 000$, $1\\le k\\le 1\\ 000\\ 000$).\n\nThese denote, respectively: the number of ports in the waters      frequented by the sailors who told Bytensson their stories,the number of waterways, and the number of tales.\n\nThe $m$ lines that follow specify the waterways.\n\nA single waterway's description consists of a single line that contains two integers, $a$ and $b$ ($1\\le a,b\\le n$,$a\\ne b$), separated by a single space; these specify the numbers of ports at the two ends of this particular waterway.\n\nThe $k$ lines that follow specify the tales that Bytensson has heard. A single tale's description consists of a single line with three integers,$s$,$t$,and $d$ ($1\\le s,t\\le n$,$1\\le d\\le 1\\ 000\\ 000\\ 000$ ), separated by single spaces. These indicate that the tale's protagonist set sail from port no. $s$ , ended the journey in port no. $t$ , and sailed exactly $d$ times through various waterways.\n\noutput_format:\nYour program should print exactly $k$ lines to the standard output; the $i$-th of them should contain the word TAK (Polish for yes) if the journey described in the $i$-th tale(in input order) could have taken place.\n\nIf it could not, then the line should contain the word NIE (Polish for no).\n*/\n\n#include<sstream>\n#include<stdlib.h>\n#include<algorithm>\n#include<math.h>\n#include<stdio.h>\n#include<vector>\n#include<string>\n#include<climits>\n#include<cstring>\n#include<iostream>\nusing namespace std;\n\n             \nstring solution(string std_in){\n    istringstream iss(std_in);\n             ", "constraints": "给n个点m条边无向图，每次询问两个点之间是否有长度为d的路径（不一定是简单路径）\n", "samples": [["8 7 4\n1 2\n2 3\n3 4\n5 6\n6 7\n7 8\n8 5\n2 3 1\n1 4 1\n5 5 8\n1 8 10\n", "TAK\nNIE\nTAK\nNIE\n"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}}
{"task_id": "P3908", "title": "数列之异或", "difficulty": "challenge", "nl": "Find the value of $1 \\bigoplus 2 \\bigoplus\\cdots\\bigoplus N$.\n\n$A \\bigoplus B$ represents the bitwise XOR of $A$ and $B$.", "code": "#include<bits/stdc++.h>\n#define ll long long\nusing namespace std;\nll n;\nint main(){\n  ll ans=0;\n  scanf(\"%lld\",&n);\n  if(!(n&1)) n++,ans=n;\n  ll num=(n+1ll)/2ll;\n  if(num&1) ans^=1;\n  cout<<ans;\n}", "step": ["Declare variable ans as 0 and n as long long.", "Take input of 'n'.", "Check if 'n' is even, and add 1 to it and assign it to 'n' if it is.", "Calculate the number 'num' as (n+1)/2.", "If 'num' is odd, perform XOR operation on 'ans' with 1.", "Print the value of 'ans'."], "nl_cn": "求$1 \\bigoplus 2 \\bigoplus\\cdots\\bigoplus N$ 的值。\n\n$A \\bigoplus B$ 即$A$ , $B$ 按位异或。\n", "test_cases": [{"input": "3", "output": "0"}, {"input": "1\n", "output": "1"}, {"input": "7\n", "output": "0"}, {"input": "12\n", "output": "12"}, {"input": "15\n", "output": "0"}, {"input": "100\n", "output": "100"}, {"input": "48\n", "output": "48"}, {"input": "55\n", "output": "0"}, {"input": "63\n", "output": "0"}, {"input": "1000\n", "output": "1000"}, {"input": "2", "output": "3"}, {"input": "4", "output": "4"}, {"input": "5", "output": "1"}, {"input": "6", "output": "7"}, {"input": "8", "output": "8"}, {"input": "9", "output": "1"}, {"input": "10", "output": "11"}, {"input": "11", "output": "0"}, {"input": "13", "output": "1"}, {"input": "14", "output": "15"}, {"input": "16", "output": "16"}, {"input": "17", "output": "1"}, {"input": "18", "output": "19"}, {"input": "19", "output": "0"}, {"input": "20", "output": "20"}], "test": "#undef NDEBUG\n#include<assert.h>\nint main(){\n    assert(solution(\"3\") == \"0\");\n    assert(solution(\"1\\n\") == \"1\");\n    assert(solution(\"7\\n\") == \"0\");\n    assert(solution(\"12\\n\") == \"12\");\n    assert(solution(\"15\\n\") == \"0\");\n    assert(solution(\"100\\n\") == \"100\");\n    assert(solution(\"48\\n\") == \"48\");\n    assert(solution(\"55\\n\") == \"0\");\n    assert(solution(\"63\\n\") == \"0\");\n    assert(solution(\"1000\\n\") == \"1000\");\n    assert(solution(\"2\") == \"3\");\n    assert(solution(\"4\") == \"4\");\n    assert(solution(\"5\") == \"1\");\n    assert(solution(\"6\") == \"7\");\n    assert(solution(\"8\") == \"8\");\n    assert(solution(\"9\") == \"1\");\n    assert(solution(\"10\") == \"11\");\n    assert(solution(\"11\") == \"0\");\n    assert(solution(\"13\") == \"1\");\n    assert(solution(\"14\") == \"15\");\n    assert(solution(\"16\") == \"16\");\n    assert(solution(\"17\") == \"1\");\n    assert(solution(\"18\") == \"19\");\n    assert(solution(\"19\") == \"0\");\n    assert(solution(\"20\") == \"20\");\n    return 0; \n}", "prompt": "/*Find the value of $1 \\bigoplus 2 \\bigoplus\\cdots\\bigoplus N$.\n\n$A \\bigoplus B$ represents the bitwise XOR of $A$ and $B$.\n\ninput_format:\n1 integer $N$.\n\noutput_format:\n1 integer, representing the desired value.\n*/\n\n#include<sstream>\n#include<stdlib.h>\n#include<algorithm>\n#include<math.h>\n#include<stdio.h>\n#include<vector>\n#include<string>\n#include<climits>\n#include<cstring>\n#include<iostream>\nusing namespace std;\n\n             \nstring solution(string std_in){\n    istringstream iss(std_in);\n             ", "constraints": "• 对于50% 的数据，$1 \\le N \\le 10^6$；\n\n• 对于100% 的数据，$1 \\le N \\le 10^{18}$。\n", "samples": [["3", "0"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}}
{"task_id": "P3075", "title": "[USACO13FEB]Partitioning the Farm G", "difficulty": "advanced", "nl": "The Farmer John's farm is divided into an N x N pasture grid (2 <= N <= 15). Currently, there is a fence around the farm, but cows can freely move from one pasture to another.\n\nFarmer John has decided to build fences to separate the cows. Due to zoning regulations, each fence must be a horizontal or vertical line and cannot cross the pastures. Farmer John only has enough money to build at most K fences (1 <= K <= 2N - 2).\n\nFarmer John wants to build the fences to minimize the maximum size of a group of cows (if two cows can reach each other without crossing any fence, they are in the same group). Given the current number of cows in each pasture, help Farmer John calculate the maximum size of a group of cows if he builds the fences in the best way possible.\n\nGiven an N x N matrix, partition the matrix using K horizontal or vertical lines to minimize the maximum sum in any region.", "code": "#include <bits/stdc++.h>\nusing namespace std;\nint a[17][17],b[17][17],c[17][17];\nbool ne[17];\nint n,m,t;\ninline bool check(int k,int v)\n{\n    int top=1,o;\n\tmemset(c,0,sizeof(c));\n    for(register int i=1;i<=n;i++)\n    {\n        if(i>1&&((k>>(i-2))&1))top++;\n        for(register int j=1;j<=n;j++)c[top][j]+=b[i][j];        \n    }\n    if(top>m+1)\n        return 0;\n    o=m-top+1;\n    for(register int l=0,r=1;r<=n;r++)\n    {\n        for(register int i=1;i<=top;i++)\n        {\n            if(c[i][r]-c[i][r-1]>v)\n                return 0;\n            else\n            {\n                if(c[i][r]-c[i][l]>v)\n                    l=r-1,o--;\n            }\n        }\n    }\n    if(o<0)return 0;return 1;\n}\nint main()\n{\n    int l=0,r=0,mid,ans;bool ok;\n    scanf(\"%d%d\",&n,&m);\n    for(register int i=1;i<=n;i++)\n    {\n        for(register int j=1;j<=n;j++)scanf(\"%d\",&a[i][j]),r+=a[i][j];\n    }\n    for(register int i=1;i<=n;i++)\n    {\n        for(register int j=1;j<=n;j++)b[i][j]=b[i][j-1]+a[i][j];\n    }\n    t=(1<<n)-1;\n    while(r>=l)\n    {\n        mid=(l+r)>>1;\n\t\tok=0;\n        for(register int i=0;i<t;i++)\n        {\n            if(check(i,mid))\n            {\n                ok=1;\n                break;\n            }\n        }\n        if(ok)\n            ans=mid,r=mid-1;\n        else\n            l=mid+1;\n    }\n    printf(\"%d\",ans);\n    return 0;\n}", "step": ["Initialize three 2D arrays and a boolean array", "Read input values", "Find the prefix sum of A", "Apply binary search to identify the maximum value V", "Check if all M*M submatrices have at most V as the sum of its elements", "Return the maximum value V"], "nl_cn": "Farmer John's farm is divided into an N x N square grid of pastures (2 <= N <= 15). Right now, there is a fence around the outside of the farm, but cows can move freely from pasture to pasture.\n\nFarmer John has decided to build fences to separate the cows from each other. Because of zoning laws, each fence must be a horizontal or vertical line going across the entire farm and fences cannot go through pastures. Farmer John only has enough money to build at most K fences (1 <= K <= 2N - 2).\n\nFarmer John wants to build the fences in order to minimize the size of the largest resulting group of cows (two cows are in the same group if they can reach each other without going through any fences). Given the current number of cows in each pasture, help Farmer John compute the size of the largest group of cows if he builds the fences optimally.\n\n给出一个n\\*n的矩阵，用k条水平或竖直直线分割矩阵，最小化区域和最大值。\n", "test_cases": [{"input": "3 2 \n1 1 2 \n1 1 2 \n2 2 4 \n", "output": "4"}, {"input": "2 2 \n1 1 \n1 2 \n", "output": "2"}, {"input": "3 2 \n1 1 2 \n1 2 3 \n2 3 4 \n", "output": "5"}, {"input": "2 1\n1 2\n3 4\n", "output": "6"}, {"input": "3 1\n1 1 1\n2 2 2\n3 3 3\n", "output": "9"}, {"input": "5 3\n1 0 1 0 1\n1 0 1 0 1\n1 0 1 0 1\n1 0 1 0 1\n1 0 1 0 1\n", "output": "3"}, {"input": "4 3\n1 1 2 2\n3 3 4 4\n5 5 6 6\n7 7 8 8\n", "output": "16"}, {"input": "3 1\n3 3 3\n2 2 2\n1 1 1\n", "output": "9"}, {"input": "2 1 \n10 5 \n7 8 \n", "output": "15"}, {"input": "3 2 \n1 2 3 \n4 5 6 \n7 8 9 \n", "output": "15"}, {"input": "3 2\n1 1 2\n1 1 2\n2 2 4\n", "output": "4"}, {"input": "3 2\n9 8 7\n6 5 4\n3 2 1\n", "output": "15"}, {"input": "3 2\n222 222 222\n111 111 111\n333 222 111\n", "output": "555"}, {"input": "5 3\n1 2 3 4 5\n1 2 3 4 5\n1 2 3 4 5\n1 2 3 4 5\n1 2 3 4 5\n", "output": "18"}], "test": "#undef NDEBUG\n#include<assert.h>\nint main(){\n    assert(solution(\"3 2 \\n1 1 2 \\n1 1 2 \\n2 2 4 \\n\") == \"4\");\n    assert(solution(\"2 2 \\n1 1 \\n1 2 \\n\") == \"2\");\n    assert(solution(\"3 2 \\n1 1 2 \\n1 2 3 \\n2 3 4 \\n\") == \"5\");\n    assert(solution(\"2 1\\n1 2\\n3 4\\n\") == \"6\");\n    assert(solution(\"3 1\\n1 1 1\\n2 2 2\\n3 3 3\\n\") == \"9\");\n    assert(solution(\"5 3\\n1 0 1 0 1\\n1 0 1 0 1\\n1 0 1 0 1\\n1 0 1 0 1\\n1 0 1 0 1\\n\") == \"3\");\n    assert(solution(\"4 3\\n1 1 2 2\\n3 3 4 4\\n5 5 6 6\\n7 7 8 8\\n\") == \"16\");\n    assert(solution(\"3 1\\n3 3 3\\n2 2 2\\n1 1 1\\n\") == \"9\");\n    assert(solution(\"2 1 \\n10 5 \\n7 8 \\n\") == \"15\");\n    assert(solution(\"3 2 \\n1 2 3 \\n4 5 6 \\n7 8 9 \\n\") == \"15\");\n    assert(solution(\"3 2\\n1 1 2\\n1 1 2\\n2 2 4\\n\") == \"4\");\n    assert(solution(\"3 2\\n9 8 7\\n6 5 4\\n3 2 1\\n\") == \"15\");\n    assert(solution(\"3 2\\n222 222 222\\n111 111 111\\n333 222 111\\n\") == \"555\");\n    assert(solution(\"5 3\\n1 2 3 4 5\\n1 2 3 4 5\\n1 2 3 4 5\\n1 2 3 4 5\\n1 2 3 4 5\\n\") == \"18\");\n    return 0; \n}", "prompt": "/*The Farmer John's farm is divided into an N x N pasture grid (2 <= N <= 15). Currently, there is a fence around the farm, but cows can freely move from one pasture to another.\n\nFarmer John has decided to build fences to separate the cows. Due to zoning regulations, each fence must be a horizontal or vertical line and cannot cross the pastures. Farmer John only has enough money to build at most K fences (1 <= K <= 2N - 2).\n\nFarmer John wants to build the fences to minimize the maximum size of a group of cows (if two cows can reach each other without crossing any fence, they are in the same group). Given the current number of cows in each pasture, help Farmer John calculate the maximum size of a group of cows if he builds the fences in the best way possible.\n\nGiven an N x N matrix, partition the matrix using K horizontal or vertical lines to minimize the maximum sum in any region.\n\ninput_format:\n\\* Line 1: Two integers, N and K\n\n\\* Lines 2.. 1+N: There are N numbers per line, describing the cows in each pasture for one row of the farm (there are at least 0 and at most 1000 cows in each pasture)\n\noutput_format:\n\\* Line 1: The minimum possible size of the largest group of cows.\n*/\n\n#include<sstream>\n#include<stdlib.h>\n#include<algorithm>\n#include<math.h>\n#include<stdio.h>\n#include<vector>\n#include<string>\n#include<climits>\n#include<cstring>\n#include<iostream>\nusing namespace std;\n\n             \nstring solution(string std_in){\n    istringstream iss(std_in);\n             ", "constraints": "Farmer John should build fences between columns 2 and 3 and between rows 2 and 3, which creates 4 groups each with 4 cows.\n", "samples": [["3 2 \n1 1 2 \n1 1 2 \n2 2 4 \n", "4 \n"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}}
{"task_id": "P3156", "title": "【深基15.例1】询问学号", "difficulty": "basic", "nl": "$n$ ($n \\le 2 \\times 10^6$) students enter the classroom one by one, and we know the student ID of each student (between $1$ and $10^9$) in the order they enter. During the class, the teacher wants to know the student ID of the $i$-th student who enters the classroom (the first student who enters the classroom has $i=1$), with no more than $10^5$ queries.", "code": "#include <iostream>\n#include <vector>\nusing namespace std;\nvector<long > vec;\nint main() {\n\tios::sync_with_stdio(false);\n\tcin.tie(0);\n\tint n, m;\n\tcin >> n >> m;\n\twhile (n--) {\n\t\tlong x;\n\t\tcin >> x;\n\t\tvec.push_back(x); \n\t}\n\t\n\twhile (m--) {\n\t\tint idx;\n\t\tcin >> idx;\n        // 注意i从1开始，但下标从0开始，所以要-1\n\t\tcout << vec[idx - 1] << endl;\n\t}\n\treturn 0;\n}", "step": ["Declare variables and an array of long long integers.", "Read in the integer values for array size and number of queries.", "Loop over the values of the array, reading in each integer.", "Loop over the number of queries, reading in each integer and outputting the corresponding array element.", "End the program."], "nl_cn": "有 $n(n \\le 2 \\times 10^6)$ 名同学陆陆续续进入教室。我们知道每名同学的学号（在 $1$ 到 $10^9$ 之间），按进教室的顺序给出。上课了，老师想知道第 $i$ 个进入教室的同学的学号是什么（最先进入教室的同学 $i=1$），询问次数不超过 $10^5$ 次。", "test_cases": [{"input": "10 3\n1 9 2 60 8 17 11 4 5 14\n1 5 9\n", "output": "1\n8\n5"}, {"input": "5 2\n3 6 9 12 15\n4 1\n", "output": "12\n3"}, {"input": "7 4\n10 20 30 40 50 60 70\n7 4 2 6\n", "output": "70\n40\n20\n60"}, {"input": "3 1\n100 200 300\n2\n", "output": "200"}, {"input": "6 5\n5 10 15 20 25 30\n3 6 1 4 2\n", "output": "15\n30\n5\n20\n10"}, {"input": "8 3\n7 14 21 28 35 42 49 56\n5 8 2\n", "output": "35\n56\n14"}, {"input": "2 2\n1000 2000\n1 2\n", "output": "1000\n2000"}, {"input": "4 1\n4 8 12 16\n3\n", "output": "12"}, {"input": "9 4\n2 4 6 8 10 12 14 16 18\n8 5 1 9\n", "output": "16\n10\n2\n18"}, {"input": "1 1\n100\n1\n", "output": "100"}, {"input": "6 2\n3 6 9 12 15 18\n4 6\n", "output": "12\n18"}, {"input": "7 3\n50 100 150 200 250 300 350\n2 7 1\n", "output": "100\n350\n50"}, {"input": "5 4\n2 4 6 8 10\n1 4 3 2\n", "output": "2\n8\n6\n4"}, {"input": "3 2\n10 20 30\n1 2\n", "output": "10\n20"}, {"input": "9 5\n1 2 3 4 5 6 7 8 9\n3 6 2 1 4\n", "output": "3\n6\n2\n1\n4"}, {"input": "4 3\n5 10 15 20\n3 2 1\n", "output": "15\n10\n5"}, {"input": "2 1\n100 200\n2\n", "output": "200"}, {"input": "8 5\n1 2 3 4 5 6 7 8\n7 2 8 1 5\n", "output": "7\n2\n8\n1\n5"}, {"input": "5 2\n1 2 3 4 5\n3 5\n", "output": "3\n5"}, {"input": "5 2\n2 4 6 8 10\n3 5\n", "output": "6\n10"}, {"input": "7 4\n7 14 21 28 35 42 49\n2 4 6 7\n", "output": "14\n28\n42\n49"}, {"input": "3 3\n10 20 30\n1 2 3\n", "output": "10\n20\n30"}, {"input": "8 5\n5 10 15 20 25 30 35 40\n6 1 8 7 4\n", "output": "30\n5\n40\n35\n20"}, {"input": "6 1\n2 4 6 8 10 12\n3\n", "output": "6"}, {"input": "9 4\n9 18 27 36 45 54 63 72 81\n3 5 8 9\n", "output": "27\n45\n72\n81"}, {"input": "4 2\n1 3 5 7\n1 4\n", "output": "1\n7"}, {"input": "2 2\n1 2\n1 2\n", "output": "1\n2"}, {"input": "7 3\n7 14 21 28 35 42 49\n1 3 5\n", "output": "7\n21\n35"}, {"input": "6 2\n2 4 6 8 10 12\n4 5\n", "output": "8\n10"}, {"input": "3 2\n10 20 30\n2 3\n", "output": "20\n30"}, {"input": "4 1\n1 3 5 7\n3\n", "output": "5"}, {"input": "2 1\n1 2\n2\n", "output": "2"}, {"input": "10 2\n5 10 15 20 25 30 35 40 45 50\n4 9\n", "output": "20\n45"}, {"input": "7 2\n7 14 21 28 35 42 49\n2 7\n", "output": "14\n49"}, {"input": "6 3\n2 4 6 8 10 12\n1 3 5\n", "output": "2\n6\n10"}, {"input": "3 1\n10 20 30\n1\n", "output": "10"}, {"input": "5 2\n10 20 30 40 50\n2 4\n", "output": "20\n40"}, {"input": "8 4\n3 6 9 12 15 18 21 24\n3 6 2 1\n", "output": "9\n18\n6\n3"}, {"input": "3 3\n100 200 300\n1 2 3\n", "output": "100\n200\n300"}, {"input": "7 1\n1 2 3 4 5 6 7\n5\n", "output": "5"}, {"input": "6 4\n10 20 30 40 50 60\n3 6 1 5\n", "output": "30\n60\n10\n50"}, {"input": "4 2\n5 10 15 20\n3 4\n", "output": "15\n20"}, {"input": "2 1\n1000000000 999999999\n1\n", "output": "1000000000"}, {"input": "9 3\n9 18 27 36 45 54 63 72 81\n2 5 7\n", "output": "18\n45\n63"}, {"input": "12 5\n1 4 7 10 13 16 19 22 25 28 31 34\n5 10 2 11 1\n", "output": "13\n28\n4\n31\n1"}, {"input": "6 2\n9 8 7 6 5 4\n1 5\n", "output": "9\n5"}, {"input": "5 1\n5 10 15 20 25\n3\n", "output": "15"}, {"input": "11 4\n11 22 33 44 55 66 77 88 99 101 202\n3 6 2 10\n", "output": "33\n66\n22\n101"}, {"input": "8 2\n5 10 15 20 25 30 35 40\n4 8\n", "output": "20\n40"}, {"input": "3 2\n1000 2000 3000\n1 3\n", "output": "1000\n3000"}, {"input": "7 3\n2 4 6 8 10 12 14\n4 6 1\n", "output": "8\n12\n2"}, {"input": "10 4\n100 200 300 400 500 600 700 800 900 1000\n2 8 1 9\n", "output": "200\n800\n100\n900"}, {"input": "4 1\n40 30 20 10\n3\n", "output": "20"}, {"input": "6 3\n6 12 18 24 30 36\n4 2 1\n", "output": "24\n12\n6"}, {"input": "5 5\n4 7 1 9 3\n3 1 5 2 4\n", "output": "1\n4\n3\n7\n9"}, {"input": "7 2\n15 3 9 11 12 8 20\n2 7\n", "output": "3\n20"}, {"input": "3 4\n11 12 9\n2 1 3 1\n", "output": "12\n11\n9\n11"}, {"input": "8 1\n1 2 3 4 5 6 7 8\n4\n", "output": "4"}, {"input": "6 3\n5 6 1 2 4 3\n3 5 2\n", "output": "1\n4\n6"}, {"input": "12 2\n5 9 12 7 10 6 11 3 2 8 1 4\n2 7\n", "output": "9\n11"}, {"input": "4 4\n4 3 2 1\n1 2 3 4\n", "output": "4\n3\n2\n1"}, {"input": "7 3\n2 4 5 3 7 6 1\n6 2 4\n", "output": "6\n4\n3"}, {"input": "5 2\n1 2 3 4 5\n4 1\n", "output": "4\n1"}, {"input": "2 2\n9 7\n1 2\n", "output": "9\n7"}, {"input": "6 4\n5 2 3 6 1 4\n1 6 3 5\n", "output": "5\n4\n3\n1"}, {"input": "8 2\n7 1 5 6 8 2 4 3\n4 1\n", "output": "6\n7"}, {"input": "4 1\n4 3 2 1\n4\n", "output": "1"}, {"input": "9 2\n1 2 3 4 5 6 7 8 9\n5 9\n", "output": "5\n9"}, {"input": "7 2\n6 4 7 2 5 3 1\n4 3\n", "output": "2\n7"}, {"input": "5 2\n3 6 9 12 15\n4 2\n", "output": "12\n6"}, {"input": "7 4\n2 4 6 8 10 12 14\n3 1 5 7\n", "output": "6\n2\n10\n14"}, {"input": "3 1\n1000000000 500000000 100000000\n2\n", "output": "500000000"}, {"input": "1 1\n42\n1\n", "output": "42"}, {"input": "6 3\n7 14 21 28 35 42\n1 3 5\n", "output": "7\n21\n35"}, {"input": "8 4\n4 8 12 16 20 24 28 32\n7 2 4 6\n", "output": "28\n8\n16\n24"}, {"input": "2 1\n999999999 1000000000\n1\n", "output": "999999999"}, {"input": "4 2\n1 3 5 7\n3 1\n", "output": "5\n1"}, {"input": "5 3\n10 20 30 40 50\n4 5 1\n", "output": "40\n50\n10"}, {"input": "3 2\n5 7 9\n2 1\n", "output": "7\n5"}, {"input": "6 2\n6 12 18 24 30 36\n2 5\n", "output": "12\n30"}, {"input": "8 3\n25 30 35 40 45 50 55 60\n4 1 7\n", "output": "40\n25\n55"}, {"input": "4 1\n5 10 15 20\n3\n", "output": "15"}, {"input": "2 2\n2 3\n1 2\n", "output": "2\n3"}, {"input": "7 4\n11 22 33 44 55 66 77\n4 6 1 7\n", "output": "44\n66\n11\n77"}, {"input": "5 4\n100 200 300 400 500\n2 4 5 1\n", "output": "200\n400\n500\n100"}, {"input": "3 2\n1 4 7\n3 2\n", "output": "7\n4"}, {"input": "9 3\n3 6 9 12 15 18 21 24 27\n4 7 1\n", "output": "12\n21\n3"}], "test": "#undef NDEBUG\n#include<assert.h>\nint main(){\n    assert(solution(\"10 3\\n1 9 2 60 8 17 11 4 5 14\\n1 5 9\\n\") == \"1\\n8\\n5\");\n    assert(solution(\"5 2\\n3 6 9 12 15\\n4 1\\n\") == \"12\\n3\");\n    assert(solution(\"7 4\\n10 20 30 40 50 60 70\\n7 4 2 6\\n\") == \"70\\n40\\n20\\n60\");\n    assert(solution(\"3 1\\n100 200 300\\n2\\n\") == \"200\");\n    assert(solution(\"6 5\\n5 10 15 20 25 30\\n3 6 1 4 2\\n\") == \"15\\n30\\n5\\n20\\n10\");\n    assert(solution(\"8 3\\n7 14 21 28 35 42 49 56\\n5 8 2\\n\") == \"35\\n56\\n14\");\n    assert(solution(\"2 2\\n1000 2000\\n1 2\\n\") == \"1000\\n2000\");\n    assert(solution(\"4 1\\n4 8 12 16\\n3\\n\") == \"12\");\n    assert(solution(\"9 4\\n2 4 6 8 10 12 14 16 18\\n8 5 1 9\\n\") == \"16\\n10\\n2\\n18\");\n    assert(solution(\"1 1\\n100\\n1\\n\") == \"100\");\n    assert(solution(\"6 2\\n3 6 9 12 15 18\\n4 6\\n\") == \"12\\n18\");\n    assert(solution(\"7 3\\n50 100 150 200 250 300 350\\n2 7 1\\n\") == \"100\\n350\\n50\");\n    assert(solution(\"5 4\\n2 4 6 8 10\\n1 4 3 2\\n\") == \"2\\n8\\n6\\n4\");\n    assert(solution(\"3 2\\n10 20 30\\n1 2\\n\") == \"10\\n20\");\n    assert(solution(\"9 5\\n1 2 3 4 5 6 7 8 9\\n3 6 2 1 4\\n\") == \"3\\n6\\n2\\n1\\n4\");\n    assert(solution(\"4 3\\n5 10 15 20\\n3 2 1\\n\") == \"15\\n10\\n5\");\n    assert(solution(\"2 1\\n100 200\\n2\\n\") == \"200\");\n    assert(solution(\"8 5\\n1 2 3 4 5 6 7 8\\n7 2 8 1 5\\n\") == \"7\\n2\\n8\\n1\\n5\");\n    assert(solution(\"5 2\\n1 2 3 4 5\\n3 5\\n\") == \"3\\n5\");\n    assert(solution(\"5 2\\n2 4 6 8 10\\n3 5\\n\") == \"6\\n10\");\n    assert(solution(\"7 4\\n7 14 21 28 35 42 49\\n2 4 6 7\\n\") == \"14\\n28\\n42\\n49\");\n    assert(solution(\"3 3\\n10 20 30\\n1 2 3\\n\") == \"10\\n20\\n30\");\n    assert(solution(\"8 5\\n5 10 15 20 25 30 35 40\\n6 1 8 7 4\\n\") == \"30\\n5\\n40\\n35\\n20\");\n    assert(solution(\"6 1\\n2 4 6 8 10 12\\n3\\n\") == \"6\");\n    assert(solution(\"9 4\\n9 18 27 36 45 54 63 72 81\\n3 5 8 9\\n\") == \"27\\n45\\n72\\n81\");\n    assert(solution(\"4 2\\n1 3 5 7\\n1 4\\n\") == \"1\\n7\");\n    assert(solution(\"2 2\\n1 2\\n1 2\\n\") == \"1\\n2\");\n    assert(solution(\"7 3\\n7 14 21 28 35 42 49\\n1 3 5\\n\") == \"7\\n21\\n35\");\n    assert(solution(\"6 2\\n2 4 6 8 10 12\\n4 5\\n\") == \"8\\n10\");\n    assert(solution(\"3 2\\n10 20 30\\n2 3\\n\") == \"20\\n30\");\n    assert(solution(\"4 1\\n1 3 5 7\\n3\\n\") == \"5\");\n    assert(solution(\"2 1\\n1 2\\n2\\n\") == \"2\");\n    assert(solution(\"10 2\\n5 10 15 20 25 30 35 40 45 50\\n4 9\\n\") == \"20\\n45\");\n    assert(solution(\"7 2\\n7 14 21 28 35 42 49\\n2 7\\n\") == \"14\\n49\");\n    assert(solution(\"6 3\\n2 4 6 8 10 12\\n1 3 5\\n\") == \"2\\n6\\n10\");\n    assert(solution(\"3 1\\n10 20 30\\n1\\n\") == \"10\");\n    assert(solution(\"5 2\\n10 20 30 40 50\\n2 4\\n\") == \"20\\n40\");\n    assert(solution(\"8 4\\n3 6 9 12 15 18 21 24\\n3 6 2 1\\n\") == \"9\\n18\\n6\\n3\");\n    assert(solution(\"3 3\\n100 200 300\\n1 2 3\\n\") == \"100\\n200\\n300\");\n    assert(solution(\"7 1\\n1 2 3 4 5 6 7\\n5\\n\") == \"5\");\n    assert(solution(\"6 4\\n10 20 30 40 50 60\\n3 6 1 5\\n\") == \"30\\n60\\n10\\n50\");\n    assert(solution(\"4 2\\n5 10 15 20\\n3 4\\n\") == \"15\\n20\");\n    assert(solution(\"2 1\\n1000000000 999999999\\n1\\n\") == \"1000000000\");\n    assert(solution(\"9 3\\n9 18 27 36 45 54 63 72 81\\n2 5 7\\n\") == \"18\\n45\\n63\");\n    assert(solution(\"12 5\\n1 4 7 10 13 16 19 22 25 28 31 34\\n5 10 2 11 1\\n\") == \"13\\n28\\n4\\n31\\n1\");\n    assert(solution(\"6 2\\n9 8 7 6 5 4\\n1 5\\n\") == \"9\\n5\");\n    assert(solution(\"5 1\\n5 10 15 20 25\\n3\\n\") == \"15\");\n    assert(solution(\"11 4\\n11 22 33 44 55 66 77 88 99 101 202\\n3 6 2 10\\n\") == \"33\\n66\\n22\\n101\");\n    assert(solution(\"8 2\\n5 10 15 20 25 30 35 40\\n4 8\\n\") == \"20\\n40\");\n    assert(solution(\"3 2\\n1000 2000 3000\\n1 3\\n\") == \"1000\\n3000\");\n    assert(solution(\"7 3\\n2 4 6 8 10 12 14\\n4 6 1\\n\") == \"8\\n12\\n2\");\n    assert(solution(\"10 4\\n100 200 300 400 500 600 700 800 900 1000\\n2 8 1 9\\n\") == \"200\\n800\\n100\\n900\");\n    assert(solution(\"4 1\\n40 30 20 10\\n3\\n\") == \"20\");\n    assert(solution(\"6 3\\n6 12 18 24 30 36\\n4 2 1\\n\") == \"24\\n12\\n6\");\n    assert(solution(\"5 5\\n4 7 1 9 3\\n3 1 5 2 4\\n\") == \"1\\n4\\n3\\n7\\n9\");\n    assert(solution(\"7 2\\n15 3 9 11 12 8 20\\n2 7\\n\") == \"3\\n20\");\n    assert(solution(\"3 4\\n11 12 9\\n2 1 3 1\\n\") == \"12\\n11\\n9\\n11\");\n    assert(solution(\"8 1\\n1 2 3 4 5 6 7 8\\n4\\n\") == \"4\");\n    assert(solution(\"6 3\\n5 6 1 2 4 3\\n3 5 2\\n\") == \"1\\n4\\n6\");\n    assert(solution(\"12 2\\n5 9 12 7 10 6 11 3 2 8 1 4\\n2 7\\n\") == \"9\\n11\");\n    assert(solution(\"4 4\\n4 3 2 1\\n1 2 3 4\\n\") == \"4\\n3\\n2\\n1\");\n    assert(solution(\"7 3\\n2 4 5 3 7 6 1\\n6 2 4\\n\") == \"6\\n4\\n3\");\n    assert(solution(\"5 2\\n1 2 3 4 5\\n4 1\\n\") == \"4\\n1\");\n    assert(solution(\"2 2\\n9 7\\n1 2\\n\") == \"9\\n7\");\n    assert(solution(\"6 4\\n5 2 3 6 1 4\\n1 6 3 5\\n\") == \"5\\n4\\n3\\n1\");\n    assert(solution(\"8 2\\n7 1 5 6 8 2 4 3\\n4 1\\n\") == \"6\\n7\");\n    assert(solution(\"4 1\\n4 3 2 1\\n4\\n\") == \"1\");\n    assert(solution(\"9 2\\n1 2 3 4 5 6 7 8 9\\n5 9\\n\") == \"5\\n9\");\n    assert(solution(\"7 2\\n6 4 7 2 5 3 1\\n4 3\\n\") == \"2\\n7\");\n    assert(solution(\"5 2\\n3 6 9 12 15\\n4 2\\n\") == \"12\\n6\");\n    assert(solution(\"7 4\\n2 4 6 8 10 12 14\\n3 1 5 7\\n\") == \"6\\n2\\n10\\n14\");\n    assert(solution(\"3 1\\n1000000000 500000000 100000000\\n2\\n\") == \"500000000\");\n    assert(solution(\"1 1\\n42\\n1\\n\") == \"42\");\n    assert(solution(\"6 3\\n7 14 21 28 35 42\\n1 3 5\\n\") == \"7\\n21\\n35\");\n    assert(solution(\"8 4\\n4 8 12 16 20 24 28 32\\n7 2 4 6\\n\") == \"28\\n8\\n16\\n24\");\n    assert(solution(\"2 1\\n999999999 1000000000\\n1\\n\") == \"999999999\");\n    assert(solution(\"4 2\\n1 3 5 7\\n3 1\\n\") == \"5\\n1\");\n    assert(solution(\"5 3\\n10 20 30 40 50\\n4 5 1\\n\") == \"40\\n50\\n10\");\n    assert(solution(\"3 2\\n5 7 9\\n2 1\\n\") == \"7\\n5\");\n    assert(solution(\"6 2\\n6 12 18 24 30 36\\n2 5\\n\") == \"12\\n30\");\n    assert(solution(\"8 3\\n25 30 35 40 45 50 55 60\\n4 1 7\\n\") == \"40\\n25\\n55\");\n    assert(solution(\"4 1\\n5 10 15 20\\n3\\n\") == \"15\");\n    assert(solution(\"2 2\\n2 3\\n1 2\\n\") == \"2\\n3\");\n    assert(solution(\"7 4\\n11 22 33 44 55 66 77\\n4 6 1 7\\n\") == \"44\\n66\\n11\\n77\");\n    assert(solution(\"5 4\\n100 200 300 400 500\\n2 4 5 1\\n\") == \"200\\n400\\n500\\n100\");\n    assert(solution(\"3 2\\n1 4 7\\n3 2\\n\") == \"7\\n4\");\n    assert(solution(\"9 3\\n3 6 9 12 15 18 21 24 27\\n4 7 1\\n\") == \"12\\n21\\n3\");\n    return 0; \n}", "prompt": "/*$n$ ($n \\le 2 \\times 10^6$) students enter the classroom one by one, and we know the student ID of each student (between $1$ and $10^9$) in the order they enter. During the class, the teacher wants to know the student ID of the $i$-th student who enters the classroom (the first student who enters the classroom has $i=1$), with no more than $10^5$ queries.\n\ninput_format:\nThe first line of $2 has integers $n$and $m$, indicating the number of students and the number of inquiries.\n\nThe second line is an integer of $n$, representing the student number that enters the classroom in order.\n\nThe third line is an integer of $m$, indicating the number of students who have entered the classroom.\n\noutput_format:\nOutput $m$an integer representing the answer, separated by a newline.\n*/\n\n#include<sstream>\n#include<stdlib.h>\n#include<algorithm>\n#include<math.h>\n#include<stdio.h>\n#include<vector>\n#include<string>\n#include<climits>\n#include<cstring>\n#include<iostream>\nusing namespace std;\n\n             \nstring solution(string std_in){\n    istringstream iss(std_in);\n             ", "constraints": "", "samples": [["10 3\n1 9 2 60 8 17 11 4 5 14\n1 5 9\n", "1\n8\n5"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000]}}
{"task_id": "P8410", "title": "「SvR-1」Don't Mozheng. /oh", "difficulty": "basic", "nl": "You are given $n$ pieces of information, which can be of three types (note that $\\texttt<\\textit{str}\\texttt>$ represents a string called $str$, **which does not contain spaces, colons, and slashes**):\n\n1. In the form of $\\texttt<\\textit{str}\\texttt{>:}$, which means that the next line contains a message from the user named $str$.\n2. In the form of $\\texttt{/<}str\\texttt>$, which represents an **emoji message** named $str$.\n3. In the form of $\\texttt<\\textit{str}\\texttt>$, which represents a text message with content $str$.\n\nAfter careful observation, you found that emoji messages named $\\texttt{oh}$ and $\\texttt{hsh}$ have a special meaning.\n\nDuring a conversation:\n\n- An $\\texttt{oh}$ emoji message increases the craziness value by $a$.\n- An $\\texttt{hsh}$ emoji message increases the craziness value by $b$.\n- **Any other information will not affect the craziness value, which is initially $0$.**\n\nNow, you need to calculate the total craziness value for these messages.", "code": "#include<iostream>\n#include<cstring>\n#include<string>\nusing namespace std;\nint n,a,b,ans;\nstring str;\nint main(){\n\tstd::ios::sync_with_stdio(false);//取消cin于stdin的同步，加速cin\n\tcin>>n>>a>>b;\n\tfor(int i=1;i<=2*n;i++){//有2n行\n\t\tcin>>str;//输入名字或消息\n\t\tif(str==\"/oh\")\tans+=a;//如果是oh表情就加a魔怔值\n\t\tif(str==\"/hsh\")\tans+=b;//如果是hsh表情就加b魔怔值\n\t}\n\tcout<<ans;\n\treturn 0;\n}", "step": ["Read inputs for n, a, and b.", "Read input for string str1 and str2 in a loop.", "If the first character of str2 is '/', check its length and characters at other positions.", "If the length of str2 is 3 and characters at positions 1 and 2 are 'o' and 'h' respectively, add a to ans.", "If the length of str2 is 4 and characters at positions 1, 2, and 3 are 'h', 's', and 'h' respectively, add b to ans.", "Print the value of ans."], "nl_cn": "你得到了 $n$ 条信息，这些信息共有三种类型（注意 $\\texttt<\\textit{str}\\texttt>$ 描述一个名为 $str$ 的字符串，**该字符串不含空格、字符 $\\texttt:$ 与 $\\texttt/$**，不含两边的尖角括号）：\n\n1. 形如 $\\texttt<\\textit{str}\\texttt{>:}$。意为**接下来一行的一条信息**是名为 $str$ 的用户发的。\n2. 形如 $\\texttt{/<}str\\texttt>$。意为一条名称为 $str$ 的**表情信息**。\n3. 形如 $\\texttt<\\textit{str}\\texttt>$。意为一条内容为 $str$ 的文字信息。\n\n你经过长期观察，发现名称为 $\\texttt{oh}$ 和 $\\texttt{hsh}$ 的**表情信息**具有魔怔的意味。\n\n并且在一段对话中：\n\n- 一个 $\\texttt{oh}$ 表情会增加 $a$ 的魔怔值。\n- 一个 $\\texttt{hsh}$ 表情会增加 $b$ 的魔怔值。\n- **其他的任何信息都不会影响魔怔值，魔怔值初始为 $0$**。\n\n现在你需要对于这些信息，计算出总的魔怔值。", "test_cases": [{"input": "7 1 2020\nwop:\n/yueliang\neoq:\nwop_loushang\nwop:\neoq_npy_when\neoq:\n/oh\ndek:\n/oh\nrif:\nNOI2022_rp_++\nrif:\n/hsh", "output": "2022"}, {"input": "2 2 3\nabc:\n/oh\ndef:\n/hsh\n", "output": "5"}, {"input": "4 0 0\nmessage1:\nmessage content 1\nemoji1:\n/hsh\nemoji2:\n/oh\n", "output": "0"}, {"input": "1 1 1\nuser1:\n/hsh\n", "output": "1"}, {"input": "3 5 1\nhello:\n/world\ngoodbye:\n/test\nxyz:\n/oh\n", "output": "5"}, {"input": "2 3 2\nabc:\n/message\ndef:\n/hsh\n", "output": "2"}, {"input": "1 2 4\nuser1:\n/oh\n", "output": "2"}, {"input": "3 4 3\nabc:\n/orange\ndef:\n/test\nxyz:\n/hsh\n", "output": "3"}, {"input": "2 0 0\nmsg1:\n/message\nmsg2:\n/test\n", "output": "0"}, {"input": "3 2 3\nhello:\n/world\ngoodbye:\n/orange\nxyz:\n/hsh\n", "output": "3"}, {"input": "2 1 0\nmsg1:\n/test\nmsg2:\n/message\n", "output": "0"}, {"input": "1 1 2\nuser1:\n/oh\nuser2:\n/hsh\nuser3:\n/test", "output": "1"}, {"input": "3 1 1\nuser1:\n/oh\nuser2:\n/oh\nuser3:\n/oh", "output": "3"}, {"input": "3 2 3\nuser1:\n/hsh\nuser2:\n/hsh\nuser3:\n/hsh", "output": "9"}, {"input": "4 1 10\nuser1:\n/test1\nuser2:\n/test1\nuser3:\n/test1\nuser4:\n/test1", "output": "0"}, {"input": "8 1 1\nuser1:\n/oh\nuser2:\n/oh\nuser3:\n/oh\nuser4:\n/oh\nuser5:\n/oh\nuser6:\n/oh\nuser7:\n/oh\nuser8:\n/oh", "output": "8"}, {"input": "8 2 2\nuser1:\n/oh\nuser2:\n/oh\nuser3:\n/hsh\nuser4:\n/hsh\nuser5:\n/test1\nuser6:\n/test1\nuser7:\n/yueliang\nuser8:\n/yueliang", "output": "8"}, {"input": "9 3 3\nuser1:\n/hsh\nuser2:\n/hsh\nuser3:\n/hsh\nuser4:\n/hsh\nuser5:\n/hsh\nuser6:\n/hsh\nuser7:\n/hsh\nuser8:\n/hsh\nuser9:\n/hsh", "output": "27"}, {"input": "9 1 6\nuser1:\n/oh\nuser2:\n/oh\nuser3:\n/oh\nuser4:\n/oh\nuser5:\n/oh\nuser6:\n/oh\nuser7:\n/oh\nuser8:\n/oh\nuser9:\n/oh", "output": "9"}, {"input": "1 1 1\nuser1:\n/oh\n", "output": "1"}, {"input": "1 1 10\nuser1:\n/hsh\n", "output": "10"}, {"input": "3 2 1\nuser1:\n/oh\nuser2:\n/hsh\nuser3:\n/message\n", "output": "3"}, {"input": "2 5 5\nuser1:\n/hsh\nuser2:\n/oh\n", "output": "10"}, {"input": "2 1 100\nuser1:\n/message\nuser2:\n/oh\n", "output": "1"}, {"input": "4 1 1\nuser1:\n/oh\nuser2:\n/oh\nuser3:\n/message\nuser4:\n/oh\n", "output": "3"}, {"input": "6 0 0\n123:\n/oh\n456:\n789:\n/hsh\n101112:\n", "output": "0"}, {"input": "1 1 1\nabcd:\n", "output": "0"}, {"input": "6 0 0\nmsg1:\n/foo\nmsg2:\nmsg3:\n/oh\nmsg4:\n/hsh\n", "output": "0"}, {"input": "3 10 2\nmsg1:\nmsg2:\nmsg3:\n", "output": "0"}, {"input": "2 5 20\nabc:\ndef:\n", "output": "0"}, {"input": "1 0 0\nabcd:\n", "output": "0"}, {"input": "9 5 10\nmsg1:\nmsg2:\nmsg3:\nmsg4:\nmsg5:\n", "output": "0"}, {"input": "7 4 6\nhello:\nworld:\nmsg1:\nfoo:\nbar:\n", "output": "0"}, {"input": "6 0 0\nmsg1:\nmsg2:\nmsg3:\nmsg4:\n", "output": "0"}, {"input": "5 2 1\nabc:\ndef:\nghi:\njkl:\n", "output": "0"}, {"input": "0 1 2\n", "output": "0"}, {"input": "1 10 20\nuser1:\n/oh\n", "output": "10"}, {"input": "3 100 200\nuser1:\nNOI2023\nuser2:\n/invalid_emoji\nuser3:\n/hsh\n", "output": "200"}, {"input": "2 1 1\nuser1:\n/hsh\nuser2:\n/hsh\n", "output": "2"}, {"input": "3 10 20\nuser1:\n/hsh\nuser2:\n/hsh\nuser3:\n/hsh\n", "output": "60"}, {"input": "5 1 1\nuser1:\nwop\nuser2:\nwop\nuser3:\nwop\nuser4:\na\nuser5:\nb\n", "output": "0"}, {"input": "1 100 200\nuser1:\n/invalid_emoji\n", "output": "0"}, {"input": "2 1 1\nuser1:\n/different_emoji\nuser2:\n/hsh\n", "output": "1"}, {"input": "2 1 1\nuser1:\n/hsh\nuser2:\n/invalid_emoji\n", "output": "1"}, {"input": "3 10 20\nuser1:\nhsh\nuser2:\nhsh\nuser3:\nhsh\n", "output": "0"}, {"input": "5 1 1\nuser1:\na\nuser2:\nb\nuser3:\n/hsh\nuser4:\na\nuser5:\nb\n", "output": "1"}], "test": "#undef NDEBUG\n#include<assert.h>\nint main(){\n    assert(solution(\"7 1 2020\\nwop:\\n/yueliang\\neoq:\\nwop_loushang\\nwop:\\neoq_npy_when\\neoq:\\n/oh\\ndek:\\n/oh\\nrif:\\nNOI2022_rp_++\\nrif:\\n/hsh\") == \"2022\");\n    assert(solution(\"2 2 3\\nabc:\\n/oh\\ndef:\\n/hsh\\n\") == \"5\");\n    assert(solution(\"4 0 0\\nmessage1:\\nmessage content 1\\nemoji1:\\n/hsh\\nemoji2:\\n/oh\\n\") == \"0\");\n    assert(solution(\"1 1 1\\nuser1:\\n/hsh\\n\") == \"1\");\n    assert(solution(\"3 5 1\\nhello:\\n/world\\ngoodbye:\\n/test\\nxyz:\\n/oh\\n\") == \"5\");\n    assert(solution(\"2 3 2\\nabc:\\n/message\\ndef:\\n/hsh\\n\") == \"2\");\n    assert(solution(\"1 2 4\\nuser1:\\n/oh\\n\") == \"2\");\n    assert(solution(\"3 4 3\\nabc:\\n/orange\\ndef:\\n/test\\nxyz:\\n/hsh\\n\") == \"3\");\n    assert(solution(\"2 0 0\\nmsg1:\\n/message\\nmsg2:\\n/test\\n\") == \"0\");\n    assert(solution(\"3 2 3\\nhello:\\n/world\\ngoodbye:\\n/orange\\nxyz:\\n/hsh\\n\") == \"3\");\n    assert(solution(\"2 1 0\\nmsg1:\\n/test\\nmsg2:\\n/message\\n\") == \"0\");\n    assert(solution(\"1 1 2\\nuser1:\\n/oh\\nuser2:\\n/hsh\\nuser3:\\n/test\") == \"1\");\n    assert(solution(\"3 1 1\\nuser1:\\n/oh\\nuser2:\\n/oh\\nuser3:\\n/oh\") == \"3\");\n    assert(solution(\"3 2 3\\nuser1:\\n/hsh\\nuser2:\\n/hsh\\nuser3:\\n/hsh\") == \"9\");\n    assert(solution(\"4 1 10\\nuser1:\\n/test1\\nuser2:\\n/test1\\nuser3:\\n/test1\\nuser4:\\n/test1\") == \"0\");\n    assert(solution(\"8 1 1\\nuser1:\\n/oh\\nuser2:\\n/oh\\nuser3:\\n/oh\\nuser4:\\n/oh\\nuser5:\\n/oh\\nuser6:\\n/oh\\nuser7:\\n/oh\\nuser8:\\n/oh\") == \"8\");\n    assert(solution(\"8 2 2\\nuser1:\\n/oh\\nuser2:\\n/oh\\nuser3:\\n/hsh\\nuser4:\\n/hsh\\nuser5:\\n/test1\\nuser6:\\n/test1\\nuser7:\\n/yueliang\\nuser8:\\n/yueliang\") == \"8\");\n    assert(solution(\"9 3 3\\nuser1:\\n/hsh\\nuser2:\\n/hsh\\nuser3:\\n/hsh\\nuser4:\\n/hsh\\nuser5:\\n/hsh\\nuser6:\\n/hsh\\nuser7:\\n/hsh\\nuser8:\\n/hsh\\nuser9:\\n/hsh\") == \"27\");\n    assert(solution(\"9 1 6\\nuser1:\\n/oh\\nuser2:\\n/oh\\nuser3:\\n/oh\\nuser4:\\n/oh\\nuser5:\\n/oh\\nuser6:\\n/oh\\nuser7:\\n/oh\\nuser8:\\n/oh\\nuser9:\\n/oh\") == \"9\");\n    assert(solution(\"1 1 1\\nuser1:\\n/oh\\n\") == \"1\");\n    assert(solution(\"1 1 10\\nuser1:\\n/hsh\\n\") == \"10\");\n    assert(solution(\"3 2 1\\nuser1:\\n/oh\\nuser2:\\n/hsh\\nuser3:\\n/message\\n\") == \"3\");\n    assert(solution(\"2 5 5\\nuser1:\\n/hsh\\nuser2:\\n/oh\\n\") == \"10\");\n    assert(solution(\"2 1 100\\nuser1:\\n/message\\nuser2:\\n/oh\\n\") == \"1\");\n    assert(solution(\"4 1 1\\nuser1:\\n/oh\\nuser2:\\n/oh\\nuser3:\\n/message\\nuser4:\\n/oh\\n\") == \"3\");\n    assert(solution(\"6 0 0\\n123:\\n/oh\\n456:\\n789:\\n/hsh\\n101112:\\n\") == \"0\");\n    assert(solution(\"1 1 1\\nabcd:\\n\") == \"0\");\n    assert(solution(\"6 0 0\\nmsg1:\\n/foo\\nmsg2:\\nmsg3:\\n/oh\\nmsg4:\\n/hsh\\n\") == \"0\");\n    assert(solution(\"3 10 2\\nmsg1:\\nmsg2:\\nmsg3:\\n\") == \"0\");\n    assert(solution(\"2 5 20\\nabc:\\ndef:\\n\") == \"0\");\n    assert(solution(\"1 0 0\\nabcd:\\n\") == \"0\");\n    assert(solution(\"9 5 10\\nmsg1:\\nmsg2:\\nmsg3:\\nmsg4:\\nmsg5:\\n\") == \"0\");\n    assert(solution(\"7 4 6\\nhello:\\nworld:\\nmsg1:\\nfoo:\\nbar:\\n\") == \"0\");\n    assert(solution(\"6 0 0\\nmsg1:\\nmsg2:\\nmsg3:\\nmsg4:\\n\") == \"0\");\n    assert(solution(\"5 2 1\\nabc:\\ndef:\\nghi:\\njkl:\\n\") == \"0\");\n    assert(solution(\"0 1 2\\n\") == \"0\");\n    assert(solution(\"1 10 20\\nuser1:\\n/oh\\n\") == \"10\");\n    assert(solution(\"3 100 200\\nuser1:\\nNOI2023\\nuser2:\\n/invalid_emoji\\nuser3:\\n/hsh\\n\") == \"200\");\n    assert(solution(\"2 1 1\\nuser1:\\n/hsh\\nuser2:\\n/hsh\\n\") == \"2\");\n    assert(solution(\"3 10 20\\nuser1:\\n/hsh\\nuser2:\\n/hsh\\nuser3:\\n/hsh\\n\") == \"60\");\n    assert(solution(\"5 1 1\\nuser1:\\nwop\\nuser2:\\nwop\\nuser3:\\nwop\\nuser4:\\na\\nuser5:\\nb\\n\") == \"0\");\n    assert(solution(\"1 100 200\\nuser1:\\n/invalid_emoji\\n\") == \"0\");\n    assert(solution(\"2 1 1\\nuser1:\\n/different_emoji\\nuser2:\\n/hsh\\n\") == \"1\");\n    assert(solution(\"2 1 1\\nuser1:\\n/hsh\\nuser2:\\n/invalid_emoji\\n\") == \"1\");\n    assert(solution(\"3 10 20\\nuser1:\\nhsh\\nuser2:\\nhsh\\nuser3:\\nhsh\\n\") == \"0\");\n    assert(solution(\"5 1 1\\nuser1:\\na\\nuser2:\\nb\\nuser3:\\n/hsh\\nuser4:\\na\\nuser5:\\nb\\n\") == \"1\");\n    return 0; \n}", "prompt": "/*You are given $n$ pieces of information, which can be of three types (note that $\\texttt<\\textit{str}\\texttt>$ represents a string called $str$, **which does not contain spaces, colons, and slashes**):\n\n1. In the form of $\\texttt<\\textit{str}\\texttt{>:}$, which means that the next line contains a message from the user named $str$.\n2. In the form of $\\texttt{/<}str\\texttt>$, which represents an **emoji message** named $str$.\n3. In the form of $\\texttt<\\textit{str}\\texttt>$, which represents a text message with content $str$.\n\nAfter careful observation, you found that emoji messages named $\\texttt{oh}$ and $\\texttt{hsh}$ have a special meaning.\n\nDuring a conversation:\n\n- An $\\texttt{oh}$ emoji message increases the craziness value by $a$.\n- An $\\texttt{hsh}$ emoji message increases the craziness value by $b$.\n- **Any other information will not affect the craziness value, which is initially $0$.**\n\nNow, you need to calculate the total craziness value for these messages.\n\ninput_format:\nThe first line has three integers $n,a,b$, indicating a total of $n$information, $a,b$meaning as described.\n\nNext $2\\times n$lines, describing each piece of information:\n\n- The first line is Type 1 information.\n- The second line is Category 2 ** or ** Category 3 information.\n\noutput_format:\nOnly one row of integers, that is, the total magic value.\n*/\n\n#include<sstream>\n#include<stdlib.h>\n#include<algorithm>\n#include<math.h>\n#include<stdio.h>\n#include<vector>\n#include<string>\n#include<climits>\n#include<cstring>\n#include<iostream>\nusing namespace std;\n\n             \nstring solution(string std_in){\n    istringstream iss(std_in);\n             ", "constraints": "#### 样例 1 说明\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/mbfgnv8i.png)\n\n如图所示。\n\n#### 数据规模与约定\n\n**本题采用捆绑测试。**\n\n记 $l$ 表示输入中单行信息的最大长度。\n\n$$\n\\newcommand{\\arraystretch}{1.5}\n\\begin{array}{c|c|c|c}\\hline\\hline\n\\textbf{Subtask} & \\bm{n\\le} & \\textbf{特殊性质} & \\textbf{分值} \\\\\\hline\n\\textsf{1} & \\le 10 & - & 20 \\\\\\hline\n\\textsf{2} & \\le 100 & - & 20 \\\\\\hline\n\\textsf{3} & \\text{无特殊限制} & \\text A & 20 \\\\\\hline\n\\textsf{4} & \\text{无特殊限制} & - & 40 \\\\\\hline\\hline\n\\end{array}\n$$\n\n- 特殊性质 $\\text{A}$：输入不含有第 3 类信息。\n\n对于 $100\\%$ 的数据，有 $1\\le n\\le 10^4$，$1\\le l\\le 50$，$1\\le a,b\\le 10^3$。", "samples": [["7 1 2020\nwop:\n/yueliang\neoq:\nwop_loushang\nwop:\neoq_npy_when\neoq:\n/oh\ndek:\n/oh\nrif:\nNOI2022_rp_++\nrif:\n/hsh", "2022"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072]}}
{"task_id": "P1030", "title": "[NOIP2001 普及组] 求先序排列", "difficulty": "challenge", "nl": "Given the inorder and postorder traversal of a binary tree, find its preorder traversal. (Assume each node of the tree is represented by a distinct uppercase letter, and the number of nodes in the binary tree is ≤ 8.)", "code": "#include<cstdio>\n#include<iostream>\n#include<cstring>\nusing namespace std;\nvoid beford(string in,string after){\n    if (in.size()>0){\n        char ch=after[after.size()-1];\n        cout<<ch;//找根输出\n        int k=in.find(ch);\n        beford(in.substr(0,k),after.substr(0,k));\n        beford(in.substr(k+1),after.substr(k,in.size()-k-1));//递归左右子树；\n    }\n}\nint main(){\n    string inord,aftord;\n    cin>>inord;cin>>aftord;//读入\n    beford(inord,aftord);cout<<endl;\n    return 0;\n}", "step": ["Define a recursive function \"beford\" that takes Inorder and Postorder traversals of a binary tree as input.", "If the size of Inorder traversal is greater than zero, find the last element of the Postorder traversal and print it.", "Find the index of the last element in the Inorder traversal and divide the Inorder and Postorder traversals into two parts.", "Recursively call \"beford\" function on the divided parts by passing the substrings as input.", "Print the Preorder traversal of the binary tree by calling the \"beford\" function with the Inorder and Postorder traversals as input in the main function.", "Return 0."], "nl_cn": "给出一棵二叉树的中序与后序排列。求出它的先序排列。（约定树结点用不同的大写字母表示，且二叉树的节点个数 $ \\le 8$）。\n", "test_cases": [{"input": "BADC\nBDCA\n", "output": "ABCD"}, {"input": "AB\nBA\n", "output": "AB"}, {"input": "A\nA\n", "output": "A"}, {"input": "NOP\nNPO\n", "output": "ONP"}, {"input": "WX\nXW\n", "output": "WX"}, {"input": "E\nE\n", "output": "E"}, {"input": "CG\nGC\n", "output": "CG"}, {"input": "MAD\nMDA\n", "output": "AMD"}, {"input": "H\nH\n", "output": "H"}, {"input": "Z\nZ\n", "output": "Z"}, {"input": "ABCD\nABCD\n", "output": "DCBA"}], "test": "#undef NDEBUG\n#include<assert.h>\nint main(){\n    assert(solution(\"BADC\\nBDCA\\n\") == \"ABCD\");\n    assert(solution(\"AB\\nBA\\n\") == \"AB\");\n    assert(solution(\"A\\nA\\n\") == \"A\");\n    assert(solution(\"NOP\\nNPO\\n\") == \"ONP\");\n    assert(solution(\"WX\\nXW\\n\") == \"WX\");\n    assert(solution(\"E\\nE\\n\") == \"E\");\n    assert(solution(\"CG\\nGC\\n\") == \"CG\");\n    assert(solution(\"MAD\\nMDA\\n\") == \"AMD\");\n    assert(solution(\"H\\nH\\n\") == \"H\");\n    assert(solution(\"Z\\nZ\\n\") == \"Z\");\n    assert(solution(\"ABCD\\nABCD\\n\") == \"DCBA\");\n    return 0; \n}", "prompt": "/*Given the inorder and postorder traversal of a binary tree, find its preorder traversal. (Assume each node of the tree is represented by a distinct uppercase letter, and the number of nodes in the binary tree is ≤ 8.)\n\ninput_format:\nThere are two lines, both composed of uppercase letters, representing the inorder and postorder traversal of a binary tree.\n\noutput_format:\nA string in a row represents the first order of a binary tree.\n*/\n\n#include<sstream>\n#include<stdlib.h>\n#include<algorithm>\n#include<math.h>\n#include<stdio.h>\n#include<vector>\n#include<string>\n#include<climits>\n#include<cstring>\n#include<iostream>\nusing namespace std;\n\n             \nstring solution(string std_in){\n    istringstream iss(std_in);\n             ", "constraints": "**【题目来源】**\n\nNOIP 2001 普及组第三题", "samples": [["BADC\nBDCA\n", "ABCD\n"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000]}}
{"task_id": "P9022", "title": "[CCC2021 J3] Secret Instructions", "difficulty": "basic", "nl": "Multiple test cases. \n\nFor each test case, read in 5 digit characters. \n\n- If the sum of the first two digits is odd, output `left`.\n- If the sum of the first two digits is an even non-zero number, output `right`.\n- If the sum of the first two digits is zero, output `left` or `right` depending on the previous test case.\n\nThen output a space and the last three digit characters.", "code": "// Author: zhang_kevin\n// Problem Name: P9022 [CCC2021 J3] Secret Instructions\n// URL: https://www.luogu.com.cn/problem/P9022\n// Memory Limit: 128 MB\n// Time Limit: 500000 ms\n// Created: 2023-02-05 13:44:54\n\n#include<bits/stdc++.h>\nusing namespace std;\nint main(){\n\tstring ans = \"\";\n\tchar c1, c2, c3, c4, c5;\n\tcin >> c1 >> c2 >> c3 >> c4 >> c5;\n\tif((c1+c2) & 1) ans = \"left\";\n\telse ans = \"right\";\n\twhile(c1 + c2 + c3 + c4 + c5 - 5 * '0' != 45){\n\t\tif((c1-'0'+c2-'0') & 1){\n\t\t\tans = \"left\";\n\t\t\tcout << ans << \" \" << c3 << c4 << c5 << endl;\n\t\t}else if(c1 - '0' + c2 - '0' != 0){\n\t\t\tans = \"right\";\n\t\t\tcout << ans << \" \" << c3 << c4 << c5 << endl;\n\t\t}else{\n\t\t\tcout << ans << \" \" << c3 << c4 << c5 << endl;\n\t\t}\n\t\tcin >> c1 >> c2 >> c3 >> c4 >> c5;\n\t}\n\treturn 0;\n}", "step": ["Initialize ans to an empty string and input 5 characters.", "Check if the sum of the first two characters is odd or even and output left or right accordingly.", "Input 5 more characters and check if their sum equals 45.", "If the sum is not 45, check if the sum of the first two characters of the new input is odd or even and output left or right accordingly.", "If the sum of the first two characters is 0, output ans.", "Repeat steps 3-5 until the sum of the input characters is equal to 45 and return 0."], "nl_cn": "多组数据。\n\n对于每组数据读入 $5$ 个数字字符。\n\n- 如果前两个之和为奇数，输出 `left`；\n- 如果前两个之和为非零偶数，输出 `right`；\n- 如果前两个之和为零，输出 `left` 或 `right` 取决于上组数据。\n\n然后输出一个空格与后三个数字字符。", "test_cases": [{"input": "57234\n00907\n34100\n99999\n", "output": "right 234\nright 907\nleft 100"}], "test": "#undef NDEBUG\n#include<assert.h>\nint main(){\n    assert(solution(\"57234\\n00907\\n34100\\n99999\\n\") == \"right 234\\nright 907\\nleft 100\");\n    return 0; \n}", "prompt": "/*Multiple test cases. \n\nFor each test case, read in 5 digit characters. \n\n- If the sum of the first two digits is odd, output `left`.\n- If the sum of the first two digits is an even non-zero number, output `right`.\n- If the sum of the first two digits is zero, output `left` or `right` depending on the previous test case.\n\nThen output a space and the last three digit characters.\n\ninput_format:\nMultiple sets of data.\n\n$5 numeric characters per line.\n\nRead until '99999'.\n\noutput_format:\nOne string per line with $3 numeric characters, separated by Spaces.\n*/\n\n#include<sstream>\n#include<stdlib.h>\n#include<algorithm>\n#include<math.h>\n#include<stdio.h>\n#include<vector>\n#include<string>\n#include<climits>\n#include<cstring>\n#include<iostream>\nusing namespace std;\n\n             \nstring solution(string std_in){\n    istringstream iss(std_in);\n             ", "constraints": "读入的第三个字符不会为 $0$。\n\n第一组数据不会以 $00$ 开头。\n\n译自 [CCC2021 J3](https://cemc.math.uwaterloo.ca/contests/computing/past_ccc_contests/2021/ccc/juniorEF.pdf)。", "samples": [["57234\n00907\n34100\n99999\n", "right 234\nright 907\nleft 100\n"]], "limits": {"time": [500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500, 500], "memory": [131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072]}}
{"task_id": "P8682", "title": "[蓝桥杯 2019 省 B] 等差数列", "difficulty": "challenge", "nl": "The math teacher gave Xiao Ming a problem of finding the sum of an arithmetic sequence. However, careless Xiao Ming forgot some of the numbers in the sequence and only remembered N integers. Now given these N integers, Xiao Ming wants to know how many terms are there in the shortest arithmetic sequence that contains these N integers.", "code": "#include<bits/stdc++.h>\nusing namespace std;\n\nint n;\nint a[100005];\nint d;\n\nint main(){\n\tcin >> n;\n\tfor(int i = 1; i <= n; i++){\n\t\tcin >> a[i];\n\t}\n\tsort(a+1, a+n+1);//题目明确说了“不一定按顺序给出”，所以要先排序\n\td = a[2]-a[1];\n\tif(d == 0){//如果d=0，那么说明所有的数都相等，最小个数肯定就是n \n\t\tcout << n;\n\t\treturn 0;\n\t}\n\tfor(int i = 2; i <= n-1; i++){\n\t\td = __gcd(d, a[i+1]-a[i]);//求所有差的最大公约数 \n\t}\n\tcout << (a[n]-a[1])/d+1;//算出项数，输出 \n\treturn 0;\n}", "step": ["Take input the size of the series.", "Take input the elements of the series.", "Sort the series.", "Find the GCD of the difference between adjacent elements.", "Calculate the number of integers in the series using the GCD.", "Print the result."], "nl_cn": "数学老师给小明出了一道等差数列求和的题目。但是粗心的小明忘记了一部分的数列，只记得其中 $N$ 个整数。\n\n现在给出这 $N$ 个整数，小明想知道包含这 $N$ 个整数的最短的等差数列有几项？", "test_cases": [{"input": "5\n2 6 4 10 20", "output": "10"}, {"input": "3\n1 2 3\n", "output": "3"}, {"input": "4\n1 3 5 7\n", "output": "4"}, {"input": "2\n10 20\n", "output": "2"}, {"input": "1\n100\n", "output": "1"}, {"input": "7\n-10 -8 -6 -4 -2 0 2\n", "output": "7"}, {"input": "10\n-1 0 1 2 3 4 5 6 7 8\n", "output": "10"}, {"input": "3\n-100 -200 -300\n", "output": "3"}, {"input": "6\n-2 -1 0 1 2 3\n", "output": "6"}, {"input": "2\n-10 -20\n", "output": "2"}, {"input": "5\n100 200 300 400 500\n", "output": "5"}, {"input": "1\n0\n", "output": "1"}, {"input": "3\n1 3 5\n", "output": "3"}, {"input": "4\n10 20 30 40\n", "output": "4"}, {"input": "5\n-100 -200 -300 -400 -500\n", "output": "5"}, {"input": "4\n7 14 21 28", "output": "4"}, {"input": "6\n-5 -10 -15 -20 -25 -30", "output": "6"}, {"input": "7\n3 10 17 24 31 38 45", "output": "7"}, {"input": "8\n2 8 14 20 26 32 38 44", "output": "8"}, {"input": "6\n-2 -4 -6 -8 -10 -12", "output": "6"}, {"input": "3\n2 4 6", "output": "3"}, {"input": "6\n-3 -6 -9 -12 -15 -18", "output": "6"}, {"input": "7\n4 12 20 28 36 44 52", "output": "7"}, {"input": "8\n3 11 19 27 35 43 51 59", "output": "8"}, {"input": "4\n3 6 9 12", "output": "4"}, {"input": "5\n1 5 9 13 17", "output": "5"}, {"input": "6\n-1 -3 -5 -7 -9 -11", "output": "6"}, {"input": "5\n5 10 15 20 25\n", "output": "5"}, {"input": "4\n1 4 7 10\n", "output": "4"}, {"input": "3\n-5 -10 -15\n", "output": "3"}, {"input": "2\n5 5\n", "output": "2"}, {"input": "1\n1234\n", "output": "1"}, {"input": "8\n100 200 300 400 500 600 700 800\n", "output": "8"}, {"input": "6\n-1 -2 -3 -4 -5 -6\n", "output": "6"}, {"input": "3\n-10 -20 -30\n", "output": "3"}, {"input": "2\n0 0\n", "output": "2"}, {"input": "1\n5\n", "output": "1"}, {"input": "7\n12 24 36 48 60 72 84\n", "output": "7"}, {"input": "8\n1 4 7 10 13 16 19 22\n", "output": "8"}, {"input": "5\n-1 -2 -3 -4 -5\n", "output": "5"}, {"input": "3\n1 2 2\n", "output": "2"}, {"input": "6\n1 2 3 4 5 6\n", "output": "6"}, {"input": "9\n1 3 5 7 9 11 13 15 17\n", "output": "9"}, {"input": "5\n10 20 30 40 50\n", "output": "5"}, {"input": "4\n-5 -10 -15 -20\n", "output": "4"}, {"input": "3\n15 10 5\n", "output": "3"}, {"input": "4\n-4 -2 2 4\n", "output": "5"}, {"input": "7\n-2 4 10 16 22 28 34\n", "output": "7"}, {"input": "4\n1 2 3 4\n", "output": "4"}, {"input": "7\n10 20 30 50 60 70 80\n", "output": "8"}, {"input": "5\n20 60 100 140 180\n", "output": "5"}, {"input": "3\n5 7 9\n", "output": "3"}, {"input": "4\n2 4 6 8\n", "output": "4"}, {"input": "3\n-1 0 1\n", "output": "3"}], "test": "#undef NDEBUG\n#include<assert.h>\nint main(){\n    assert(solution(\"5\\n2 6 4 10 20\") == \"10\");\n    assert(solution(\"3\\n1 2 3\\n\") == \"3\");\n    assert(solution(\"4\\n1 3 5 7\\n\") == \"4\");\n    assert(solution(\"2\\n10 20\\n\") == \"2\");\n    assert(solution(\"1\\n100\\n\") == \"1\");\n    assert(solution(\"7\\n-10 -8 -6 -4 -2 0 2\\n\") == \"7\");\n    assert(solution(\"10\\n-1 0 1 2 3 4 5 6 7 8\\n\") == \"10\");\n    assert(solution(\"3\\n-100 -200 -300\\n\") == \"3\");\n    assert(solution(\"6\\n-2 -1 0 1 2 3\\n\") == \"6\");\n    assert(solution(\"2\\n-10 -20\\n\") == \"2\");\n    assert(solution(\"5\\n100 200 300 400 500\\n\") == \"5\");\n    assert(solution(\"1\\n0\\n\") == \"1\");\n    assert(solution(\"3\\n1 3 5\\n\") == \"3\");\n    assert(solution(\"4\\n10 20 30 40\\n\") == \"4\");\n    assert(solution(\"5\\n-100 -200 -300 -400 -500\\n\") == \"5\");\n    assert(solution(\"4\\n7 14 21 28\") == \"4\");\n    assert(solution(\"6\\n-5 -10 -15 -20 -25 -30\") == \"6\");\n    assert(solution(\"7\\n3 10 17 24 31 38 45\") == \"7\");\n    assert(solution(\"8\\n2 8 14 20 26 32 38 44\") == \"8\");\n    assert(solution(\"6\\n-2 -4 -6 -8 -10 -12\") == \"6\");\n    assert(solution(\"3\\n2 4 6\") == \"3\");\n    assert(solution(\"6\\n-3 -6 -9 -12 -15 -18\") == \"6\");\n    assert(solution(\"7\\n4 12 20 28 36 44 52\") == \"7\");\n    assert(solution(\"8\\n3 11 19 27 35 43 51 59\") == \"8\");\n    assert(solution(\"4\\n3 6 9 12\") == \"4\");\n    assert(solution(\"5\\n1 5 9 13 17\") == \"5\");\n    assert(solution(\"6\\n-1 -3 -5 -7 -9 -11\") == \"6\");\n    assert(solution(\"5\\n5 10 15 20 25\\n\") == \"5\");\n    assert(solution(\"4\\n1 4 7 10\\n\") == \"4\");\n    assert(solution(\"3\\n-5 -10 -15\\n\") == \"3\");\n    assert(solution(\"2\\n5 5\\n\") == \"2\");\n    assert(solution(\"1\\n1234\\n\") == \"1\");\n    assert(solution(\"8\\n100 200 300 400 500 600 700 800\\n\") == \"8\");\n    assert(solution(\"6\\n-1 -2 -3 -4 -5 -6\\n\") == \"6\");\n    assert(solution(\"3\\n-10 -20 -30\\n\") == \"3\");\n    assert(solution(\"2\\n0 0\\n\") == \"2\");\n    assert(solution(\"1\\n5\\n\") == \"1\");\n    assert(solution(\"7\\n12 24 36 48 60 72 84\\n\") == \"7\");\n    assert(solution(\"8\\n1 4 7 10 13 16 19 22\\n\") == \"8\");\n    assert(solution(\"5\\n-1 -2 -3 -4 -5\\n\") == \"5\");\n    assert(solution(\"3\\n1 2 2\\n\") == \"2\");\n    assert(solution(\"6\\n1 2 3 4 5 6\\n\") == \"6\");\n    assert(solution(\"9\\n1 3 5 7 9 11 13 15 17\\n\") == \"9\");\n    assert(solution(\"5\\n10 20 30 40 50\\n\") == \"5\");\n    assert(solution(\"4\\n-5 -10 -15 -20\\n\") == \"4\");\n    assert(solution(\"3\\n15 10 5\\n\") == \"3\");\n    assert(solution(\"4\\n-4 -2 2 4\\n\") == \"5\");\n    assert(solution(\"7\\n-2 4 10 16 22 28 34\\n\") == \"7\");\n    assert(solution(\"4\\n1 2 3 4\\n\") == \"4\");\n    assert(solution(\"7\\n10 20 30 50 60 70 80\\n\") == \"8\");\n    assert(solution(\"5\\n20 60 100 140 180\\n\") == \"5\");\n    assert(solution(\"3\\n5 7 9\\n\") == \"3\");\n    assert(solution(\"4\\n2 4 6 8\\n\") == \"4\");\n    assert(solution(\"3\\n-1 0 1\\n\") == \"3\");\n    return 0; \n}", "prompt": "/*The math teacher gave Xiao Ming a problem of finding the sum of an arithmetic sequence. However, careless Xiao Ming forgot some of the numbers in the sequence and only remembered N integers. Now given these N integers, Xiao Ming wants to know how many terms are there in the shortest arithmetic sequence that contains these N integers.\n\ninput_format:\nThe first line of input contains an integer $N$.\n\nThe second row contains $N$integers $A_1,A_2,\\cdots,A_N$. (Note that $A_1 to A_N$is not necessarily given in the order in the arithmetic sequence).\n\noutput_format:\nOutput an integer representing the answer.\n*/\n\n#include<sstream>\n#include<stdlib.h>\n#include<algorithm>\n#include<math.h>\n#include<stdio.h>\n#include<vector>\n#include<string>\n#include<climits>\n#include<cstring>\n#include<iostream>\nusing namespace std;\n\n             \nstring solution(string std_in){\n    istringstream iss(std_in);\n             ", "constraints": "包含 `2,6,4,10,20` 的最短的等差数列是 `2,4,6,8,10,12,14,16,18,20`。\n\n对于所有评测用例，$2 \\le N \\le 10^5$，$0 \\le A_i \\le 10^9$。\n\n蓝桥杯 2019 年省赛 B 组 H 题。", "samples": [["5\n2 6 4 10 20", "10"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144]}}
{"task_id": "P6057", "title": "[加油武汉]七步洗手法", "difficulty": "advanced", "nl": "Given an undirected complete graph with $n$ vertices, where $m$ edges are white and the rest are black. \n\nYou are required to find the number of same-colored triangles (or, three-cycles).", "code": "#include<cstdio>\n#define reg register\n#define MAXN 100001\nusing namespace std;\n\ntypedef long long ll;\n\nint deg[MAXN];\nll ans=0;\nint n,m;\n\nint main()\n{\n    scanf(\"%d %d\",&n,&m);\n    for(reg int i=1;i<=m;i++)\n    {\n        int u,v;\n        scanf(\"%d %d\",&u,&v);\n        ++deg[u],++deg[v];\n    }\n    for(reg int i=1;i<=n;i++)\n        ans+=(1ll*deg[i]*(n-1-deg[i]));\n    printf(\"%lld\",1ll*n*(n-1)*(n-2)/6-(ans>>1));\n    return(0);\n}", "step": ["Read input for the number of vertices and edges.", "Loop through all the edges and increment degree of each vertex involved.", "Calculate the number of triplets that form triangles in the graph using a formula.", "Divide the total triplet count by two to avoid counting each triangle twice.", "Subtract the number of triangles from the total count to get the final result.", "Print the final result."], "nl_cn": "给定一张含有 $n$ 个点的无向完全图，其中 $m$ 条边是白边，其余是黑边。\n\n现在需要你求出同色的三元环（或者说，三角形）的个数。", "test_cases": [{"input": "5 3\n1 5\n2 5\n3 5", "output": "4"}, {"input": "5 0\n", "output": "10"}, {"input": "3 3\n1 2\n2 3\n3 1\n", "output": "1"}, {"input": "4 0\n", "output": "4"}, {"input": "2 1\n1 2\n", "output": "0"}, {"input": "4 6\n1 2\n1 3\n1 4\n2 3\n2 4\n3 4\n", "output": "4"}, {"input": "3 1\n1 2\n", "output": "0"}], "test": "#undef NDEBUG\n#include<assert.h>\nint main(){\n    assert(solution(\"5 3\\n1 5\\n2 5\\n3 5\") == \"4\");\n    assert(solution(\"5 0\\n\") == \"10\");\n    assert(solution(\"3 3\\n1 2\\n2 3\\n3 1\\n\") == \"1\");\n    assert(solution(\"4 0\\n\") == \"4\");\n    assert(solution(\"2 1\\n1 2\\n\") == \"0\");\n    assert(solution(\"4 6\\n1 2\\n1 3\\n1 4\\n2 3\\n2 4\\n3 4\\n\") == \"4\");\n    assert(solution(\"3 1\\n1 2\\n\") == \"0\");\n    return 0; \n}", "prompt": "/*Given an undirected complete graph with $n$ vertices, where $m$ edges are white and the rest are black. \n\nYou are required to find the number of same-colored triangles (or, three-cycles).\n\ninput_format:\nThe first row of integers $n,m$, meaning as the question.\n\nThe remaining $m$rows each have two integers $u,v$, representing the two endpoints of the white edge. Ensure that the given white edge has no heavy edges and self-loops.\n\noutput_format:\nA line with an integer is the answer.\n*/\n\n#include<sstream>\n#include<stdlib.h>\n#include<algorithm>\n#include<math.h>\n#include<stdio.h>\n#include<vector>\n#include<string>\n#include<climits>\n#include<cstring>\n#include<iostream>\nusing namespace std;\n\n             \nstring solution(string std_in){\n    istringstream iss(std_in);\n             ", "constraints": " - 对于 $20\\%$ 的数据，满足 $n \\leq 200$；\n - 对于 $50\\%$ 的数据，满足 $n \\leq 2000$；\n - 对于 $100\\%$ 的数据，满足 $1 \\leq n \\leq 10^5,1 \\leq m \\leq 3\\times 10^5$。", "samples": [["5 3\n1 5\n2 5\n3 5", "4"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}}
{"task_id": "P8901", "title": "[USACO22DEC] Circular Barn S", "difficulty": "advanced", "nl": "Farmer John and his archenemy Farmer Nhoj are playing a game in a circular cow barn. The barn has N (1 ≤ N ≤ 10^5) rooms, with the i-th room initially containing a_i cows (1 ≤ a_i ≤ 5 × 10^6). The game is played as follows:\n\n- The two farmers will always be in the same room. After entering a room, each farmer takes one action, with Farmer John going first. The two farmers start in room 1.\n- If the number of cows in the current room is zero, the farmer taking the action at this point loses. Otherwise, the farmer taking the action selects an integer P, where P is 1 or a prime no larger than the current number of cows in the room, and removes P cows from the current room.\n- After both farmers have taken their actions, they move to the next room in the circular barn. That is, if the farmers are in room i, they move to room i+1, unless they are in room N, in which case they wrap around to room 1.\n\nDetermine the winning farmer when both farmers use optimal strategies.", "code": "#include <iostream>\nusing namespace std;\nconst int N=5e6+5;\nbool isprime[N];\nint prime[N];\nint n,cnt;\nint s[4];//统计格式为4k+1,4k+2,4k+3的最大质数\nint ans[N];\nint t;\nvoid euler()//欧拉筛\n{\n    int i,j;\n    isprime[1]=true;\n    ans[1]=1;\n    s[1]=1;\n    for(i=2; i<=N; i++)\n    {\n        if(!isprime[i])\n        {\n            prime[++cnt]=i;\n            if(i%4!=0)\n                s[i%4]=i;//更新最大质数数组\n        }\n        for(j=1; j<=cnt && i*prime[j]<=N; j++)\n        {\n            isprime[i*prime[j]]=true;\n            if(i%prime[j]==0)\n                break;\n        }\n        if(i%4==0)\n            ans[i]=i/4+1;//套公式\n        else\n            ans[i]=(i-s[i%4])/4+1;//套公式\n    }\n}\nint main()\n{\n    int i;\n    euler();\n    cin>>t;\n    while(t--)\n    {\n        cin>>n;\n        int minx1=1e9,mark1;\n        int minx2=1e9,mark2;\n        for(i=1; i<=n; i++)//不多解释了，作者的代码很烂，不一定要学习我的，自己写也行\n        {\n            int temp;\n            cin>>temp;\n            if(temp%4==0)\n            {\n                if(minx2>ans[temp])\n                {\n                    minx2=ans[temp];\n                    mark2=i;\n                }\n            }\n            else\n            {\n                if(minx1>ans[temp])\n                {\n                    minx1=ans[temp];\n                    mark1=i;\n                }\n            }\n        }\n        if(minx1<minx2)\n            cout<<\"Farmer John\"<<endl;\n        else if(minx1>minx2)\n            cout<<\"Farmer Nhoj\"<<endl;\n        else\n        {\n            if(mark1<mark2)\n                cout<<\"Farmer John\"<<endl;\n            else\n                cout<<\"Farmer Nhoj\"<<endl;\n        }\n    }\n    return 0;\n}", "step": ["Initialize an array b with zeros and check all of its multiples for primes or not. This is done to determine which numbers in the given set are prime.", "Flip the bits of array b to find all desired primes for the given problem.", "Determine which numbers belong to 'Farmer John' and which belong to 'Farmer Nhoj' while keeping track of the lowest possible score for each player.", "Compare the scores. The player with the lowest score wins. If both scores are the same, compare the index of each player's last move to determine the winner.", "Continue the process if the input has more test cases."], "nl_cn": "Farmer John 和他的死对头 Farmer Nhoj 在一个环形牛棚内玩游戏。牛棚内有 $N(1 \\le N \\le 10^5)$ 个房间，第 $i$ 个房间初始时内有 $a_i$ 头奶牛 $(1 \\le a_i \\le 5 \\times 10^6)$。游戏玩法如下：\n\n- 两位农夫将总是在同一个房间里。进入一个房间后，每位农夫各执行一次行动，Farmer John 在先。两位农夫在游戏开始时进入房间 $1$。\n- 如果当前房间中的奶牛数量为零，则此时执行行动的农夫即失败。否则，执行行动的农夫选择一个整数 $P$，其中 $P$ 为 $1$ 或一个不超过当前房间中奶牛的数量的质数，并从当前房间中移除 $P$ 头奶牛。\n- 两位农夫均完成行动之后，两位农夫移动到环形牛棚的下一间房间。也就是说，如果农夫们在房间 $i$，那么他们会移动到房间 $i+1$，除非他们在房间 $N$，在这种情况下他们会移动到房间 $1$。\n\n当两位农夫均采用最优策略时，求获胜的农夫。 ", "test_cases": [{"input": "5\n1\n4\n1\n9\n2\n2 3\n2\n7 10\n3\n4 9 4", "output": "Farmer Nhoj\nFarmer John\nFarmer John\nFarmer John\nFarmer Nhoj"}, {"input": "3\n9\n3\n10\n1", "output": "Farmer John\nFarmer John\nFarmer John"}, {"input": "2\n5\n8", "output": "Farmer Nhoj\nFarmer Nhoj"}, {"input": "5\n1\n1\n1\n1\n1", "output": "Farmer John\nFarmer John\nFarmer John\nFarmer John\nFarmer John"}, {"input": "2\n10\n7", "output": "Farmer John\nFarmer John"}], "test": "#undef NDEBUG\n#include<assert.h>\nint main(){\n    assert(solution(\"5\\n1\\n4\\n1\\n9\\n2\\n2 3\\n2\\n7 10\\n3\\n4 9 4\") == \"Farmer Nhoj\\nFarmer John\\nFarmer John\\nFarmer John\\nFarmer Nhoj\");\n    assert(solution(\"3\\n9\\n3\\n10\\n1\") == \"Farmer John\\nFarmer John\\nFarmer John\");\n    assert(solution(\"2\\n5\\n8\") == \"Farmer Nhoj\\nFarmer Nhoj\");\n    assert(solution(\"5\\n1\\n1\\n1\\n1\\n1\") == \"Farmer John\\nFarmer John\\nFarmer John\\nFarmer John\\nFarmer John\");\n    assert(solution(\"2\\n10\\n7\") == \"Farmer John\\nFarmer John\");\n    return 0; \n}", "prompt": "/*Farmer John and his archenemy Farmer Nhoj are playing a game in a circular cow barn. The barn has N (1 ≤ N ≤ 10^5) rooms, with the i-th room initially containing a_i cows (1 ≤ a_i ≤ 5 × 10^6). The game is played as follows:\n\n- The two farmers will always be in the same room. After entering a room, each farmer takes one action, with Farmer John going first. The two farmers start in room 1.\n- If the number of cows in the current room is zero, the farmer taking the action at this point loses. Otherwise, the farmer taking the action selects an integer P, where P is 1 or a prime no larger than the current number of cows in the room, and removes P cows from the current room.\n- After both farmers have taken their actions, they move to the next room in the circular barn. That is, if the farmers are in room i, they move to room i+1, unless they are in room N, in which case they wrap around to room 1.\n\nDetermine the winning farmer when both farmers use optimal strategies.\n\ninput_format:\nThe input contains $T$subtest cases. The first line of input contains $T(1 \\le T \\le 1000)$. Below is the $T$subtest case.\n\nThe first line of each subtest case contains $N$, and the second line contains $a_1, \\cdots,a_N$.\n\nEnter a guarantee that the sum of all $N$does not exceed $2 \\times 10^5$.\n\noutput_format:\nFor each subtest case, output the winning Farmer, one of 'Farmer John' or 'Farmer Nhoj'.\n*/\n\n#include<sstream>\n#include<stdlib.h>\n#include<algorithm>\n#include<math.h>\n#include<stdio.h>\n#include<vector>\n#include<string>\n#include<climits>\n#include<cstring>\n#include<iostream>\nusing namespace std;\n\n             \nstring solution(string std_in){\n    istringstream iss(std_in);\n             ", "constraints": "### 样例 1 解释\n\n对于第一个子测试用例，Farmer John 可以从第一个房间中移除 $1$、$2$ 或 $3$ 头奶牛。无论他移除多少头奶牛，Nhoj 都可以移除剩余的奶牛，迫使 FJ 在他们绕回第一个房间时失败。\n\n对于第二个子测试用例，FJ 可以移除 $5$ 头奶牛，迫使 Nhoj 面对剩下的 $4$ 头奶牛。现在，Nhoj 可以移除 $1$、$2$ 或 $3$ 奶牛。现在的情况类似于第一个子测试用例。\n\n对于第三个和第四个子测试用例，FJ 可以立即移除第一个房间的所有奶牛，使 Nhoj 失败。\n\n对于第五个子测试用例，FJ 可以从第一个房间中移除 $1$\n、$2$ 或 $3$ 奶牛，然后 Nhoj 可以随后移除余下的奶牛。当他们绕回第一个房间时，FJ 将会失败。 \n\n### 测试点性质\n\n- 测试点 $2-4$ 满足 $N=1$。\n- 测试点 $1,2,5-7$ 满足 $a_i \\le 1000$。\n- 测试点 $8-20$ 没有额外限制。", "samples": [["5\n1\n4\n1\n9\n2\n2 3\n2\n7 10\n3\n4 9 4", "Farmer Nhoj\nFarmer John\nFarmer John\nFarmer John\nFarmer Nhoj"]], "limits": {"time": [2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000], "memory": [262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144]}}
{"task_id": "P2373", "title": "yyy2015c01 的 IDE 之 Call Stack", "difficulty": "challenge", "nl": "As a member of the development team, unfortunately yyy2015c01 was selected to be part of the debugger development group.\n\nOne of the components yyy2015c01 envisioned for the debugger is the call stack, which is known as \"调用栈\" in Chinese.\n\nSince the IDE is currently in beta stage, the development team needs to first develop a call stack that can recognize parameter lists to see how it works. This task is assigned to you.\n\nThe call stack envisioned by the development team can recognize \"int\" and \"char\" parameter lists to differentiate between different functions, based on the following rules:\n\n```\nint fac1(int n);\n```\n\nand\n\n```\nint fac1(char n);\n```\n\nare considered as two different functions; however,\n\n```\nint Fac1(int n, int m);\n```\n\nand\n\n```\nint FAC1(int x, int y);\n```\n\nare considered as the same function. In other words, the call stack recognizes not the parameter names, but the type and case-insensitive function names.\n\nNote: int main() may or may not appear, and should not be included in any function.\n\nPlease write a call stack that outputs the total number of incomplete identical functions after all functions in the program have been called at least once.", "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define pb push_back\nstruct fact{\n\tstring na;//函数名 \n\tvector <int> para;//由于不知道参数个数，所以最好用vector存参数类型\n};\nint n;\nvector <fact> ans;//答案\nint strcmp(string a,string b)//判断两个字符串是否相同（因为不会用现成函数，所以只好手写strcmp） \n{\n\tif(a.size()!=b.size())return 0;\n\tfor(int x=0;x<a.size();x++)if(a[x]!=b[x])return 0;\n\treturn 1;\n}\nvector <int> getpara()//获取参数类型的函数\n{\n\tstring p;\n\tint pc=0;//0：数字，1：字符\n\tvector <int> para;//各个所输入参数的类型\n\tgetline(cin,p);//由于有空格，所以需要用getline \n\tfor(int x=0;x<p.size();x++){\n\t\tif(p[x]==','||p[x]==')')para.pb(pc),pc=0;//一个参数结束，将它的类型压入vector\n\t\tif(p[x]==39)pc=1;//如果有单引号，那么这个参数就是字符类型\n\t}\n\treturn para;//返回所有参数类型 \n}\nint main()\n{\n\tcin>>n;\n\tfor(int x=1;x<=n;x++){\n\t\tstring na;//函数名 \n\t\tcin>>na;\n\t\tfor(int y=0;y<na.size();y++)if(na[y]<'a')na[y]+=32;//都转为小写\n\t\tif(strcmp(na,\"main\"))continue;//判断是否是 \"main\" 函数\n\t\tint same=1;//same：是否重复\n\t\tvector <int> para=getpara();//获取参数类型\n\t\tfor(int y=0;y<ans.size();y++){//和已有答案去重\n\t\t\tfact cmp=ans[y];\n\t\t\tif(cmp.para.size()!=para.size()||!strcmp(cmp.na,na))same=0;//参数个数不同或函数名不同\n\t\t\telse for(int z=0;z<cmp.para.size();z++)\n\t\t\t\t\tif(cmp.para[z]!=para[z])same=0;//参数类型不同\n\t\t}\n\t\tif(!same||x==1)ans.pb((fact){na,para});//如果不重复或者才调用第一个函数，那就把这个函数压入答案\n\t}\n\tcout<<ans.size();\n\treturn 0;\n}", "step": ["Read in integer n from input", "For each of the n functions:", "Read in the function name as a string", "Convert the function name to lowercase", "Read in the function parameters as a vector of integers using a custom function", "Check if the function is 'main' or if it already exists in the vector with the same name and parameters", "If neither of those are true, add the struct with the function name and parameters to the vector", "Output the size of the vector of structs"], "nl_cn": "作为他开发团队中的一员，你不幸地 yyy2015c01 被选入了 Debugger 的开发组。\n\nyyy2015c01 设想的 Debugger 由几部分组成，其中的一个小组件就是 Call Stack——中文称之为 “调用栈”。\n\n由于 IDE 目前还是内测版，开发组需要先编一个能识别参数表的 Call Stack 来看看效果如何。这个任务交由你来完成。\n\n开发组假想的 Call Stack 能实现识别 `int` 和 `char` 参数表，以辨别出不同的函数，规则是：\n\n```\nint fac1(int n);\n```\n\n和\n\n```\nint fac1(char n);\n```\n\n是两个不同的函数；但\n\n```\nint Fac1(int n,int m);\n```\n\n和\n\n```\nint FAC1(int x,int y);\n```\n\n被认为是相同的函数。也就是说，这个 Call Stack 认的不是参数名，而是其类型和忽略大小写的函数名。\n\n注意：`int main()` 可能会出现，也可能不出现；无论它有没有出现，都不能将其算入函数中。\n\n请你编写一个 Call Stack，并在所有函数调用完后输出这个程序一共有多少个不完全相同的函数（保证程序中的每个函数至少调用一次）。\n", "test_cases": [{"input": "2\nFAC1 (N=233, M=65 'A', A=0)\nmain ()\n", "output": "1"}, {"input": "2\nfac1 (N=250)\nFAC1 (a=987)\n", "output": "1"}, {"input": "1\nfac1 (n=10)\n", "output": "1"}, {"input": "3\nfac1 (n=10)\nfac1 (n=20)\nfac1 (n=30)\n", "output": "1"}, {"input": "3\nfac1 (n=10)\nfac1 (n=10)\nfac1 (n=10)\n", "output": "1"}, {"input": "4\nfac1 (n=10)\nfac1 (n=20)\nfac1 (n=30)\nfac1 (n=10)\n", "output": "1"}, {"input": "3\nfac1 (n=10)\nfac1 (m=20)\nfac1 (n=10)\n", "output": "1"}, {"input": "3\nfac1 (n=10)\nfac1 (m=20)\nfac1 (m=30)\n", "output": "1"}, {"input": "3\nfac1 (n=10)\nfac1 (m=20)\n FAC1 (m=30)\n", "output": "1"}, {"input": "3\nfac1 (n=10)\nfac1 (m=20)\n FAC1 (a=30)\n", "output": "1"}, {"input": "1\nmain ()\n", "output": "0"}, {"input": "2\nmain ()\nmain ()\n", "output": "0"}, {"input": "3\nmain ()\nmain ()\nmain ()\n", "output": "0"}, {"input": "2\nfac1 (n=10)\nmain ()\n", "output": "1"}, {"input": "1\nFAC1 (n=10)\n", "output": "1"}, {"input": "2\nFAC1 (n=10)\nFAC1 (m=20)\n", "output": "1"}, {"input": "3\nfac1 (n=9)\nFac1 (a=5, b=3)\nmain ()\n", "output": "2"}, {"input": "4\nfac1 (n=3)\nFac1 (x=2, y=1)\nfac1 (N=2)\nmain ()\n", "output": "3"}, {"input": "5\nFAC1 (N=1, M=1)\nFAC1 (x=2, y=2)\nfac1 (n=2)\nfac1 (N=3)\nmain ()\n", "output": "3"}, {"input": "6\nfac1 (n=4)\nFAC1 (x=3, y=2)\nfac1 (N=7)\nFac1 (a=9, b=6)\nFAC1 (N=5, M=5)\nmain ()\n", "output": "5"}, {"input": "7\nfac1 (n=7)\nFac1 (a=2, b=4)\nFac1 (c=8, d=3)\nFAC1 (N=1)\nFAC1 (x=6, y=6)\nfac1 (N=2)\nmain ()\n", "output": "6"}, {"input": "8\nfac1 (n=9)\nFAC1 (x=2, y=8)\nFAC1 (z=2, y=1)\nFac1 (a=2, b=7)\nFAC1 (N=1, M=1)\nfac1 (N=7)\nFac1 (c=3, d=8)\nmain ()\n", "output": "7"}, {"input": "9\nFac1 (a=7, b=2)\nfac1 (n=9)\nFAC1 (z=4, y=8)\nfac1 (N=2)\nfac1 (N=9)\nFAC1 (x=5, y=6)\nFac1 (c=7, d=6)\nFac1 (N=1, M=5)\nmain ()\n", "output": "8"}, {"input": "11\nfac1 (n=5)\nFAC1 (N=4, M=3)\nFac1 (c=7, d=5)\nfac1 (N=7)\nfac1 (N=9)\nFAC1 (x=3, y=9)\nFAC1 (z=1, y=4)\nFac1 (a=6, b=1)\nFAC1 (z=7, y=2)\nFac1 (a=4, b=6)\nmain ()\n", "output": "10"}, {"input": "12\nfac1 (n=6)\nFAC1 (x=7, y=6)\nFac1 (a=4, b=9)\nFAC1 (z=2, y=6)\nfac1 (N=5)\nFac1 (a=5, b=8)\nfac1 (N=2)\nFAC1 (N=6, M=6)\nFac1 (c=2, d=4)\nfac1 (N=3)\nfac1 (N=1)\nmain ()\n", "output": "11"}, {"input": "13\nFac1 (a=9, b=9)\nfac1 (n=4)\nFac1 (c=10, d=8)\nFAC1 (N=15)\nFac1 (a=5, b=2)\nfac1 (N=2)\nfac1 (N=11)\nFAC1 (z=5, y=2)\nFAC1 (N=5, M=1)\nfac1 (n=5)\nFac1 (x=4, y=8)\nFac1 (a=1, b=10)\nmain ()\n", "output": "12"}, {"input": "14\nfac1 (n=7)\nFac1 (a=4, b=2)\nFAC1 (z=2, y=6)\nFac1 (c=9, d=8)\nFAC1 (z=7, y=7)\nFAC1 (x=9, y=2)\nFAC1 (N=1, M=6)\nfac1 (N=3)\nfac1 (n=1)\nFac1 (a=7, b=5)\nFac1 (c=2, d=4)\nfac1 (N=11)\nFac1 (a=9, b=4)\nmain ()\n", "output": "13"}, {"input": "15\nFAC1 (N=11, M=13)\nfac1 (n=1)\nFac1 (c=4, d=1)\nfac1 (N=8)\nFAC1 (N=3, M=5)\nFac1 (a=4, b=2)\nFAC1 (x=6, y=3)\nFac1 (a=9, b=8)\nFAC1 (z=8, y=1)\nFac1 (a=7, b=10)\nfac1 (N=9)\nfac1 (n=7)\nFac1 (c=1, d=2)\nFac1 (a=5, b=9)\nmain ()\n", "output": "14"}, {"input": "17\nFac1 (c=8, d=1)\nFAC1 (N=11, M=12)\nfac1 (n=1)\nFAC1 (N=2, M=8)\nFac1 (a=7, b=5)\nFac1 (c=4, d=3)\nFac1 (a=2, b=10)\nFAC1 (x=6, y=7)\nfac1 (N=9)\nFAC1 (z=3, y=2)\nfac1 (N=4)\nFac1 (a=4, b=8)\nfac1 (n=10)\nFac1 (c=2, d=6)\nfac1 (N=1)\nmain ()\n", "output": "15"}, {"input": "20\nFac1 (a=6, b=5)\nFac1 (c=5, d=2)\nFAC1 (N=13, M=11)\nfac1 (N=12)\nFac1 (c=6, d=8)\nFAC1 (x=10, y=4)\nFac1 (a=5, b=5)\nfac1 (n=1)\nFAC1 (z=9, y=2)\nFac1 (c=2, d=9)\nfac1 (N=2)\nfac1 (N=8)\nfac1 (n=2)\nFac1 (a=7, b=10)\nFAC1 (N=4, M=2)\nfac1 (N=3)\nFac1 (a=7, b=1)\nFAC1 (z=1, y=1)\nmain ()\n", "output": "17"}, {"input": "1\nFac1 (m=100)\n", "output": "1"}, {"input": "3\nFAC1 (n=8)\nFAC1 (x=7, y=9)\nFAC1 (n=3)\nmain ()\n", "output": "3"}, {"input": "0\n", "output": "0"}, {"input": "2\nfac1 (x = 5, y = 6)\nfac1 (a=3)\nmain ()\n", "output": "2"}, {"input": "2\nFAC1 (N=0, M=1)\nmain ()\n", "output": "1"}, {"input": "4\nfac1 (N=0, M=1)\nFac1 (n = 2)\nfac1 (a=3)\nmain ()\n", "output": "3"}, {"input": "1\nfac1 (a=0)\n", "output": "1"}, {"input": "3\nFAC1 (N=0, M=1)\nfac1 (n = 2)\nFAC1 (a=3)\nmain ()\n", "output": "3"}, {"input": "7\nFAC1 (N=0, M=1)\nfac1 (n = 2)\nFAC1 (a=3)\nFAC1 (x=4)\nfac1 (y = 5)\nfac1 (z=6)\nmain ()\n", "output": "6"}, {"input": "1\nfac1 (N=5)\n", "output": "1"}, {"input": "3\nfac1 (N=1)\nfac1 (N=2)\nfac1 (N=3)\n", "output": "1"}, {"input": "2\nFac1 (N=3)\nfac1 (N=3)\n", "output": "1"}, {"input": "1\nFAC1 (A=1, B=2)\n", "output": "1"}, {"input": "1\nfac1 (a='A', b=1)\n", "output": "1"}, {"input": "1\nFAC1 (a=1, b='B')\n", "output": "1"}, {"input": "1\nFAC1 (a='A', b='B')\n", "output": "1"}, {"input": "1\nFAC1 (A=1, B=2, C='C')\n", "output": "1"}, {"input": "1\nFAC1 (A=1, B=2, C='C', D=3)\n", "output": "1"}, {"input": "4\nfac1 (n=10)\nFAC1 (N=20)\nFac1 (a=15, b=35)\nFAC1 (n=15)\n", "output": "3"}, {"input": "5\nfac1 (N=20)\nFAC1 (n=15)\nFac1 (x=1, y=2)\nFac1 (X=3)\nFAC1 (A=10)\n", "output": "4"}, {"input": "1\nFac1 (A=10)\n", "output": "1"}, {"input": "2\nfac1 (n=10)\nfac1 (N=15)\n", "output": "1"}, {"input": "2\nFAC1 (N=10)\nFAC1 (n=5, m=3)\n", "output": "2"}, {"input": "2\nfac1 (N=20)\nfac1 (n=15)\n", "output": "1"}], "test": "#undef NDEBUG\n#include<assert.h>\nint main(){\n    assert(solution(\"\"2\\nFAC1 (N=233, M=65 A, A=0)\\nmain ()\\n\"\") == \"1\");\n    assert(solution(\"2\\nfac1 (N=250)\\nFAC1 (a=987)\\n\") == \"1\");\n    assert(solution(\"1\\nfac1 (n=10)\\n\") == \"1\");\n    assert(solution(\"3\\nfac1 (n=10)\\nfac1 (n=20)\\nfac1 (n=30)\\n\") == \"1\");\n    assert(solution(\"3\\nfac1 (n=10)\\nfac1 (n=10)\\nfac1 (n=10)\\n\") == \"1\");\n    assert(solution(\"4\\nfac1 (n=10)\\nfac1 (n=20)\\nfac1 (n=30)\\nfac1 (n=10)\\n\") == \"1\");\n    assert(solution(\"3\\nfac1 (n=10)\\nfac1 (m=20)\\nfac1 (n=10)\\n\") == \"1\");\n    assert(solution(\"3\\nfac1 (n=10)\\nfac1 (m=20)\\nfac1 (m=30)\\n\") == \"1\");\n    assert(solution(\"3\\nfac1 (n=10)\\nfac1 (m=20)\\n FAC1 (m=30)\\n\") == \"1\");\n    assert(solution(\"3\\nfac1 (n=10)\\nfac1 (m=20)\\n FAC1 (a=30)\\n\") == \"1\");\n    assert(solution(\"1\\nmain ()\\n\") == \"0\");\n    assert(solution(\"2\\nmain ()\\nmain ()\\n\") == \"0\");\n    assert(solution(\"3\\nmain ()\\nmain ()\\nmain ()\\n\") == \"0\");\n    assert(solution(\"2\\nfac1 (n=10)\\nmain ()\\n\") == \"1\");\n    assert(solution(\"1\\nFAC1 (n=10)\\n\") == \"1\");\n    assert(solution(\"2\\nFAC1 (n=10)\\nFAC1 (m=20)\\n\") == \"1\");\n    assert(solution(\"3\\nfac1 (n=9)\\nFac1 (a=5, b=3)\\nmain ()\\n\") == \"2\");\n    assert(solution(\"4\\nfac1 (n=3)\\nFac1 (x=2, y=1)\\nfac1 (N=2)\\nmain ()\\n\") == \"3\");\n    assert(solution(\"5\\nFAC1 (N=1, M=1)\\nFAC1 (x=2, y=2)\\nfac1 (n=2)\\nfac1 (N=3)\\nmain ()\\n\") == \"3\");\n    assert(solution(\"6\\nfac1 (n=4)\\nFAC1 (x=3, y=2)\\nfac1 (N=7)\\nFac1 (a=9, b=6)\\nFAC1 (N=5, M=5)\\nmain ()\\n\") == \"5\");\n    assert(solution(\"7\\nfac1 (n=7)\\nFac1 (a=2, b=4)\\nFac1 (c=8, d=3)\\nFAC1 (N=1)\\nFAC1 (x=6, y=6)\\nfac1 (N=2)\\nmain ()\\n\") == \"6\");\n    assert(solution(\"8\\nfac1 (n=9)\\nFAC1 (x=2, y=8)\\nFAC1 (z=2, y=1)\\nFac1 (a=2, b=7)\\nFAC1 (N=1, M=1)\\nfac1 (N=7)\\nFac1 (c=3, d=8)\\nmain ()\\n\") == \"7\");\n    assert(solution(\"9\\nFac1 (a=7, b=2)\\nfac1 (n=9)\\nFAC1 (z=4, y=8)\\nfac1 (N=2)\\nfac1 (N=9)\\nFAC1 (x=5, y=6)\\nFac1 (c=7, d=6)\\nFac1 (N=1, M=5)\\nmain ()\\n\") == \"8\");\n    assert(solution(\"11\\nfac1 (n=5)\\nFAC1 (N=4, M=3)\\nFac1 (c=7, d=5)\\nfac1 (N=7)\\nfac1 (N=9)\\nFAC1 (x=3, y=9)\\nFAC1 (z=1, y=4)\\nFac1 (a=6, b=1)\\nFAC1 (z=7, y=2)\\nFac1 (a=4, b=6)\\nmain ()\\n\") == \"10\");\n    assert(solution(\"12\\nfac1 (n=6)\\nFAC1 (x=7, y=6)\\nFac1 (a=4, b=9)\\nFAC1 (z=2, y=6)\\nfac1 (N=5)\\nFac1 (a=5, b=8)\\nfac1 (N=2)\\nFAC1 (N=6, M=6)\\nFac1 (c=2, d=4)\\nfac1 (N=3)\\nfac1 (N=1)\\nmain ()\\n\") == \"11\");\n    assert(solution(\"13\\nFac1 (a=9, b=9)\\nfac1 (n=4)\\nFac1 (c=10, d=8)\\nFAC1 (N=15)\\nFac1 (a=5, b=2)\\nfac1 (N=2)\\nfac1 (N=11)\\nFAC1 (z=5, y=2)\\nFAC1 (N=5, M=1)\\nfac1 (n=5)\\nFac1 (x=4, y=8)\\nFac1 (a=1, b=10)\\nmain ()\\n\") == \"12\");\n    assert(solution(\"14\\nfac1 (n=7)\\nFac1 (a=4, b=2)\\nFAC1 (z=2, y=6)\\nFac1 (c=9, d=8)\\nFAC1 (z=7, y=7)\\nFAC1 (x=9, y=2)\\nFAC1 (N=1, M=6)\\nfac1 (N=3)\\nfac1 (n=1)\\nFac1 (a=7, b=5)\\nFac1 (c=2, d=4)\\nfac1 (N=11)\\nFac1 (a=9, b=4)\\nmain ()\\n\") == \"13\");\n    assert(solution(\"15\\nFAC1 (N=11, M=13)\\nfac1 (n=1)\\nFac1 (c=4, d=1)\\nfac1 (N=8)\\nFAC1 (N=3, M=5)\\nFac1 (a=4, b=2)\\nFAC1 (x=6, y=3)\\nFac1 (a=9, b=8)\\nFAC1 (z=8, y=1)\\nFac1 (a=7, b=10)\\nfac1 (N=9)\\nfac1 (n=7)\\nFac1 (c=1, d=2)\\nFac1 (a=5, b=9)\\nmain ()\\n\") == \"14\");\n    assert(solution(\"17\\nFac1 (c=8, d=1)\\nFAC1 (N=11, M=12)\\nfac1 (n=1)\\nFAC1 (N=2, M=8)\\nFac1 (a=7, b=5)\\nFac1 (c=4, d=3)\\nFac1 (a=2, b=10)\\nFAC1 (x=6, y=7)\\nfac1 (N=9)\\nFAC1 (z=3, y=2)\\nfac1 (N=4)\\nFac1 (a=4, b=8)\\nfac1 (n=10)\\nFac1 (c=2, d=6)\\nfac1 (N=1)\\nmain ()\\n\") == \"15\");\n    assert(solution(\"20\\nFac1 (a=6, b=5)\\nFac1 (c=5, d=2)\\nFAC1 (N=13, M=11)\\nfac1 (N=12)\\nFac1 (c=6, d=8)\\nFAC1 (x=10, y=4)\\nFac1 (a=5, b=5)\\nfac1 (n=1)\\nFAC1 (z=9, y=2)\\nFac1 (c=2, d=9)\\nfac1 (N=2)\\nfac1 (N=8)\\nfac1 (n=2)\\nFac1 (a=7, b=10)\\nFAC1 (N=4, M=2)\\nfac1 (N=3)\\nFac1 (a=7, b=1)\\nFAC1 (z=1, y=1)\\nmain ()\\n\") == \"17\");\n    assert(solution(\"1\\nFac1 (m=100)\\n\") == \"1\");\n    assert(solution(\"3\\nFAC1 (n=8)\\nFAC1 (x=7, y=9)\\nFAC1 (n=3)\\nmain ()\\n\") == \"3\");\n    assert(solution(\"0\\n\") == \"0\");\n    assert(solution(\"2\\nfac1 (x = 5, y = 6)\\nfac1 (a=3)\\nmain ()\\n\") == \"2\");\n    assert(solution(\"2\\nFAC1 (N=0, M=1)\\nmain ()\\n\") == \"1\");\n    assert(solution(\"4\\nfac1 (N=0, M=1)\\nFac1 (n = 2)\\nfac1 (a=3)\\nmain ()\\n\") == \"3\");\n    assert(solution(\"1\\nfac1 (a=0)\\n\") == \"1\");\n    assert(solution(\"3\\nFAC1 (N=0, M=1)\\nfac1 (n = 2)\\nFAC1 (a=3)\\nmain ()\\n\") == \"3\");\n    assert(solution(\"7\\nFAC1 (N=0, M=1)\\nfac1 (n = 2)\\nFAC1 (a=3)\\nFAC1 (x=4)\\nfac1 (y = 5)\\nfac1 (z=6)\\nmain ()\\n\") == \"6\");\n    assert(solution(\"1\\nfac1 (N=5)\\n\") == \"1\");\n    assert(solution(\"3\\nfac1 (N=1)\\nfac1 (N=2)\\nfac1 (N=3)\\n\") == \"1\");\n    assert(solution(\"2\\nFac1 (N=3)\\nfac1 (N=3)\\n\") == \"1\");\n    assert(solution(\"1\\nFAC1 (A=1, B=2)\\n\") == \"1\");\n    assert(solution(\"\"1\\nfac1 (a=A, b=1)\\n\"\") == \"1\");\n    assert(solution(\"\"1\\nFAC1 (a=1, b=B)\\n\"\") == \"1\");\n    assert(solution(\"\"1\\nFAC1 (a=A, b=B)\\n\"\") == \"1\");\n    assert(solution(\"\"1\\nFAC1 (A=1, B=2, C=C)\\n\"\") == \"1\");\n    assert(solution(\"\"1\\nFAC1 (A=1, B=2, C=C, D=3)\\n\"\") == \"1\");\n    assert(solution(\"4\\nfac1 (n=10)\\nFAC1 (N=20)\\nFac1 (a=15, b=35)\\nFAC1 (n=15)\\n\") == \"3\");\n    assert(solution(\"5\\nfac1 (N=20)\\nFAC1 (n=15)\\nFac1 (x=1, y=2)\\nFac1 (X=3)\\nFAC1 (A=10)\\n\") == \"4\");\n    assert(solution(\"1\\nFac1 (A=10)\\n\") == \"1\");\n    assert(solution(\"2\\nfac1 (n=10)\\nfac1 (N=15)\\n\") == \"1\");\n    assert(solution(\"2\\nFAC1 (N=10)\\nFAC1 (n=5, m=3)\\n\") == \"2\");\n    assert(solution(\"2\\nfac1 (N=20)\\nfac1 (n=15)\\n\") == \"1\");\n    return 0; \n}", "prompt": "/*As a member of the development team, unfortunately yyy2015c01 was selected to be part of the debugger development group.\n\nOne of the components yyy2015c01 envisioned for the debugger is the call stack, which is known as \"调用栈\" in Chinese.\n\nSince the IDE is currently in beta stage, the development team needs to first develop a call stack that can recognize parameter lists to see how it works. This task is assigned to you.\n\nThe call stack envisioned by the development team can recognize \"int\" and \"char\" parameter lists to differentiate between different functions, based on the following rules:\n\n```\nint fac1(int n);\n```\n\nand\n\n```\nint fac1(char n);\n```\n\nare considered as two different functions; however,\n\n```\nint Fac1(int n, int m);\n```\n\nand\n\n```\nint FAC1(int x, int y);\n```\n\nare considered as the same function. In other words, the call stack recognizes not the parameter names, but the type and case-insensitive function names.\n\nNote: int main() may or may not appear, and should not be included in any function.\n\nPlease write a call stack that outputs the total number of incomplete identical functions after all functions in the program have been called at least once.\n\ninput_format:\nThere are a total of $n + 1$ lines of input: the first line is a positive integer $n$, indicating that there are $n$ operation calls in total; the $2 \\sim n+1$ lines each represent a function call information (strictly following the format in the example input), and there will be no additional characters.\n\noutput_format:\nOutput a single line: a positive integer $m$, indicating how many functions have different parameter tables in the above call.\n*/\n\n#include<sstream>\n#include<stdlib.h>\n#include<algorithm>\n#include<math.h>\n#include<stdio.h>\n#include<vector>\n#include<string>\n#include<climits>\n#include<cstring>\n#include<iostream>\nusing namespace std;\n\n             \nstring solution(string std_in){\n    istringstream iss(std_in);\n             ", "constraints": "每个函数的参数最多有 $10$ 个，每行的输入数据长度均不超过 $255$。\n\n向本题主人公 yyy2015c01 同学致敬！\n", "samples": [["2\nFAC1 (N=233, M=65 'A', A=0)\nmain ()\n", "1\n"], ["2\nfac1 (N=250)\nFAC1 (a=987)\n", "1\n"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}}
{"task_id": "P3027", "title": "[USACO10OCT]Making Money G", "difficulty": "challenge", "nl": "FJ operates a unique business, buying and selling various small ornaments, such as cow Christmas tree decorations. He knows he can sell every piece of ornament he can store from a catalog of N (1<=N<=100) different cow ornaments, and he can buy any number of the same type of ornament. He only has M (1<=M<=100,000) dollars to invest, but he hopes to maximize his profit (which is defined a little differently) in his first year of operation.\n\nThe cost of ornament type i is C_i (1<=C_i<=100,000) dollars, and each sale of the ornament generates revenue of R_i (1<=R_i<=100,000) dollars (profit=R_i-C_i). FJ can mix and match any ornaments he wants to sell. He doesn't need to spend all his money when buying ornaments.\n\nWhat is the total profit (profit=initial cash-all costs+all sales) that FJ can have at the end of the first year? This number is guaranteed to be less than 1,000,000,000.\n\nConsider the case where FJ only has 3 types of ornaments and an initial capital of 17. The following are the cost and revenue numbers for each type of ornament:\n\n1         2         4\n\n2         5         6\n\n3         3         7\n\nIn this case, FJ should buy 5 type 3 ornaments, costing 15 dollars, and 1 type 1 ornament, costing 2 dollars, for a total cost of 17 dollars. His profit will be 5*(7-3)+1*(4-2)=5 * 4 + 1 * 2 = 22 dollars. Given the cost and revenue structure, he cannot do better than this.\n\nNote: the second test case is quite challenging, but our answer is correct.", "code": "#include<cstdio>\nusing namespace std;\nconst int maxn=105;\nint n,m,ans,c[maxn],r[maxn],dp[100005];\nint max(int a,int b){if(a>b) return a;else return b;}\nint main(){\n\tscanf(\"%d%d\",&n,&m);\n\tfor(register int i=1;i<=n;++i) scanf(\"%d%d\",&c[i],&r[i]);\n\tfor(register int i=1;i<=n;++i){\n\t\tfor(register int j=c[i];j<=m;++j){\n\t\t\tdp[j]=max(dp[j],dp[j-c[i]]+r[i]-c[i]);\n\t\t}\n\t}\n\tfor(register int i=1;i<=m;++i) ans=max(ans,dp[i]-i+m);\n\tprintf(\"%d\",ans);\n}", "step": ["Read input of number of goods and maximum weight.", "Read input of each good's cost and profit.", "Loop over each good and calculate maximum profit for each weight using dynamic programming.", "Calculate the answer as the maximum profit subtracted by the weight and added by the maximum weight.", "Print the answer."], "nl_cn": "FJ has gone into the curio business, buying and selling knickknacks like cow Christmas tree ornaments. He knows he will sell every single curio he can stock from a catalog of N (1 <= N <= 100)\n\ndifferent cow curios, and he can buy as many of each kind of curio as his heart desires. He has only M (1 <= M <= 100,000) money to invest but wants to maximize his profit (which has a slightly unusual definition) at the end of his first year in business.\n\nCurio type i costs C\\_i (1 <= C\\_i <= 100,000) money to purchase and yields R\\_i (1 <= R\\_i <= 100,000) revenue for each curio sold (a profit of R\\_i-C\\_i). FJ can mix and match the curios he sells in any way he wishes. He need not spend all his money when purchasing curios.\n\nWhat is the greatest amount of total profit (profit = initial\\_cash - all\\_costs + all\\_sales) FJ can have at the end of his first year? This number is guaranteed to be less than 1,000,000,000.\n\nConsider the situation when FJ has just 3 kinds of curios and starts with M=17. Below are the cost and revenue numbers for each curio:\n\nCurio     Cost     Revenue\n\n#        C\\_i       R\\_i\n\n1         2         4\n\n2         5         6\n\n3         3         7\n\nIn this case, FJ should purchase 5 curios of type 3 for 15 money and 1 more curio of type 1 for 2 money, a total of 17 money. His profit will be 5 \\* (7-3) + 1 \\* (4-2) = 5\\*4 + 1\\*2 = 22 money. He can do no better than this given the cost and revenue structure.\n\nNOTE: The second test case is challenging -- but our answer is correct.\n", "test_cases": [{"input": "3 17 \n2 4 \n5 6 \n3 7 \n", "output": "22"}, {"input": "1 7 \n9 6 \n", "output": "6"}, {"input": "3 14 \n3 7 \n4 6 \n6 5 \n", "output": "18"}, {"input": "4 25 \n8 10 \n12 18 \n5 6 \n4 4 \n", "output": "24"}, {"input": "3 6 \n1 2 \n2 3 \n3 4 \n", "output": "6"}, {"input": "2 4 \n1 1 \n3 2 \n", "output": "3"}, {"input": "3 10 \n6 1 \n8 4 \n5 8 \n", "output": "9"}, {"input": "3 7 \n3 6 \n5 1 \n2 3 \n", "output": "7"}, {"input": "2 10 \n2 4 \n5 5 \n", "output": "10"}, {"input": "1 1 \n1 1 \n", "output": "0"}], "test": "#undef NDEBUG\n#include<assert.h>\nint main(){\n    assert(solution(\"3 17 \\n2 4 \\n5 6 \\n3 7 \\n\") == \"22\");\n    assert(solution(\"1 7 \\n9 6 \\n\") == \"6\");\n    assert(solution(\"3 14 \\n3 7 \\n4 6 \\n6 5 \\n\") == \"18\");\n    assert(solution(\"4 25 \\n8 10 \\n12 18 \\n5 6 \\n4 4 \\n\") == \"24\");\n    assert(solution(\"3 6 \\n1 2 \\n2 3 \\n3 4 \\n\") == \"6\");\n    assert(solution(\"2 4 \\n1 1 \\n3 2 \\n\") == \"3\");\n    assert(solution(\"3 10 \\n6 1 \\n8 4 \\n5 8 \\n\") == \"9\");\n    assert(solution(\"3 7 \\n3 6 \\n5 1 \\n2 3 \\n\") == \"7\");\n    assert(solution(\"2 10 \\n2 4 \\n5 5 \\n\") == \"10\");\n    assert(solution(\"1 1 \\n1 1 \\n\") == \"0\");\n    return 0; \n}", "prompt": "/*FJ operates a unique business, buying and selling various small ornaments, such as cow Christmas tree decorations. He knows he can sell every piece of ornament he can store from a catalog of N (1<=N<=100) different cow ornaments, and he can buy any number of the same type of ornament. He only has M (1<=M<=100,000) dollars to invest, but he hopes to maximize his profit (which is defined a little differently) in his first year of operation.\n\nThe cost of ornament type i is C_i (1<=C_i<=100,000) dollars, and each sale of the ornament generates revenue of R_i (1<=R_i<=100,000) dollars (profit=R_i-C_i). FJ can mix and match any ornaments he wants to sell. He doesn't need to spend all his money when buying ornaments.\n\nWhat is the total profit (profit=initial cash-all costs+all sales) that FJ can have at the end of the first year? This number is guaranteed to be less than 1,000,000,000.\n\nConsider the case where FJ only has 3 types of ornaments and an initial capital of 17. The following are the cost and revenue numbers for each type of ornament:\n\n1         2         4\n\n2         5         6\n\n3         3         7\n\nIn this case, FJ should buy 5 type 3 ornaments, costing 15 dollars, and 1 type 1 ornament, costing 2 dollars, for a total cost of 17 dollars. His profit will be 5*(7-3)+1*(4-2)=5 * 4 + 1 * 2 = 22 dollars. Given the cost and revenue structure, he cannot do better than this.\n\nNote: the second test case is quite challenging, but our answer is correct.\n\ninput_format:\n\\* Line 1: Two space-separated integers: N and M\n\n\\* Lines 2..N+1: Line i+1 contains two space-separated integers: C\\_i and R\\_i\n\nTranslation:\n\\* Line 1: Two integers separated by a space: N and M.\n\n\\* Lines 2 to N+1: Each line contains two integers separated by a space: C\\_i and R\\_i.\n\noutput_format:\n\\* Line 1: The maximum profit FJ can generate given the costs and revenues\n*/\n\n#include<sstream>\n#include<stdlib.h>\n#include<algorithm>\n#include<math.h>\n#include<stdio.h>\n#include<vector>\n#include<string>\n#include<climits>\n#include<cstring>\n#include<iostream>\nusing namespace std;\n\n             \nstring solution(string std_in){\n    istringstream iss(std_in);\n             ", "constraints": "", "samples": [["3 17 \n2 4 \n5 6 \n3 7 \n", "22 \n"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}}
{"task_id": "P1190", "title": "[NOIP2010 普及组] 接水问题", "difficulty": "challenge", "nl": "There is a water room in the school, which has a total of $m$ taps for students to turn on water. The water supply of each tap is the same, which is $1$ liter per second.\n\nNow there are $n$ students ready to fetch water, and their initial order has been determined. Number these students from $1$ to $n$ according to the order of fetching water, and the water fetching volume of student $i$ is $w_i$. At the beginning of fetching water, students from $1$ to $m$ each take a tap and turn on the tap to fetch water at the same time. When one of them, student $j$, completes his/her water fetching requirement $w_j$, the next student $k$ in the queue for water fetching will immediately take over the position to fetch water from student $j$. This handover process is instant and there is no waste of water. That is, if student $j$ completes the water fetching at the $x$-th second, student $k$ will immediately start fetching water at the $(x+1)$-th second. If the current number of people fetching water $n'<m$, only $n'$ taps are available for water supply, and the other $m-n'$ taps are closed.\n\nNow given the water fetching volume of $n$ students, according to the above water fetching rules, how many seconds are needed for all students to fetch water?", "code": "#include<cstdio>\nusing namespace std;\nint n,m,w[10001],s[101],maxx;//定义\nint main()\n{\n    scanf(\"%d%d\",&n,&m);\n    for (int i=1;i<=n;i++) scanf(\"%d\",&w[i]);//输入每个人打水需要的时间\n    for (int i=1;i<=n;i++)\n    {\n        maxx=1;\n        for (int j=2;j<=m;j++)\n         if (s[maxx]>s[j])  maxx=j;//找到最小的\n        s[maxx]+=w[i];//加上他的时间\n    }\n    maxx=1;\n    for (int i=1;i<=m;i++) maxx=s[i]>maxx? s[i]:maxx;//找到最大值\n    printf(\"%d\",maxx);//输出\n}", "step": ["Take input values n and m", "Take an array w of size n as input", "Iterate through n and find the largest element in array s of size m", "Add the ith element of w to the largest element in s and continue the loop until all elements in w have been iterated", "Find the largest element in array s", "Print the largest element found in s"], "nl_cn": "学校里有一个水房，水房里一共装有 $m$ 个龙头可供同学们打开水，每个龙头每秒钟的供水量相等，均为 $1$。\n\n现在有 $n$ 名同学准备接水，他们的初始接水顺序已经确定。将这些同学按接水顺序从 $1$ 到 $n$ 编号，$i$ 号同学的接水量为 $w_i$。接水开始时，$1$ 到 $m$ 号同学各占一个水龙头，并同时打开水龙头接水。当其中某名同学 $j$ 完成其接水量要求 $w_j$ 后，下一名排队等候接水的同学 $k$ 马上接替 $j$ 同学的位置开始接水。这个换人的过程是瞬间完成的，且没有任何水的浪费。即 $j$ 同学第 $x$ 秒结束时完成接水，则 $k$ 同学第 $x+1$ 秒立刻开始接水。若当前接水人数 $n'$ 不足 $m$，则只有 $n'$ 个龙头供水，其它 $m - n'$ 个龙头关闭。\n\n现在给出 $n$ 名同学的接水量，按照上述接水规则，问所有同学都接完水需要多少秒。\n", "test_cases": [{"input": "5 3\n4 4 1 2 1\n", "output": "4"}, {"input": "8 4\n23 71 87 32 70 93 80 76\n", "output": "163"}, {"input": "1 1\n5\n", "output": "5"}, {"input": "2 1\n10 10\n", "output": "20"}, {"input": "4 4\n1 2 3 4\n", "output": "4"}, {"input": "5 5\n10 10 10 10 10\n", "output": "10"}, {"input": "3 3\n1 2 3\n", "output": "3"}, {"input": "4 2\n8 6 4 2\n", "output": "10"}, {"input": "1 1\n10\n", "output": "10"}, {"input": "3 3\n2 4 6\n", "output": "6"}, {"input": "4 4\n10 20 30 40\n", "output": "40"}, {"input": "10 5\n5 5 5 5 5 5 5 5 5 5\n", "output": "10"}, {"input": "2 2\n1 2\n", "output": "2"}, {"input": "3 1\n100 200 300\n", "output": "600"}, {"input": "5 5\n1 2 3 4 5\n", "output": "5"}, {"input": "7 4\n2 3 1 2 3 1 2\n", "output": "4"}, {"input": "4 1\n3 5 7 9\n", "output": "24"}, {"input": "4 2\n1 1 1 1\n", "output": "2"}, {"input": "15 5\n1 1 1 1 1 1 1 1 1 1 1 1 1 1 1\n", "output": "3"}, {"input": "6 6\n3 2 4 1 5 6\n", "output": "6"}, {"input": "20 10\n1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1\n", "output": "2"}, {"input": "2 2\n5 6\n", "output": "6"}, {"input": "7 5\n12 8 10 9 7 6 11\n", "output": "19"}, {"input": "6 3\n8 5 2 1 3 4\n", "output": "9"}, {"input": "1 1\n10000\n", "output": "10000"}, {"input": "5 5\n2 2 2 2 2\n", "output": "2"}, {"input": "6 6\n2 4 6 8 10 12\n", "output": "12"}, {"input": "3 3\n10 20 30\n", "output": "30"}, {"input": "1 1\n1\n", "output": "1"}, {"input": "2 1\n3 3\n", "output": "6"}, {"input": "5 5\n1 1 1 1 1\n", "output": "1"}, {"input": "3 1\n1 2 3\n", "output": "6"}, {"input": "6 6\n2 2 2 2 2 2\n", "output": "2"}], "test": "#undef NDEBUG\n#include<assert.h>\nint main(){\n    assert(solution(\"5 3\\n4 4 1 2 1\\n\") == \"4\");\n    assert(solution(\"8 4\\n23 71 87 32 70 93 80 76\\n\") == \"163\");\n    assert(solution(\"1 1\\n5\\n\") == \"5\");\n    assert(solution(\"2 1\\n10 10\\n\") == \"20\");\n    assert(solution(\"4 4\\n1 2 3 4\\n\") == \"4\");\n    assert(solution(\"5 5\\n10 10 10 10 10\\n\") == \"10\");\n    assert(solution(\"3 3\\n1 2 3\\n\") == \"3\");\n    assert(solution(\"4 2\\n8 6 4 2\\n\") == \"10\");\n    assert(solution(\"1 1\\n10\\n\") == \"10\");\n    assert(solution(\"3 3\\n2 4 6\\n\") == \"6\");\n    assert(solution(\"4 4\\n10 20 30 40\\n\") == \"40\");\n    assert(solution(\"10 5\\n5 5 5 5 5 5 5 5 5 5\\n\") == \"10\");\n    assert(solution(\"2 2\\n1 2\\n\") == \"2\");\n    assert(solution(\"3 1\\n100 200 300\\n\") == \"600\");\n    assert(solution(\"5 5\\n1 2 3 4 5\\n\") == \"5\");\n    assert(solution(\"7 4\\n2 3 1 2 3 1 2\\n\") == \"4\");\n    assert(solution(\"4 1\\n3 5 7 9\\n\") == \"24\");\n    assert(solution(\"4 2\\n1 1 1 1\\n\") == \"2\");\n    assert(solution(\"15 5\\n1 1 1 1 1 1 1 1 1 1 1 1 1 1 1\\n\") == \"3\");\n    assert(solution(\"6 6\\n3 2 4 1 5 6\\n\") == \"6\");\n    assert(solution(\"20 10\\n1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1\\n\") == \"2\");\n    assert(solution(\"2 2\\n5 6\\n\") == \"6\");\n    assert(solution(\"7 5\\n12 8 10 9 7 6 11\\n\") == \"19\");\n    assert(solution(\"6 3\\n8 5 2 1 3 4\\n\") == \"9\");\n    assert(solution(\"1 1\\n10000\\n\") == \"10000\");\n    assert(solution(\"5 5\\n2 2 2 2 2\\n\") == \"2\");\n    assert(solution(\"6 6\\n2 4 6 8 10 12\\n\") == \"12\");\n    assert(solution(\"3 3\\n10 20 30\\n\") == \"30\");\n    assert(solution(\"1 1\\n1\\n\") == \"1\");\n    assert(solution(\"2 1\\n3 3\\n\") == \"6\");\n    assert(solution(\"5 5\\n1 1 1 1 1\\n\") == \"1\");\n    assert(solution(\"3 1\\n1 2 3\\n\") == \"6\");\n    assert(solution(\"6 6\\n2 2 2 2 2 2\\n\") == \"2\");\n    return 0; \n}", "prompt": "/*There is a water room in the school, which has a total of $m$ taps for students to turn on water. The water supply of each tap is the same, which is $1$ liter per second.\n\nNow there are $n$ students ready to fetch water, and their initial order has been determined. Number these students from $1$ to $n$ according to the order of fetching water, and the water fetching volume of student $i$ is $w_i$. At the beginning of fetching water, students from $1$ to $m$ each take a tap and turn on the tap to fetch water at the same time. When one of them, student $j$, completes his/her water fetching requirement $w_j$, the next student $k$ in the queue for water fetching will immediately take over the position to fetch water from student $j$. This handover process is instant and there is no waste of water. That is, if student $j$ completes the water fetching at the $x$-th second, student $k$ will immediately start fetching water at the $(x+1)$-th second. If the current number of people fetching water $n'<m$, only $n'$ taps are available for water supply, and the other $m-n'$ taps are closed.\n\nNow given the water fetching volume of $n$ students, according to the above water fetching rules, how many seconds are needed for all students to fetch water?\n\ninput_format:\nThe first line contains two integers $n$ and $m$, separated by a space, representing the number of people waiting for water and the number of taps available.\n\nThe second line contains $n$ integers $w_1,w_2,\\ldots,w_n$, separated by a space, where $w_i$ represents the amount of water that the $i$-th student needs to fetch.\n\noutput_format:\nAn integer representing the total time required to connect the water.\n*/\n\n#include<sstream>\n#include<stdlib.h>\n#include<algorithm>\n#include<math.h>\n#include<stdio.h>\n#include<vector>\n#include<string>\n#include<climits>\n#include<cstring>\n#include<iostream>\nusing namespace std;\n\n             \nstring solution(string std_in){\n    istringstream iss(std_in);\n             ", "constraints": "【输入输出样例 \\#1 说明】\n\n第 $1$ 秒，$3$ 人接水。第 $1$ 秒结束时，$1,2,3$ 号同学每人的已接水量为 $1,3$ 号同学接完水，$4$ 号同学接替 $3$ 号同学开始接水。\n\n第 $2$ 秒，$3$ 人接水。第 $2$ 秒结束时，$1,2$ 号同学每人的已接水量为 $2,4$ 号同学的已接水量为 $1$。\n\n第 $3$ 秒，$3$ 人接水。第 $3$ 秒结束时，$1,2$ 号同学每人的已接水量为 $3,4$ 号同学的已接水量为 $2$。$4$ 号同学接完水，$5$ 号同学接替 $4$ 号同学开始接水。\n\n第 $4$ 秒，$3$ 人接水。第 $4$ 秒结束时，$1,2$ 号同学每人的已接水量为 $4,5$ 号同学的已接水量为 $1$。$1,2,5$ 号同学接完水，即所有人完成接水的总接水时间为 $4$ 秒。\n\n【数据范围】\n\n$1 \\le n \\le {10}^4$，$1 \\le m \\le 100$，$m \\le n$；\n\n$1 \\le w_i \\le 100$。\n\nNOIP2010 普及组 第二题\n", "samples": [["5 3\n4 4 1 2 1\n", "4"], ["8 4\n23 71 87 32 70 93 80 76\n", "163"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}}
{"task_id": "P5248", "title": "[LnOI2019SP]快速多项式变换(FPT)", "difficulty": "advanced", "nl": "This is a constructive problem.\n\nShinomiya has a polynomial $f(x)$ of $n+1$ terms in mind. The $i$-th term has a degree of $i$ and a coefficient of $a_i$:\n\n$$f(x)=a_0+a_1x+a_2x^2+a_3x^3+ \\cdots +a_nx^n$$\n\nGiven $m$ and the value of $f(m)$ (i.e., the value of the polynomial when $x=m$), please construct a polynomial that satisfies $0 \\leq a_i < m$ and $a_i$ is a non-negative integer.\n\nIf the polynomial you constructed has $n$ terms, it must satisfy $1 ≤ n ≤ 100$ and the coefficient of the highest term is not zero.", "code": "#include <iostream>\n#include <cstdio>\nusing namespace std;\nlong long n, m, fm, a[100050];\nint main() {\n\tcin >> m >> fm;\n\tfor(; fm; fm /= m) a[++n] = fm % m;\n\tprintf(\"%d\\n\", n);\n\tfor(int i = 1; i < n; ++i) cout << a[i] << \" \";\n\tcout << a[n];\n}", "step": ["Read in m and fm input.", "Convert fm to the new number system by dividing by m.", "Store the remainder in an array and continue dividing until fm equals zero.", "Print out the length of the array.", "Loop through the array and print out the values separated by spaces."], "nl_cn": "这是一道构造题。\n\n诗乃在心中想了一个$n+1$项的多项式$f(x)$。第$i$项次数为$i$，系数为$a_i$：\n\n$$f(x)=a_0+a_1x+a_2x^2+a_3x^3+ \\cdots +a_nx^n$$\n\n给定$m$以及$f(m)$的值（即当$x=m$时此多项式的值），请构造多项式，满足任意$0 \\leq a_i < m$且$a_i$为非负整数。\n\n设你构造的多项式项数为$n$，则必须满足$1 ≤ n ≤ 100$且最高项系数不为零。", "test_cases": [{"input": "10 10", "output": "2\n0 1"}, {"input": "2 4\n", "output": "3\n0 0 1"}, {"input": "6 216\n", "output": "4\n0 0 0 1"}, {"input": "4 64\n", "output": "4\n0 0 0 1"}, {"input": "5 18", "output": "2\n3 3"}, {"input": "9 45", "output": "2\n0 5"}, {"input": "8 63", "output": "2\n7 7"}, {"input": "9 20", "output": "2\n2 2"}, {"input": "8 1\n", "output": "1\n1"}, {"input": "11 20\n", "output": "2\n9 1"}, {"input": "15 30\n", "output": "2\n0 2"}, {"input": "13 15\n", "output": "2\n2 1"}, {"input": "10 100\n", "output": "3\n0 0 1"}, {"input": "7 49\n", "output": "3\n0 0 1"}, {"input": "12 12\n", "output": "2\n0 1"}, {"input": "7 7\n", "output": "2\n0 1"}, {"input": "3 10\n", "output": "3\n1 0 1"}, {"input": "4 36\n", "output": "3\n0 1 2"}, {"input": "5 10\n", "output": "2\n0 2"}, {"input": "10 20\n", "output": "2\n0 2"}, {"input": "3 27", "output": "4\n0 0 0 1"}, {"input": "10 1", "output": "1\n1"}, {"input": "5 1", "output": "1\n1"}, {"input": "7 1", "output": "1\n1"}, {"input": "3 1", "output": "1\n1"}, {"input": "2 1", "output": "1\n1"}, {"input": "6 1", "output": "1\n1"}, {"input": "4 1", "output": "1\n1"}, {"input": "9 1", "output": "1\n1"}], "test": "#undef NDEBUG\n#include<assert.h>\nint main(){\n    assert(solution(\"10 10\") == \"2\\n0 1\");\n    assert(solution(\"2 4\\n\") == \"3\\n0 0 1\");\n    assert(solution(\"6 216\\n\") == \"4\\n0 0 0 1\");\n    assert(solution(\"4 64\\n\") == \"4\\n0 0 0 1\");\n    assert(solution(\"5 18\") == \"2\\n3 3\");\n    assert(solution(\"9 45\") == \"2\\n0 5\");\n    assert(solution(\"8 63\") == \"2\\n7 7\");\n    assert(solution(\"9 20\") == \"2\\n2 2\");\n    assert(solution(\"8 1\\n\") == \"1\\n1\");\n    assert(solution(\"11 20\\n\") == \"2\\n9 1\");\n    assert(solution(\"15 30\\n\") == \"2\\n0 2\");\n    assert(solution(\"13 15\\n\") == \"2\\n2 1\");\n    assert(solution(\"10 100\\n\") == \"3\\n0 0 1\");\n    assert(solution(\"7 49\\n\") == \"3\\n0 0 1\");\n    assert(solution(\"12 12\\n\") == \"2\\n0 1\");\n    assert(solution(\"7 7\\n\") == \"2\\n0 1\");\n    assert(solution(\"3 10\\n\") == \"3\\n1 0 1\");\n    assert(solution(\"4 36\\n\") == \"3\\n0 1 2\");\n    assert(solution(\"5 10\\n\") == \"2\\n0 2\");\n    assert(solution(\"10 20\\n\") == \"2\\n0 2\");\n    assert(solution(\"3 27\") == \"4\\n0 0 0 1\");\n    assert(solution(\"10 1\") == \"1\\n1\");\n    assert(solution(\"5 1\") == \"1\\n1\");\n    assert(solution(\"7 1\") == \"1\\n1\");\n    assert(solution(\"3 1\") == \"1\\n1\");\n    assert(solution(\"2 1\") == \"1\\n1\");\n    assert(solution(\"6 1\") == \"1\\n1\");\n    assert(solution(\"4 1\") == \"1\\n1\");\n    assert(solution(\"9 1\") == \"1\\n1\");\n    return 0; \n}", "prompt": "/*This is a constructive problem.\n\nShinomiya has a polynomial $f(x)$ of $n+1$ terms in mind. The $i$-th term has a degree of $i$ and a coefficient of $a_i$:\n\n$$f(x)=a_0+a_1x+a_2x^2+a_3x^3+ \\cdots +a_nx^n$$\n\nGiven $m$ and the value of $f(m)$ (i.e., the value of the polynomial when $x=m$), please construct a polynomial that satisfies $0 \\leq a_i < m$ and $a_i$ is a non-negative integer.\n\nIf the polynomial you constructed has $n$ terms, it must satisfy $1 ≤ n ≤ 100$ and the coefficient of the highest term is not zero.\n\ninput_format:\nTwo integers, $m$, $f(m)$.\n\noutput_format:\nThe first line outputs a positive integer $n$, representing the number of terms of the polynomial.\n\nThe second line prints $n$non-negative integers ($a_0$to $a_{n-1}$), each separated by a ** * space.\n*/\n\n#include<sstream>\n#include<stdlib.h>\n#include<algorithm>\n#include<math.h>\n#include<stdio.h>\n#include<vector>\n#include<string>\n#include<climits>\n#include<cstring>\n#include<iostream>\nusing namespace std;\n\n             \nstring solution(string std_in){\n    istringstream iss(std_in);\n             ", "constraints": "对于20%的数据， $ 2 ≤ m ≤ 5. $\n\n对于100%的数据，\n $ 2 ≤ m,f(m) ≤ 10^{18}.$\n\n所有数据的时间限制为 $1000ms$，空间限制为 $256MB$，可开启O2优化。", "samples": [["10 10", "2\n0 1"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000]}}
{"task_id": "P1348", "title": "Couple number", "difficulty": "challenge", "nl": "For an integer $n$, if there exist two natural numbers $x, y$ that satisfy $n = x^2 - y^2$, then $n$ is called a Couple number.\n\nGiven $a$ and $b$, find the number of Couple numbers in the range $[a, b]$.", "code": "#include<cstdio>\n#include<iostream>\n#include<cstring>\n#include<string>\n#include<cmath>\n#include<algorithm>\n#include<queue>\nusing namespace std;\nint main()\n{\n    long long gs,ygs;\n    long long n1,n2;\n    scanf(\"%lld%lld\",&n1,&n2);\n    ygs=n2-n1+1;//求总个数\n    int h1,h2;\n    if(n1<=0&&n2>=0)//一正一负\n    {\n        h1=(n2+2)/4;\n        h2=((-n1)+2)/4;//将它分成正负两段分别统计\n        gs=h1+h2;//求和即可\n    }\n    else\n    {\n        if(n1>0)//均为正数\n        gs=(n2+2)/4-(n1+1)/4;//同上文解析\n        else//均为负数\n        gs=(-n1+2)/4-(-n2+1)/4;//取相反数，然后同均为正数情况\n    }\n    printf(\"%lld\",ygs-gs);//相减即是答案\n    return 0;\n}", "step": ["Take input of two numbers n1 and n2.", "Calculate the number of integers including n1 and n2.", "If n1<=0 and n2>=0, calculate the number of multiples of 4 within the range (n1, n2).", "If n1 > 0, calculate the number of multiples of 4 between (n1, n2) exclusively.", "If n1 < 0, calculate the number of multiples of 4 between (-n2, -n1) exclusively.", "Subtract the number of multiples of 4 from the total number of integers within the given range.", "Print the result as output."], "nl_cn": "对于一个整数 $n$，若存在两个自然数 $x, y$，满足 $n = x^2 - y^2$，则称 $n$ 是 Couple number。\n\n给出 $a,b$，请求出 $[a, b]$ 范围内有多少个 Couple number。", "test_cases": [{"input": "1 10\n", "output": "7"}, {"input": "6 6\n", "output": "0"}, {"input": "0 0\n", "output": "1"}, {"input": "1000000000 1000000000\n", "output": "1"}, {"input": "2 5\n", "output": "3"}], "test": "#undef NDEBUG\n#include<assert.h>\nint main(){\n    assert(solution(\"1 10\\n\") == \"7\");\n    assert(solution(\"6 6\\n\") == \"0\");\n    assert(solution(\"0 0\\n\") == \"1\");\n    assert(solution(\"1000000000 1000000000\\n\") == \"1\");\n    assert(solution(\"2 5\\n\") == \"3\");\n    return 0; \n}", "prompt": "/*For an integer $n$, if there exist two natural numbers $x, y$ that satisfy $n = x^2 - y^2$, then $n$ is called a Couple number.\n\nGiven $a$ and $b$, find the number of Couple numbers in the range $[a, b]$.\n\ninput_format:\nEnter only one line with two integers, representing $a and b$respectively.\n\noutput_format:\nOutput a line with an integer representing the answer.\n*/\n\n#include<sstream>\n#include<stdlib.h>\n#include<algorithm>\n#include<math.h>\n#include<stdio.h>\n#include<vector>\n#include<string>\n#include<climits>\n#include<cstring>\n#include<iostream>\nusing namespace std;\n\n             \nstring solution(string std_in){\n    istringstream iss(std_in);\n             ", "constraints": "#### 数据规模与约定\n\n对于全部的测试点，保证 $-10^7 \\le a < b \\le 10^7$ ，$b - a \\le 10^7$。", "samples": [["1 10\n", "7\n"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}}
{"task_id": "P2755", "title": "洗牌问题", "difficulty": "challenge", "nl": "There are $2n$ cards numbered as $1,2,3\\dots n,n+1,\\dots,2n$ in their original order. A shuffle will transform the sequence into $n+1,1,n+2,2,n+3,3,n+4,4\\dots 2n,n$.\n\nIt can be proven that for any positive integer $n$, after $m$ times of shuffling, the sequence will return to its original order for the first time.\n\nGiven $n$ ($n\\leq 10^8$), find the value of $m$.", "code": "#include<cstdio>\n#include<cmath>\nint phi(int x)//欧拉函数 \n{\n\tint p=x;\n\tfor(int i=2;i*i<=x;++i)\n\t\tif(x%i==0)\n\t\t{\n\t\t\tp-=p/i;\n\t\t\twhile(x%i==0)x/=i;\n\t\t}\n\tif(x>1)p-=p/x;\n\treturn p;\n}\nint fp(int q,int p,int MOD)//快速幂 \n{\n\tlong long a=q%MOD,ans=1;\n\twhile(p)\n\t{\n\t\tif(p&1)ans*=a,ans%=MOD;\n\t\ta*=a,a%=MOD,p>>=1;\n\t}\n\treturn ans;\n}\nint main()\n{\n\tint n,m,p,t,e;\n\tscanf(\"%d\",&n);\n\tm=2*n+1,p=phi(m),t=p,e=sqrt(p);\n\tfor(int i=1;i<=e;i++)//枚举因子，一个是i，另一个是p/i\n\t\tif(fp(2,i,m)==1)\n\t\t//欧拉定理的特解可能大于循环节\n\t\t//循环节一定是φ(2n+1)的因子\n\t\t{\n\t\t\tt=i;\n\t\t\tbreak;//从前往后找到了解，一定是最小的\n\t\t}\n\t\telse\n\t\t{\n\t\t\tif(fp(2,p/i,m)==1)t=p/i;\n\t\t\t//从后往前找的解不一定是最小的，暂存一下\n\t\t}\n\tprintf(\"%d\",t);\n}", "step": ["Compute n and create variables m, p, t, and e.", "Calculate the Euler's totient function of m.", "Initialize t to p and loop through all i less than or equal to the square root of p. If fp(2, i, m) is equal to 1, update t to i and break the loop.", "If the previous loop did not update t, loop through all i less than p/e. If fp(2, p/i, m) is equal to 1, update t to p/i and break the loop.", "Print the value of t."], "nl_cn": "有 $ 2n $ 张牌，编号为\n\n$$ 1,2,3 \\dots n,n+1, \\dots 2n$$\n\n这也是最初的牌的顺序。一次洗牌是把序列变为\n\n$$ n+1,1,n+2,2,n+3,3,n+4,4 \\dots 2n,n $$\n\n可以证明，对于任意自然数 $ n $，都可以在经过 $ m $ 次洗牌后第一次重新得到初始的顺序。\n\n现给定 $n$（$n \\le 10^8$），求出 $ m $ 的值。", "test_cases": [{"input": "20", "output": "20"}, {"input": "15\n", "output": "5"}, {"input": "200 \n", "output": "200"}, {"input": "11 \n", "output": "11"}], "test": "#undef NDEBUG\n#include<assert.h>\nint main(){\n    assert(solution(\"20\") == \"20\");\n    assert(solution(\"15\\n\") == \"5\");\n    assert(solution(\"200 \\n\") == \"200\");\n    assert(solution(\"11 \\n\") == \"11\");\n    return 0; \n}", "prompt": "/*There are $2n$ cards numbered as $1,2,3\\dots n,n+1,\\dots,2n$ in their original order. A shuffle will transform the sequence into $n+1,1,n+2,2,n+3,3,n+4,4\\dots 2n,n$.\n\nIt can be proven that for any positive integer $n$, after $m$ times of shuffling, the sequence will return to its original order for the first time.\n\nGiven $n$ ($n\\leq 10^8$), find the value of $m$.\n\ninput_format:\nOne line, one positive integer $n$.\n\noutput_format:\nOne line, a positive integer $m$.\n*/\n\n#include<sstream>\n#include<stdlib.h>\n#include<algorithm>\n#include<math.h>\n#include<stdio.h>\n#include<vector>\n#include<string>\n#include<climits>\n#include<cstring>\n#include<iostream>\nusing namespace std;\n\n             \nstring solution(string std_in){\n    istringstream iss(std_in);\n             ", "constraints": "对于 $100 \\%$ 的数据，$1 \\le n \\le 10^8$。", "samples": [["20", "20"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}}
{"task_id": "P8091", "title": "[USACO22JAN] Non-Transitive Dice B", "difficulty": "challenge", "nl": "To pass the time in the barn, cows like to play simple dice games. One game involves two dice, labeled X and Y. Both dice are thrown and the winner is the die showing the bigger number. If the two dice show the same number, they are thrown again (and again, potentially indefinitely, until a winner is determined). We will say that die X beats die Y if it is more likely to win the game.\n\nConsider the following four-sided dice:\n\nDie A has sides labeled 4, 5, 6, and 7.\n\nDie B has sides labeled 2, 4, 5, and 10.\n\nDie C has sides labeled 1, 4, 8, and 9.\n\nThese dice satisfy a rather remarkable property: A beats B, B beats C, and C beats A. In particular, none of the three is \"best\" in the sense that it beats the other two. In this case, when no two dice tie and no die is best, we will say that the set of three dice is \"non-transitive\", meaning that each die beats one of the others and loses to another.\n\nGiven two four-sided dice A and B, with each side labeled by an integer, help the cows determine whether it is possible to assign numbers to the sides of a third die C such that the set of three dice is non-transitive. The numbers on all sides of all dice must be integers between 1 and 10.", "code": "#include<bits/stdc++.h>\n\nusing namespace std;\n\nint T, a[4],b[4],c[4];\n\ninline int read()\n{\n    int f = 1, x = 0; char c = getchar();\n    while (c < '0' || c > '9') { if (c == '-') f = -1; c = getchar();}\n    while (c >= '0' && c <= '9') { x = x * 10 + c - '0'; c = getchar();}\n    return f * x;\n}\n\nbool x_win_y(int x[4], int y[4]){\n    int x_cnt =0, y_cnt = 0; \n    for(int i=0;i<4;i++){\n        for(int j=0;j<4;j++){\n            if(x[i]>y[j])x_cnt++;\n            else if(x[i]<y[j])y_cnt++;\n        }\n    }\n    return x_cnt > y_cnt;\n}\n\nbool check(){\n    if(x_win_y(a,b) && x_win_y(b,c) && x_win_y(c,a))return true;\n    if(x_win_y(b,a) && x_win_y(c,b) && x_win_y(a,c))return true;\n    return false; \n}\n\nvoid solve(){\n\n    for(c[0]=1;c[0]<=10;c[0]++){\n        for(c[1]=c[0];c[1]<=10;c[1]++){\n            for(c[2]=c[1];c[2]<=10;c[2]++){\n                for(c[3]=c[2];c[3]<=10;c[3]++){\n                    if(check()){\n                        puts(\"yes\"); \n                        return;\n                    }\n                }\n            }\n        }\n    }\n    puts(\"no\");\n}\n\nint main()\n{\n    T = read();\n    while(T--){\n        for(int i=0;i<4;i++) a[i] = read();\n        for(int i=0;i<4;i++) b[i] = read();\n        solve();\n    }\n   return 0;\n}", "step": ["The program reads in an integer representing the number of test cases.", "A series of nested loops sets a range of valid values for a four-element array.", "An isWinner function is called which compares the Player 1 and Player 2 arrays, and counts how many times Player 1's numbers beat Player 2's numbers.", "The solve function calls check, to determine if Player 1 can beat all arrays of Player 2, using the valid array elements resulting from the nested loops.", "The main method contains a loop that iterates over each test case and calls solve.", "The program prints 'yes' or 'no', depending on the outcome of the solve function."], "nl_cn": "为了消磨牛棚里的时光，奶牛们喜欢玩简单的骰子游戏。其中一种游戏使用两个骰子 X 和 Y 进行。两个骰子均被投掷，获胜的骰子是显示的数字较大的骰子。如果两者显示相同的数字，则重新投掷（只要持续打平，骰子可能会被重新投掷多次）。我们称骰子 X 击败骰子 Y，如果骰子 X 比骰子 Y 更有可能赢得这局游戏。\n\n考虑以下的 $4$ 面骰子：\n\n骰子 A 在各面上有数字 $4$，$5$，$6$ 和 $7$。\n\n骰子 B 在各面上有数字 $2$，$4$，$5$ 和 $10$。\n\n骰子 C 在各面上有数字 $1$，$4$，$8$ 和 $9$。\n\n这些骰子满足一个相当奇妙的性质：A 击败 B，B 击败 C，并且 C 也击败 A。特别地，三个骰子都不是「最佳的」，可以击败其他两个。在这种情况下，当没有两个骰子打平，也没有一个骰子是最佳的，我们称这三个骰子的集合为「非传递的」。在非传递的三个骰子的集合中，每个骰子击败一个其他骰子，并输给另一个其他骰子。\n\n给定两个 $4$ 面骰子 A 和 B 各面上的数字，请帮助奶牛们求出是否有方法为第三个骰子 C 的各面分配数字，使得这个骰子的集合是非传递的。所有骰子面上的数字必须是 $1$ 到 $10$ 的整数。", "test_cases": [{"input": "3\n4 5 6 7 2 4 5 10\n2 2 2 2 1 1 1 1\n1 1 1 1 2 2 2 2", "output": "yes\nno\nno"}, {"input": "1\n1 1 1 1 10 10 10 10\n2 2 2 2 3 3 3 3 ", "output": "no"}, {"input": "1\n6 6 6 6 9 9 9 9\n1 1 1 1 4 4 4 4 ", "output": "no"}, {"input": "1\n2 4 6 8 3 5 7 9\n1 3 5 7 2 4 6 8 ", "output": "no"}, {"input": "1\n4 7 9 9 2 4 6 8\n1 3 5 7 10 10 10 10 ", "output": "no"}, {"input": "1\n2 4 6 8 3 6 7 8\n1 2 3 4 10 10 10 10 ", "output": "no"}, {"input": "1\n1 1 1 1 7 7 7 7\n2 2 2 2 8 8 8 8 ", "output": "no"}, {"input": "1\n3 6 9 10 2 2 2 2\n1 1 1 1 10 10 10 10 ", "output": "no"}, {"input": "1\n2 3 4 5 1 2 3 4\n5 6 7 8 1 2 3 4", "output": "no"}, {"input": "1\n10 10 10 10 8 8 8 8\n6 7 8 9 10 6 7 8", "output": "no"}, {"input": "2\n3 4 5 6 1 2 3 4\n5 6 7 8 1 2 3 4\n5 5 5 5 5 5 5 5", "output": "no\nno"}, {"input": "1\n7 8 9 10 1 2 3 4\n5 6 7 8 1 2 3 4", "output": "no"}, {"input": "2\n1 2 3 4 1 2 3 4\n1 2 3 4 1 2 3 4\n2 3 4 5 2 3 4 5", "output": "no\nno"}, {"input": "1\n5 6 7 8 5 6 7 8\n1 1 1 1 1 1 1 1", "output": "no"}, {"input": "1\n2 3 4 5 5 6 7 8\n2 3 4 5 5 6 7 8", "output": "no"}, {"input": "1\n1 2 3 4 5 6 7 8\n1 2 3 4 5 6 7 8", "output": "no"}, {"input": "1\n1 2 3 4 2 4 5 10\n10 10 10 10 9 9 9 9", "output": "no"}, {"input": "2\n5 6 7 8 2 4 5 10\n9 9 9 9 10 10 10 10\n1 2 3 4 5 6 7 8", "output": "no\nno"}, {"input": "1\n1 1 1 1 1 2 2 2\n1 1 1 1 1 2 2 2", "output": "no"}], "test": "#undef NDEBUG\n#include<assert.h>\nint main(){\n    assert(solution(\"3\\n4 5 6 7 2 4 5 10\\n2 2 2 2 1 1 1 1\\n1 1 1 1 2 2 2 2\") == \"yes\\nno\\nno\");\n    assert(solution(\"1\\n1 1 1 1 10 10 10 10\\n2 2 2 2 3 3 3 3 \") == \"no\");\n    assert(solution(\"1\\n6 6 6 6 9 9 9 9\\n1 1 1 1 4 4 4 4 \") == \"no\");\n    assert(solution(\"1\\n2 4 6 8 3 5 7 9\\n1 3 5 7 2 4 6 8 \") == \"no\");\n    assert(solution(\"1\\n4 7 9 9 2 4 6 8\\n1 3 5 7 10 10 10 10 \") == \"no\");\n    assert(solution(\"1\\n2 4 6 8 3 6 7 8\\n1 2 3 4 10 10 10 10 \") == \"no\");\n    assert(solution(\"1\\n1 1 1 1 7 7 7 7\\n2 2 2 2 8 8 8 8 \") == \"no\");\n    assert(solution(\"1\\n3 6 9 10 2 2 2 2\\n1 1 1 1 10 10 10 10 \") == \"no\");\n    assert(solution(\"1\\n2 3 4 5 1 2 3 4\\n5 6 7 8 1 2 3 4\") == \"no\");\n    assert(solution(\"1\\n10 10 10 10 8 8 8 8\\n6 7 8 9 10 6 7 8\") == \"no\");\n    assert(solution(\"2\\n3 4 5 6 1 2 3 4\\n5 6 7 8 1 2 3 4\\n5 5 5 5 5 5 5 5\") == \"no\\nno\");\n    assert(solution(\"1\\n7 8 9 10 1 2 3 4\\n5 6 7 8 1 2 3 4\") == \"no\");\n    assert(solution(\"2\\n1 2 3 4 1 2 3 4\\n1 2 3 4 1 2 3 4\\n2 3 4 5 2 3 4 5\") == \"no\\nno\");\n    assert(solution(\"1\\n5 6 7 8 5 6 7 8\\n1 1 1 1 1 1 1 1\") == \"no\");\n    assert(solution(\"1\\n2 3 4 5 5 6 7 8\\n2 3 4 5 5 6 7 8\") == \"no\");\n    assert(solution(\"1\\n1 2 3 4 5 6 7 8\\n1 2 3 4 5 6 7 8\") == \"no\");\n    assert(solution(\"1\\n1 2 3 4 2 4 5 10\\n10 10 10 10 9 9 9 9\") == \"no\");\n    assert(solution(\"2\\n5 6 7 8 2 4 5 10\\n9 9 9 9 10 10 10 10\\n1 2 3 4 5 6 7 8\") == \"no\\nno\");\n    assert(solution(\"1\\n1 1 1 1 1 2 2 2\\n1 1 1 1 1 2 2 2\") == \"no\");\n    return 0; \n}", "prompt": "/*To pass the time in the barn, cows like to play simple dice games. One game involves two dice, labeled X and Y. Both dice are thrown and the winner is the die showing the bigger number. If the two dice show the same number, they are thrown again (and again, potentially indefinitely, until a winner is determined). We will say that die X beats die Y if it is more likely to win the game.\n\nConsider the following four-sided dice:\n\nDie A has sides labeled 4, 5, 6, and 7.\n\nDie B has sides labeled 2, 4, 5, and 10.\n\nDie C has sides labeled 1, 4, 8, and 9.\n\nThese dice satisfy a rather remarkable property: A beats B, B beats C, and C beats A. In particular, none of the three is \"best\" in the sense that it beats the other two. In this case, when no two dice tie and no die is best, we will say that the set of three dice is \"non-transitive\", meaning that each die beats one of the others and loses to another.\n\nGiven two four-sided dice A and B, with each side labeled by an integer, help the cows determine whether it is possible to assign numbers to the sides of a third die C such that the set of three dice is non-transitive. The numbers on all sides of all dice must be integers between 1 and 10.\n\ninput_format:\nEach test case contains multiple independent sub-test cases, all of which must be answered correctly to pass the entire test case. The first line of input contains $T$($1\\le T\\le 10$) for the number of subtest cases you need to solve.\n\nThe following $T$lines, each describing A subtest case, contain $8$integers: integers on the $4$face of die A, and integers on the $4$face of die B. All numbers are between $1$and $10$and are not necessarily ordered. The same number may occur more than once, even on the same die.\n\noutput_format:\nOutput $T$line. If it is possible to assign numbers to die C such that the first $k$test case is a non-transitive set of dice, line $k$outputs' yes', otherwise 'no'.\n*/\n\n#include<sstream>\n#include<stdlib.h>\n#include<algorithm>\n#include<math.h>\n#include<stdio.h>\n#include<vector>\n#include<string>\n#include<climits>\n#include<cstring>\n#include<iostream>\nusing namespace std;\n\n             \nstring solution(string std_in){\n    istringstream iss(std_in);\n             ", "constraints": "**【样例解释】**\n\n第一个子测试用例对应题目中的例子。在第二个子测试用例中，不存在骰子 C 可以使得这个骰子集合是非传递的。同理第三个子测试用例的答案也是 `no`。\n\n", "samples": [["3\n4 5 6 7 2 4 5 10\n2 2 2 2 1 1 1 1\n1 1 1 1 2 2 2 2", "yes\nno\nno"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144]}}
{"task_id": "P6337", "title": "[COCI2007-2008#2] CRNE", "difficulty": "basic", "nl": "On a rectangular board, make cuts parallel to the edges of the rectangle for $n$ times. What is the maximum number of pieces the board can be divided into?", "code": "#include<bits/stdc++.h>\nusing namespace std;\nint n;\nint main()\n{\n\tcin>>n;\n\tcout<<(n/2+1)*(n-n/2+1);//公式 \n}", "step": ["Declare a variable n and take integer input from the standard input.", "Calculate a value using the formula (n/2+1)*(n-n/2+1).", "Print the calculated value to the standard output."], "nl_cn": "在一个矩形棋盘上，切与矩形的边平行的 $n$ 次，问最多棋盘能被切成多少块？", "test_cases": [{"input": "1", "output": "2"}, {"input": "3", "output": "6"}, {"input": "0\n", "output": "1"}, {"input": "10\n", "output": "36"}, {"input": "20\n", "output": "121"}, {"input": "50\n", "output": "676"}, {"input": "2\n", "output": "4"}, {"input": "5\n", "output": "12"}, {"input": "4\n", "output": "9"}, {"input": "7\n", "output": "20"}, {"input": "8\n", "output": "25"}, {"input": "9\n", "output": "30"}, {"input": "11\n", "output": "42"}, {"input": "12\n", "output": "49"}, {"input": "13\n", "output": "56"}, {"input": "14\n", "output": "64"}, {"input": "15\n", "output": "72"}, {"input": "16\n", "output": "81"}, {"input": "17\n", "output": "90"}, {"input": "18\n", "output": "100"}, {"input": "19\n", "output": "110"}, {"input": "6\n", "output": "16"}], "test": "#undef NDEBUG\n#include<assert.h>\nint main(){\n    assert(solution(\"1\") == \"2\");\n    assert(solution(\"3\") == \"6\");\n    assert(solution(\"0\\n\") == \"1\");\n    assert(solution(\"10\\n\") == \"36\");\n    assert(solution(\"20\\n\") == \"121\");\n    assert(solution(\"50\\n\") == \"676\");\n    assert(solution(\"2\\n\") == \"4\");\n    assert(solution(\"5\\n\") == \"12\");\n    assert(solution(\"4\\n\") == \"9\");\n    assert(solution(\"7\\n\") == \"20\");\n    assert(solution(\"8\\n\") == \"25\");\n    assert(solution(\"9\\n\") == \"30\");\n    assert(solution(\"11\\n\") == \"42\");\n    assert(solution(\"12\\n\") == \"49\");\n    assert(solution(\"13\\n\") == \"56\");\n    assert(solution(\"14\\n\") == \"64\");\n    assert(solution(\"15\\n\") == \"72\");\n    assert(solution(\"16\\n\") == \"81\");\n    assert(solution(\"17\\n\") == \"90\");\n    assert(solution(\"18\\n\") == \"100\");\n    assert(solution(\"19\\n\") == \"110\");\n    assert(solution(\"6\\n\") == \"16\");\n    return 0; \n}", "prompt": "/*On a rectangular board, make cuts parallel to the edges of the rectangle for $n$ times. What is the maximum number of pieces the board can be divided into?\n\ninput_format:\nEnter a line with an integer $n$.\n\noutput_format:\nThe output line is an integer representing the maximum number of blocks the board can be divided into.\n*/\n\n#include<sstream>\n#include<stdlib.h>\n#include<algorithm>\n#include<math.h>\n#include<stdio.h>\n#include<vector>\n#include<string>\n#include<climits>\n#include<cstring>\n#include<iostream>\nusing namespace std;\n\n             \nstring solution(string std_in){\n    istringstream iss(std_in);\n             ", "constraints": "#### 数据规模与约定\n\n对于 $100\\%$ 的数据，保证 $1\\le n\\le 100$。\n#### 说明\n\n**题目译自 [COCI2007-2008](https://hsin.hr/coci/archive/2007_2008/) [CONTEST #2](https://hsin.hr/coci/archive/2007_2008/contest2_tasks.pdf) *T2 CRNE***。", "samples": [["1", "2"], ["3", "6"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000], "memory": [32000, 32000, 32000, 32000, 32000]}}
{"task_id": "P7772", "title": "[COCI2009-2010#2] FAKTOR", "difficulty": "basic", "nl": "Given $A,I$, find the minimum $N$ such that $\\lceil\\frac{N}{A}\\rceil\\geq I$.", "code": "#include<bits/stdc++.h>\nusing namespace std;\nint main(){\n    int a,b;//数很小，不用开long long\n    cin>>a>>b;\n    cout<<a*(b-1)+1;\n\treturn 0;\n}", "step": ["Declare two integers a and b.", "Read values for a and b from the user.", "Calculate the value using the formula 'a*(b-1)+1'.", "Display the calculated value.", "Return 0 to end the program."], "nl_cn": "给定 $A,I$，求一个最小的 $N$，使得$\\lceil\\frac{N}{A}\\rceil\\geq I$。", "test_cases": [{"input": "38 24", "output": "875"}, {"input": "1 100", "output": "100"}, {"input": "10 10", "output": "91"}, {"input": "4 25\n", "output": "97"}, {"input": "2 30\n", "output": "59"}, {"input": "5 5", "output": "21"}, {"input": "100 100", "output": "9901"}, {"input": "12 6", "output": "61"}, {"input": "3 7", "output": "19"}, {"input": "8 4", "output": "25"}, {"input": "5 15\n", "output": "71"}, {"input": "20 7\n", "output": "121"}, {"input": "18 8\n", "output": "127"}, {"input": "30 1\n", "output": "1"}, {"input": "12 12\n", "output": "133"}, {"input": "60 4\n", "output": "181"}, {"input": "100 1\n", "output": "1"}, {"input": "0 0\n", "output": "1"}, {"input": "50 3\n", "output": "101"}, {"input": "7 7\n", "output": "43"}, {"input": "20 5\n", "output": "81"}, {"input": "100 2\n", "output": "101"}, {"input": "5 20\n", "output": "96"}, {"input": "7 8\n", "output": "50"}], "test": "#undef NDEBUG\n#include<assert.h>\nint main(){\n    assert(solution(\"38 24\") == \"875\");\n    assert(solution(\"1 100\") == \"100\");\n    assert(solution(\"10 10\") == \"91\");\n    assert(solution(\"4 25\\n\") == \"97\");\n    assert(solution(\"2 30\\n\") == \"59\");\n    assert(solution(\"5 5\") == \"21\");\n    assert(solution(\"100 100\") == \"9901\");\n    assert(solution(\"12 6\") == \"61\");\n    assert(solution(\"3 7\") == \"19\");\n    assert(solution(\"8 4\") == \"25\");\n    assert(solution(\"5 15\\n\") == \"71\");\n    assert(solution(\"20 7\\n\") == \"121\");\n    assert(solution(\"18 8\\n\") == \"127\");\n    assert(solution(\"30 1\\n\") == \"1\");\n    assert(solution(\"12 12\\n\") == \"133\");\n    assert(solution(\"60 4\\n\") == \"181\");\n    assert(solution(\"100 1\\n\") == \"1\");\n    assert(solution(\"0 0\\n\") == \"1\");\n    assert(solution(\"50 3\\n\") == \"101\");\n    assert(solution(\"7 7\\n\") == \"43\");\n    assert(solution(\"20 5\\n\") == \"81\");\n    assert(solution(\"100 2\\n\") == \"101\");\n    assert(solution(\"5 20\\n\") == \"96\");\n    assert(solution(\"7 8\\n\") == \"50\");\n    return 0; \n}", "prompt": "/*Given $A,I$, find the minimum $N$ such that $\\lceil\\frac{N}{A}\\rceil\\geq I$.\n\ninput_format:\nA row of two integers $A,I$.\n\noutput_format:\nOne line is an integer $N$.\n*/\n\n#include<sstream>\n#include<stdlib.h>\n#include<algorithm>\n#include<math.h>\n#include<stdio.h>\n#include<vector>\n#include<string>\n#include<climits>\n#include<cstring>\n#include<iostream>\nusing namespace std;\n\n             \nstring solution(string std_in){\n    istringstream iss(std_in);\n             ", "constraints": "$1\\leq A,I\\leq 100$。", "samples": [["38 24", "875"], ["1 100", "100"], ["10 10", "91"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [32768, 32768, 32768, 32768, 32768, 32768, 32768, 32768, 32768, 32768]}}
{"task_id": "P3609", "title": "[USACO17JAN]Hoof, Paper, Scissor G", "difficulty": "advanced", "nl": "You may have played \"Rock, Paper, Scissors\" before, which is also popular among cows, but it is called \"Hoof, Scissors, Cloth\" here.\n\nThe rules of \"Hoof, Scissors, Cloth\" are very similar to \"Rock, Paper, Scissors\". Two cows count to three and then make a gesture representing hoof, scissors or cloth. Hoof beats scissors, scissors beats cloth, and cloth beats hoof. In particular, if the gestures of the two cows are the same, it is considered a draw.\n\nNow FJ and Bassie are going to compete for $N$ rounds. Bassie has predicted FJ's gesture for each round. However, Bassie is lazy and she only wants to change her own gesture for at most $K$ times.\n\nNow please help Bassie to find out how many rounds she can win at most.", "code": "#include<map>\n#include<cstdio>\n#include<iostream>\nusing namespace std;\nmap <char,int> qwq;\nint pk[4][4];\nvoid orz(){\n\tqwq['H']=1;\tqwq['S']=2;\tqwq['P']=3;\n\tpk[1][2]=1; pk[2][3]=1; pk[3][1]=1;\n\treturn ;\n}\nint a[100010],f[100010][21][4];\nint main(){\n\torz();\n\tint n,s;\n\tchar x=' ';\n\tcin>>n>>s;\n\tfor(int i=1;i<=n;i++){\n\t\tcin>>x;\n\t\ta[i]=qwq[x];\n\t}\n\tfor(int i=1;i<=n;i++)\n\t\tfor(int j=0;j<=min(s,i);j++)\n\t\t\tfor(int k=1;k<=3;k++){\n\t\t\t\tint t=pk[k][a[i]];\n\t\t\t\tf[i][j][k]=max(f[i-1][j][k]+t,f[i][j][k]);\n\t\t\t\tfor(int l=1;l<=3;l++)\n\t\t\t\t\tif(l!=k&&j)\n\t\t\t\t\t\tf[i][j][k]=max(f[i-1][j-1][l]+t,f[i][j][k]);\n\t\t\t}\n\tint ans=0;\n\tfor(int i=1;i<=3;i++)\n\t\tans=max(f[n][s][i],ans);\n\tcout<<ans;\n\treturn 0;\n}", "step": ["Read in the game length and number of moves allowed.", "Read in each player's move and accumulate their scores and bonuses/penalties.", "Initialize the base cases for the dynamic programming algorithm.", "Use dynamic programming to compute the maximum score for all possible move combinations.", "Return the maximum score attainable for the given game length and number of moves allowed."], "nl_cn": "你可能玩过“石头，剪刀，布”，这个游戏在奶牛中同样流行，不过它的名字变成了“蹄子，剪刀，布”。\n\n“蹄子，剪刀，布”和“石头，剪刀，布”的规则十分类似，两只奶牛数到三，然后出一个代表蹄子，剪刀或布的手势。蹄子胜过剪刀，剪刀胜过布，布胜过蹄子。特别地，如果两只奶牛的手势相同，则视为平局。\n\n现在 FJ 和 Bassie 要进行 $N$ 轮对抗。Bassie 已经预测了 FJ 每一轮要出的手势。然而 Bassie 很懒，她最多只想变换 $K$ 次手势。\n\n现在请你帮 Bassie 求出她最多能赢多少轮。", "test_cases": [{"input": "5 1\nP\nP\nH\nP\nS", "output": "4"}, {"input": "3 0\nH\nS\nP\n", "output": "1"}, {"input": "4 0\nP\nS\nS\nH\n", "output": "2"}, {"input": "2 1\nP\nH\n", "output": "2"}, {"input": "5 0\nH\nP\nH\nS\nS\n", "output": "2"}, {"input": "3 1\nH\nS\nP\n", "output": "2"}, {"input": "8 3\nH\nP\nP\nP\nS\nH\nH\nS\n", "output": "7"}, {"input": "4 0\nS\nS\nP\nH\n", "output": "2"}, {"input": "7 2\nH\nP\nH\nH\nP\nS\nS\n", "output": "6"}, {"input": "2 0\nH\nP\n", "output": "1"}, {"input": "9 4\nP\nH\nP\nP\nS\nS\nH\nS\nH\n", "output": "8"}, {"input": "5 1\nH\nH\nP\nH\nS\n", "output": "4"}, {"input": "5 0\nH\nS\nP\nP\nP", "output": "3"}, {"input": "6 1\nH\nH\nP\nS\nS\nP", "output": "4"}, {"input": "4 0\nS\nP\nS\nH", "output": "2"}, {"input": "8 3\nS\nP\nH\nH\nP\nH\nP\nH", "output": "6"}, {"input": "5 2\nP\nS\nH\nS\nP", "output": "4"}, {"input": "7 0\nP\nH\nP\nH\nH\nS\nH", "output": "4"}, {"input": "4 1\nP\nS\nS\nP", "output": "3"}, {"input": "6 1\nS\nH\nS\nP\nS\nH", "output": "4"}, {"input": "7 3\nS\nP\nH\nS\nP\nH\nP", "output": "5"}, {"input": "5 0\nP\nS\nH\nP\nS ", "output": "2"}, {"input": "6 1\nH\nP\nS\nH\nP\nS ", "output": "3"}, {"input": "3 1\nP\nS\nP ", "output": "2"}, {"input": "5 1\nP\nH\nS\nS\nH ", "output": "3"}, {"input": "4 0\nH\nP\nP\nH ", "output": "2"}, {"input": "1 1\nH\n", "output": "1"}, {"input": "4 3\nS\nP\nP\nH\n", "output": "4"}, {"input": "4 1\nP\nH\nS\nH\n", "output": "3"}, {"input": "5 3\nS\nH\nP\nS\nP\n", "output": "4"}, {"input": "4 0\nP\nH\nP\nS\n", "output": "2"}, {"input": "5 1\nH\nS\nH\nP\nS\n", "output": "3"}, {"input": "3 1\nP\nH\nP\n", "output": "2"}, {"input": "2 0\nP\nS\n", "output": "1"}], "test": "#undef NDEBUG\n#include<assert.h>\nint main(){\n    assert(solution(\"5 1\\nP\\nP\\nH\\nP\\nS\") == \"4\");\n    assert(solution(\"3 0\\nH\\nS\\nP\\n\") == \"1\");\n    assert(solution(\"4 0\\nP\\nS\\nS\\nH\\n\") == \"2\");\n    assert(solution(\"2 1\\nP\\nH\\n\") == \"2\");\n    assert(solution(\"5 0\\nH\\nP\\nH\\nS\\nS\\n\") == \"2\");\n    assert(solution(\"3 1\\nH\\nS\\nP\\n\") == \"2\");\n    assert(solution(\"8 3\\nH\\nP\\nP\\nP\\nS\\nH\\nH\\nS\\n\") == \"7\");\n    assert(solution(\"4 0\\nS\\nS\\nP\\nH\\n\") == \"2\");\n    assert(solution(\"7 2\\nH\\nP\\nH\\nH\\nP\\nS\\nS\\n\") == \"6\");\n    assert(solution(\"2 0\\nH\\nP\\n\") == \"1\");\n    assert(solution(\"9 4\\nP\\nH\\nP\\nP\\nS\\nS\\nH\\nS\\nH\\n\") == \"8\");\n    assert(solution(\"5 1\\nH\\nH\\nP\\nH\\nS\\n\") == \"4\");\n    assert(solution(\"5 0\\nH\\nS\\nP\\nP\\nP\") == \"3\");\n    assert(solution(\"6 1\\nH\\nH\\nP\\nS\\nS\\nP\") == \"4\");\n    assert(solution(\"4 0\\nS\\nP\\nS\\nH\") == \"2\");\n    assert(solution(\"8 3\\nS\\nP\\nH\\nH\\nP\\nH\\nP\\nH\") == \"6\");\n    assert(solution(\"5 2\\nP\\nS\\nH\\nS\\nP\") == \"4\");\n    assert(solution(\"7 0\\nP\\nH\\nP\\nH\\nH\\nS\\nH\") == \"4\");\n    assert(solution(\"4 1\\nP\\nS\\nS\\nP\") == \"3\");\n    assert(solution(\"6 1\\nS\\nH\\nS\\nP\\nS\\nH\") == \"4\");\n    assert(solution(\"7 3\\nS\\nP\\nH\\nS\\nP\\nH\\nP\") == \"5\");\n    assert(solution(\"5 0\\nP\\nS\\nH\\nP\\nS \") == \"2\");\n    assert(solution(\"6 1\\nH\\nP\\nS\\nH\\nP\\nS \") == \"3\");\n    assert(solution(\"3 1\\nP\\nS\\nP \") == \"2\");\n    assert(solution(\"5 1\\nP\\nH\\nS\\nS\\nH \") == \"3\");\n    assert(solution(\"4 0\\nH\\nP\\nP\\nH \") == \"2\");\n    assert(solution(\"1 1\\nH\\n\") == \"1\");\n    assert(solution(\"4 3\\nS\\nP\\nP\\nH\\n\") == \"4\");\n    assert(solution(\"4 1\\nP\\nH\\nS\\nH\\n\") == \"3\");\n    assert(solution(\"5 3\\nS\\nH\\nP\\nS\\nP\\n\") == \"4\");\n    assert(solution(\"4 0\\nP\\nH\\nP\\nS\\n\") == \"2\");\n    assert(solution(\"5 1\\nH\\nS\\nH\\nP\\nS\\n\") == \"3\");\n    assert(solution(\"3 1\\nP\\nH\\nP\\n\") == \"2\");\n    assert(solution(\"2 0\\nP\\nS\\n\") == \"1\");\n    return 0; \n}", "prompt": "/*You may have played \"Rock, Paper, Scissors\" before, which is also popular among cows, but it is called \"Hoof, Scissors, Cloth\" here.\n\nThe rules of \"Hoof, Scissors, Cloth\" are very similar to \"Rock, Paper, Scissors\". Two cows count to three and then make a gesture representing hoof, scissors or cloth. Hoof beats scissors, scissors beats cloth, and cloth beats hoof. In particular, if the gestures of the two cows are the same, it is considered a draw.\n\nNow FJ and Bassie are going to compete for $N$ rounds. Bassie has predicted FJ's gesture for each round. However, Bassie is lazy and she only wants to change her own gesture for at most $K$ times.\n\nNow please help Bassie to find out how many rounds she can win at most.\n\ninput_format:\nOn the first line, enter two integers $N,K$($1 \\leq N \\leq 10^5$, $0 \\leq K \\leq 20$).\n\nThe next $N$line, one letter per line, represents the gesture of the FJ round. 'H' stands for Hoof, 'S' for Scissors, and 'P' for Paper.\n\noutput_format:\nOutputs an integer representing the maximum number of rounds Bassie can win with a maximum of $K$gestures.\n*/\n\n#include<sstream>\n#include<stdlib.h>\n#include<algorithm>\n#include<math.h>\n#include<stdio.h>\n#include<vector>\n#include<string>\n#include<climits>\n#include<cstring>\n#include<iostream>\nusing namespace std;\n\n             \nstring solution(string std_in){\n    istringstream iss(std_in);\n             ", "constraints": "", "samples": [["5 1\nP\nP\nH\nP\nS", "4\n"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}}
{"task_id": "P2800", "title": "又上锁妖塔", "difficulty": "challenge", "nl": "Small A is playing \"Immortal Sword\" and he encountered a Demon Tower that he wants to climb from the outside.\n\nThe Demon Tower has a total of n floors, and the height of the i-th floor is h_i. Small A can use his magic, and each time he can jump up one or two floors, but after each jump Small A will be exhausted and must climb at least one floor before jumping again (you can assume that Small A needs to rest by jumping two floors twice).\n\nNow Small A wants you to help him calculate the shortest time to climb to the top of the tower.", "code": "#include<bits/stdc++.h>\nusing namespace std;\n\nint n;\nint a[1000005];\nint f[1000005];\n\nint main() {\n\tcin>>n;\n\tfor(int i=1; i<=n; i++) {\n\t\tcin>>a[i];\n\t\tf[i]=1e9;//注意初始化\n\t}\n\tf[n+1]=1e9;\n\t\n\tfor(int i=1; i<=n+1; i++) {//循环到n+1\n\t\tf[i]=min(f[i],f[i-1]);\n\t\tf[i]=min(f[i],f[i-2]);\n\t\tf[i]=min(f[i],f[i-3]);\n\t\tf[i]+=a[i];\n\t}\n\t\n\tcout<<f[n+1];//输出解\n\treturn 0;//愉快的结束\n}", "step": ["Declare variables n, a and f.", "Loop through the array a and initialize all values of f to 1e9.", "Perform dynamic programming to compute the minimum cost to reach each index i of the array.", "Return the minimum cost to reach the end of the array."], "nl_cn": "小 A 在玩《剑仙》，他遇到了一个锁妖塔，想从外面爬上去。\n\n锁妖塔共有 $n$ 层，第 $i$ 层的高度为 $h_i$。小 A 会用仙术，每用一次可以让他向上跳一层或两层，但是每次跳跃后小 A 都将用完力气，必须爬过至少一层才能再次跳跃（你可以认为小 A 需要跳两次一层才休息）。\n\n现在小 A 想让你帮他算出爬上塔顶的最短时间。", "test_cases": [{"input": "5\n3 5 1 8 4", "output": "1"}, {"input": "5\n9 9 9 9 9\n", "output": "9"}, {"input": "9\n6 5 4 3 2 1 7 8 9\n", "output": "12"}, {"input": "12\n1 2 3 4 5 6 7 8 9 10 11 12\n", "output": "22"}, {"input": "7\n1 1 1 1 1 1 1\n", "output": "2"}, {"input": "7\n7 7 7 7 7 7 7\n", "output": "14"}], "test": "#undef NDEBUG\n#include<assert.h>\nint main(){\n    assert(solution(\"5\\n3 5 1 8 4\") == \"1\");\n    assert(solution(\"5\\n9 9 9 9 9\\n\") == \"9\");\n    assert(solution(\"9\\n6 5 4 3 2 1 7 8 9\\n\") == \"12\");\n    assert(solution(\"12\\n1 2 3 4 5 6 7 8 9 10 11 12\\n\") == \"22\");\n    assert(solution(\"7\\n1 1 1 1 1 1 1\\n\") == \"2\");\n    assert(solution(\"7\\n7 7 7 7 7 7 7\\n\") == \"14\");\n    return 0; \n}", "prompt": "/*Small A is playing \"Immortal Sword\" and he encountered a Demon Tower that he wants to climb from the outside.\n\nThe Demon Tower has a total of n floors, and the height of the i-th floor is h_i. Small A can use his magic, and each time he can jump up one or two floors, but after each jump Small A will be exhausted and must climb at least one floor before jumping again (you can assume that Small A needs to rest by jumping two floors twice).\n\nNow Small A wants you to help him calculate the shortest time to climb to the top of the tower.\n\ninput_format:\nThe first line contains an integer $n \\in [1, 10^6]$.\n\nThe second line contains $n$ integers $h_i \\in [1, 100]$, representing the height of the $i$-th layer from bottom to top.\n\noutput_format:\nA number $t$indicates the shortest time.\n*/\n\n#include<sstream>\n#include<stdlib.h>\n#include<algorithm>\n#include<math.h>\n#include<stdio.h>\n#include<vector>\n#include<string>\n#include<climits>\n#include<cstring>\n#include<iostream>\nusing namespace std;\n\n             \nstring solution(string std_in){\n    istringstream iss(std_in);\n             ", "constraints": "", "samples": [["5\n3 5 1 8 4", "1"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}}
{"task_id": "P7280", "title": "[COCI2020-2021#4] Pizza", "difficulty": "challenge", "nl": "The pizza shop offers $m$ different types of pizzas. Each pizza uses positive integers to represent the ingredients. The $i$-th pizza has $k_i$ ingredients, numbered as $b_{i,1},b_{i,2},\\cdots,b_{i,k_i}$.\n\nMirko is particularly picky when it comes to food. He dislikes $n$ types of ingredients, numbered as $a_1,a_2,\\cdots,a_n$. Therefore, he wants to order a pizza that does not contain any of the above ingredients. Determine the number of pizzas that Mirko can order.", "code": "#include<bits/stdc++.h>\nusing namespace std;\nint n,m,ans;\nint a[105],b[105],t[105];\nint main(){\n\tscanf(\"%d\",&n);\n\tfor(int i=1;i<=n;i++) scanf(\"%d\",&a[i]),t[a[i]]=1;//输入Mirko不喜欢的配料，并用桶标记 \n\tscanf(\"%d\",&m);\n\tfor(int i=1;i<=m;i++){\n\t\tint k,x,trap=0;scanf(\"%d\",&k);//k代表当前披萨有几个配料，x代表是哪种配料，trap标记当前披萨有无Mirko不喜欢的配料 \n\t\tfor(int j=1;j<=k;j++){\n\t\t\tscanf(\"%d\",&x);\n\t\t\tif(t[x]) trap=1;//如果当前配料Mirko不喜欢，则标记为1\n\t\t}\n\t\tif(trap==0) ans++;//如果没有被标记，则ans++ \n\t}\n\tprintf(\"%d\",ans);\n}", "step": ["Initialize variables for the length of two arrays and a counter", "Input the first array and create a flag array using its elements as indexes", "Input the second array and loop through each group", "For each group, check if any of its elements exist in the flag array", "If none of the elements exist, increment the counter", "Output the final count"], "nl_cn": "比萨店提供 $m$ 种不同的比萨。比萨的配料使用正整数来编号。第 $i$ 个比萨有 $k_i$ 种配料，编号分别为 $b_{i,1},b_{i,2},\\cdots,b_{i,k_i}$。\n\nMirko 在食物面前格外挑剔。他不喜欢其中的 $n$ 种配料，即编号为 $a_1,a_2,\\cdots,a_n$ 的配料，因此他想订购一个没有上述配料的比萨。求 Mirko 能订购的比萨的数量。", "test_cases": [{"input": "1 2\n3\n1 1\n1 2\n1 3", "output": "2"}, {"input": "2 1 2\n4\n2 1 4\n3 1 2 3\n2 3 4\n3 3 5 7", "output": "2"}, {"input": "1 4\n3\n1 1\n1 2\n1 3", "output": "3"}, {"input": "2 1\n2\n4\n2 1 4\n3 1 2 3\n2 3 4\n3 3 5 7", "output": "2"}, {"input": "3 2\n5\n1 2 3 4 5\n5 4 3 2 1\n2 1\n2 2", "output": "0"}, {"input": "4 4\n7\n2 4 6\n1 3 5\n3 5 6\n1 2 3 4 5\n5 4 3 2 1\n2 4\n1 6\n5 2 1 3 6", "output": "2"}, {"input": "5 5\n10\n2 4 6\n1 3 5\n3 5 6\n1 2 3 4 5\n5 4 3 2 1\n2 4\n1 6\n5 2 1 3 6\n2 4 6 8 10\n3 1 5 9", "output": "0"}, {"input": "8 3\n7\n2 4 6\n1 3 5\n3 5 6\n1 2 3 4 5\n5 4 3 2 1\n2 2\n3 4 5\n2 3\n1 6\n5 2 1 3 6\n1 5\n6 2\n9 10", "output": "0"}, {"input": "9 4\n10\n2 4 6\n1 3 5\n3 5 6\n1 2 3 4 5\n5 4 3 2 1\n2 2\n3 4 5\n2 3\n1 6\n5 2 1 3 6\n1 5\n6 2\n4 6 7 9\n6 8 10", "output": "0"}, {"input": "11 2\n8\n2 4 6\n1 3 5\n3 5 6\n1 2 3 4 5\n5 4 3 2 1\n2 2\n3 4 5\n2 3\n1 6\n5 2 1 3 6\n1 5\n6 2\n9 10\n6 8 10\n4 5 7 9\n1 2 3 4 5 6 7 8", "output": "0"}, {"input": "14 2\n9\n2 4 6\n1 3 5\n3 5 6\n1 2 3 4 5\n5 4 3 2 1\n2 2\n3 4 5\n2 3\n1 6\n5 2 1 3 6\n1 5\n6 2\n9 10\n6 8 10\n4 5 7 9\n1 2 3 4 5 6 7 8\n3 5 7 9 11\n1 5 9 13\n2 4 6 8 10 12 14", "output": "0"}, {"input": "0 0\n0\n", "output": "0"}, {"input": "1 1\n1\n1 1\n", "output": "0"}, {"input": "3 2\n1\n1 3\n2 1 2\n2 2 3\n", "output": "1"}, {"input": "2 1\n2\n2 1 2\n2 1 2\n", "output": "0"}, {"input": "4 3\n2\n1 2\n1 2\n2 1 2\n3 2 3 4\n4 1 2 3 4\n", "output": "0"}, {"input": "3 3\n3\n1 3 5\n2 2\n2 1 2\n2 2 3\n3 1 2 3\n", "output": "0"}, {"input": "3 4\n3\n1 2 3\n1 2\n2 1 3\n2 1 2\n3 1 2 3\n4 1 2 3 4\n", "output": "0"}, {"input": "2 3\n5\n3 6 10\n2 5 7\n3 2 4 7\n4 4 6 9 10\n2 7 10\n", "output": "2"}, {"input": "3 2\n4\n1 2 3 4\n2 1 5\n1 3\n", "output": "0"}, {"input": "2 2\n4\n1 2 3 4\n2 1 5\n2 1 4\n", "output": "0"}, {"input": "3 3\n6\n1 2 3 4 5 6\n1 2\n1 3\n1 4\n", "output": "1"}, {"input": "4 3\n5\n1 2 3 4 5\n1 3\n2 3 10\n2 4 5\n", "output": "1"}, {"input": "3 1\n5\n1 2 3 4 5\n1 5\n3 1 2 3\n", "output": "0"}, {"input": "3 1\n5\n1 2 3 4 5\n1 5\n3 1 5 6\n", "output": "0"}], "test": "#undef NDEBUG\n#include<assert.h>\nint main(){\n    assert(solution(\"1 2\\n3\\n1 1\\n1 2\\n1 3\") == \"2\");\n    assert(solution(\"2 1 2\\n4\\n2 1 4\\n3 1 2 3\\n2 3 4\\n3 3 5 7\") == \"2\");\n    assert(solution(\"1 4\\n3\\n1 1\\n1 2\\n1 3\") == \"3\");\n    assert(solution(\"2 1\\n2\\n4\\n2 1 4\\n3 1 2 3\\n2 3 4\\n3 3 5 7\") == \"2\");\n    assert(solution(\"3 2\\n5\\n1 2 3 4 5\\n5 4 3 2 1\\n2 1\\n2 2\") == \"0\");\n    assert(solution(\"4 4\\n7\\n2 4 6\\n1 3 5\\n3 5 6\\n1 2 3 4 5\\n5 4 3 2 1\\n2 4\\n1 6\\n5 2 1 3 6\") == \"2\");\n    assert(solution(\"5 5\\n10\\n2 4 6\\n1 3 5\\n3 5 6\\n1 2 3 4 5\\n5 4 3 2 1\\n2 4\\n1 6\\n5 2 1 3 6\\n2 4 6 8 10\\n3 1 5 9\") == \"0\");\n    assert(solution(\"8 3\\n7\\n2 4 6\\n1 3 5\\n3 5 6\\n1 2 3 4 5\\n5 4 3 2 1\\n2 2\\n3 4 5\\n2 3\\n1 6\\n5 2 1 3 6\\n1 5\\n6 2\\n9 10\") == \"0\");\n    assert(solution(\"9 4\\n10\\n2 4 6\\n1 3 5\\n3 5 6\\n1 2 3 4 5\\n5 4 3 2 1\\n2 2\\n3 4 5\\n2 3\\n1 6\\n5 2 1 3 6\\n1 5\\n6 2\\n4 6 7 9\\n6 8 10\") == \"0\");\n    assert(solution(\"11 2\\n8\\n2 4 6\\n1 3 5\\n3 5 6\\n1 2 3 4 5\\n5 4 3 2 1\\n2 2\\n3 4 5\\n2 3\\n1 6\\n5 2 1 3 6\\n1 5\\n6 2\\n9 10\\n6 8 10\\n4 5 7 9\\n1 2 3 4 5 6 7 8\") == \"0\");\n    assert(solution(\"14 2\\n9\\n2 4 6\\n1 3 5\\n3 5 6\\n1 2 3 4 5\\n5 4 3 2 1\\n2 2\\n3 4 5\\n2 3\\n1 6\\n5 2 1 3 6\\n1 5\\n6 2\\n9 10\\n6 8 10\\n4 5 7 9\\n1 2 3 4 5 6 7 8\\n3 5 7 9 11\\n1 5 9 13\\n2 4 6 8 10 12 14\") == \"0\");\n    assert(solution(\"0 0\\n0\\n\") == \"0\");\n    assert(solution(\"1 1\\n1\\n1 1\\n\") == \"0\");\n    assert(solution(\"3 2\\n1\\n1 3\\n2 1 2\\n2 2 3\\n\") == \"1\");\n    assert(solution(\"2 1\\n2\\n2 1 2\\n2 1 2\\n\") == \"0\");\n    assert(solution(\"4 3\\n2\\n1 2\\n1 2\\n2 1 2\\n3 2 3 4\\n4 1 2 3 4\\n\") == \"0\");\n    assert(solution(\"3 3\\n3\\n1 3 5\\n2 2\\n2 1 2\\n2 2 3\\n3 1 2 3\\n\") == \"0\");\n    assert(solution(\"3 4\\n3\\n1 2 3\\n1 2\\n2 1 3\\n2 1 2\\n3 1 2 3\\n4 1 2 3 4\\n\") == \"0\");\n    assert(solution(\"2 3\\n5\\n3 6 10\\n2 5 7\\n3 2 4 7\\n4 4 6 9 10\\n2 7 10\\n\") == \"2\");\n    assert(solution(\"3 2\\n4\\n1 2 3 4\\n2 1 5\\n1 3\\n\") == \"0\");\n    assert(solution(\"2 2\\n4\\n1 2 3 4\\n2 1 5\\n2 1 4\\n\") == \"0\");\n    assert(solution(\"3 3\\n6\\n1 2 3 4 5 6\\n1 2\\n1 3\\n1 4\\n\") == \"1\");\n    assert(solution(\"4 3\\n5\\n1 2 3 4 5\\n1 3\\n2 3 10\\n2 4 5\\n\") == \"1\");\n    assert(solution(\"3 1\\n5\\n1 2 3 4 5\\n1 5\\n3 1 2 3\\n\") == \"0\");\n    assert(solution(\"3 1\\n5\\n1 2 3 4 5\\n1 5\\n3 1 5 6\\n\") == \"0\");\n    return 0; \n}", "prompt": "/*The pizza shop offers $m$ different types of pizzas. Each pizza uses positive integers to represent the ingredients. The $i$-th pizza has $k_i$ ingredients, numbered as $b_{i,1},b_{i,2},\\cdots,b_{i,k_i}$.\n\nMirko is particularly picky when it comes to food. He dislikes $n$ types of ingredients, numbered as $a_1,a_2,\\cdots,a_n$. Therefore, he wants to order a pizza that does not contain any of the above ingredients. Determine the number of pizzas that Mirko can order.\n\ninput_format:\nOn the first line, enter an integer $n$to indicate the number of ingredients Mirko doesn't like. Next, enter $n$a number of different integers $a_i$to indicate that Mirko does not like the number of the ingredient.\n\nOn the second line, enter an integer $m$to represent the number of pizzas.\n\nOn the next $m$line, enter an integer $k_i$on the first $i$line, representing the number of ingredients for the first $i$pizza. Next, enter $k_i$a different integer $b_{i,j}$to indicate the pizza ingredient number.\n\nThere will never be two pizzas with exactly the same ingredients.\n\noutput_format:\nOutput the number of pizzas Mirko can order.\n*/\n\n#include<sstream>\n#include<stdlib.h>\n#include<algorithm>\n#include<math.h>\n#include<stdio.h>\n#include<vector>\n#include<string>\n#include<climits>\n#include<cstring>\n#include<iostream>\nusing namespace std;\n\n             \nstring solution(string std_in){\n    istringstream iss(std_in);\n             ", "constraints": "#### 数据规模与约定\n\n对于 $40\\%$ 的数据，$n=k_1=k_2=\\cdots=k_m=1$。\n\n对于 $100\\%$ 的数据，$1 \\le n,m,a_i,k_i,b_{i,j} \\le 100$。\n\n#### 说明\n\n**本题分值按 COCI 原题设置，满分 $50$。**\n\n**题目译自 [COCI2020-2021](https://hsin.hr/coci/) [CONTEST #4](https://hsin.hr/coci/contest4_tasks.pdf)  _T1 Pizza_。**", "samples": [["1 2\n3\n1 1\n1 2\n1 3", "2"], ["2 1 2\n4\n2 1 4\n3 1 2 3\n2 3 4\n3 3 5 7", "2"], ["1 4\n3\n1 1\n1 2\n1 3", "3"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000]}}
{"task_id": "P2174", "title": "小Z的神奇数列", "difficulty": "advanced", "nl": "You need to maintain a multi-set that supports the following five operations:\n\n- `D x` deletes `x` from the set, and `x` is guaranteed to be in the set. If there are multiple `x`, only one needs to be deleted.\n\n- `B` queries the maximum value in the set.\n\n- `S` queries the minimum value in the set.\n\n- `M` let the maximum value in the set be `a`, the minimum value be `b`, and query `a^b mod 317847191`.\n\n- `T` queries the product of all numbers in the set, mod `317847191`.\n\nFor all queries, the set is guaranteed to be non-empty.", "code": "#include<cstdio>\n#include<cstring>\n#include<algorithm>\n#define I inline\n#define LL long long\n#define R register\n#define mod 317847191\n#define inf 2147483647\nusing namespace std;\n    int n,m;\n    LL maxx=-2147483647,minn=2147483647,sum=1;\n    LL a[1000001],p[1000001][3],ans[1000001];\nI LL readint()\n{\n    LL x=0;\n    int f=1;\n    char ch=getchar();\n    for(;ch<'0'||ch>'9';ch=getchar())\n        if(ch=='-') f=-1;\n    for(;ch>='0'&&ch<='9';x=(x<<3)+(x<<1)+(ch^48),ch=getchar());\n    return x*f;\n}\nI void printint(LL x)\n{\n    if(x<0) putchar('-'),x=-x;\n    if(x>9) printint(x/10);\n    putchar(x%10+'0');\n}\nI LL dg(LL x,LL k)\n{\n    if(k==0) return 1;\n    LL f=dg(x,k>>1);\n    if(k&1) return f*f%mod*x%mod; else return f*f%mod;\n}\nint main()\n{\n    n=readint();m=readint();\n    for(R int i=1;i<=n;i++)\n        a[i]=readint();\n    sort(a+1,a+n+1);\n    for(R int i=1;i<=m;i++)\n    {\n        char ch[2];\n        bool bz=false;\n        LL x;\n        scanf(\"%s\",ch+1);\n        switch(ch[1])\n        {\n            case 'D':x=readint();*(lower_bound(a+1,a+n+1,x))=inf;p[i][1]=1;p[i][2]=x;break;\n            case 'B':p[i][1]=2;break;\n            case 'S':p[i][1]=3;break;\n            case 'M':p[i][1]=4;break;\n            case 'T':p[i][1]=5;break;\n        }\n    }\n    for(R int i=1;i<=n;i++)\n        if(a[i]!=inf)\n        {\n            sum=(sum*a[i])%mod;\n            maxx=max(maxx,a[i]);\n            minn=min(minn,a[i]);\n        }\n    for(R int i=m;i>=1;i--)\n        switch(p[i][1])\n        {\n            case 1:ans[i]=inf;sum=(sum*p[i][2])%mod;maxx=max(maxx,p[i][2]);minn=min(minn,p[i][2]);break;\n            case 2:ans[i]=maxx;break;\n            case 3:ans[i]=minn;break;\n            case 4:ans[i]=dg(maxx,minn);break;\n            case 5:ans[i]=sum;break;\n        }\n    for(R int i=1;i<=m;i++)\n        if(ans[i]!=inf) printint(ans[i]),putchar('\\n');\n}", "step": ["Read in the size of the multiset and the number of operations to perform.", "Read in the initial values of the multiset and insert them into the set.", "For each operation, read in its type and argument and perform the corresponding operation on the multiset.", "Calculate the minimum, maximum, product, and store operation results in an array, iterating backwards through the operations.", "If the operation was a delete operation, update the minimum and maximum values.", "Print the non-negative values in the array."], "nl_cn": "你需要维护一个可重集，支持五种操作：\n\n- `D x` 表示删除 $x$，保证 $x$ 一定存在。若有多个只用删除一个。\n\n- `B` 询问集合中最大值。\n\n- `S` 询问集合中最小值。\n\n- `M` 设集合中最大值为 $a$，最小值为 $b$，询问 $a^b \\bmod 317847191$。\n\n- `T` 询问数列中所有数的乘积，对 $317847191$ 取模。\n\n对于所有询问保证集合非空。\n", "test_cases": [{"input": "3 6\n2 6 9\nM\nD 9\nB\nS\nM\nT", "output": "81\n6\n2\n36\n12"}, {"input": "2 3\n10 20\nB\nS\nT\n", "output": "20\n10\n200"}, {"input": "3 3\n2 3 5\nS\nT\nB\n", "output": "2\n30\n5"}, {"input": "4 4\n8 2 6 4\nB\nS\nM\nT\n", "output": "8\n2\n64\n384"}, {"input": "3 3\n7 6 5\nT\nS\nB\n", "output": "210\n5\n7"}, {"input": "2 1\n10000 9999\nD 9999\n", "output": ""}, {"input": "3 3\n7 1 3\nD 1\nT\nB\n", "output": "21\n7"}, {"input": "2 3\n1 3\nD 3\nT\nS\n", "output": "1\n1"}, {"input": "2 2\n8 10\nD 8\nT\n", "output": "10"}], "test": "#undef NDEBUG\n#include<assert.h>\nint main(){\n    assert(solution(\"3 6\\n2 6 9\\nM\\nD 9\\nB\\nS\\nM\\nT\") == \"81\\n6\\n2\\n36\\n12\");\n    assert(solution(\"2 3\\n10 20\\nB\\nS\\nT\\n\") == \"20\\n10\\n200\");\n    assert(solution(\"3 3\\n2 3 5\\nS\\nT\\nB\\n\") == \"2\\n30\\n5\");\n    assert(solution(\"4 4\\n8 2 6 4\\nB\\nS\\nM\\nT\\n\") == \"8\\n2\\n64\\n384\");\n    assert(solution(\"3 3\\n7 6 5\\nT\\nS\\nB\\n\") == \"210\\n5\\n7\");\n    assert(solution(\"2 1\\n10000 9999\\nD 9999\\n\") == \"\");\n    assert(solution(\"3 3\\n7 1 3\\nD 1\\nT\\nB\\n\") == \"21\\n7\");\n    assert(solution(\"2 3\\n1 3\\nD 3\\nT\\nS\\n\") == \"1\\n1\");\n    assert(solution(\"2 2\\n8 10\\nD 8\\nT\\n\") == \"10\");\n    return 0; \n}", "prompt": "/*You need to maintain a multi-set that supports the following five operations:\n\n- `D x` deletes `x` from the set, and `x` is guaranteed to be in the set. If there are multiple `x`, only one needs to be deleted.\n\n- `B` queries the maximum value in the set.\n\n- `S` queries the minimum value in the set.\n\n- `M` let the maximum value in the set be `a`, the minimum value be `b`, and query `a^b mod 317847191`.\n\n- `T` queries the product of all numbers in the set, mod `317847191`.\n\nFor all queries, the set is guaranteed to be non-empty.\n\ninput_format:\nThe first line contains two positive integers $n,m$, representing the initial set size and operand.\nThe second line contains $n$positive integers $a_i$, representing the initial set.\nNext, $m$lines, each representing an operation.\n\noutput_format:\nFor each query, the output line is an integer representing the answer.\n*/\n\n#include<sstream>\n#include<stdlib.h>\n#include<algorithm>\n#include<math.h>\n#include<stdio.h>\n#include<vector>\n#include<string>\n#include<climits>\n#include<cstring>\n#include<iostream>\nusing namespace std;\n\n             \nstring solution(string std_in){\n    istringstream iss(std_in);\n             ", "constraints": "【数据规模】  \n对于部分数据，$1 \\le n \\le 1000$，$1\\le m \\le 100$，$1\\le a_i \\le 400$；  \n对于 $100\\%$ 的数据，$1\\le n,m \\le 10^6$，$1\\le a_i \\le 10^8$。\n", "samples": [["3 6\n2 6 9\nM\nD 9\nB\nS\nM\nT", "81\n6\n2\n36\n12"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072]}}
{"task_id": "P2088", "title": "果汁店的难题", "difficulty": "advanced", "nl": "On a hot summer day, it's a comfortable thing to have a glass of freshly squeezed cold fruit juice. Little Wang saw this business opportunity and opened a juice shop near the school, but recently he encountered a problem: Little Wang prepared K juicers in the juice shop, of course, each juicer can only squeeze one kind of fruit juice. At a certain moment, if a customer orders a certain kind of fruit juice, and there is a juicer that has already squeezed this kind of fruit juice, then the customer can use this juicer directly. However, if the customer orders a new type of fruit juice, Little Wang needs to find a clean juicer to use. The problem is, if all the juicers are occupied, Little Wang needs to take a juicer that has just been used to clean it, but cleaning it will waste a lot of time and water. Little Wang is a very smart person, he wants to know how many times he needs to clean the juicers at a minimum, under the condition that the demand of customers in the queue is known? It is assumed that all the juicers are clean at the beginning. For convenience, we will number the fruit juices as 1 (orange juice), 2 (apple juice), 3 (grape juice), etc. [Friendly reminder: Our shop does not sell mixed fruit juice.]", "code": "#include <bits/stdc++.h>\nusing namespace std;\nconst int N = 110;\nint k, n, ans = 0;\nqueue<int> pos[N];    //pos[i].表示要 i号果汁客人的位置 \nset<int> machine;    //machine表示当前机器正在榨的果汁 \nqueue<int> juice;    //表示果汁请求队列 \nvoid arrange(int x)\n{\n    juice.pop(), pos[x].pop();\n    if (machine.find(x) == machine.end()) //如果没有找到合适的榨汁机就要清洗了 \n    {\n        ans++;\n        int farthest = 0, best;\n        for (set<int>::iterator it = machine.begin(); it != machine.end(); it++)\n            if (pos[*it].empty()) //如果这个果汁之后都没有客人点了,就直接清洗 \n            {\n                machine.erase(*it), machine.insert(x);\n                return ;\n            }\n            else if (farthest < pos[*it].front()) //找一个短时间不可能用到的榨汁机清洗 \n                farthest = pos[*it].front(), best = *it;\n        machine.erase(best), machine.insert(x);\n    }\n    return ;\n}\nint main()\n{\n    ios::sync_with_stdio(false);\n    cin >>k >>n;\n    for (int i = 1, x; i <= n; i++)\n    {\n        cin >>x;\n        pos[x].push(i);    //类似桶排的方法存果汁请求的位置 \n        juice.push(x);    //当前请求入队 \n    }\n    //在不清洗的情况下安排满k个榨汁机 \n    while (machine.size() < k && !juice.empty())\n    {\n        int temp = juice.front();\n        juice.pop(), pos[temp].pop();\n        machine.insert(temp);\n    }\n    while (!juice.empty()) //如果还有果汁要榨就给安排榨汁机 \n        arrange(juice.front());\n    cout <<ans <<endl;\n    return 0;\n}", "step": ["Initialize required variables including arrays, a set and a queue.", "Read input values for the number of machines and orders.", "Populate the arrays and queue with input values.", "Assign machines to orders using queues and sets.", "Find farthest machine to optimize machine usage.", "Return minimum number of needed machines to complete all orders."], "nl_cn": "炎热的夏天，来上一杯现榨的冰爽果汁想想都是一件惬意的事情！话说小王就看准了这一商机，在学校附近开了这么一家果汁店，但是最近他碰到了一个不大不小的难题：小王的果汁店里准备了 $K$ 台榨汁机，当然每台榨汁机只能榨一种果汁，在某个时段内，一个客人点了某种果汁，如果恰好有某台果汁机榨过这种果汁，那么就直接给客人用这台果汁机接着榨就可以了，但是如果点的是一种新的果汁就需要找一台干净的果汁机来用，问题就出在这，如果这时候还有空的果汁机还好，如果没有的话小王就需要将某台刚才用过的拿去清洗，清洗的话呢就得浪费很多的时间和很多的水，小王是个很有经济头脑的人，他想知道在排队客人需求已知的情况下最少需要清洗多少次果汁机？假定开始时所有果汁机都是干净的，为了方便描述，我们将果汁编号为 $1$ （橙汁）, $2$（苹果汁）， $3$ （葡萄汁）......\n\n[友情提示：本店不售卖混合果汁]", "test_cases": [{"input": "2 7\n1\n2\n3\n1\n3\n1\n3\n", "output": "1"}, {"input": "3 8\n1\n2\n2\n3\n1\n3\n2\n1\n", "output": "0"}, {"input": "2 4\n2\n1\n1\n2\n", "output": "0"}, {"input": "3 8\n1\n3\n2\n1\n1\n2\n3\n3\n", "output": "0"}, {"input": "5 6\n1\n2\n3\n4\n5\n3\n", "output": "0"}, {"input": "2 5\n1\n2\n1\n2\n3\n", "output": "1"}, {"input": "3 5\n1\n2\n1\n1\n2\n", "output": "0"}, {"input": "1 5\n3\n1\n1\n2\n5\n", "output": "3"}, {"input": "4 8\n2\n4\n3\n3\n4\n1\n3\n1\n", "output": "0"}, {"input": "1 6\n6\n5\n3\n5\n5\n4\n", "output": "4"}, {"input": "3 7\n2\n2\n1\n2\n3\n2\n1\n", "output": "0"}, {"input": "4 6\n1\n1\n1\n2\n2\n2\n", "output": "0"}, {"input": "3 8\n1\n1\n1\n2\n2\n2\n3\n3\n", "output": "0"}, {"input": "2 5\n5\n4\n3\n2\n1\n", "output": "3"}, {"input": "2 6\n1\n2\n1\n2\n1\n2\n", "output": "0"}, {"input": "2 6\n1\n1\n2\n2\n1\n2\n", "output": "0"}, {"input": "3 8\n1\n2\n3\n1\n2\n3\n1\n2\n", "output": "0"}, {"input": "3 5\n2\n1\n1\n3\n2\n ", "output": "0"}, {"input": "2 3\n1\n2\n3\n ", "output": "1"}, {"input": "3 4\n1\n3\n2\n3\n ", "output": "0"}, {"input": "1 2\n2\n1\n ", "output": "1"}, {"input": "2 4\n1\n1\n2\n1\n ", "output": "0"}, {"input": "2 5\n1\n2\n2\n1\n2\n ", "output": "0"}, {"input": "1 3\n2\n1\n3\n ", "output": "2"}, {"input": "2 6\n1\n2\n2\n1\n1\n2\n ", "output": "0"}, {"input": "3 8\n2\n2\n3\n1\n3\n1\n2\n3\n ", "output": "0"}, {"input": "4 10\n1\n3\n4\n2\n2\n3\n1\n2\n3\n1\n ", "output": "0"}, {"input": "2 2\n1\n2\n ", "output": "0"}, {"input": "3 3\n1\n1\n2\n ", "output": "0"}, {"input": "3 5\n2\n3\n1\n2\n3\n", "output": "0"}, {"input": "3 4\n2\n3\n2\n1\n", "output": "0"}, {"input": "3 5\n3\n2\n1\n2\n1\n", "output": "0"}, {"input": "5 7\n1\n2\n3\n4\n5\n2\n3\n", "output": "0"}, {"input": "2 4\n1\n2\n1\n2\n", "output": "0"}, {"input": "3 4\n1\n2\n3\n2\n", "output": "0"}], "test": "#undef NDEBUG\n#include<assert.h>\nint main(){\n    assert(solution(\"2 7\\n1\\n2\\n3\\n1\\n3\\n1\\n3\\n\") == \"1\");\n    assert(solution(\"3 8\\n1\\n2\\n2\\n3\\n1\\n3\\n2\\n1\\n\") == \"0\");\n    assert(solution(\"2 4\\n2\\n1\\n1\\n2\\n\") == \"0\");\n    assert(solution(\"3 8\\n1\\n3\\n2\\n1\\n1\\n2\\n3\\n3\\n\") == \"0\");\n    assert(solution(\"5 6\\n1\\n2\\n3\\n4\\n5\\n3\\n\") == \"0\");\n    assert(solution(\"2 5\\n1\\n2\\n1\\n2\\n3\\n\") == \"1\");\n    assert(solution(\"3 5\\n1\\n2\\n1\\n1\\n2\\n\") == \"0\");\n    assert(solution(\"1 5\\n3\\n1\\n1\\n2\\n5\\n\") == \"3\");\n    assert(solution(\"4 8\\n2\\n4\\n3\\n3\\n4\\n1\\n3\\n1\\n\") == \"0\");\n    assert(solution(\"1 6\\n6\\n5\\n3\\n5\\n5\\n4\\n\") == \"4\");\n    assert(solution(\"3 7\\n2\\n2\\n1\\n2\\n3\\n2\\n1\\n\") == \"0\");\n    assert(solution(\"4 6\\n1\\n1\\n1\\n2\\n2\\n2\\n\") == \"0\");\n    assert(solution(\"3 8\\n1\\n1\\n1\\n2\\n2\\n2\\n3\\n3\\n\") == \"0\");\n    assert(solution(\"2 5\\n5\\n4\\n3\\n2\\n1\\n\") == \"3\");\n    assert(solution(\"2 6\\n1\\n2\\n1\\n2\\n1\\n2\\n\") == \"0\");\n    assert(solution(\"2 6\\n1\\n1\\n2\\n2\\n1\\n2\\n\") == \"0\");\n    assert(solution(\"3 8\\n1\\n2\\n3\\n1\\n2\\n3\\n1\\n2\\n\") == \"0\");\n    assert(solution(\"3 5\\n2\\n1\\n1\\n3\\n2\\n \") == \"0\");\n    assert(solution(\"2 3\\n1\\n2\\n3\\n \") == \"1\");\n    assert(solution(\"3 4\\n1\\n3\\n2\\n3\\n \") == \"0\");\n    assert(solution(\"1 2\\n2\\n1\\n \") == \"1\");\n    assert(solution(\"2 4\\n1\\n1\\n2\\n1\\n \") == \"0\");\n    assert(solution(\"2 5\\n1\\n2\\n2\\n1\\n2\\n \") == \"0\");\n    assert(solution(\"1 3\\n2\\n1\\n3\\n \") == \"2\");\n    assert(solution(\"2 6\\n1\\n2\\n2\\n1\\n1\\n2\\n \") == \"0\");\n    assert(solution(\"3 8\\n2\\n2\\n3\\n1\\n3\\n1\\n2\\n3\\n \") == \"0\");\n    assert(solution(\"4 10\\n1\\n3\\n4\\n2\\n2\\n3\\n1\\n2\\n3\\n1\\n \") == \"0\");\n    assert(solution(\"2 2\\n1\\n2\\n \") == \"0\");\n    assert(solution(\"3 3\\n1\\n1\\n2\\n \") == \"0\");\n    assert(solution(\"3 5\\n2\\n3\\n1\\n2\\n3\\n\") == \"0\");\n    assert(solution(\"3 4\\n2\\n3\\n2\\n1\\n\") == \"0\");\n    assert(solution(\"3 5\\n3\\n2\\n1\\n2\\n1\\n\") == \"0\");\n    assert(solution(\"5 7\\n1\\n2\\n3\\n4\\n5\\n2\\n3\\n\") == \"0\");\n    assert(solution(\"2 4\\n1\\n2\\n1\\n2\\n\") == \"0\");\n    assert(solution(\"3 4\\n1\\n2\\n3\\n2\\n\") == \"0\");\n    return 0; \n}", "prompt": "/*On a hot summer day, it's a comfortable thing to have a glass of freshly squeezed cold fruit juice. Little Wang saw this business opportunity and opened a juice shop near the school, but recently he encountered a problem: Little Wang prepared K juicers in the juice shop, of course, each juicer can only squeeze one kind of fruit juice. At a certain moment, if a customer orders a certain kind of fruit juice, and there is a juicer that has already squeezed this kind of fruit juice, then the customer can use this juicer directly. However, if the customer orders a new type of fruit juice, Little Wang needs to find a clean juicer to use. The problem is, if all the juicers are occupied, Little Wang needs to take a juicer that has just been used to clean it, but cleaning it will waste a lot of time and water. Little Wang is a very smart person, he wants to know how many times he needs to clean the juicers at a minimum, under the condition that the demand of customers in the queue is known? It is assumed that all the juicers are clean at the beginning. For convenience, we will number the fruit juices as 1 (orange juice), 2 (apple juice), 3 (grape juice), etc. [Friendly reminder: Our shop does not sell mixed fruit juice.]\n\ninput_format:\nThe first row of each group of test data includes two integers $K and N$, where $K$indicates that Xiao Wang has prepared a clean juicer of $K$, $N$indicates that there are $N$customers waiting in line, and the next row is $N$, and an integer in each row indicates the type of juice $X_i$ordered by a customer.\n\noutput_format:\nOutput the minimum number of times Xiao Wang needs to clean the juice machine under the current request sequence.\n*/\n\n#include<sstream>\n#include<stdlib.h>\n#include<algorithm>\n#include<math.h>\n#include<stdio.h>\n#include<vector>\n#include<string>\n#include<climits>\n#include<cstring>\n#include<iostream>\nusing namespace std;\n\n             \nstring solution(string std_in){\n    istringstream iss(std_in);\n             ", "constraints": "$1\\le K\\le 10$，$1\\le N\\le 100$。\n\n$1\\le x_i\\le 100$。", "samples": [["2 7\n1\n2\n3\n1\n3\n1\n3\n", "1\n"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072]}}
{"task_id": "P1236", "title": "算24点", "difficulty": "advanced", "nl": "Several decades ago, a digital game became popular worldwide, and some people still enjoy it today. In China, we call this game \"24-point arithmetic\". As a player, you will be given four natural numbers between 1 and 9 as operands, and your task is to perform appropriate arithmetic operations on these four operands, requiring the arithmetic result to be equal to 24.\n\nThe only operations you can use are: +, -, *, /, and you can also use parentheses to change the order of operations. Note that all intermediate results must be integers, so some division operations are not allowed (for example, (2*2)/4 is legal, but 2*(2/4) is not). Here is an example of a game:\n\nIf the four operands given are 1, 2, 3, 7, then one possible solution is 1+2+3*7=24.", "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nint a[5];\nchar opt[5]= {' ','+','-','*','/'};\n\nint F(int x,int k, int y)                                 \n{\n  if(k==1)\n    return x+y;\n  if(k==2)\n    return max(x,y)-min(x,y);\n  if(k==3)\n    return x*y;\n  return (y==0 || x<y || x%y!=0) ? -999999 : x/y;\n}\n\nvoid Out(int a,int b,int c,int d,int e,int f,int k1,int k2,int k3)\n{\n  printf(\"%d%c%d=%d\\n\",max(a,b),opt[k1],min(a,b),F(max(a,b),k1,min(a,b)));\n  printf(\"%d%c%d=%d\\n\",max(c,d),opt[k2],min(c,d),F(max(c,d),k2,min(c,d)));\n  printf(\"%d%c%d=%d\\n\",max(e,f),opt[k3],min(e,f),F(max(e,f),k3,min(e,f)));\n  exit(0);                                                  //直接退出程序\n}\n\nint main()\n{\n  scanf(\"%d%d%d%d\", &a[1],&a[2],&a[3],&a[4]);\n  sort(a+1,a+5);                                            //保证遍历所有情况\n  do\n  {\n    for (int i = 1; i <= 4; i++)                            //暴力枚举3个运算符\n      for (int j = 1; j <= 4; j++)\n        for (int k = 1; k <= 4; k++)\n          if (F(F(F(a[1],i,a[2]),j,a[3]),k,a[4])==24)       //((a?b)?c)?d\n            Out(a[1],a[2],F(a[1],i,a[2]),a[3],F(F(a[1],i,a[2]),j,a[3]),a[4],i,j,k);\n          else if (F(F(a[1],i,a[2]),k,F(a[3],j,a[4])) == 24)//(a?b)?(c?d)\n            Out(a[1],a[2],a[3],a[4],F(a[1],i,a[2]),F(a[3],j,a[4]),i,j,k);\n  }  while (next_permutation(a + 1, a + 5));\n  puts(\"No answer!\");\n  return 0;\n}", "step": ["Take 4 integers input from the user.", "Arrange all the possible operators between the integers and calculate the result for each combination.", "If any of the combinations result in 24, output the combination of integers and operators with the correct order.", "If there is no such combination, output 'No answer!'", "The program terminates after getting the first answer."], "nl_cn": "几十年前全世界就流行一种数字游戏，至今仍有人乐此不疲．在中国我们把这种游戏称为“算24点”。您作为游戏者将得到4个1~9之间的自然数作为操作数，而您的任务是对这4个操作数进行适当的算术运算，要求运算结果等于24。\n\n您可以使用的运算只有：+，-，\\*，/，您还可以使用（）来改变运算顺序。注意：所有的中间结果须是整数，所以一些除法运算是不允许的（例如，(2\\*2)/4是合法的，2\\*(2/4)是不合法的）。下面我们给出一个游戏的具体例子：\n\n若给出的4个操作数是：1、2、3、7，则一种可能的解答是1+2+3\\*7=24。\n", "test_cases": [{"input": "1 2 3 7\n", "output": "2+1=3\n7*3=21\n21+3=24"}], "test": "#undef NDEBUG\n#include<assert.h>\nint main(){\n    assert(solution(\"1 2 3 7\\n\") == \"2+1=3\\n7*3=21\\n21+3=24\");\n    return 0; \n}", "prompt": "/*Several decades ago, a digital game became popular worldwide, and some people still enjoy it today. In China, we call this game \"24-point arithmetic\". As a player, you will be given four natural numbers between 1 and 9 as operands, and your task is to perform appropriate arithmetic operations on these four operands, requiring the arithmetic result to be equal to 24.\n\nThe only operations you can use are: +, -, *, /, and you can also use parentheses to change the order of operations. Note that all intermediate results must be integers, so some division operations are not allowed (for example, (2*2)/4 is legal, but 2*(2/4) is not). Here is an example of a game:\n\nIf the four operands given are 1, 2, 3, 7, then one possible solution is 1+2+3*7=24.\n\ninput_format:\nJust one line, four natural numbers between 1 and 9.\n\noutput_format:\nIf there is a solution, as long as you output a solution, the output is three lines of data, each representing the steps of the operation. The first line is the input of two numbers and an operator and the result of the operation, the second line is the result of the first line and an input data, operator, the result of the operation, or the output result of another two numbers; The third line is the result of the previous second line or the remaining number, operator, and \"=24\". If the two operands have sizes, print the larger one first.\n\nIf there is No solution, output \"No answer!\"\n\nIf there are multiple legal solutions, output any of them.\n\nNote: All results are positive integers\n*/\n\n#include<sstream>\n#include<stdlib.h>\n#include<algorithm>\n#include<math.h>\n#include<stdio.h>\n#include<vector>\n#include<string>\n#include<climits>\n#include<cstring>\n#include<iostream>\nusing namespace std;\n\n             \nstring solution(string std_in){\n    istringstream iss(std_in);\n             ", "constraints": "感谢 chenyy 提供 special judge\n\n---\n\n$\\text{upd 2022.8.1}$：新增加一组 Hack 数据。\n", "samples": [["1 2 3 7\n", "2+1=3\n7*3=21\n21+3=24\n"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072]}}
{"task_id": "P1170", "title": "兔八哥与猎人", "difficulty": "challenge", "nl": "Bugs Bunny is hiding in an orchard next to a forest. The orchard consists of $M \\times N$ trees, forming an $M$-by-$N$ matrix, with a distance of $1$ between horizontally or vertically adjacent trees. Bugs Bunny is hiding under one of the trees.\n\nA hunter carrying a gun walks into the orchard and climbs one of the trees, preparing to kill Bugs Bunny. \n\nIf there are no other trees between the hunter and Bugs Bunny, the hunter can see Bugs Bunny. \n\nGiven the positions of the hunter and Bugs Bunny, write a program to determine if Bugs Bunny's location is safe.", "code": "#include<bits/stdc++.h>\nusing namespace std;\nint n,ax,ay,bx,by;\nint gcd(int x,int y)\n{\n\tif(y==0) return x;\n\t  else return (gcd(y,x%y));\n}\nint main()\n{\n\tcin>>n;\n\tfor(int i=1;i<=n;i++)\n\t{\n\t\tscanf(\"%d%d%d%d\",&ax,&ay,&bx,&by);\n\t\tif(gcd(abs(ax-bx),abs(ay-by))==1) cout<<\"no\\n\";\n\t\t  else cout<<\"yes\\n\";\n\t}\n\treturn 0;\n}", "step": ["Take input of n and initialize variables for ax, ay, bx and by.", "Run a loop for n times to take input of ax, ay, bx and by.", "Use the gcd function to check if the absolute difference between ax and bx and ay and by have a common factor other than 1.", "If the gcd function returns 1, print 'no' otherwise print 'yes'.", "Return 0."], "nl_cn": "兔八哥躲藏在树林旁边的果园里。果园有 $M  \\times  N$ 棵树，组成一个 $M$ 行 $N$ 列的矩阵，水平或垂直相邻的两棵树的距离为 $1$。兔八哥在一棵果树下。\n\n猎人背着猎枪走进了果园，他爬上一棵果树，准备杀死兔八哥。\n\n如果猎人与兔八哥之间没有其它的果树，猎人就可以看到兔八哥。\n\n现己知猎人和兔八哥的位置，编写程序判断兔子所在的位置是否安全.\n", "test_cases": [{"input": "1\n1 1\n1 2", "output": "no"}, {"input": "1\n3 4\n5 6\n", "output": "yes"}, {"input": "1\n100 200\n300 400\n", "output": "yes"}, {"input": "1\n5 5\n6 6\n", "output": "no"}, {"input": "1\n-1 -1\n2 3\n", "output": "no"}, {"input": "1\n1 1\n2 1", "output": "no"}, {"input": "3\n1 1\n5 1\n2 4\n8 5\n3 6\n7 9", "output": "yes\nno\nno"}, {"input": "1\n11 12\n13 14\n", "output": "yes"}, {"input": "1\n19 20\n21 22\n", "output": "yes"}, {"input": "1\n27 28\n29 30\n", "output": "yes"}, {"input": "1\n35 36\n37 38\n", "output": "yes"}, {"input": "1\n43 44\n45 46\n", "output": "yes"}, {"input": "1\n51 52\n53 54\n", "output": "yes"}, {"input": "1\n59 60\n61 62\n", "output": "yes"}, {"input": "1\n67 68\n69 70\n", "output": "yes"}, {"input": "1\n75 76\n77 78\n", "output": "yes"}, {"input": "1\n0 0\n0 1\n", "output": "no"}, {"input": "1\n10 0\n20 0\n", "output": "yes"}, {"input": "1\n-3 -3\n-3 -2\n", "output": "no"}, {"input": "1\n1 -1\n2 -2\n", "output": "no"}, {"input": "1\n-4 5\n3 -2\n", "output": "yes"}, {"input": "1\n-7 8\n-9 12\n", "output": "yes"}, {"input": "1\n7 -8\n-7 8\n", "output": "yes"}, {"input": "1\n2 2\n3 3\n", "output": "no"}, {"input": "1\n-2 6\n8 -2\n", "output": "yes"}], "test": "#undef NDEBUG\n#include<assert.h>\nint main(){\n    assert(solution(\"1\\n1 1\\n1 2\") == \"no\");\n    assert(solution(\"1\\n3 4\\n5 6\\n\") == \"yes\");\n    assert(solution(\"1\\n100 200\\n300 400\\n\") == \"yes\");\n    assert(solution(\"1\\n5 5\\n6 6\\n\") == \"no\");\n    assert(solution(\"1\\n-1 -1\\n2 3\\n\") == \"no\");\n    assert(solution(\"1\\n1 1\\n2 1\") == \"no\");\n    assert(solution(\"3\\n1 1\\n5 1\\n2 4\\n8 5\\n3 6\\n7 9\") == \"yes\\nno\\nno\");\n    assert(solution(\"1\\n11 12\\n13 14\\n\") == \"yes\");\n    assert(solution(\"1\\n19 20\\n21 22\\n\") == \"yes\");\n    assert(solution(\"1\\n27 28\\n29 30\\n\") == \"yes\");\n    assert(solution(\"1\\n35 36\\n37 38\\n\") == \"yes\");\n    assert(solution(\"1\\n43 44\\n45 46\\n\") == \"yes\");\n    assert(solution(\"1\\n51 52\\n53 54\\n\") == \"yes\");\n    assert(solution(\"1\\n59 60\\n61 62\\n\") == \"yes\");\n    assert(solution(\"1\\n67 68\\n69 70\\n\") == \"yes\");\n    assert(solution(\"1\\n75 76\\n77 78\\n\") == \"yes\");\n    assert(solution(\"1\\n0 0\\n0 1\\n\") == \"no\");\n    assert(solution(\"1\\n10 0\\n20 0\\n\") == \"yes\");\n    assert(solution(\"1\\n-3 -3\\n-3 -2\\n\") == \"no\");\n    assert(solution(\"1\\n1 -1\\n2 -2\\n\") == \"no\");\n    assert(solution(\"1\\n-4 5\\n3 -2\\n\") == \"yes\");\n    assert(solution(\"1\\n-7 8\\n-9 12\\n\") == \"yes\");\n    assert(solution(\"1\\n7 -8\\n-7 8\\n\") == \"yes\");\n    assert(solution(\"1\\n2 2\\n3 3\\n\") == \"no\");\n    assert(solution(\"1\\n-2 6\\n8 -2\\n\") == \"yes\");\n    return 0; \n}", "prompt": "/*Bugs Bunny is hiding in an orchard next to a forest. The orchard consists of $M \\times N$ trees, forming an $M$-by-$N$ matrix, with a distance of $1$ between horizontally or vertically adjacent trees. Bugs Bunny is hiding under one of the trees.\n\nA hunter carrying a gun walks into the orchard and climbs one of the trees, preparing to kill Bugs Bunny. \n\nIf there are no other trees between the hunter and Bugs Bunny, the hunter can see Bugs Bunny. \n\nGiven the positions of the hunter and Bugs Bunny, write a program to determine if Bugs Bunny's location is safe.\n\ninput_format:\nThe first line is $n$, which indicates that there are $n$ sets of data. For each set of data, the first line consists of two positive integers $a_x$ and $a_y$, indicating the position of the hunter. The second line consists of two positive integers $b_x$ and $b_y$, indicating the position of the rabbit.\n\noutput_format:\nThere are $n$lines, and each action 'yes' or' no 'indicates whether Bugs Bunny's location is safe.\n*/\n\n#include<sstream>\n#include<stdlib.h>\n#include<algorithm>\n#include<math.h>\n#include<stdio.h>\n#include<vector>\n#include<string>\n#include<climits>\n#include<cstring>\n#include<iostream>\nusing namespace std;\n\n             \nstring solution(string std_in){\n    istringstream iss(std_in);\n             ", "constraints": "$1\\le n \\le 10^5$，$1 \\le  a_x, a_y, b_x, b_y \\le  10^8$。", "samples": [["1\n1 1\n1 2", "no"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}}
{"task_id": "P1762", "title": "偶数", "difficulty": "advanced", "nl": "Given a positive integer $n$, please output the result of the number of even integers in the first $n$ rows of the Pascal's triangle, modulo $1000003$.", "code": "#include<iostream>\n#include<cstdio>\n#include<cstdlib>\n#include<cmath>\n#include<cstring>\n#include<algorithm>\n#include<queue>\n#include<stack>\nusing namespace std;\nlong long n,i,f[200],j,t,s;\nlong long p=1000003,l,k,pp;\nlong long aa(long long n)\n{\n     long long i=2LL,j=1LL,q;\n     if (n<=2) return 0;\n     while (i*2<=n){i=i*2;j++;}\n     return (2*aa(n-i)%p+f[j+1]-2*f[j]%p-((i*2-n)%p)*((i*2-n-1)%p)*l+p*p*p)%p;\n}\nint main()\n{\n    cin>>n;f[1]=0;i=2;j=1;\n    k=2;l=1;pp=p-2;\n    while (pp>0)\n    {\n          if (pp%2==1) l=l*k%p;\n          k=k*k%p;pp=pp/2;\n    }   \n    while (i<=n)\n    {\n          j++;s=i%p;t=s*(s-1)%p;\n          f[j]=((f[j-1]*3%p)+((i%p)*((i-1)%p)%p)*l)%p;\n          i=i*2;\n    }\n    cout<<aa(n);\n    system(\"pause\");\n    return 0;\n}", "step": ["Initialize variables and input value of n", "Generate a value of l using loop and modular arithmetic", "Calculate sequence of values f(j) using iterative formula", "Recursive function aa(n) uses f(j) values and returns a final value", "Output value of aa(n)", "End program"], "nl_cn": "给定一个正整数 $n$，请输出杨辉三角形前 $n$ 行的偶数个数对 $1000003$ 取模后的结果。\n", "test_cases": [{"input": "6\n", "output": "6"}, {"input": "1\n", "output": "0"}, {"input": "2\n", "output": "0"}], "test": "#undef NDEBUG\n#include<assert.h>\nint main(){\n    assert(solution(\"6\\n\") == \"6\");\n    assert(solution(\"1\\n\") == \"0\");\n    assert(solution(\"2\\n\") == \"0\");\n    return 0; \n}", "prompt": "/*Given a positive integer $n$, please output the result of the number of even integers in the first $n$ rows of the Pascal's triangle, modulo $1000003$.\n\ninput_format:\nOne line is a positive integer $n$.\n\noutput_format:\nA line with an integer represents the answer.\n*/\n\n#include<sstream>\n#include<stdlib.h>\n#include<algorithm>\n#include<math.h>\n#include<stdio.h>\n#include<vector>\n#include<string>\n#include<climits>\n#include<cstring>\n#include<iostream>\nusing namespace std;\n\n             \nstring solution(string std_in){\n    istringstream iss(std_in);\n             ", "constraints": "对于 $30\\%$ 的数据，$n\\le 4\\times 10^3$。\n\n对于 $70\\%$ 的数据，$n\\le 4\\times 10^9$。\n\n对于 $100\\%$ 的数据，$1\\le n\\le 10^{15}$。\n\n杨辉三角形的前七行：\n\n```plain\n       1\n      1 1\n     1 2 1\n    1 3 3 1\n   1 4 6 4 1\n 1 5 10 10 5 1\n1 6 15 20 15 6 1\n```", "samples": [["6\n", "6\n"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}}
{"task_id": "P5833", "title": "[USACO19DEC]Livestock Lineup B", "difficulty": "challenge", "nl": "Every day, Farmer John has to milk his 8 cows. Their names are Bessie, Buttercup, Belinda, Beatrice, Bella, Blue, Betsy, and Sue.\n\nUnfortunately, these cows are quite difficult to handle, and they demand that Farmer John milk them in a certain order that satisfies N constraints. Each constraint takes the form \"X must be milked right after Y\", requiring cow X to be milked right after cow Y or right before cow Y.\n\nPlease help Farmer John find an order to milk the cows that satisfies all the constraints. It is guaranteed that such an order exists. If there are multiple orders that satisfy the constraints, please output the one with the smallest lexicographic order. That is, the first cow must be the cow with the smallest name in lexicographic order among all cows that can be the first cow in any legal order. Among all legal orders that start with this cow, the second cow must be the one with the smallest name, and so on.", "code": "#include<bits/stdc++.h>\nusing namespace std;\nvector <string> cows,st_a,st_b; \nint n;\nint find(string c)\n{\n\tfor(int i=0;i<8;i++)\n\t{\n\t\tif(cows[i]==c) return i;\n\t}\n\treturn -1;\n}\nbool sati()\n{\n\tfor(int i=0;i<n;i++)\n\t{\n\t\tif(abs(find(st_a[i])-find(st_b[i]))!=1) return false;\n\t}\n\treturn true;\n}\nint main()\n{\n\tcows.push_back(\"Beatrice\");\n\tcows.push_back(\"Belinda\");\n\tcows.push_back(\"Bella\");\n\tcows.push_back(\"Bessie\");\n\tcows.push_back(\"Betsy\");\n\tcows.push_back(\"Blue\");\n\tcows.push_back(\"Buttercup\");\n\tcows.push_back(\"Sue\");\n    cin>>n;\n    string a,b,t;\n    for(int i=0;i<n;i++)\n    {\n    \tcin>>a;\n    \tcin>>t;\n    \tcin>>t;\n    \tcin>>t;\n    \tcin>>t;\n    \tcin>>b;\n    \tst_a.push_back(a);\n    \tst_b.push_back(b);\n\t}\n\tdo{\n\t\tif(sati()){\n\t\t\tfor(int i=0;i<8;i++) cout<<cows[i]<<endl;\n\t\t\tbreak;\n\t\t}\n\t}\n\twhile(next_permutation(cows.begin(),cows.end()));\nreturn 0;\n}", "step": ["Read in the number of cows and the length of their names", "Assign values to each cow based on length of their name", "Generate all possible permutations of cow order", "Check if each pair of friends are standing next to each other in the permutation", "If all pairs are standing next to each other in the permutation, output the cow order", "End the program"], "nl_cn": "每天，Farmer John 都要给他的 $8$ 头奶牛挤奶。她们的名字分别是 Bessie，Buttercup，Belinda，Beatrice，Bella，Blue，Betsy，和 Sue。\n\n不幸的是，这些奶牛相当难以伺候，她们要求 Farmer John 以一种符合 $N$ 条限制的顺序给她们挤奶。每条限制的形式为“$X$ 必须紧邻着 $Y$ 挤奶”，要求奶牛 $X$ 在挤奶顺序中必须紧接在奶牛 $Y$ 之后，或者紧接在奶牛 $Y$ 之前。\n\n请帮助 Farmer John 求出一种满足所有限制的奶牛挤奶顺序。保证这样的顺序是存在的。如果有多种顺序都满足要求，请输出字典序最小的一种。也就是说，第一头奶牛需要是所有可能排在任意合法奶牛顺序的第一位的奶牛中名字字典序最小的。在所有合法的以这头字典序最小的奶牛为首的奶牛顺序中，第二头奶牛需要是字典序最小的，以此类推。", "test_cases": [{"input": "3\nButtercup must be milked beside Bella\nBlue must be milked beside Bella\nSue must be milked beside Beatrice", "output": "Beatrice\nSue\nBelinda\nBessie\nBetsy\nBlue\nBella\nButtercup"}, {"input": "2\nBeatrice must be milked beside Bessie\nBetsy must be milked beside Bella\n", "output": "Beatrice\nBessie\nBelinda\nBella\nBetsy\nBlue\nButtercup\nSue"}, {"input": "3\nSue must be milked beside Beatrice\nBlue must be milked beside Bella\nButtercup must be milked beside Bella\n", "output": "Beatrice\nSue\nBelinda\nBessie\nBetsy\nBlue\nBella\nButtercup"}], "test": "#undef NDEBUG\n#include<assert.h>\nint main(){\n    assert(solution(\"3\\nButtercup must be milked beside Bella\\nBlue must be milked beside Bella\\nSue must be milked beside Beatrice\") == \"Beatrice\\nSue\\nBelinda\\nBessie\\nBetsy\\nBlue\\nBella\\nButtercup\");\n    assert(solution(\"2\\nBeatrice must be milked beside Bessie\\nBetsy must be milked beside Bella\\n\") == \"Beatrice\\nBessie\\nBelinda\\nBella\\nBetsy\\nBlue\\nButtercup\\nSue\");\n    assert(solution(\"3\\nSue must be milked beside Beatrice\\nBlue must be milked beside Bella\\nButtercup must be milked beside Bella\\n\") == \"Beatrice\\nSue\\nBelinda\\nBessie\\nBetsy\\nBlue\\nBella\\nButtercup\");\n    return 0; \n}", "prompt": "/*Every day, Farmer John has to milk his 8 cows. Their names are Bessie, Buttercup, Belinda, Beatrice, Bella, Blue, Betsy, and Sue.\n\nUnfortunately, these cows are quite difficult to handle, and they demand that Farmer John milk them in a certain order that satisfies N constraints. Each constraint takes the form \"X must be milked right after Y\", requiring cow X to be milked right after cow Y or right before cow Y.\n\nPlease help Farmer John find an order to milk the cows that satisfies all the constraints. It is guaranteed that such an order exists. If there are multiple orders that satisfy the constraints, please output the one with the smallest lexicographic order. That is, the first cow must be the cow with the smallest name in lexicographic order among all cows that can be the first cow in any legal order. Among all legal orders that start with this cow, the second cow must be the one with the smallest name, and so on.\n\ninput_format:\nThe first line of input contains $N$. The following $N$lines each contain a sentence describing a restriction in the format \"$X$must be milked beside $Y$\", where $X$and $Y$are the names of some of Farmer John's cows (eight possible names are listed above).\n\noutput_format:\nPlease output the order of a cow in the $8$line, with the name of one cow per line, satisfying all restrictions. If multiple orders meet the requirements, output the lexicographically smallest cow order.\n*/\n\n#include<sstream>\n#include<stdlib.h>\n#include<algorithm>\n#include<math.h>\n#include<stdio.h>\n#include<vector>\n#include<string>\n#include<climits>\n#include<cstring>\n#include<iostream>\nusing namespace std;\n\n             \nstring solution(string std_in){\n    istringstream iss(std_in);\n             ", "constraints": "$1 \\leq N \\leq 7$。\n\n供题：Brian Dean", "samples": [["3\nButtercup must be milked beside Bella\nBlue must be milked beside Bella\nSue must be milked beside Beatrice", "Beatrice\nSue\nBelinda\nBessie\nBetsy\nBlue\nBella\nButtercup"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}}
{"task_id": "P2250", "title": "二面体群", "difficulty": "advanced", "nl": "Consider $n$ points on a unit circle, numbered from $K=0$ to $K=n-1$. The initial angle of point $K$ relative to the $x$-axis is $\\frac{360 \\times k}{n}$ degrees, where angles are measured in a counterclockwise direction from the $x$-axis. We perform 2 types of operations on this set of points:\n\n1. Rotate clockwise by $\\frac{360}{n}$ degrees.\n2. Reflect across the $x$-axis.\n\nFor a given sequence of operations, we are only interested in the shortest sequence that produces the same result. Two sequences produce the same result if, after applying the sequence to the initial configuration, the position of each individual point is the same regardless of the specific sequence of operations applied.\n\nThe operations are given as a string of `r`'s and `m`'s. `r` denotes a clockwise rotation and `m` denotes a reflection across the $x$-axis. If multiple letters appear consecutively, we abbreviate them as `<letter><number>`. For simplicity, we also use this notation for single letters. For example, the string `rrmrrrrrrrrrrrr` can be abbreviated as `r2 m1 r12`. Each sequence of operations is given on a separate line.", "code": "#include<cstdio>\nint read()\n{\n\tint a(0);char c(getchar());\n\twhile(c<'0')c=getchar();\n\twhile(c>='0')a=a*10+(c^48),c=getchar();\n\treturn a;\n}\nint main()\n{\n\tint n(read()),a,p(0),f(1);\n\t//p初值为0，表示选取基准点为0号点，f=1，f=0分别表示顺时针序列、逆时针序列 \n\tfor(char c=getchar();~c;c=getchar())//~c表示如果读入-1(EOF)跳出 \n\t{\n\t\tif(c<33)continue;\n\t\t//ASCII中前32个字符中不包含数字和字母，直接吃掉继续读入 \n\t\ta=read();\n\t\tif(c=='r')\n\t\t{\n\t\t\ta%=n;\n\t\t\tif(f)p=(p+a)%n;\n\t\t\telse p=(n+p-a)%n;//p有可能为负，需要+n \n\t\t}\n\t\telse if(a&1)f=!f;\n\t}\n\tif(p==0)\n\t{\n\t\tif(!f)return printf(\"m1\"),0;\n\t\telse return 0;\n\t}//如果没有旋转操作直接结束程序，最多对称一下 \n\tif(f)\n\t{\n\t\t//顺时针序列： \n\t\t//n-p+2表示借助两次对称进行旋转，p表示直接旋转，可以取等，不必讨论这种情况 \n\t\tif(n-p+2<p)printf(\"m1 r%d m1\",n-p);\n\t\telse printf(\"r%d\",p);\n\t}\n\telse\n\t{\n\t\t//逆时针序列： \n\t\t//n-p表示先对称后旋转，p表示先旋转后对称，可以取等，不必讨论这种情况 \n\t\tif(n-p<p)printf(\"m1 r%d\",n-p);\n\t\telse printf(\"r%d m1\",p);\n\t}\n}", "step": ["Initialize variables", "Loop until end of line or file", "Read input and calculate intermediate values", "Calculate final output and print", "Return exit status"], "nl_cn": "考虑在一个单位圆周上的 $n$ 个点，$n$ 个点的标号为 $K=0,1,\\ldots,n-1$。初始的时候 $K$ 相对于 X 轴的角度为 $\\dfrac{360 \\times k}{n}$ 度，这里的角度是相对于 X 轴的逆时针角度。我们将在这组点上运行 2 种不同类型的操作：\n\n1. 顺时针旋转 $\\dfrac{360}{n}$度\n2. 相对于 X 轴的映射\n\n对于给定的操作序列，如果结果相同，我们只对最短的操作序列感兴趣。结果相同是指对于不同的操作序列，最后的操作结果中每一个单一点的位置都是一样的。\n\n操作序列以字符串的形式给出，该字符串中只含有字母 `r` 和 `m`。`r` 代表顺时针旋转，`m` 代表单独映射（到右边并且对称）。字符串中如果有多个字母连续出现要简写成 `<字母><数字>` 的形式，为了方便起见，字母如果单独出现也写成这种形式。如 `rrmrrrrrrrrrrrr` 可以写成 `r2 m1 r12`，每个操作序列一行。", "test_cases": [{"input": "54\nr218 m3 r1\n", "output": "r1 m1"}, {"input": "54\nr1 m1\n", "output": "r1 m1"}, {"input": "54\nr24 m4\n", "output": "r24"}, {"input": "3\nr1\n", "output": "r1"}, {"input": "20\nr10\n", "output": "r10"}, {"input": "16\nm1 m1 m1 r4\n", "output": "m1 r4"}, {"input": "40\nm1 m1 r6\n", "output": "r6"}], "test": "#undef NDEBUG\n#include<assert.h>\nint main(){\n    assert(solution(\"54\\nr218 m3 r1\\n\") == \"r1 m1\");\n    assert(solution(\"54\\nr1 m1\\n\") == \"r1 m1\");\n    assert(solution(\"54\\nr24 m4\\n\") == \"r24\");\n    assert(solution(\"3\\nr1\\n\") == \"r1\");\n    assert(solution(\"20\\nr10\\n\") == \"r10\");\n    assert(solution(\"16\\nm1 m1 m1 r4\\n\") == \"m1 r4\");\n    assert(solution(\"40\\nm1 m1 r6\\n\") == \"r6\");\n    return 0; \n}", "prompt": "/*Consider $n$ points on a unit circle, numbered from $K=0$ to $K=n-1$. The initial angle of point $K$ relative to the $x$-axis is $\\frac{360 \\times k}{n}$ degrees, where angles are measured in a counterclockwise direction from the $x$-axis. We perform 2 types of operations on this set of points:\n\n1. Rotate clockwise by $\\frac{360}{n}$ degrees.\n2. Reflect across the $x$-axis.\n\nFor a given sequence of operations, we are only interested in the shortest sequence that produces the same result. Two sequences produce the same result if, after applying the sequence to the initial configuration, the position of each individual point is the same regardless of the specific sequence of operations applied.\n\nThe operations are given as a string of `r`'s and `m`'s. `r` denotes a clockwise rotation and `m` denotes a reflection across the $x$-axis. If multiple letters appear consecutively, we abbreviate them as `<letter><number>`. For simplicity, we also use this notation for single letters. For example, the string `rrmrrrrrrrrrrrr` can be abbreviated as `r2 m1 r12`. Each sequence of operations is given on a separate line.\n\ninput_format:\nThere are two input lines in total.\n\nThe first line contains an integer $N$, representing the number of points on the circumference.\n\nThe second line is the abbreviated operation sequence in the format mentioned above. All the numbers are positive integers and less than $10^8$. There are no empty lines in the input file, and the number of characters in each line is less than $10^5$.\n\noutput_format:\nOutput the shortest sequence of operations. If no operation is required, nothing is output.\n*/\n\n#include<sstream>\n#include<stdlib.h>\n#include<algorithm>\n#include<math.h>\n#include<stdio.h>\n#include<vector>\n#include<string>\n#include<climits>\n#include<cstring>\n#include<iostream>\nusing namespace std;\n\n             \nstring solution(string std_in){\n    istringstream iss(std_in);\n             ", "constraints": "$100\\%$ 的数据满足 $3 \\leq N \\leq 10^8$。\n\n", "samples": [["54\nr218 m3 r1\n", "r1 m1"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}}
{"task_id": "P5726", "title": "【深基4.习9】打分", "difficulty": "challenge", "nl": "There are n (n ≤ 1000) judges giving scores to a player, with scores ranging from 0 to 10. The highest and lowest scores are excluded (if there are multiple highest or lowest scores, only one of them needs to be excluded), and the average of the remaining scores is the player's score. Given the number of judges and their scores, output the player's final score, rounded to 2 decimal places.", "code": "#include<bits/stdc++.h>\nusing namespace std;\nint n,a[10001];\ndouble ans;\nint main()\n{\n\tcin>>n;\n\tfor(int i=1;i<=n;i++) cin>>a[i];\n\tsort(a+1,a+n+1);\n\tfor(int i=2;i<=n-1;i++) ans+=a[i];\n\tprintf(\"%.2lf\",ans/(n-2));\n\treturn 0;\n}", "step": ["Take input of an integer value n", "Take input of n integers and store them in an array a", "Sort the array a in ascending order", "Take the sum of all integers in the array except the first and last element", "Divide the sum by (n-2) and store in ans", "Print the ans in 2 decimal places"], "nl_cn": "现在有 $n(n \\le 1000)$ 位评委给选手打分，分值从 $0$ 到 $10$。需要去掉一个最高分，去掉一个最低分（如果有多个最高或者最低分，也只需要去掉一个），剩下的评分的平均数就是这位选手的得分。现在输入评委人数和他们的打分，请输出选手的最后得分，精确到 $2$ 位小数。 ", "test_cases": [{"input": "5\n9 5 6 8 9", "output": "7.67"}, {"input": "3\n7 5 9\n", "output": "7.00"}, {"input": "4\n8 7 6 7\n", "output": "7.00"}, {"input": "8\n6 6 6 6 6 6 6 6\n", "output": "6.00"}, {"input": "3\n2 2 2\n", "output": "2.00"}, {"input": "4\n5 1 9 3\n", "output": "4.00"}, {"input": "6\n10 10 9 8 7 7\n", "output": "8.50"}, {"input": "10\n0 1 2 3 4 5 6 7 8 9\n", "output": "4.50"}, {"input": "5\n1 2 3 4 5\n", "output": "3.00"}, {"input": "3\n4 5 6\n", "output": "5.00"}, {"input": "4\n1 2 3 4\n", "output": "2.50"}, {"input": "3\n1 2 3\n", "output": "2.00"}, {"input": "5\n10 10 10 10 10\n", "output": "10.00"}, {"input": "6\n1 1 1 1 1 1\n", "output": "1.00"}, {"input": "4\n3 3 3 3\n", "output": "3.00"}, {"input": "5\n9 7 6 8 5\n", "output": "7.00"}, {"input": "3\n5 5 5\n", "output": "5.00"}, {"input": "4\n1 2 3 7\n", "output": "2.50"}, {"input": "5\n4 5 5 6 6\n", "output": "5.33"}, {"input": "3\n10 9 8\n", "output": "9.00"}, {"input": "5\n7 8 8 9 9\n", "output": "8.33"}, {"input": "4\n6 6 6 6\n", "output": "6.00"}], "test": "#undef NDEBUG\n#include<assert.h>\nint main(){\n    assert(solution(\"5\\n9 5 6 8 9\") == \"7.67\");\n    assert(solution(\"3\\n7 5 9\\n\") == \"7.00\");\n    assert(solution(\"4\\n8 7 6 7\\n\") == \"7.00\");\n    assert(solution(\"8\\n6 6 6 6 6 6 6 6\\n\") == \"6.00\");\n    assert(solution(\"3\\n2 2 2\\n\") == \"2.00\");\n    assert(solution(\"4\\n5 1 9 3\\n\") == \"4.00\");\n    assert(solution(\"6\\n10 10 9 8 7 7\\n\") == \"8.50\");\n    assert(solution(\"10\\n0 1 2 3 4 5 6 7 8 9\\n\") == \"4.50\");\n    assert(solution(\"5\\n1 2 3 4 5\\n\") == \"3.00\");\n    assert(solution(\"3\\n4 5 6\\n\") == \"5.00\");\n    assert(solution(\"4\\n1 2 3 4\\n\") == \"2.50\");\n    assert(solution(\"3\\n1 2 3\\n\") == \"2.00\");\n    assert(solution(\"5\\n10 10 10 10 10\\n\") == \"10.00\");\n    assert(solution(\"6\\n1 1 1 1 1 1\\n\") == \"1.00\");\n    assert(solution(\"4\\n3 3 3 3\\n\") == \"3.00\");\n    assert(solution(\"5\\n9 7 6 8 5\\n\") == \"7.00\");\n    assert(solution(\"3\\n5 5 5\\n\") == \"5.00\");\n    assert(solution(\"4\\n1 2 3 7\\n\") == \"2.50\");\n    assert(solution(\"5\\n4 5 5 6 6\\n\") == \"5.33\");\n    assert(solution(\"3\\n10 9 8\\n\") == \"9.00\");\n    assert(solution(\"5\\n7 8 8 9 9\\n\") == \"8.33\");\n    assert(solution(\"4\\n6 6 6 6\\n\") == \"6.00\");\n    return 0; \n}", "prompt": "/*There are n (n ≤ 1000) judges giving scores to a player, with scores ranging from 0 to 10. The highest and lowest scores are excluded (if there are multiple highest or lowest scores, only one of them needs to be excluded), and the average of the remaining scores is the player's score. Given the number of judges and their scores, output the player's final score, rounded to 2 decimal places.\n\ninput_format:\nEnter a positive integer $n$on the first line to indicate that there are $n$judges.\n\nIn the second line, enter a positive integer of $n$. The positive integer of $i$indicates the score of the judge of $i$.\n\noutput_format:\nOutput a line of two decimal places, representing the final score of the player.\n*/\n\n#include<sstream>\n#include<stdlib.h>\n#include<algorithm>\n#include<math.h>\n#include<stdio.h>\n#include<vector>\n#include<string>\n#include<climits>\n#include<cstring>\n#include<iostream>\nusing namespace std;\n\n             \nstring solution(string std_in){\n    istringstream iss(std_in);\n             ", "constraints": "数据保证，$3 \\leq n \\leq 1000$，每个评委打出的分值为为 $0$ 到 $10$（含 $0$ 与 $10$）之间的整数。", "samples": [["5\n9 5 6 8 9", "7.67"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000]}}
{"task_id": "P7505", "title": "「Wdsr-2.5」小小的埴轮兵团", "difficulty": "challenge", "nl": "Grinding Bow gives the command to make the potters stand in a row. Let's assume they are standing on a number line, and the position of each potter is the number on the number line under its feet. Grinding Bow will tell you that the position of the $i$-th potter is $a_i$. It is **not guaranteed** that $\\bm {a_i}$ is in ascending order.\n\nThe length of the number line is limited, and the specific range is $[-k,k]$. That is to say, if a potter moves out of this range, it will leave the queue and will not return to the queue again.\n\nIn order to train the potters, Grinding Bow gave $m$ instructions, as follows:\n\n- Instruction 1: **All the potters** move $x$ units of length in the positive direction of the number line.\n- Instruction 2: **All the potters** move $x$ units of length in the negative direction of the number line.\n- Instruction 3: Count the number of potters in the queue and report it in order.\n\nHowever, Grinding Bow found that the size of the potter army was too large, making these operations very slow. Nevertheless, Grinding Bow still wants you to tell her the results of all instruction 3.", "code": "#include<bits/stdc++.h>\n#define int long long\nusing namespace std;\nint n,m,op;\nint k,a[300005],x,w;\nsigned main(){\n    cin>>n>>m>>k;\n    int l=1,r=n;\n    for(int i=1;i<=n;i++)cin>>a[i];\n\tsort(a+1,a+n+1);\n\tfor(int i=1;i<=m;i++){\n\t\tcin>>op;\n\t\tif(op==3){\n\t\t\tcout<<r-l+1<<endl;\n\t\t\tcontinue;\n\t\t}cin>>x;\n\t\tif(op==1){\n\t\t\tw=w+x;\n\t\t\twhile(a[r]+w>k&&l<=r)r--;\n\t\t}else if(op==2){\n\t\t\tw=w-x;\n\t\t\twhile(a[l]+w<-k&&l<=r)l++;\n\t\t}\n\t}\n\treturn 0;\n}", "step": ["Input the size of the deque(n), number of operations(m), and value(k).", "Input the elements of deque and sort them in non-descending order.", "For m iterations, take input user's input op(1,2,3) and follow these operations:", "If op is 3, print the size of the deque.", "If op is 1, input value x and add elements to the front of the deque until total sum of elements is greater than k.", "If op is 2, input value x and remove elements from the front of deque until total sum of elements is less than -k."], "nl_cn": "磨弓下达命令让埴轮们站成一行。不妨认为它们站在了一个数轴上，每个埴轮的位置就是它脚下数轴的数字。磨弓会告诉你，第 $i$ 个埴轮的位置为 $a_i$ 。**不保证** $\\bm {a_i}$ **升序**。\n\n数轴的长度是有限制的，具体的范围是 $[-k,k]$ 。也就是说，如果某个埴轮移出了这个范围，它就脱离了这个队列了，并且不会再次回到队列当中。\n\n为了训练埴轮，磨弓给埴轮们下达了 $m$ 个指令，有以下 3 种：\n\n- 指令 1：**全体埴轮**向数轴的正方向移动 $x$ 个单位长度。\n- 指令 2：**全体埴轮**往数轴的反方向移动 $x$ 个单位长度。\n- 指令 3：依次报数，统计目前队列里一共有多少个埴轮。\n\n但是磨弓发现，埴轮兵团的大小实在是太大了，以至于执行这些操作变得非常缓慢。尽管如此，磨弓仍然希望你告诉她所有指令 3 的结果。", "test_cases": [{"input": "3 4 3\n-1 1 2\n2 3\n3\n1 5\n3", "output": "2\n1"}, {"input": "1 1 0\n0\n3\n", "output": "1"}, {"input": "4 4 2\n-10 -5 5 10\n3 2 1 3\n2\n1 7\n3\n", "output": "4\n2"}], "test": "#undef NDEBUG\n#include<assert.h>\nint main(){\n    assert(solution(\"3 4 3\\n-1 1 2\\n2 3\\n3\\n1 5\\n3\") == \"2\\n1\");\n    assert(solution(\"1 1 0\\n0\\n3\\n\") == \"1\");\n    assert(solution(\"4 4 2\\n-10 -5 5 10\\n3 2 1 3\\n2\\n1 7\\n3\\n\") == \"4\\n2\");\n    return 0; \n}", "prompt": "/*Grinding Bow gives the command to make the potters stand in a row. Let's assume they are standing on a number line, and the position of each potter is the number on the number line under its feet. Grinding Bow will tell you that the position of the $i$-th potter is $a_i$. It is **not guaranteed** that $\\bm {a_i}$ is in ascending order.\n\nThe length of the number line is limited, and the specific range is $[-k,k]$. That is to say, if a potter moves out of this range, it will leave the queue and will not return to the queue again.\n\nIn order to train the potters, Grinding Bow gave $m$ instructions, as follows:\n\n- Instruction 1: **All the potters** move $x$ units of length in the positive direction of the number line.\n- Instruction 2: **All the potters** move $x$ units of length in the negative direction of the number line.\n- Instruction 3: Count the number of potters in the queue and report it in order.\n\nHowever, Grinding Bow found that the size of the potter army was too large, making these operations very slow. Nevertheless, Grinding Bow still wants you to tell her the results of all instruction 3.\n\ninput_format:\nThe first line has a total of $3$integers $n, m, k$, meaning as shown on the surface.\n\nThe second row has a total of $n$integers $a_1, a_2, \\cdots, a_n$, indicating the position of each haniwa.\n\nNext, the $m$line, with a positive integer of $1$or $2$, describes an instruction. The first is an integer $\\operatorname{op}$, which indicates the type of the instruction. If $1 \\leq \\operatorname{op} \\leq 2$, an integer $x$is also entered next.\n\noutput_format:\nFor each instruction 3, output an integer indicating the number of haniwa that are currently in the queue.\n*/\n\n#include<sstream>\n#include<stdlib.h>\n#include<algorithm>\n#include<math.h>\n#include<stdio.h>\n#include<vector>\n#include<string>\n#include<climits>\n#include<cstring>\n#include<iostream>\nusing namespace std;\n\n             \nstring solution(string std_in){\n    istringstream iss(std_in);\n             ", "constraints": "#### 样例 1 说明\n\n一共有三个埴轮。初始时，它们的站位分别是 $[-1,1,2]$ 。\n\n- 第一次操作后，所有埴轮向左移动 $3$ 格，位置变成了  $[\\underline{\\bm{-4}},-2,-1]$ 。第一个埴轮被移出了数轴。\n- 第二次操作后，输出当前的埴轮数目，为 $2$ 个。\n- 第三次操作后，所有埴轮向右移动 $5$ 格，位置变成了 $[3,\\underline \\bm4]$ ，第二个埴轮被移出了数轴。\n- 第四次操作后，输出当前的埴轮数目，为 $1$ 个。\n\n#### 样例 2, 3\n\n见下发附件。\n\n#### 数据规模与约定\n\n- 对于 $30\\%$ 的数据，$1 \\leq n, m \\leq 5\\times 10^3$；\n- 对于另外 $20\\%$ 的数据，$1\\le k\\le 500$；\n- 对于 $100\\%$ 的数据，$1 \\leq n, m \\leq 3\\times 10^5$，$1 \\leq k, x \\leq 2 \\times 10^9$，$-k \\le a_i \\le k$ 。", "samples": [["3 4 3\n-1 1 2\n2 3\n3\n1 5\n3", "2\n1"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072]}}
{"task_id": "P2849", "title": "[USACO14DEC]Marathon S", "difficulty": "advanced", "nl": "Bessie is participating in a city marathon where she needs to visit N (3 <= N <= 500) checkpoints in sequence, where checkpoint 1 is the starting location and checkpoint N is the finish. She can skip up to K checkpoints (K < N) to reduce her total journey, but checkpoints 1 and N cannot be skipped. The distance between two checkpoints at locations (x1, y1) and (x2, y2) is given by |x1-x2| + |y1-y2|.", "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nint n,k,x[501],y[501],f[501][501],a[501][501];\n\ninline int dis(int a,int b){\n    return abs(x[a]-x[b])+abs(y[a]-y[b]);\n}\n\nint main()\n{\n    memset(f,0x7f,sizeof(f));\n    scanf(\"%d%d\",&n,&k);\n    for(int i=1;i<=n;++i)\n    {\n        scanf(\"%d%d\",&x[i],&y[i]);\n    }\n    f[1][0]=0;\n    for(int i=0;i<=n;++i)\n        f[i][i]=0;\n    for(int i=2;i<=n;++i)\n        for(int j=0;j<=min(i-1,k);++j)\n            for(int l=0;l<=j;++l)f[i][j]=min(f[i][j],f[i-l-1][j-l]+dis(i,i-l-1));\n    printf(\"%d\\n\",f[n][k]);\n}", "step": ["Set all values of f to maximum integer", "Read the number of points (n) and the maximum number of intermediate points to visit (k) from standard input", "Read the coordinates (x[i], y[i]) of each point", "Initialize f[1][0] to 0 and f[i][i] to 0 for all values of i from 0 to n", "Calculate the minimum distance by looping through all possible values of i, j, and l and taking the minimum of f[i][j] and f[i-l-1][j-l]+dis(i,i-l-1)", "Print the calculated minimum distance from the first point to the last point with up to k intermediate points visited"], "nl_cn": "Unhappy with the poor health of his cows, Farmer John enrolls them in an assortment of different physical fitness activities. His prize cow Bessie is enrolled in a running class, where she is eventually expected to run a marathon through the downtown area of the city near Farmer John's farm!\n\n\nThe marathon course consists of N checkpoints (3 <= N <= 500) to be visited in sequence, where checkpoint 1 is the starting location and checkpoint N is the finish. Bessie is supposed to visit all of these checkpoints one by one, but being the lazy cow she is, she decides that she will skip up to K checkpoints (K < N) in order to shorten her total journey. She cannot skip checkpoints 1 or N, however, since that would be too noticeable.\n\n\nPlease help Bessie find the minimum distance that she has to run if she can skip up to K checkpoints.\n\n\nSince the course is set in a downtown area with a grid of streets, the distance between two checkpoints at locations (x1, y1) and (x2, y2) is given by |x1-x2| + |y1-y2|.\n\nBessie 参加城市马拉松比赛，要顺序经过 $N (3 \\leq N \\leq 500)$ 个检查点，其中检查点 $1$ 是起点，检查点 $N$ 是终点。 Bessie尝试略过 $K(K < N)$ 个检查点，以减少总路程，检查点 $1$ 和检查点 $N$ 不能被略过。两个检查点的距离是 $|x_1-x_2| + |y_1-y_2|$。\n\n输入输出格式\n", "test_cases": [{"input": "5 2\n0 0\n8 3\n1 1\n10 -5\n2 2", "output": "4"}, {"input": "7 4\n-2 -2\n-1 -1\n0 0\n1 1\n2 2\n3 3\n4 4", "output": "6"}, {"input": "10 5\n0 0\n1 1\n2 2\n3 3\n4 4\n5 5\n6 6\n7 7\n8 8\n9 9", "output": "10"}, {"input": "3 0\n0 0\n0 0\n0 0\n", "output": "0"}, {"input": "6 3\n-5 -5\n-10 -10\n-12 -5\n-5 -12\n-10 5\n-5 5\n", "output": "20"}, {"input": "5 2\n0 0\n-2 -2\n2 2\n-3 3\n3 -3\n", "output": "10"}, {"input": "8 4\n-5 -5\n-3 -3\n-1 -1\n3 3\n5 5\n7 7\n9 9\n11 11\n", "output": "16"}, {"input": "3 1\n1 1\n2 2\n3 3\n", "output": "4"}], "test": "#undef NDEBUG\n#include<assert.h>\nint main(){\n    assert(solution(\"5 2\\n0 0\\n8 3\\n1 1\\n10 -5\\n2 2\") == \"4\");\n    assert(solution(\"7 4\\n-2 -2\\n-1 -1\\n0 0\\n1 1\\n2 2\\n3 3\\n4 4\") == \"6\");\n    assert(solution(\"10 5\\n0 0\\n1 1\\n2 2\\n3 3\\n4 4\\n5 5\\n6 6\\n7 7\\n8 8\\n9 9\") == \"10\");\n    assert(solution(\"3 0\\n0 0\\n0 0\\n0 0\\n\") == \"0\");\n    assert(solution(\"6 3\\n-5 -5\\n-10 -10\\n-12 -5\\n-5 -12\\n-10 5\\n-5 5\\n\") == \"20\");\n    assert(solution(\"5 2\\n0 0\\n-2 -2\\n2 2\\n-3 3\\n3 -3\\n\") == \"10\");\n    assert(solution(\"8 4\\n-5 -5\\n-3 -3\\n-1 -1\\n3 3\\n5 5\\n7 7\\n9 9\\n11 11\\n\") == \"16\");\n    assert(solution(\"3 1\\n1 1\\n2 2\\n3 3\\n\") == \"4\");\n    return 0; \n}", "prompt": "/*Bessie is participating in a city marathon where she needs to visit N (3 <= N <= 500) checkpoints in sequence, where checkpoint 1 is the starting location and checkpoint N is the finish. She can skip up to K checkpoints (K < N) to reduce her total journey, but checkpoints 1 and N cannot be skipped. The distance between two checkpoints at locations (x1, y1) and (x2, y2) is given by |x1-x2| + |y1-y2|.\n\ninput_format:\nThe first line provides the values of N and K.\n\n\nThe following N lines each contain two integers separated by a space, x and y, which represent a checkpoint (-1000 <= x <= 1000, -1000 <= y <= 1000).\n\n\nThe checkpoints are listed in the order that they need to be visited.\n\n\nIt is important to note that the track may cross itself multiple times, resulting in several checkpoints occurring at the same physical location. If Bessie chooses to skip a checkpoint at a certain location, she will only skip one instance of that checkpoint and not all the checkpoints at the same location.\n\noutput_format:\nOutput the minimum distance that Bessie can run by skipping up to K checkpoints. In the sample case shown here, skipping the checkpoints at (8, 3) and (10, -5) leads to the minimum total distance of 4.\n*/\n\n#include<sstream>\n#include<stdlib.h>\n#include<algorithm>\n#include<math.h>\n#include<stdio.h>\n#include<vector>\n#include<string>\n#include<climits>\n#include<cstring>\n#include<iostream>\nusing namespace std;\n\n             \nstring solution(string std_in){\n    istringstream iss(std_in);\n             ", "constraints": "", "samples": [["5 2\n0 0\n8 3\n1 1\n10 -5\n2 2", "4"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}}
{"task_id": "P5364", "title": "[SNOI2017]礼物", "difficulty": "advanced", "nl": "The friendly **little monkey** invites friends in the forest to dinner, numbered from $1$ to $N$. Each arriving friend will bring him some gifts: **big bananas**. Among them, the first friend will bring him $1$ **big banana**. After that, every time a friend arrives, he will bring as many gifts as the sum of the gift numbers brought by all the previous friends plus his own number raised to the power of $K$. So, assuming that $K=2$, the number of gifts brought by the first few friends are:\n\n$1,5,15,37,83,\\ldots$\n\nAssume $K=3$, the number of gifts brought by the first few friends are:\n\n$1,9,37,111,\\ldots$\n\nNow, the **little monkey** is curious about how many gifts he can receive from his $N$th friend, so he asks for your help.\n\nGiven $N,K$, please output the number of gifts sent by the $N$th friend, modulo $10^9+7$.", "code": "// luogu-judger-enable-o2\n#include <algorithm>\n#include <cctype>\n#include <cstdio>\n#include <cstring>\n\ntypedef long long LL;\n\nconst int K = 15;\nconst int mod = 1000000007;\n\nLL pow_mod(LL a, LL b) {\n  LL ans = 1;\n  for (; b; b >>= 1, a = a * a % mod)\n    if (b & 1) ans = ans * a % mod;\n  return ans;\n}\n\nLL pK[K], f[K], inv[K];\nint pr[K], cnt;\n\nvoid Sieve(int k) {\n  pK[1] = 1;\n  for (int i = 2; i <= k + 1; ++i) {\n    if (!pK[i]) pK[pr[cnt++] = i] = pow_mod(i, k);\n    for (int j = 0; pr[j] * i <= k + 1; ++j) {\n      pK[i * pr[j]] = pK[i] * pK[pr[j]] % mod;\n      if (i % pr[j] == 0) break;\n    }\n  }\n}\n\nint main() {\n  int k; LL n;\n  scanf(\"%lld%d\", &n, &k); --n;\n\n  LL s = 0, tn = n % mod;\n  Sieve(k);\n  for (int i = 0; i <= k; ++i) {\n    if ((f[i] = s + pK[i + 1]) >= mod) f[i] -= mod;\n    if ((s += f[i]) >= mod) s -= mod;\n  }\n  if (n <= k) return printf(\"%lld\\n\", f[n]) & 0;\n\n  LL g = -1; inv[1] = 1;\n  for (int i = 2; i <= k; ++i) {\n    inv[i] = -(mod / i) * inv[mod % i] % mod;\n    g = g * -inv[i] % mod;\n  }\n\n  LL c = 1, p = 0;\n  for (int i = 0; i <= k; ++i) {\n    // sum_{i=0}^k (-1)^(k-i) C(k, i) f[i+1]\n    LL _t = c * f[i] % mod;\n    c = c * inv[i + 1] % mod * (k - i) % mod;\n    if ((k - i) & 1) p -= _t;\n    else p += _t;\n  }\n\n  LL ans = 0, p2 = p, t = 1;\n  for (int i = 0; i <= k; ++i) {\n    LL _y = (f[i] - p2) * g % mod;\n    ans = (ans * (tn - i) + _y * t) % mod;\n\n    t = t * (tn - i) % mod;\n    p2 = p2 * 2 % mod;\n    g = g * (i - k) % mod * inv[i + 1] % mod;\n  }\n  ans = (ans + p * pow_mod(2, n % (mod - 1))) % mod;\n  printf(\"%lld\\n\", (ans + mod) % mod);\n}", "step": ["Initialize variables and input values.", "Call Sieve function to calculate pre-calculated values.", "Calculate f with the help of pre-calculated values.", "Calculate g, c, and p using mod math.", "Calculate ans using mod math.", "Return ans."], "nl_cn": "热情好客的**小猴子**请森林中的朋友们吃饭，他的朋友被编号为 $1\\sim N$，每个到来的朋友都会带给他一些礼物：**大香蕉**。其中，第一个朋友会带给他 $1$ 个**大香蕉**，之后，每一个朋友到来以后，都会带给他之前所有人带来的礼物个数再加他的编号的 $K$ 次方那么多个。所以，假设 $K=2$，前几位朋友带来的礼物个数分别是：\n\n$1,5,15,37,83,\\ldots$\n\n假设 $K=3$，前几位朋友带来的礼物个数分别是：\n\n$1,9,37,111,\\ldots$\n\n现在，**小猴子**好奇自己到底能收到第 $N$ 个朋友多少礼物，因此拜托于你了。\n\n已知 $N,K$，请输出第 $N$ 个朋友送的礼物个数对 $10^9+7$ 取模的结果。", "test_cases": [{"input": "4 2", "output": "37"}, {"input": "2333333 2", "output": "514898185"}, {"input": "1234567890000 3", "output": "891659731"}, {"input": "66666666 10", "output": "32306309"}, {"input": "1 2\n", "output": "1"}, {"input": "2 2\n", "output": "5"}, {"input": "3 2\n", "output": "15"}, {"input": "5 2", "output": "83"}, {"input": "1 3", "output": "1"}, {"input": "2 3", "output": "9"}, {"input": "3 3", "output": "37"}, {"input": "4 3", "output": "111"}, {"input": "1 4", "output": "1"}, {"input": "2 4", "output": "17"}, {"input": "1 5", "output": "1"}, {"input": "2 5", "output": "33"}, {"input": "1 1\n", "output": "1"}], "test": "#undef NDEBUG\n#include<assert.h>\nint main(){\n    assert(solution(\"4 2\") == \"37\");\n    assert(solution(\"2333333 2\") == \"514898185\");\n    assert(solution(\"1234567890000 3\") == \"891659731\");\n    assert(solution(\"66666666 10\") == \"32306309\");\n    assert(solution(\"1 2\\n\") == \"1\");\n    assert(solution(\"2 2\\n\") == \"5\");\n    assert(solution(\"3 2\\n\") == \"15\");\n    assert(solution(\"5 2\") == \"83\");\n    assert(solution(\"1 3\") == \"1\");\n    assert(solution(\"2 3\") == \"9\");\n    assert(solution(\"3 3\") == \"37\");\n    assert(solution(\"4 3\") == \"111\");\n    assert(solution(\"1 4\") == \"1\");\n    assert(solution(\"2 4\") == \"17\");\n    assert(solution(\"1 5\") == \"1\");\n    assert(solution(\"2 5\") == \"33\");\n    assert(solution(\"1 1\\n\") == \"1\");\n    return 0; \n}", "prompt": "/*The friendly **little monkey** invites friends in the forest to dinner, numbered from $1$ to $N$. Each arriving friend will bring him some gifts: **big bananas**. Among them, the first friend will bring him $1$ **big banana**. After that, every time a friend arrives, he will bring as many gifts as the sum of the gift numbers brought by all the previous friends plus his own number raised to the power of $K$. So, assuming that $K=2$, the number of gifts brought by the first few friends are:\n\n$1,5,15,37,83,\\ldots$\n\nAssume $K=3$, the number of gifts brought by the first few friends are:\n\n$1,9,37,111,\\ldots$\n\nNow, the **little monkey** is curious about how many gifts he can receive from his $N$th friend, so he asks for your help.\n\nGiven $N,K$, please output the number of gifts sent by the $N$th friend, modulo $10^9+7$.\n\ninput_format:\nFirst line, two integers $N,K$.\n\noutput_format:\nAn integer representing the number of gifts from the $N$friend modulo $10^9+7$.\n*/\n\n#include<sstream>\n#include<stdlib.h>\n#include<algorithm>\n#include<math.h>\n#include<stdio.h>\n#include<vector>\n#include<string>\n#include<climits>\n#include<cstring>\n#include<iostream>\nusing namespace std;\n\n             \nstring solution(string std_in){\n    istringstream iss(std_in);\n             ", "constraints": "- $20\\%$ 的数据：$N \\le 10^6$；\n- 另外 $10\\%$ 的数据：$K=1$；\n- 另外 $20\\%$ 的数据：$K=2$；\n- 另外 $20\\%$ 的数据：$K=3$；\n- $100\\%$ 的数据：$N \\le 10^{18}$，$K \\le 10$。", "samples": [["4 2", "37"], ["2333333 2", "514898185"], ["1234567890000 3", "891659731"], ["66666666 10", "32306309"]], "limits": {"time": [1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500], "memory": [512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000]}}
{"task_id": "P1535", "title": "[USACO08MAR]Cow Travelling S", "difficulty": "challenge", "nl": "The cows are wandering around on a grassland divided into N rows and M columns (2 ≤ N, M ≤ 100), trying to find the most delicious pasture in the whole area.\n\nAt some point, Farmer John sees Bessie at position (R1,C1), and exactly T (0 < T ≤ 15) seconds later, FJ runs into Bessie at position (R2,C2). FJ doesn't know if Bessie has been to (R2,C2) during those T seconds; all he knows is that she's there now.\n\nLet S be the total number of paths the cow could have taken to get from (R1,C1) to (R2,C2) in T seconds. During each second, the cow can move horizontally or vertically by one unit (the cow is always moving and never stays in the same place for two consecutive seconds). Some places in the grassland have trees, and of course, the cow cannot go through trees or off the edge of the field.\n\nNow you are given a terrain map of the entire grassland, where '.' represents the flat grass and '*' represents trees obstructing the path. Your task is to compute the possible paths the cow could take to move from (R1,C1) to (R2,C2) in T seconds.", "code": "////////////////////////\n///////////////////////\n//////////////////////\n/////////////////////\n/////Author/////////\n//////zyh//////////\n//////////////////\n/////////////////\n////////////////\n///////////////\n//////////////\n/////////////\n////////////\n#include<bits/stdc++.h>\n#define EL putchar('\\n')\n#define SP putchar(' ')\nusing namespace std;\nconst int dx[4]={1,-1,0,0};\nconst int dy[4]={0,0,1,-1};\nint n,m,t,r1,c1,r2,c2;\nbitset<108>b[108];\nint re[108][108][20];\nint dfs(int x,int y,int time)\n{\n\tif(re[x][y][time]!=-1)return re[x][y][time];\n\tif(abs(x-r2)+abs(y-c2)>t-time)return re[x][y][time]=0;\n\tif(time>t)return re[x][y][time]=0;\n\tif(time==t)\n\t{\n\t\tif(x==r2&&y==c2)return re[x][y][time]=1;\n\t\telse return re[x][y][time]=0;\n\t}\n\tint ans=0;\n\tfor(int i=0;i<4;i++)\n\t{\n\t\tif(b[x+dx[i]][y+dy[i]]||x+dx[i]<1||x+dx[i]>n||y+dy[i]<1||y+dy[i]>m)continue;\n\t\tans+=dfs(x+dx[i],y+dy[i],time+1);\n\t}\n\treturn re[x][y][time]=ans;\n}\nint main()\n{\n\tcin>>n>>m>>t;\n\tmemset(re,-1,sizeof(re));\n\tfor(int i=1;i<=n;i++)\n\t{\n\t\tstring s;\n\t\tcin>>s;\n\t\tfor(int j=0;j<m;j++)\n\t\t{\n\t\t\tif(s[j]=='*')b[i][j+1]=1;\n\t\t}\n\t}\n\tcin>>r1>>c1>>r2>>c2;\n\tcout<<dfs(r1,c1,0)<<endl;\n \treturn 0;\n}", "step": ["Initialize grid size, time limit and start and end points.", "Fill the grid with obstacles.", "Use depth-first search to find the number of ways to move from one point to another within a time limit.", "Implement memoization to store previous search results.", "Return the number of ways found.", "Print the final answer."], "nl_cn": "奶牛们在被划分成 $N$ 行 $M$ 列（$2 \\leq N,M \\leq 100$）的草地上游走， 试图找到整块草地中最美味的牧草。\n\nFarmer John 在某个时刻看见贝茜在位置 $(R_1, C_1)$，恰好 $T$（$0 \\lt T \\leq 15$）秒后，FJ 又在位置 $(R_2, C_2)$ 与贝茜撞了正着。FJ 并不知道在这 $T$ 秒内贝茜是否曾经到过 $(R_2, C_2)$，他能确定的只是，现在贝茜在那里。\n\n设 $S$ 为奶牛在 $T$ 秒内从 $(R_1, C_1)$ 走到 $(R_2, C_2)$ 所能选择的路径总数，FJ 希望有 一个程序来帮他计算这个值。每一秒内，奶牛会水平或垂直地移动 $1$ 单位距离（奶牛总是在移动，不会在某秒内停在它上一秒所在的点）。草地上的某些地方有树，自然，奶牛不能走到树所在的位置，也不会走出草地。\n\n现在你拿到了一张整块草地的地形图，其中 `.` 表示平坦的草地，`*` 表示挡路的树。你的任务是计算出，一头在 $T$ 秒内从 $(R_1, C_1)$ 移动到 $(R_2, C_2)$ 的奶牛可能经过的路径有哪些。", "test_cases": [{"input": "4 5 6\n...*.\n...*.\n.....\n.....\n1 3 1 5", "output": "1"}, {"input": "2 2 2\n..\n..\n1 1 2 2", "output": "2"}, {"input": "3 4 3\n....\n.*.*\n....\n3 1 1 4", "output": "0"}, {"input": "3 3 2\n.*.\n..\n.*.\n3 2 1 1", "output": "0"}, {"input": "3 3 3\n.*.\n...\n.*.\n1 1 3 1", "output": "0"}, {"input": "2 2 2\n.*\n.*\n2 1 1 2", "output": "0"}, {"input": "3 3 2\n**.\n..*\n.*.\n1 3 3 1", "output": "0"}, {"input": "2 3 2\n.**\n...\n1 1 2 3", "output": "0"}, {"input": "3 3 2\n.*.\n*.*\n..*\n3 2 1 1", "output": "0"}, {"input": "3 3 3\n...\n*..\n..*\n3 1 2 2", "output": "0"}, {"input": "4 4 2\n....\n**..\n....\n....\n1 2 4 3", "output": "0"}, {"input": "3 3 2\n.*.\n.*.\n*..\n1 3 2 2", "output": "0"}, {"input": "2 2 1\n.*\n.*\n1 1 2 2\n", "output": "0"}, {"input": "3 3 2\n.*.\n...\n*..\n1 1 3 3\n", "output": "0"}, {"input": "3 3 4\n.*.\n.*.\n.*.\n1 1 3 3\n", "output": "0"}, {"input": "3 3 3\n...\n.*.\n...\n1 1 3 2\n", "output": "1"}, {"input": "3 3 2\n..*\n..*\n...\n1 1 3 3\n", "output": "0"}, {"input": "3 3 3\n*..\n.*.\n...\n1 1 3 3\n", "output": "0"}, {"input": "3 3 4\n.*.\n..*\n.*.\n1 1 3 3\n", "output": "0"}, {"input": "3 3 2\n.*.\n.*.\n.*.\n1 1 3 3\n", "output": "0"}, {"input": "3 3 3\n...\n..*\n*..\n1 1 3 3\n", "output": "0"}, {"input": "3 4 3\n....\n....\n....\n1 2 3 4\n", "output": "0"}, {"input": "5 5 5\n.....\n.....\n.*...\n.....\n.....\n1 1 1 5\n", "output": "0"}, {"input": "4 3 3\n...\n.*.\n...\n...\n1 1 4 3\n", "output": "0"}, {"input": "3 3 4\n.*.\n.*.\n...\n1 1 2 2\n", "output": "0"}, {"input": "2 3 3\n***\n..*\n1 1 2 3\n", "output": "0"}, {"input": "4 5 3\n.....\n.....\n.*..*\n.....\n1 1 4 4\n", "output": "0"}, {"input": "5 5 4\n.....\n.*...\n.....\n.....\n.....\n1 1 5 5\n", "output": "0"}, {"input": "3 4 2\n....\n....\n....\n1 1 3 4\n", "output": "0"}, {"input": "3 3 3\n.*.\n.*.\n...\n1 1 2 2\n", "output": "0"}, {"input": "4 5 3\n.....\n.....\n..*..\n.....\n1 1 4 3\n", "output": "0"}, {"input": "5 5 4\n.....\n.....\n.....\n.....\n.*...\n1 1 5 5\n", "output": "0"}, {"input": "5 5 5\n.....\n.*...\n.....\n.....\n.....\n1 1 5 5\n", "output": "0"}, {"input": "2 3 1\n***\n...\n1 1 2 3\n", "output": "0"}, {"input": "2 2 3\n.*\n.*\n1 1 2 2\n", "output": "0"}, {"input": "3 3 2\n...\n.*.\n...\n1 1 3 3\n", "output": "0"}, {"input": "4 4 4\n....\n.*..\n...*\n..*.\n1 1 4 4\n", "output": "0"}, {"input": "3 3 3\n...\n.*.\n...\n1 1 3 3\n", "output": "0"}, {"input": "3 3 3\n...\n...\n...\n1 1 3 3\n", "output": "0"}, {"input": "5 5 2\n.....\n.*.*.\n.***.\n.*.*.\n.....\n1 1 5 5\n", "output": "0"}], "test": "#undef NDEBUG\n#include<assert.h>\nint main(){\n    assert(solution(\"4 5 6\\n...*.\\n...*.\\n.....\\n.....\\n1 3 1 5\") == \"1\");\n    assert(solution(\"2 2 2\\n..\\n..\\n1 1 2 2\") == \"2\");\n    assert(solution(\"3 4 3\\n....\\n.*.*\\n....\\n3 1 1 4\") == \"0\");\n    assert(solution(\"3 3 2\\n.*.\\n..\\n.*.\\n3 2 1 1\") == \"0\");\n    assert(solution(\"3 3 3\\n.*.\\n...\\n.*.\\n1 1 3 1\") == \"0\");\n    assert(solution(\"2 2 2\\n.*\\n.*\\n2 1 1 2\") == \"0\");\n    assert(solution(\"3 3 2\\n**.\\n..*\\n.*.\\n1 3 3 1\") == \"0\");\n    assert(solution(\"2 3 2\\n.**\\n...\\n1 1 2 3\") == \"0\");\n    assert(solution(\"3 3 2\\n.*.\\n*.*\\n..*\\n3 2 1 1\") == \"0\");\n    assert(solution(\"3 3 3\\n...\\n*..\\n..*\\n3 1 2 2\") == \"0\");\n    assert(solution(\"4 4 2\\n....\\n**..\\n....\\n....\\n1 2 4 3\") == \"0\");\n    assert(solution(\"3 3 2\\n.*.\\n.*.\\n*..\\n1 3 2 2\") == \"0\");\n    assert(solution(\"2 2 1\\n.*\\n.*\\n1 1 2 2\\n\") == \"0\");\n    assert(solution(\"3 3 2\\n.*.\\n...\\n*..\\n1 1 3 3\\n\") == \"0\");\n    assert(solution(\"3 3 4\\n.*.\\n.*.\\n.*.\\n1 1 3 3\\n\") == \"0\");\n    assert(solution(\"3 3 3\\n...\\n.*.\\n...\\n1 1 3 2\\n\") == \"1\");\n    assert(solution(\"3 3 2\\n..*\\n..*\\n...\\n1 1 3 3\\n\") == \"0\");\n    assert(solution(\"3 3 3\\n*..\\n.*.\\n...\\n1 1 3 3\\n\") == \"0\");\n    assert(solution(\"3 3 4\\n.*.\\n..*\\n.*.\\n1 1 3 3\\n\") == \"0\");\n    assert(solution(\"3 3 2\\n.*.\\n.*.\\n.*.\\n1 1 3 3\\n\") == \"0\");\n    assert(solution(\"3 3 3\\n...\\n..*\\n*..\\n1 1 3 3\\n\") == \"0\");\n    assert(solution(\"3 4 3\\n....\\n....\\n....\\n1 2 3 4\\n\") == \"0\");\n    assert(solution(\"5 5 5\\n.....\\n.....\\n.*...\\n.....\\n.....\\n1 1 1 5\\n\") == \"0\");\n    assert(solution(\"4 3 3\\n...\\n.*.\\n...\\n...\\n1 1 4 3\\n\") == \"0\");\n    assert(solution(\"3 3 4\\n.*.\\n.*.\\n...\\n1 1 2 2\\n\") == \"0\");\n    assert(solution(\"2 3 3\\n***\\n..*\\n1 1 2 3\\n\") == \"0\");\n    assert(solution(\"4 5 3\\n.....\\n.....\\n.*..*\\n.....\\n1 1 4 4\\n\") == \"0\");\n    assert(solution(\"5 5 4\\n.....\\n.*...\\n.....\\n.....\\n.....\\n1 1 5 5\\n\") == \"0\");\n    assert(solution(\"3 4 2\\n....\\n....\\n....\\n1 1 3 4\\n\") == \"0\");\n    assert(solution(\"3 3 3\\n.*.\\n.*.\\n...\\n1 1 2 2\\n\") == \"0\");\n    assert(solution(\"4 5 3\\n.....\\n.....\\n..*..\\n.....\\n1 1 4 3\\n\") == \"0\");\n    assert(solution(\"5 5 4\\n.....\\n.....\\n.....\\n.....\\n.*...\\n1 1 5 5\\n\") == \"0\");\n    assert(solution(\"5 5 5\\n.....\\n.*...\\n.....\\n.....\\n.....\\n1 1 5 5\\n\") == \"0\");\n    assert(solution(\"2 3 1\\n***\\n...\\n1 1 2 3\\n\") == \"0\");\n    assert(solution(\"2 2 3\\n.*\\n.*\\n1 1 2 2\\n\") == \"0\");\n    assert(solution(\"3 3 2\\n...\\n.*.\\n...\\n1 1 3 3\\n\") == \"0\");\n    assert(solution(\"4 4 4\\n....\\n.*..\\n...*\\n..*.\\n1 1 4 4\\n\") == \"0\");\n    assert(solution(\"3 3 3\\n...\\n.*.\\n...\\n1 1 3 3\\n\") == \"0\");\n    assert(solution(\"3 3 3\\n...\\n...\\n...\\n1 1 3 3\\n\") == \"0\");\n    assert(solution(\"5 5 2\\n.....\\n.*.*.\\n.***.\\n.*.*.\\n.....\\n1 1 5 5\\n\") == \"0\");\n    return 0; \n}", "prompt": "/*The cows are wandering around on a grassland divided into N rows and M columns (2 ≤ N, M ≤ 100), trying to find the most delicious pasture in the whole area.\n\nAt some point, Farmer John sees Bessie at position (R1,C1), and exactly T (0 < T ≤ 15) seconds later, FJ runs into Bessie at position (R2,C2). FJ doesn't know if Bessie has been to (R2,C2) during those T seconds; all he knows is that she's there now.\n\nLet S be the total number of paths the cow could have taken to get from (R1,C1) to (R2,C2) in T seconds. During each second, the cow can move horizontally or vertically by one unit (the cow is always moving and never stays in the same place for two consecutive seconds). Some places in the grassland have trees, and of course, the cow cannot go through trees or off the edge of the field.\n\nNow you are given a terrain map of the entire grassland, where '.' represents the flat grass and '*' represents trees obstructing the path. Your task is to compute the possible paths the cow could take to move from (R1,C1) to (R2,C2) in T seconds.\n\ninput_format:\nThe first line contains $3$integers separated by Spaces: $N,M,T$.\n\nNext $n$line: The first $i$behavior $M$consecutive characters, describing the situation of the first $i$line points of the grass, ensuring that the character is one of '. 'and' * '.\n\nLast line $4$integers $R_1,C_1,R_2,C_2$.\n\noutput_format:\nOutput the number of schemes moved from $(R_1, C_1)$to $(R_2, C_2)$.\n*/\n\n#include<sstream>\n#include<stdlib.h>\n#include<algorithm>\n#include<math.h>\n#include<stdio.h>\n#include<vector>\n#include<string>\n#include<climits>\n#include<cstring>\n#include<iostream>\nusing namespace std;\n\n             \nstring solution(string std_in){\n    istringstream iss(std_in);\n             ", "constraints": "奶牛在 $6$ 秒内从 $(1,3)$ 走到 $(1,5)$ 的方法只有一种，绕过她面前的树。", "samples": [["4 5 6\n...*.\n...*.\n.....\n.....\n1 3 1 5", "1\n"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288]}}
{"task_id": "P3913", "title": "车的攻击", "difficulty": "challenge", "nl": "On an $N\\times N$ chessboard, there are $K$ rooks placed at row $R_i$ and column $C_i$. Find the minimum number of squares that are attacked by at least one rook. A rook can attack all squares on its row and column.", "code": "#include <iostream>\n#include <iomanip>\n#include <algorithm>\n#include <cstdio>\n#include <vector>\n#include <queue>\n#define ll long long\nconst int maxn=1e6+5;\nusing namespace std;\nll n,k;\nll x[maxn],y[maxn];\nint main(){\n //       freopen(\"test.in\",\"r\",stdin);\n        //cin>>n>>k;\n        scanf(\"%lld%lld\",&n,&k);\n        for(ll i=0;i<k;i++){\n                //cin>>x[i]>>y[i];\n            scanf(\"%lld%lld\",&x[i],&y[i]);\n        }\n        sort(x,x+k);\n        sort(y,y+k);\n        ll sizex=unique(x,x+k)-x;\n        ll sizey=unique(y,y+k)-y;\n        //cout<<n*n-(n-sizex)*(n-sizey);\n        printf(\"%lld\",n*n-(n-sizex)*(n-sizey));\n        return 0;\n}", "step": ["Read the number of rows and columns and the number of rows and columns to be removed.", "Read the indices of rows and columns to be removed.", "Sort the indices of rows and columns.", "Compute the number of unique rows and columns.", "Calculate the number of cells in the grid after removing the desired rows and columns.", "Print the result."], "nl_cn": "$N \\times N$ 的国际象棋棋盘上有$K$ 个车，第$i$个车位于第$R_i$行，第$C_i$ 列。求至少被一个车攻击的格子数量。\n\n车可以攻击所有同一行或者同一列的地方。\n", "test_cases": [{"input": "3 2\n1 2\n2 2", "output": "7"}, {"input": "2 1\n2 2\n", "output": "3"}, {"input": "6 3\n4 2\n1 1\n6 3\n", "output": "27"}, {"input": "2 1\n2 1\n", "output": "3"}, {"input": "3 3\n1 1\n2 2\n3 3\n", "output": "9"}, {"input": "2 2\n1 1\n2 2\n", "output": "4"}, {"input": "3 2\n1 1\n2 2\n", "output": "8"}, {"input": "4 3\n1 1\n1 4\n4 1\n", "output": "12"}, {"input": "5 1\n4 5\n", "output": "9"}], "test": "#undef NDEBUG\n#include<assert.h>\nint main(){\n    assert(solution(\"3 2\\n1 2\\n2 2\") == \"7\");\n    assert(solution(\"2 1\\n2 2\\n\") == \"3\");\n    assert(solution(\"6 3\\n4 2\\n1 1\\n6 3\\n\") == \"27\");\n    assert(solution(\"2 1\\n2 1\\n\") == \"3\");\n    assert(solution(\"3 3\\n1 1\\n2 2\\n3 3\\n\") == \"9\");\n    assert(solution(\"2 2\\n1 1\\n2 2\\n\") == \"4\");\n    assert(solution(\"3 2\\n1 1\\n2 2\\n\") == \"8\");\n    assert(solution(\"4 3\\n1 1\\n1 4\\n4 1\\n\") == \"12\");\n    assert(solution(\"5 1\\n4 5\\n\") == \"9\");\n    return 0; \n}", "prompt": "/*On an $N\\times N$ chessboard, there are $K$ rooks placed at row $R_i$ and column $C_i$. Find the minimum number of squares that are attacked by at least one rook. A rook can attack all squares on its row and column.\n\ninput_format:\nRow 1, 2 integers $N,K$.\n\nThe next line is K, each line has 2 integers $R_i,C_i$.\n\noutput_format:\n1 integer, indicating the number of cells attacked.\n*/\n\n#include<sstream>\n#include<stdlib.h>\n#include<algorithm>\n#include<math.h>\n#include<stdio.h>\n#include<vector>\n#include<string>\n#include<climits>\n#include<cstring>\n#include<iostream>\nusing namespace std;\n\n             \nstring solution(string std_in){\n    istringstream iss(std_in);\n             ", "constraints": "• 对于30% 的数据，$1 \\le N \\le 10^3; 1 \\le K \\le 10^3$；\n\n• 对于60% 的数据，$1 \\le N \\le 10^6; 1 \\le K \\le 10^6$；\n\n• 对于100% 的数据，$1 \\le N \\le 10^9; 1 \\le K \\le 10^6; 1 \\le R_i , C_i \\le N$。\n", "samples": [["3 2\n1 2\n2 2", "7"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}}
{"task_id": "P4851", "title": "yyf hates ganhuodong", "difficulty": "challenge", "nl": "You are given $11$ positive integers:\n\n$a$: the amount of activity points you gain for completing a song\n$b$: the LP cost of completing a song\n$c$: your LP limit at the start of the event\n$d$: your initial LP at the start of the event\n$e$: your experience point limit at the start of the event\n$f$: your initial experience points at the start of the event\n$g$: the amount of experience points you gain for completing a song\n$h$: the increase in LP limit upon leveling up\n$k$: the increase in experience point limit upon leveling up\n$x$: the remaining time until the end of the event (in hours)\n$y$: your target amount of activity points\n\nAssuming that it takes no time for you to play a song, every time you play a song you spend a certain amount of LP to gain a certain amount of activity points and experience points. Your initial activity points are 0.\n\nLP recovers automatically at a rate of 1 point per hour, and once it reaches the LP limit, it will not recover further (this case is not considered in this problem). However, you can exceed the LP limit by using the method described below.\n\nUpon reaching the experience point limit, you will level up, which increases your LP limit and restores \"new LP\" (the increased amount). The restored LP can exceed the LP limit, and the overflowed experience points will be carried over to the next level up. The experience point limit for the next level up will also increase.\n\nYou can spend a loveca at any time to gain LP up to the current LP limit (even exceeding the limit).\n\nYour goal is to obtain at least y activity points, and you want to know the minimum number of loveca needed to achieve this goal.\n\nIn the formal description, your initial LP can be considered as d+x, and you have two operations:\n\n1. Given that your experience points before the operation are $\\mathrm{exp}$, your LP limit is $\\mathrm{LPmax}$, and your LP value is $l$ (you can only perform operation 1 if $l \\ge b$), and your experience point limit is $\\mathrm{EXPmax}$, then after the operation your activity points increase by $a$.\n- If $\\mathrm{exp+g \\ge EXPmax}$, then your remaining LP value is $l-b+\\mathrm{LPmax}+h$, your experience points are $\\mathrm{(exp+g)\\bmod EXPmax}$, your LP limit increases by $h$, and your experience point limit increases by $k$\n- Otherwise, your remaining LP value is $l-b$, and your experience points are $\\mathrm{exp+g}$\n\n2. Given that your LP limit before the operation is $\\mathrm{LPmax}$ and your LP value is $l$, then after the operation your remaining LP value is $\\mathrm{LPmax}+l$\n\nYour goal is to have more than or equal to y activity points, and you want to know the minimum number of operation 2 required to achieve this goal.\n\nNote that you can play an arbitrary number of songs at the moment when the event ends, since playing songs does not take any time. Thus, the initial LP can be considered as d+x.", "code": "#include<iostream>\nusing namespace std;\nint a,b,c,d,e,f,g,h,k,x,y,pt,lp,exp;\nlong long cnt;//注意要用long long\nint main()//主函数\n{\n    cin >> a >> b >> c >> d >> e >> f >> g >> h >> k >> x >> y;//如此繁琐 \n    lp=d+x;exp=f;//初值 \n    while(pt<y)//开始（核心）\n    {\n        while(lp<b)cnt++,lp+=c;\n        lp-=b;pt+=a;exp+=g;\n        if(exp>=e)//如果没加等号就只有96分\n        {\n            exp-=e;\n    \t    e+=k;c+=h;lp+=c;\n        }\n    }\n    cout << cnt << endl;//输出答案\n    return 0;\n}", "step": ["Take input values a,b,c,d,e,f,g,h,k,x, and y.", "Calculate the value of lp and exp based on input values.", "Enter a while loop that continues to execute until pt<y.", "Increase the value of cnt based on conditions within the loop.", "If exp>=e then update the values of e, c, and lp.", "Print the value of cnt."], "nl_cn": "给你如下 $11$ 个正整数：\n\n$a$：完成一首歌曲所能获得的活动$\\mathrm{pt}$\n\n$b$：完成一首歌曲所需的 $\\mathrm{LP}$\n\n$c$：你开始肝活动时的 $\\mathrm{LP}$ 上限\n\n$d$：你开始肝活动时的 $\\mathrm{LP}$\n\n$e$：你开始肝活动时的经验值上限\n\n$f$：你开始肝活动时的经验值\n\n$g$：打一首歌能获得的经验值\n\n$h$：升一级增加的 $\\mathrm{LP}$ 上限\n\n$k$：升一级增加的经验值上限\n\n$x$：离活动结束的剩余时间（小时）\n\n$y$：你的目标活动$\\mathrm{pt}$\n\n假设yyf打歌不需要花费时间，每打一首歌需要花费一定的 $\\mathrm{LP}$ 来获取一定的活动$\\mathrm{pt}$ 以及一定的经验值。yyf的初始活动$\\mathrm{pt}$ 为 $0$\n\n$\\mathrm{LP}$ 每小时自动恢复 $1$ 点，$\\mathrm{LP}$ 达到上限后不会自动恢复（本题不需考虑这种情况），但可以通过后文所述方式超过上限。\n\n经验值达到上限后会升级，升级时会增加 $\\mathrm{LP}$上限并恢复“新的 $\\mathrm{LP}$上限”（增加后的）点 $\\mathrm{LP}$，恢复后的 $\\mathrm{LP}$ 可以超过 $\\mathrm{LP}$ 上限，且溢出的经验值会计入下一次升级，下一次升级所需要的经验值（经验值上限）会增加。\n\n可以随时耗费一个 $\\mathrm{loveca}$ 来获得当前 $\\mathrm{LP}$上限点 $\\mathrm{LP}$（可以超过上限）。\n\n你的目标是获得大于等于 $y$ 的活动$\\mathrm{pt}$，请求出最少需要耗费多少个 $\\mathrm{loveca}$。\n\n形式化地说，你初始的 $\\mathrm{LP}$ 可以视作 $d+x$，你有两种操作：\n\n1. 设你操作前的经验值为 $\\mathrm{exp}$，$\\mathrm{LP}$上限为 $\\mathrm{LPmax}$，$\\mathrm{LP}$ 值为 $l$（当且仅当 $l \\ge b$ 时能进行操作 $1$ ），经验值上限为 $\\mathrm{EXPmax}$，则在你操作后活动$\\mathrm{pt}$ 加上 $a$ 。\n- 若 $\\mathrm{exp+g \\ge EXPmax}$，则你的剩余 $\\mathrm{LP}$值为 $l-b+\\mathrm{LPmax}+h$，经验值为 \n $\\mathrm{(exp+g)\\bmod EXPmax}$，$\\mathrm{LP}$上限加上 $h$，经验值上限加上 $k$\n- 否则你的剩余 $\\mathrm{LP}$值为 $l-b$，经验值为 $\\mathrm{exp+g}$\n\n2. 设你操作前的 $\\mathrm{LP}$上限为 $\\mathrm{LPmax}$，$\\mathrm{LP}$值为 $l$ ，则你操作后的剩余 $\\mathrm{LP}$值为 $\\mathrm{LPmax}+l$\n\n你的目标为使你的活动$\\mathrm{pt}$ 大于等于 $y$ ，请求出最少需要的操作 $2$ 数量\n\n## 由于打歌不计时间可以在活动结束的瞬间打任意次歌，即进行任意次操作1，也就是初始LP可以视作d+x", "test_cases": [{"input": "9 7 46 6 114 50 17 6 18 11 9118", "output": "7"}, {"input": "8 6 30 10 1000 200 30 5 20 10 90", "output": "2"}, {"input": "1 1 1 1 1 1 1 1 1 1 1", "output": "0"}, {"input": "10 5 50 5 100 0 20 3 5 10 101", "output": "1"}, {"input": "10 5 50 5 100 0 20 3 5 10 95", "output": "1"}, {"input": "5 3 20 5 50 0 10 2 5 8 73", "output": "1"}, {"input": "4 2 15 3 40 0 12 2 3 5 38", "output": "0"}, {"input": "8 6 40 4 90 0 25 4 6 10 55", "output": "1"}], "test": "#undef NDEBUG\n#include<assert.h>\nint main(){\n    assert(solution(\"9 7 46 6 114 50 17 6 18 11 9118\") == \"7\");\n    assert(solution(\"8 6 30 10 1000 200 30 5 20 10 90\") == \"2\");\n    assert(solution(\"1 1 1 1 1 1 1 1 1 1 1\") == \"0\");\n    assert(solution(\"10 5 50 5 100 0 20 3 5 10 101\") == \"1\");\n    assert(solution(\"10 5 50 5 100 0 20 3 5 10 95\") == \"1\");\n    assert(solution(\"5 3 20 5 50 0 10 2 5 8 73\") == \"1\");\n    assert(solution(\"4 2 15 3 40 0 12 2 3 5 38\") == \"0\");\n    assert(solution(\"8 6 40 4 90 0 25 4 6 10 55\") == \"1\");\n    return 0; \n}", "prompt": "/*You are given $11$ positive integers:\n\n$a$: the amount of activity points you gain for completing a song\n$b$: the LP cost of completing a song\n$c$: your LP limit at the start of the event\n$d$: your initial LP at the start of the event\n$e$: your experience point limit at the start of the event\n$f$: your initial experience points at the start of the event\n$g$: the amount of experience points you gain for completing a song\n$h$: the increase in LP limit upon leveling up\n$k$: the increase in experience point limit upon leveling up\n$x$: the remaining time until the end of the event (in hours)\n$y$: your target amount of activity points\n\nAssuming that it takes no time for you to play a song, every time you play a song you spend a certain amount of LP to gain a certain amount of activity points and experience points. Your initial activity points are 0.\n\nLP recovers automatically at a rate of 1 point per hour, and once it reaches the LP limit, it will not recover further (this case is not considered in this problem). However, you can exceed the LP limit by using the method described below.\n\nUpon reaching the experience point limit, you will level up, which increases your LP limit and restores \"new LP\" (the increased amount). The restored LP can exceed the LP limit, and the overflowed experience points will be carried over to the next level up. The experience point limit for the next level up will also increase.\n\nYou can spend a loveca at any time to gain LP up to the current LP limit (even exceeding the limit).\n\nYour goal is to obtain at least y activity points, and you want to know the minimum number of loveca needed to achieve this goal.\n\nIn the formal description, your initial LP can be considered as d+x, and you have two operations:\n\n1. Given that your experience points before the operation are $\\mathrm{exp}$, your LP limit is $\\mathrm{LPmax}$, and your LP value is $l$ (you can only perform operation 1 if $l \\ge b$), and your experience point limit is $\\mathrm{EXPmax}$, then after the operation your activity points increase by $a$.\n- If $\\mathrm{exp+g \\ge EXPmax}$, then your remaining LP value is $l-b+\\mathrm{LPmax}+h$, your experience points are $\\mathrm{(exp+g)\\bmod EXPmax}$, your LP limit increases by $h$, and your experience point limit increases by $k$\n- Otherwise, your remaining LP value is $l-b$, and your experience points are $\\mathrm{exp+g}$\n\n2. Given that your LP limit before the operation is $\\mathrm{LPmax}$ and your LP value is $l$, then after the operation your remaining LP value is $\\mathrm{LPmax}+l$\n\nYour goal is to have more than or equal to y activity points, and you want to know the minimum number of operation 2 required to achieve this goal.\n\nNote that you can play an arbitrary number of songs at the moment when the event ends, since playing songs does not take any time. Thus, the initial LP can be considered as d+x.\n\ninput_format:\nA single line is all the above positive integers totaling $11, meaning as described above\n\noutput_format:\nA positive integer representing the minimum amount of $\\mathrm{loveca}$to be spent\n*/\n\n#include<sstream>\n#include<stdlib.h>\n#include<algorithm>\n#include<math.h>\n#include<stdio.h>\n#include<vector>\n#include<string>\n#include<climits>\n#include<cstring>\n#include<iostream>\nusing namespace std;\n\n             \nstring solution(string std_in){\n    istringstream iss(std_in);\n             ", "constraints": "$a∈[1,10]$\n\n$b∈[5,20]$\n\n$c∈[30,50]$\n\n$d∈[5,10]$\n\n$e∈[100,200]$\n\n$f∈[1,50]$\n\n$g∈[10,20]$\n\n$h∈[5,10]$\n\n$k∈[10,20]$\n\n$x∈[10,15]$\n\n$y∈[5000,10000]$", "samples": [["9 7 46 6 114 50 17 6 18 11 9118", "7"]], "limits": {"time": [233, 233, 233, 233, 233, 233, 233, 233, 233, 233, 233, 233, 233, 233, 233, 233, 233, 233, 233, 233, 233, 233, 233, 233, 233, 233, 233, 233, 233, 233, 233, 233, 233, 233, 233, 233, 233, 233, 233, 233, 233, 233, 233, 233, 233, 233, 233, 233, 233, 233], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}}
{"task_id": "P6443", "title": "[COCI2010-2011#1] TIMSKO", "difficulty": "basic", "nl": "A university holds an informatics competition every year, where each team consists of 1 male student and 2 female students. In order to reduce the competition, the dean of a college arranges other competitors to go on internships in a distant country, and those who are sent on internships will not be able to participate in the competition. There are m female players and n male players, and k players can be sent on internships. The dean must create teams that can participate in the competition. Your task is to output the maximum number of teams that can be created.", "code": "#include<iostream>\nusing namespace std;\nint main()\n{\n\tint n,m,k,ans=0;\n\tcin>>n>>m>>k;//n是女生人数，m是男生人数 \n\tfor(int i=0;i<=(n+m-k)/3;i++)//组成队伍最大不超过剩余人数的三分之一 \n\t{\n\t\tint boy=m-i;//组成i个队伍，剩下男生人数 \n\t\tint girl=n-2*i;//组成i个队伍，剩下女生人数 \n\t\tif(boy+girl>=k&&boy>=0&&girl>=0)ans=i;//如果满足条件，则更新ans \n\t}\n\tcout<<ans;\n\treturn 0;\n }", "step": ["Take input for n, m and k.", "Run a loop from 0 to (n+m-k)/3 and check if the given condition is satisfied.", "Calculate the number of boys and girls in a pair at each iteration of the loop.", "If the condition is satisfied, update the ans variable.", "Print the final value of ans."], "nl_cn": "有一所大学每年都会举办一场信息学竞赛，竞赛中，每支队伍由 $1$ 名男生和  $2$ 名女生组成。一所学院的院长为了减少对手，把其他对手安排在一个遥远的国家进行实习，被派去实习的对手将无法参加比赛。所有选手中，女性选手的数量为 $m$，男性选手的数量为 $n$，可以派去实习的对手数量为 $k$。院长必须创建能参加比赛的队伍。你的任务是输出可以创建的最大团队数。", "test_cases": [{"input": "6 3 2", "output": "2"}, {"input": "2 1 1", "output": "0"}, {"input": "6 10 3", "output": "3"}, {"input": "0 0 0\n", "output": "0"}, {"input": "1 0 0\n", "output": "0"}, {"input": "3 5 2\n", "output": "1"}, {"input": "2 4 1\n", "output": "1"}, {"input": "1 1 0\n", "output": "0"}, {"input": "0 1 0", "output": "0"}, {"input": "1 1 1", "output": "0"}, {"input": "2 2 2", "output": "0"}, {"input": "3 3 3", "output": "1"}, {"input": "4 4 4", "output": "1"}, {"input": "6 6 6", "output": "2"}, {"input": "10 20 15\n", "output": "5"}, {"input": "7 5 4\n", "output": "2"}, {"input": "5 8 6\n", "output": "2"}, {"input": "5 10 5\n", "output": "2"}, {"input": "7 2 4\n", "output": "1"}, {"input": "3 3 2\n", "output": "1"}], "test": "#undef NDEBUG\n#include<assert.h>\nint main(){\n    assert(solution(\"6 3 2\") == \"2\");\n    assert(solution(\"2 1 1\") == \"0\");\n    assert(solution(\"6 10 3\") == \"3\");\n    assert(solution(\"0 0 0\\n\") == \"0\");\n    assert(solution(\"1 0 0\\n\") == \"0\");\n    assert(solution(\"3 5 2\\n\") == \"1\");\n    assert(solution(\"2 4 1\\n\") == \"1\");\n    assert(solution(\"1 1 0\\n\") == \"0\");\n    assert(solution(\"0 1 0\") == \"0\");\n    assert(solution(\"1 1 1\") == \"0\");\n    assert(solution(\"2 2 2\") == \"0\");\n    assert(solution(\"3 3 3\") == \"1\");\n    assert(solution(\"4 4 4\") == \"1\");\n    assert(solution(\"6 6 6\") == \"2\");\n    assert(solution(\"10 20 15\\n\") == \"5\");\n    assert(solution(\"7 5 4\\n\") == \"2\");\n    assert(solution(\"5 8 6\\n\") == \"2\");\n    assert(solution(\"5 10 5\\n\") == \"2\");\n    assert(solution(\"7 2 4\\n\") == \"1\");\n    assert(solution(\"3 3 2\\n\") == \"1\");\n    return 0; \n}", "prompt": "/*A university holds an informatics competition every year, where each team consists of 1 male student and 2 female students. In order to reduce the competition, the dean of a college arranges other competitors to go on internships in a distant country, and those who are sent on internships will not be able to participate in the competition. There are m female players and n male players, and k players can be sent on internships. The dean must create teams that can participate in the competition. Your task is to output the maximum number of teams that can be created.\n\ninput_format:\nInput data in a row.\n\nThree integers in a row, $m,n,k$, meaning as shown in the question.\n\noutput_format:\nOutput data in one line.\n\nAn integer on a row, $ans$, represents the maximum number of teams that can be formed.\n*/\n\n#include<sstream>\n#include<stdlib.h>\n#include<algorithm>\n#include<math.h>\n#include<stdio.h>\n#include<vector>\n#include<string>\n#include<climits>\n#include<cstring>\n#include<iostream>\nusing namespace std;\n\n             \nstring solution(string std_in){\n    istringstream iss(std_in);\n             ", "constraints": "**样例输入输出 1 解释**\n\n院长就可以派一男一女去实习，这样就变成了：$m=5$，$n=2$，分成两队（一个女生没有队伍），所以答案为 $2$。\n\n---\n\n**数据规模与约定**\n\n对于 $100\\%$ 的数据，$0 \\leq n,m \\leq 100$，$0 \\leq k \\leq m+n$。\n\n---\n\n**说明**\n\n**题目译自 [COCI2010-2011](https://hsin.hr/coci/archive/2010_2011/) [CONTEST #1](https://hsin.hr/coci/archive/2010_2011/contest1_tasks.pdf) *T1 TIMSKO*。**", "samples": [["6 3 2", "2"], ["2 1 1", "0"], ["6 10 3", "3"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000]}}
{"task_id": "P1561", "title": "[USACO12JAN]Mountain Climbing S", "difficulty": "advanced", "nl": "Farmer John, the owner of a farm, found out that the quality of milk produced by his cows significantly improved after they exercised vigorously. As a result, he decided to send N (1 <= N <= 25,000) cows to climb a nearby mountain and then return.\n\nThe i-th cow takes a time U(i) to climb the mountain and a time D(i) to come back down. Farmers John and Don are there to guide the cows. However, due to economic difficulties, the farm can only afford to pay for one guide per stretch of the journey. Although each cow needs a guide, only one farmer can guide cows on each stretch of the journey. Only one cow can be climbing up the mountain at any given moment, and only one cow can be coming down at any given moment. After climbing the mountain, the cows can stay at the top and wait for Don's help. The order of cows climbing up the mountain and coming down does not have to be the same.\n\nPlease calculate the minimum amount of time it takes for all N cows to complete the journey.", "code": "#include <cstdio>\n#include <algorithm>\n\nusing std::sort;\nusing std::max;\n\nconst int MAXN=25005;\nint n;\nint up_tm[MAXN],dwn_tm[MAXN];\n\nstruct Cow{\n    int up,dwn;\n    static bool cmp_tm(const Cow &a,const Cow &b){\n        if(a.up<a.dwn){\n            if(b.up<b.dwn) return a.up<b.up;\n            else return true;\n        }\n        else{\n            if(b.up<b.dwn) return false;\n            else return a.dwn>b.dwn;\n        }\n    }\n}cow[MAXN];\n\ninline int greedy(){\n    sort(cow+1,cow+n+1,Cow::cmp_tm);\n    for(int i=1;i<=n;++i)\n        up_tm[i]=up_tm[i-1]+cow[i].up;\n    for(int i=1;i<=n;++i)\n        dwn_tm[i]=max(dwn_tm[i-1],up_tm[i])+cow[i].dwn;\n    return dwn_tm[n];\n}\n\nint main(){\n    scanf(\"%d\",&n);\n    for(int i=1;i<=n;++i)\n        scanf(\"%d%d\",&cow[i].up,&cow[i].dwn);\n    printf(\"%d\",greedy());\n    return 0;\n}", "step": ["Define the maximum number of cows that can cross the chasm in a given instance.", "Create two arrays to store the time taken to go up and down the chasm.", "Define and implement a function to sort the cows based on time.", "Using greedy approach, calculate the minimum time it would take for all cows to cross the chasm.", "Read the input values for the number of cows and the time taken for going up and down the chasm.", "Print the calculated minimum time, which is the output of the program."], "nl_cn": "Farmer John has discovered that his cows produce higher quality milk when they are subject to strenuous exercise.  He therefore decides to send his N cows (1 <= N <= 25,000) to climb up and then back down a nearby mountain!\n\nCow i takes U(i) time to climb up the mountain and then D(i) time to climb down the mountain.  Being domesticated cows, each cow needs the help of a farmer for each leg of the climb, but due to the poor economy, there are only two farmers available, Farmer John and his cousin Farmer Don.  FJ plans to guide cows for the upward climb, and FD will then guide the cows for the downward climb.  Since every cow needs a guide, and there is only one farmer for each part of the voyage, at most one cow may be climbing upward at any point in time (assisted by FJ), and at most one cow may be climbing down at any point in time (assisted by FD).  A group of cows may temporarily accumulate at the top of the mountain if they climb up and then need to wait for FD's assistance before climbing down.  Cows may climb down in a different order than they climbed up.\n\nPlease determine the least possible amount of time for all N cows to make the entire journey.\n\n农场主约翰发现他的奶牛剧烈运动后产奶的质量更高，所以他决定让N头(1 <= N <= 25,000)奶牛去附近爬山再返回来。\n\n第i头奶牛用时U(i)爬上山，用时D(i)下山。作为家畜，奶牛们每段路都要有农夫的帮助，可是由于经济疲软，农场里只有两个农夫John和Don。John计划引导奶牛爬山，Don引导奶牛下山。虽然每个奶牛都需要向导，但每段旅途只有一名农夫。所有任何时刻只有一头奶牛爬山也只能有一头奶牛下山，奶牛爬上山后，可以暂时停留在山顶上等待Don的帮助。奶牛上山的顺序和下山的顺序不一定要相同。\n\n请计算出所有N 头牛完成旅程的最短时间。\n", "test_cases": [{"input": "3\n6 4\n8 1\n2 3", "output": "17"}, {"input": "1\n5 2\n", "output": "7"}, {"input": "1\n10 5\n", "output": "15"}], "test": "#undef NDEBUG\n#include<assert.h>\nint main(){\n    assert(solution(\"3\\n6 4\\n8 1\\n2 3\") == \"17\");\n    assert(solution(\"1\\n5 2\\n\") == \"7\");\n    assert(solution(\"1\\n10 5\\n\") == \"15\");\n    return 0; \n}", "prompt": "/*Farmer John, the owner of a farm, found out that the quality of milk produced by his cows significantly improved after they exercised vigorously. As a result, he decided to send N (1 <= N <= 25,000) cows to climb a nearby mountain and then return.\n\nThe i-th cow takes a time U(i) to climb the mountain and a time D(i) to come back down. Farmers John and Don are there to guide the cows. However, due to economic difficulties, the farm can only afford to pay for one guide per stretch of the journey. Although each cow needs a guide, only one farmer can guide cows on each stretch of the journey. Only one cow can be climbing up the mountain at any given moment, and only one cow can be coming down at any given moment. After climbing the mountain, the cows can stay at the top and wait for Don's help. The order of cows climbing up the mountain and coming down does not have to be the same.\n\nPlease calculate the minimum amount of time it takes for all N cows to complete the journey.\n\ninput_format:\nFirst line, an integer N\n\nLines 2 to N+1, each with two space-separated integers U(i) and D(i).\n\n(1 <= U(i), D(i) <= 50,000).\n\noutput_format:\nOne line, an integer, represents the shortest time for all N cows to complete the journey.\n*/\n\n#include<sstream>\n#include<stdlib.h>\n#include<algorithm>\n#include<math.h>\n#include<stdio.h>\n#include<vector>\n#include<string>\n#include<climits>\n#include<cstring>\n#include<iostream>\nusing namespace std;\n\n             \nstring solution(string std_in){\n    istringstream iss(std_in);\n             ", "constraints": "", "samples": [["3\n6 4\n8 1\n2 3", "17"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000, 512000]}}
{"task_id": "P7892", "title": "『JROI-3』田径", "difficulty": "basic", "nl": "You need to fence a rectangular area with a fence of dimensions $a+1\\times b+1$, assuming that the size of the rectangular area is $a \\times b$ pixels. \n\nNow you realize that your sheep and cows need exactly $n$ pixels to survive, and you have $m$ fences in your backpack. You want to know if you can fence out $n$ pixels with the fences you have.\n\nYou don't need to use all the fences, just fence out a rectangular area with a size of $n$ pixels.\n\nNote that $a$, $b$, $n$ and $m$ should all be integers.", "code": "#include<iostream>\n#include<cstdio>\n#include<iomanip>\n#include<algorithm>\n#include<queue>\n#include<stack>\n#include<cmath>\n#include<cstring>\n#define il inline\n#define re register\n#define inf 0x3f3f3f3f\n#define maxn 100010\nusing namespace std;\n\ninline int read(){\n\tint s = 0, w = 1;\n\tchar ch = getchar();\n\twhile(ch < '0' || ch > '9') {if(ch == '-'){w = -1;}ch = getchar();}\n\twhile(ch >= '0' && ch <= '9')s = s * 10 + ch - '0',ch = getchar();\n\treturn s*w;\n} \nint t;\nint n,m;\nint ans;\nsigned main(){\n\tt = read();\n\tfor(re int i = 1; i <= t; i++) {\n\t\tint flag = 0;\n\t\tn = read(), m = read();\n\t\tfor (re int k = 1; k * k <= n; k++) {\n\t\t\t\tif(n % k == 0) {//k是n的因子 \n\t\t\t\t\tif ((n / k + k + 2) * 2 <= m) {//判断\n\t\t\t\t\t\tflag = 1;//用来看是否有解的\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t}\n\t\tif(flag) cout<<\"Good\\n\";\n\t\telse cout<<\"Miss\\n\";\n\t}\n}", "step": ["Read the number of test cases T", "For each test case, read two integers n and m", "Calculate the largest factor of n, then calculate the other factor", "Check if the calculated values satisfy the condition 2*(f1+1+f2+1)<=m", "If the condition is satisfied, output 'Good', otherwise output 'Miss'"], "nl_cn": "你需要用栅栏框住一个长方形区域，假设这个长方形区域大小为 $a \\times b$ 个像素格，则需要长为 $a+1$，宽为 $b+1$ 规模的栅栏框住这个区域。\n\n现在你发现他的羊和牛需要**恰好** $n$ 个像素格才够生存，而你的背包里有 $m$ 个栅栏，你想知道，你用你所拥有的的栅栏是否能框出 $n$ 个像素格？\n\n不需要用光所有栅栏，只要框出区域大小为 $n$ 个像素格的长方形即可。\n\n注意，上面的 $a,b,n,m$ 都应是整数。", "test_cases": [{"input": "2\n4 1\n4 20", "output": "Miss\nGood"}, {"input": "1\n20 10\n", "output": "Miss"}, {"input": "1\n6 8\n", "output": "Miss"}, {"input": "2\n36 6\n6 36\n", "output": "Miss\nGood"}, {"input": "1\n13 2\n", "output": "Miss"}, {"input": "1\n7 9\n", "output": "Miss"}, {"input": "1\n6 9\n", "output": "Miss"}, {"input": "1\n3 5\n", "output": "Miss"}, {"input": "2\n4 5\n5 4\n", "output": "Miss\nMiss"}, {"input": "2\n2 3\n1 2\n", "output": "Miss\nMiss"}, {"input": "1\n5 8\n", "output": "Miss"}, {"input": "2\n4 6\n3 2\n", "output": "Miss\nMiss"}, {"input": "1\n12 7\n", "output": "Miss"}, {"input": "2\n10 6\n10 3\n", "output": "Miss\nMiss"}, {"input": "1\n32 5\n", "output": "Miss"}, {"input": "2\n15 5\n15 10\n", "output": "Miss\nMiss"}, {"input": "1\n24 7\n", "output": "Miss"}, {"input": "3\n16 4\n12 7\n14 1\n", "output": "Miss\nMiss\nMiss"}, {"input": "2\n14 7\n14 1\n", "output": "Miss\nMiss"}, {"input": "1\n27 6\n", "output": "Miss"}, {"input": "2\n20 4\n20 8\n", "output": "Miss\nMiss"}], "test": "#undef NDEBUG\n#include<assert.h>\nint main(){\n    assert(solution(\"2\\n4 1\\n4 20\") == \"Miss\\nGood\");\n    assert(solution(\"1\\n20 10\\n\") == \"Miss\");\n    assert(solution(\"1\\n6 8\\n\") == \"Miss\");\n    assert(solution(\"2\\n36 6\\n6 36\\n\") == \"Miss\\nGood\");\n    assert(solution(\"1\\n13 2\\n\") == \"Miss\");\n    assert(solution(\"1\\n7 9\\n\") == \"Miss\");\n    assert(solution(\"1\\n6 9\\n\") == \"Miss\");\n    assert(solution(\"1\\n3 5\\n\") == \"Miss\");\n    assert(solution(\"2\\n4 5\\n5 4\\n\") == \"Miss\\nMiss\");\n    assert(solution(\"2\\n2 3\\n1 2\\n\") == \"Miss\\nMiss\");\n    assert(solution(\"1\\n5 8\\n\") == \"Miss\");\n    assert(solution(\"2\\n4 6\\n3 2\\n\") == \"Miss\\nMiss\");\n    assert(solution(\"1\\n12 7\\n\") == \"Miss\");\n    assert(solution(\"2\\n10 6\\n10 3\\n\") == \"Miss\\nMiss\");\n    assert(solution(\"1\\n32 5\\n\") == \"Miss\");\n    assert(solution(\"2\\n15 5\\n15 10\\n\") == \"Miss\\nMiss\");\n    assert(solution(\"1\\n24 7\\n\") == \"Miss\");\n    assert(solution(\"3\\n16 4\\n12 7\\n14 1\\n\") == \"Miss\\nMiss\\nMiss\");\n    assert(solution(\"2\\n14 7\\n14 1\\n\") == \"Miss\\nMiss\");\n    assert(solution(\"1\\n27 6\\n\") == \"Miss\");\n    assert(solution(\"2\\n20 4\\n20 8\\n\") == \"Miss\\nMiss\");\n    return 0; \n}", "prompt": "/*You need to fence a rectangular area with a fence of dimensions $a+1\\times b+1$, assuming that the size of the rectangular area is $a \\times b$ pixels. \n\nNow you realize that your sheep and cows need exactly $n$ pixels to survive, and you have $m$ fences in your backpack. You want to know if you can fence out $n$ pixels with the fences you have.\n\nYou don't need to use all the fences, just fence out a rectangular area with a size of $n$ pixels.\n\nNote that $a$, $b$, $n$ and $m$ should all be integers.\n\ninput_format:\nThe first line contains an integer $T$, indicating the number of test groups.\n\nNext, line $T$, line with two integers $n,m$.\n\noutput_format:\nOne string in a row, output 'Good' if feasible, output 'Miss' if not feasible.\n*/\n\n#include<sstream>\n#include<stdlib.h>\n#include<algorithm>\n#include<math.h>\n#include<stdio.h>\n#include<vector>\n#include<string>\n#include<climits>\n#include<cstring>\n#include<iostream>\nusing namespace std;\n\n             \nstring solution(string std_in){\n    istringstream iss(std_in);\n             ", "constraints": "#### 样例 1 解释\n\n第一组数据：\n\n实测可证，无法用 $1$ 个栅栏围出 $4$ 个像素格。\n\n第二组数据：\n\n可以考虑围出如下 $4=1 \\times 4$ 的像素格。\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/bho8z78k.png)\n\n用下方的方式只需要用 $14$ 个栅栏即可。\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/o8s6bz81.png)\n\n栅栏宽为 $1+1=2$，长为 $4+1=5$，$(2+5) \\times 2=14$。\n\n#### 数据规模与约定\n\n**本题采用捆绑测试。**\n\n- Subtask 1（30 pts）：$1\\le n,m \\le 10^4$，$T \\leq 10^3$；\n- Subtask 2（70 pts）：$1\\le n,m \\le 10^{8}$，$T \\leq 10^3$。\n\n----\n在本题中栅栏是**抽象化**的而非具象化的，即栅栏将会**退化成一个点而非一个方格**，也就是我们可以通过**求周长的方式**求出一个栅栏框所需消耗的栅栏（如果不理解可以看看样例 1 解释）。", "samples": [["2\n4 1\n4 20", "Miss\nGood"]], "limits": {"time": [150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150, 150], "memory": [131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072]}}
{"task_id": "P2235", "title": "[HNOI2002]Kathy函数", "difficulty": "advanced", "nl": "Tiger loves math very much, so he joined the school's extracurricular math interest group. During the study in the interest group, the teacher introduced Tiger to the Kathy function, which is defined as follows:\n\n$$\n\\left\\{\n\\begin{aligned}\n&f(1)=1\\\\\n&f(3)=3\\\\\n&f(2n)=f(n)\\\\\n&f(4n+1)=2f(2n+1)-f(n)\\\\\n&f(4n+3)=3f(2n+1)-2f(n)\n\\end{aligned}\n\\right.\n$$\n\nTiger became very interested in the Kathy function and discovered that there are many numbers $n$ that satisfy $f(n)=n$.\n\nFor a given number $m$, he hopes you can find the number of positive integers $n$ that satisfy $f(n)=n$, where $n\\leq m$.", "code": "#include <bits/stdc++.h>\nusing namespace std;\nconst int N=405;\nstruct Integer{\n\tint a[102],len;\n\tInteger(){len=0,memset(a,0,sizeof(a));}\n\tinline void read(){\n\t\tregister string str;\n\t\tcin>>str,len=str.length();\n\t\tfor(int i=0;i<str.length();i++)a[len-i]=str[i]-'0';\n\t}\n\tinline void print(){\n\t\tfor(int i=len;i;i--)cout<<a[i];puts(\"\");\n\t}\n\tinline int mod(){return a[1]&1;}\n}num,ans,_1;\nInteger div2(Integer A){\n\tInteger B;\n\tint k=0;\n\tfor(int i=A.len;i;i--){\n\t\tk=k*10+A.a[i];\n\t\tB.a[i]=k>>1,k&=1;\n\t\tif(B.a[i]&&!B.len)B.len=i;\n\t}\n\treturn B;\n}\nInteger operator*(Integer A,Integer B){\n\tInteger C;\n\tfor(int i=1;i<=A.len;i++)\n\t\tfor(int j=1,k,f=0;f||j<=B.len;j++){\n\t\t\tk=A.a[i]*B.a[j]+C.a[i+j-1]+f;\n\t\t\tf=k/10;\n\t\t\tC.a[i+j-1]=k%10;\n\t\t\tC.len=max(C.len,i+j-1);\n\t\t}\n\treturn C;\n}\nInteger operator+(Integer A,Integer B){\n\tInteger C;\n\tfor(int i=1,k,f=0;i<=max(A.len,B.len)||f;i++){\n\t\tk=A.a[i]+B.a[i]+f;\n\t\tf=k/10;\n\t\tC.a[i]=k%10;\n\t\tC.len=i;\n\t}\n\treturn C;\n}\nInteger qp2(int b){\n\tInteger A,Ans;A.len=1,A.a[1]=2;Ans.len=1,Ans.a[1]=1;\n\tfor(;b;b>>=1,A=A*A)if(b&1)Ans=Ans*A;\n\treturn Ans;\n}\nint n,b[N],_b[N];\nbool leq(){\n\tfor(int i=n;i;i--)if(_b[i]<b[i])return 1;else if(b[i]<_b[i])return 0;\n\treturn 1;\n}\nint main(){\n\tnum.read();\n\twhile(num.len)b[++n]=num.mod(),num=div2(num);\n\tfor(int i=1;i<n;i++)ans=ans+qp2(((i+1)>>1)-1);\n\tfor(int i=n-1;i>n/2;i--){\n\t\tif(!b[i])continue;\n\t\tans=ans+qp2(i-1-n/2);\n\t}\n\t_1.len=1,_1.a[1]=1;\n\tfor(int i=1;i<=n/2;i++)_b[i]=b[n-i+1];\n\tfor(int i=n/2+1;i<=n;i++)_b[i]=b[i];\n\tif(leq())ans=ans+_1;\n\tans.print();\n}", "step": ["Read the input and transform it into binary.", "Solve the problem for the binary number.", "For odd-length binary numbers, adjust the number to make it palindromic.", "For even-length binary numbers, adjust the number or make it smaller to make it palindromic.", "Calculate the number of palindromic binaries.", "Output the result."], "nl_cn": "Tiger 非常喜欢数学，所以他参加了学校组织的数学课外兴趣小组。在兴趣小组的学习当中，老师向 Tiger 介绍了 Kathy 函数，Kathy 函数是这样定义的：\n\n$$\n\\left\\{\n\\begin{aligned}\n&f(1)=1\\\\\n&f(3)=3\\\\\n&f(2n)=f(n)\\\\\n&f(4n+1)=2f(2n+1)-f(n)\\\\\n&f(4n+3)=3f(2n+1)-2f(n)\n\\end{aligned}\n\\right.\n$$\n\nTiger 对 Kathy 函数产生了浓厚的兴趣，他通过研究发现有很多的数 $n$ 都满足 $f(n)=n$。\n\n对于一个给定的数 $m$，他希望你求出所有的满足 $f(n)=n$ 的正整数 $n$ 的个数，其中 $n\\leq m$。", "test_cases": [{"input": "5", "output": "3"}, {"input": "30\n", "output": "9"}, {"input": "1", "output": "1"}, {"input": "3", "output": "2"}, {"input": "10", "output": "5"}, {"input": "2\n", "output": "1"}], "test": "#undef NDEBUG\n#include<assert.h>\nint main(){\n    assert(solution(\"5\") == \"3\");\n    assert(solution(\"30\\n\") == \"9\");\n    assert(solution(\"1\") == \"1\");\n    assert(solution(\"3\") == \"2\");\n    assert(solution(\"10\") == \"5\");\n    assert(solution(\"2\\n\") == \"1\");\n    return 0; \n}", "prompt": "/*Tiger loves math very much, so he joined the school's extracurricular math interest group. During the study in the interest group, the teacher introduced Tiger to the Kathy function, which is defined as follows:\n\n$$\n\\left\\{\n\\begin{aligned}\n&f(1)=1\\\\\n&f(3)=3\\\\\n&f(2n)=f(n)\\\\\n&f(4n+1)=2f(2n+1)-f(n)\\\\\n&f(4n+3)=3f(2n+1)-2f(n)\n\\end{aligned}\n\\right.\n$$\n\nTiger became very interested in the Kathy function and discovered that there are many numbers $n$ that satisfy $f(n)=n$.\n\nFor a given number $m$, he hopes you can find the number of positive integers $n$ that satisfy $f(n)=n$, where $n\\leq m$.\n\ninput_format:\nEnter only one line of an integer, representing $m$.\n\noutput_format:\nOutput a line of an integer, representing $n$.\n*/\n\n#include<sstream>\n#include<stdlib.h>\n#include<algorithm>\n#include<math.h>\n#include<stdio.h>\n#include<vector>\n#include<string>\n#include<climits>\n#include<cstring>\n#include<iostream>\nusing namespace std;\n\n             \nstring solution(string std_in){\n    istringstream iss(std_in);\n             ", "constraints": "#### 数据规模与约定\n\n对于全部的测试点，保证 $1 \\leq m \\leq 10^{100}$。", "samples": [["5", "3"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}}
{"task_id": "P6586", "title": "『JROI-1』 蒟蒻火锅的盛宴", "difficulty": "challenge", "nl": "There are $n$ distinct integers and $m$ integers belong to set $G$.\n\nAwddon sets the following rules for the set:\n\n- If $x\\in G$, then $x+a\\in G$.\n- If $x+a$ is not among the $n$ integers, then do not include it.\n- If there is no element that needs to be added to set $G$, then it is perfect.\n\nIf the set is perfect, output `Great Set!`, otherwise output the minimum number of ingredients that need to be added to perfect the set according to the rules.", "code": "#include<bits/stdc++.h>\n#define reg register\ntypedef long long ll;\nusing namespace std;\nint n,m,a;\nset<int>S1,S2;\nint main(){\n\tscanf(\"%d\",&n);\n\tfor(reg int i=1,x;i<=n;i++)\n\t\tscanf(\"%d\",&x),S1.insert(x);\n\tscanf(\"%d\",&m);\n\tfor(reg int i=1,x;i<=m;i++)\n\t\tscanf(\"%d\",&x),S2.insert(x);\n\tscanf(\"%d\",&a);reg int Ans=0;\n\tfor(auto x:S2)if(S1.count(x+a)&&!S2.count(x+a))Ans++,S2.insert(x+a);\n\tif(Ans)printf(\"%d\\n\",Ans);\n\telse puts(\"Great Set!\");\n\treturn 0;\n}", "step": ["Take input of an integer n and an array a of n integers", "Find the maximum element in array a", "Take input of an integer m and an array b of m integers", "Take input of s, which is the number to be added to elements of array b", "Check for elements which can be created by adding s to the elements of array b and already present in array a", "Add such elements to array b", "Output the number of new elements added to array b or if it is a great set"], "nl_cn": "有 $n$ 个互不相同的整数，现有 $m$ 个整数属于集合 $G$ 中。\n\nAw顿顿规定这个集合有如下规定：\n\n- 若 $x\\in G$，则 $x+a\\in G$。\n- 若 $x+a$ 不在 $n$ 个整数中就不做处理。\n- 若对于一个集合 $G$ 不存在需要加入的元素，那么它是完善的。\n\n若集合是完善的，输出 `Great Set!`，反之输出至少还要按规定加入几个食材才能完善该级别。", "test_cases": [{"input": "5\n1 2 3 4 5\n3\n1 3 5\n2", "output": "Great Set!"}, {"input": "15\n13 2 10 3 1 12 8 4 5 7 9 6 15 14 11 \n7\n13 2 1 12 8 3 10 \n2", "output": "8"}, {"input": "50\n13 2 10 50 1 28 37 32 30 46 19 47 33 41 24 34 27 42 49 18 9 48 23 35 31 8 7 12 6 5 3 22 43 36 11 40 26 4 44 17 39 38 15 14 25 16 29 20 21 45 \n10\n50 46 30 32 10 2 28 37 1 13 \n3", "output": "31"}], "test": "#undef NDEBUG\n#include<assert.h>\nint main(){\n    assert(solution(\"5\\n1 2 3 4 5\\n3\\n1 3 5\\n2\") == \"Great Set!\");\n    assert(solution(\"15\\n13 2 10 3 1 12 8 4 5 7 9 6 15 14 11 \\n7\\n13 2 1 12 8 3 10 \\n2\") == \"8\");\n    assert(solution(\"50\\n13 2 10 50 1 28 37 32 30 46 19 47 33 41 24 34 27 42 49 18 9 48 23 35 31 8 7 12 6 5 3 22 43 36 11 40 26 4 44 17 39 38 15 14 25 16 29 20 21 45 \\n10\\n50 46 30 32 10 2 28 37 1 13 \\n3\") == \"31\");\n    return 0; \n}", "prompt": "/*There are $n$ distinct integers and $m$ integers belong to set $G$.\n\nAwddon sets the following rules for the set:\n\n- If $x\\in G$, then $x+a\\in G$.\n- If $x+a$ is not among the $n$ integers, then do not include it.\n- If there is no element that needs to be added to set $G$, then it is perfect.\n\nIf the set is perfect, output `Great Set!`, otherwise output the minimum number of ingredients that need to be added to perfect the set according to the rules.\n\ninput_format:\nThe first line is an integer $n$, indicating that there are a total of $n$integers.\n\nThe next line contains $n$integers $A_i$separated by Spaces, ** not identical **.\n\nA positive integer $m$in the next line indicates that there are $m$integers in the set $G$, all of which belong to $n$integers.\n\nThe next line is $m$, an integer separated by Spaces.\n\nThe last is a positive integer $a$.\n\noutput_format:\nIf the Set is complete, output 'Great Set! '.\n\nInstead output the number of integers needed to complete the set.\n*/\n\n#include<sstream>\n#include<stdlib.h>\n#include<algorithm>\n#include<math.h>\n#include<stdio.h>\n#include<vector>\n#include<string>\n#include<climits>\n#include<cstring>\n#include<iostream>\nusing namespace std;\n\n             \nstring solution(string std_in){\n    istringstream iss(std_in);\n             ", "constraints": "### 【样例解释】\n\n#### 样例 1 解释\n\n这个集合包含 $1,3,5$，其中 $1+2=3$，$3+2=5$，$5+2=7$ 不存在，所以这个集合是完善的。\n\n#### 样例 2 解释\n\n剩下的所有整数都属于这个集合。\n\n### 【数据范围】\n\n- $1\\le m<n\\le6\\times10^4$。\n- $1\\le A_i\\le n$。\n- $0\\le a\\le 10^4$。\n\n### 【捆绑测试情况】\n\n|测试点编号|时间限制|分数分配|$n,m\\le$|\n|:--------:|:------:|:------:|:------:|\n|$\\rm Subtask 1$|$\\rm 400ms$|$\\rm 10pts$|$10^3$|\n|$\\rm Subtask 2$|$\\rm 400ms$|$\\rm 15pts$|$10^4$|\n|$\\rm Subtask 3$|$\\rm 400ms$|$\\rm 35pts$|$3\\times 10^4$|\n|$\\rm Subtask 4$|$\\rm 400ms$|$\\rm 40pts$|$6\\times 10^4$|\n\n$\\rm P.S.$ 这题的时限已经开到 $\\rm std$ 的 $\\bf 15$ 倍，附件内有部分测试点。", "samples": [["5\n1 2 3 4 5\n3\n1 3 5\n2", "Great Set!"], ["15\n13 2 10 3 1 12 8 4 5 7 9 6 15 14 11 \n7\n13 2 1 12 8 3 10 \n2", "8"], ["50\n13 2 10 50 1 28 37 32 30 46 19 47 33 41 24 34 27 42 49 18 9 48 23 35 31 8 7 12 6 5 3 22 43 36 11 40 26 4 44 17 39 38 15 14 25 16 29 20 21 45 \n10\n50 46 30 32 10 2 28 37 1 13 \n3", "31"]], "limits": {"time": [400, 400, 400, 400, 400, 400, 400, 400, 400, 400, 400, 400, 400, 400, 400, 400, 400, 400, 400, 400, 400, 400, 400, 400, 400, 400, 400, 400, 400, 400, 400, 400, 400, 400, 400, 400, 400, 400, 400, 400, 400, 400, 400, 400, 400, 400, 400, 400, 400, 400], "memory": [51200, 51200, 51200, 51200, 51200, 51200, 51200, 51200, 51200, 51200, 51200, 51200, 51200, 51200, 51200, 51200, 51200, 51200, 51200, 51200, 51200, 51200, 51200, 51200, 51200, 51200, 51200, 51200, 51200, 51200, 51200, 51200, 51200, 51200, 51200, 51200, 51200, 51200, 51200, 51200, 51200, 51200, 51200, 51200, 51200, 51200, 51200, 51200, 51200, 51200]}}
{"task_id": "P5735", "title": "【深基7.例1】距离函数", "difficulty": "basic", "nl": "Given three points $(x_1,y_1),(x_2,y_2),(x_3,y_3)$ on a two-dimensional coordinate plane, not on the same line. The coordinates are real numbers and have absolute values ​​not exceeding 100.00. Find the circumference of the triangle formed. Keep two decimal places.\n\nFor two points $(x_1,y_1),(x_2,y_2)$ on a plane, the distance between these two points is $dis=\\sqrt{(x_2-x_1)^2+(y_2-y_1)^2}$.", "code": "#include<iostream>\n#include<cstdio>\n#include<cmath>\nusing namespace std;\ndouble dis(double x1, double y1, double x2, double y2)\n{\n\treturn sqrt(abs((x1 - x2) * (x1 - x2)) + abs((y1 - y2) * (y1 - y2)));\n}\nint main()\n{\n\tdouble x1, y1, x2, y2, x3, y3, c;\n\tcin >> x1 >> y1 >> x2 >> y2 >> x3 >> y3;\n\tdouble dis1 = dis(x1, y1, x2, y2), dis2 = dis(x2, y2, x3, y3), dis3 = dis(x3, y3, x1, y1);\n\tc = dis1 + dis2 + dis3;\n\tprintf(\"%.2f\", c);\n\treturn 0;\n}", "step": ["Input the coordinates of three points of the triangle.", "Calculate the distance between each pair of points using the distance formula.", "Add up the distances to get the perimeter.", "Print the perimeter rounded to two decimal places."], "nl_cn": "给出平面坐标上不在一条直线上三个点坐标 $(x_1,y_1),(x_2,y_2),(x_3,y_3)$，坐标值是实数，且绝对值不超过 100.00，求围成的三角形周长。保留两位小数。\n\n对于平面上的两个点 $(x_1,y_1),(x_2,y_2)$，则这两个点之间的距离 $dis=\\sqrt{(x_2-x_1)^2+(y_2-y_1)^2}$", "test_cases": [{"input": "0 0\n0 3\n4 0", "output": "12.00"}, {"input": "10 10\n20 20\n30 30\n", "output": "56.57"}, {"input": "-10 -10\n-20 -20\n-30 -30\n", "output": "56.57"}, {"input": "0 0\n0 0\n0 0\n", "output": "0.00"}, {"input": "0 0\n0 1\n1 0\n", "output": "3.41"}, {"input": "0 0\n1 0\n0 1\n", "output": "3.41"}, {"input": "0 0\n0 0\n1 1\n", "output": "2.83"}], "test": "#undef NDEBUG\n#include<assert.h>\nint main(){\n    assert(solution(\"0 0\\n0 3\\n4 0\") == \"12.00\");\n    assert(solution(\"10 10\\n20 20\\n30 30\\n\") == \"56.57\");\n    assert(solution(\"-10 -10\\n-20 -20\\n-30 -30\\n\") == \"56.57\");\n    assert(solution(\"0 0\\n0 0\\n0 0\\n\") == \"0.00\");\n    assert(solution(\"0 0\\n0 1\\n1 0\\n\") == \"3.41\");\n    assert(solution(\"0 0\\n1 0\\n0 1\\n\") == \"3.41\");\n    assert(solution(\"0 0\\n0 0\\n1 1\\n\") == \"2.83\");\n    return 0; \n}", "prompt": "/*Given three points $(x_1,y_1),(x_2,y_2),(x_3,y_3)$ on a two-dimensional coordinate plane, not on the same line. The coordinates are real numbers and have absolute values ​​not exceeding 100.00. Find the circumference of the triangle formed. Keep two decimal places.\n\nFor two points $(x_1,y_1),(x_2,y_2)$ on a plane, the distance between these two points is $dis=\\sqrt{(x_2-x_1)^2+(y_2-y_1)^2}$.\n\ninput_format:\nEnter three lines, with the $i$line representing the coordinates $(x_i,y_i)$, separated by a space.\n\noutput_format:\nOutput a two-digit decimal number representing the perimeter of the triangle formed by these three coordinates.\n*/\n\n#include<sstream>\n#include<stdlib.h>\n#include<algorithm>\n#include<math.h>\n#include<stdio.h>\n#include<vector>\n#include<string>\n#include<climits>\n#include<cstring>\n#include<iostream>\nusing namespace std;\n\n             \nstring solution(string std_in){\n    istringstream iss(std_in);\n             ", "constraints": "数据保证，坐标均为实数且绝对值不超过 $100$，小数点后最多仅有 $3$ 位。", "samples": [["0 0\n0 3\n4 0", "12.00"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000]}}
{"task_id": "P8841", "title": "[传智杯 #4 初赛] 竞争得分", "difficulty": "basic", "nl": "To encourage students to submit better assignments, the assembly experiment of Hualishu University of Science and Technology (HUST) adopts the method of competitive scoring.\n\nSpecifically, suppose there are n students who submitted assignments, and the person with the lowest original score is denoted as amin, the person with the highest original score is denoted as amax, and the original score of the i-th person is ai. The score of the i-th person is then calculated as:\n\n$$100 \\times \\frac{a_i-a_{min}}{a_{max}-a_{min}}$$\n\nDue to issues with the grading system, the final recorded score can only be an integer and the decimal part should be directly discarded.", "code": "#include<iostream>\n#include<cmath>\nusing namespace std;\nint n,a[1000],maxx,minn=10000;\nint main()\n{\n\tcin>>n;\n\tfor(int i=0;i<n;i++) {\n\t\tcin>>a[i];\n\t\tif(a[i]>maxx) maxx=a[i];\n\t\tif(a[i]<minn) minn=a[i];\n\t}\n\tfor(int i=0;i<n;i++) cout<<floor(100.0*(a[i]-minn)/(maxx-minn))<<' ';\n\treturn 0;\n}", "step": ["Read input integer n followed by n integers into array a.", "Set maxn and minn to the first integer in the array.", "Loop through the array to find the maximum and minimum numbers.", "Calculate fenmu to be the difference between maxn and minn.", "Loop through the array to calculate the percentage of each number in the range and output it.", "End the program."], "nl_cn": "为了鼓励大家写出更好的作业，花栗鼠科技大学（Hualishu University of Science and Technology, HUST）的组原实验采用了竞争得分的方式。\n\n具体来说，假设有 $n$ 个人提交了作业，并且其中原始得分最低的人记作 $a_{min}$ ，原始得分最高的人记作 $a_{max}$，第 $i$ 个人的原始得分为 $a_i$，那么第 $i$ 个人的得分就是：\n$$100 \\times \\frac{a_i-a_{min}}{a_{max}-a_{min}}$$\n\n由于成绩系统的问题，最终录入的成绩只能是整数，**采用直接去掉小数部分的方法**。", "test_cases": [{"input": "3\n1 2 3", "output": "0 50 100"}, {"input": "4\n2 4 6 8\n", "output": "0 33 66 100"}, {"input": "2\n10 20\n", "output": "0 100"}, {"input": "5\n5 10 15 20 25\n", "output": "0 25 50 75 100"}, {"input": "2\n-5 10\n", "output": "0 100"}, {"input": "3\n100 200 300\n", "output": "0 50 100"}, {"input": "5\n1 3 5 7 9\n", "output": "0 25 50 75 100"}, {"input": "2\n-10 20\n", "output": "0 100"}, {"input": "5\n10 20 30 40 50", "output": "0 25 50 75 100"}, {"input": "2\n50 75", "output": "0 100"}, {"input": "6\n10 20 30 40 50 60", "output": "0 20 40 60 80 100"}, {"input": "3\n-10 -5 0", "output": "0 50 100"}, {"input": "5\n1 2 3 4 5", "output": "0 25 50 75 100"}, {"input": "6\n-100 -80 -60 -40 -20 0", "output": "0 20 40 60 80 100"}, {"input": "3\n-100 -50 0", "output": "0 50 100"}, {"input": "6\n5 10 15 20 25 30", "output": "0 20 40 60 80 100"}, {"input": "2\n0 1\n", "output": "0 100"}, {"input": "2\n100 0\n", "output": "100 0"}, {"input": "3\n50 40 30\n", "output": "100 50 0"}, {"input": "2\n-5 5\n", "output": "0 100"}, {"input": "6\n2 4 6 8 10 12\n", "output": "0 20 40 60 80 100"}, {"input": "3\n-10 0 10\n", "output": "0 50 100"}, {"input": "2\n5 10\n", "output": "0 100"}, {"input": "3\n-1 0 1\n", "output": "0 50 100"}, {"input": "4\n5 4 3 2", "output": "100 66 33 0"}, {"input": "2\n1 100", "output": "0 100"}, {"input": "3\n2 1 0", "output": "100 50 0"}], "test": "#undef NDEBUG\n#include<assert.h>\nint main(){\n    assert(solution(\"3\\n1 2 3\") == \"0 50 100\");\n    assert(solution(\"4\\n2 4 6 8\\n\") == \"0 33 66 100\");\n    assert(solution(\"2\\n10 20\\n\") == \"0 100\");\n    assert(solution(\"5\\n5 10 15 20 25\\n\") == \"0 25 50 75 100\");\n    assert(solution(\"2\\n-5 10\\n\") == \"0 100\");\n    assert(solution(\"3\\n100 200 300\\n\") == \"0 50 100\");\n    assert(solution(\"5\\n1 3 5 7 9\\n\") == \"0 25 50 75 100\");\n    assert(solution(\"2\\n-10 20\\n\") == \"0 100\");\n    assert(solution(\"5\\n10 20 30 40 50\") == \"0 25 50 75 100\");\n    assert(solution(\"2\\n50 75\") == \"0 100\");\n    assert(solution(\"6\\n10 20 30 40 50 60\") == \"0 20 40 60 80 100\");\n    assert(solution(\"3\\n-10 -5 0\") == \"0 50 100\");\n    assert(solution(\"5\\n1 2 3 4 5\") == \"0 25 50 75 100\");\n    assert(solution(\"6\\n-100 -80 -60 -40 -20 0\") == \"0 20 40 60 80 100\");\n    assert(solution(\"3\\n-100 -50 0\") == \"0 50 100\");\n    assert(solution(\"6\\n5 10 15 20 25 30\") == \"0 20 40 60 80 100\");\n    assert(solution(\"2\\n0 1\\n\") == \"0 100\");\n    assert(solution(\"2\\n100 0\\n\") == \"100 0\");\n    assert(solution(\"3\\n50 40 30\\n\") == \"100 50 0\");\n    assert(solution(\"2\\n-5 5\\n\") == \"0 100\");\n    assert(solution(\"6\\n2 4 6 8 10 12\\n\") == \"0 20 40 60 80 100\");\n    assert(solution(\"3\\n-10 0 10\\n\") == \"0 50 100\");\n    assert(solution(\"2\\n5 10\\n\") == \"0 100\");\n    assert(solution(\"3\\n-1 0 1\\n\") == \"0 50 100\");\n    assert(solution(\"4\\n5 4 3 2\") == \"100 66 33 0\");\n    assert(solution(\"2\\n1 100\") == \"0 100\");\n    assert(solution(\"3\\n2 1 0\") == \"100 50 0\");\n    return 0; \n}", "prompt": "/*To encourage students to submit better assignments, the assembly experiment of Hualishu University of Science and Technology (HUST) adopts the method of competitive scoring.\n\nSpecifically, suppose there are n students who submitted assignments, and the person with the lowest original score is denoted as amin, the person with the highest original score is denoted as amax, and the original score of the i-th person is ai. The score of the i-th person is then calculated as:\n\n$$100 \\times \\frac{a_i-a_{min}}{a_{max}-a_{min}}$$\n\nDue to issues with the grading system, the final recorded score can only be an integer and the decimal part should be directly discarded.\n\ninput_format:\nThe first line is an integer $n$indicates the number of people. ($1 \\leq n \\leq 1000$)\n\nThe second row contains $n$integers and is the sequence $a$, where $a_i$represents the original job score of the $i$individual. ($1 \\leq a_i \\leq 1000$)\n\noutput_format:\nA row of $n$integers represents each person's score after the update.\n*/\n\n#include<sstream>\n#include<stdlib.h>\n#include<algorithm>\n#include<math.h>\n#include<stdio.h>\n#include<vector>\n#include<string>\n#include<climits>\n#include<cstring>\n#include<iostream>\nusing namespace std;\n\n             \nstring solution(string std_in){\n    istringstream iss(std_in);\n             ", "constraints": "", "samples": [["3\n1 2 3", "0 50 100"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000], "memory": [131072, 131072, 131072, 131072, 131072]}}
{"task_id": "P5339", "title": "[TJOI2019]唱、跳、rap和篮球", "difficulty": "advanced", "nl": "The center-forward's college is organizing a student tour to the museum and requires students to line up for the visit. His classmates can be divided into four categories: some love to sing, some love to dance, some love to rap, and some love basketball. If the students at positions $k, k+1, k+2, k+3$ in the queue respectively love to sing, dance, rap, and basketball, they will gather together to discuss Cai Xukun. The center-forward does not want this to happen because it will make the queue look messy. The center-forward wants to know how many ways there are to line up without students gathering to discuss Cai Xukun. Two student queues are considered different if and only if at least one student's preference is different in the two queues. As there may be many valid queues, count the number of types for which the result should be taken modulo $998244353$.", "code": "#include<bits/stdc++.h>\n#define ll long long\n#define ljc 998244353\nusing namespace std;\nll n,m,r[40006],lim;\nll a[20001],w[20001],b[20001],mini,num[4],c[20001],d[20001],fac[20010],inv[20001];\ninline ll fast_pow(ll a,ll b,ll p){\n    ll t=1;a%=p;\n    while (b){\n        if (b&1) t=t*a%p;\n        b>>=1;a=a*a%p;\n    }\n    return t;\n}\ninline void NTT(ll f[],int lim,int id){\n    for (int i=0;i<lim;i++){\n        if (i<r[i]) swap(f[r[i]],f[i]);\n    }\n    w[0]=1;\n    for (int len=1;len<lim;len<<=1){\n        ll gen=fast_pow(3,(ljc-1)/(len<<1)*id+ljc-1,ljc);\n        for (int i=1;i<len;i++) w[i]=w[i-1]*gen%ljc;\n        for (int i=0;i<lim;i+=len<<1){\n            ll *f1=f+i,*f2=f1+len;\n            for (int j=0;j<len;j++){\n                ll x=f1[j],y=f2[j]*w[j]%ljc;\n                f1[j]=(x+y)%ljc;\n                f2[j]=(x-y+ljc)%ljc;\n            }\n        }\n    }\n    if (id==1) return;\n    ll Inv=fast_pow(lim,ljc-2,ljc);\n    for (int i=0;i<lim;i++) f[i]=f[i]*Inv%ljc;\n}\ninline ll P(ll n,ll A,ll B,ll C,ll D){\n    if (n>A+B+C+D) return 0;\n    if (n<0) return 0;\n    ll lim=1,len=0;\n    while (lim<(A+B+C+D<<1)) lim<<=1,len++;\n    for (int i=0;i<lim;i++) r[i]=(r[i>>1LL]>>1LL)|(((1LL*i)&1)<<(len-1LL));\n    for (int i=0;i<lim;i++) a[i]=(i<=A)?inv[i]:0;\n    for (int i=0;i<lim;i++) b[i]=(i<=B)?inv[i]:0;\n    for (int i=0;i<lim;i++) c[i]=(i<=C)?inv[i]:0;\n    for (int i=0;i<lim;i++) d[i]=(i<=D)?inv[i]:0;\n    NTT(a,lim,1);NTT(b,lim,1);NTT(c,lim,1);NTT(d,lim,1);\n    for (int i=0;i<lim;i++) a[i]=a[i]*b[i]%ljc*c[i]%ljc*d[i]%ljc;\n    NTT(a,lim,-1);\n    return fac[n]*a[n]%ljc;\n}\ninline ll C(ll m,ll n){\n    if (m<n) return 0;\n    return (fac[m]*inv[n]%ljc*inv[m-n]%ljc);\n}\ninline void init(int n){\n    n*=2;\n    inv[0]=inv[1]=1;fac[0]=1;\n    for (int i=1;i<=n;i++) fac[i]=fac[i-1]*i%ljc;\n    for (int i=2;i<=n;i++) inv[i]=(ljc-(ljc/i)*inv[ljc%i]%ljc)%ljc;\n    for (int i=2;i<=n;i++) inv[i]=inv[i-1]*inv[i]%ljc;\n}\nint main(){\n    cin>>n>>num[0]>>num[1]>>num[2]>>num[3];\n    mini=min(num[0],min(num[1],min(num[2],num[3])));\n    init(n);\n    ll ans=0,one=1;\n    for (int i=0;i<=min(mini,n/4);i++){\n        ans=(ans+one*C(n-3*i,i)%ljc*P(n-4*i,num[0]-i,num[1]-i,num[2]-i,num[3]-i)%ljc)%ljc;\n        one=ljc-one;\t\t\n    }\n    cout<<ans;\n    return 0;\n}", "step": ["Initialize variables and input values", "Calculate minimum value of num[0], num[1], num[2], num[3]", "Initialize values for n and inv[]", "Using for loop, calculate ans variable with NTT", "In each iteration, calculate one and add C() and P() values to ans", "Return ans as the output"], "nl_cn": "大中锋的学院要组织学生参观博物馆，要求学生们在博物馆中排成一队进行参观。他的同学可以分为四类：一部分最喜欢唱、一部分最喜欢跳、一部分最喜欢rap，还有一部分最喜欢篮球。如果队列中$k$,$k + 1$,$k + 2$,$k + 3$位置上的同学依次，最喜欢唱、最喜欢跳、最喜欢rap、最喜欢篮球，那么他们就会聚在一起讨论蔡徐坤。大中锋不希望这种事情发生，因为这会使得队伍显得很乱。大中锋想知道有多少种排队的方法，不会有学生聚在一起讨论蔡徐坤。两个学生队伍被认为是不同的，当且仅当两个队伍中至少有一个位置上的学生的喜好不同。由于合法的队伍可能会有很多种，种类数对$998244353$取模。", "test_cases": [{"input": "4 4 3 2 1\n", "output": "174"}, {"input": "996 208 221 132 442\n", "output": "442572391"}, {"input": "0 0 0 0 0\n", "output": "1"}], "test": "#undef NDEBUG\n#include<assert.h>\nint main(){\n    assert(solution(\"4 4 3 2 1\\n\") == \"174\");\n    assert(solution(\"996 208 221 132 442\\n\") == \"442572391\");\n    assert(solution(\"0 0 0 0 0\\n\") == \"1\");\n    return 0; \n}", "prompt": "/*The center-forward's college is organizing a student tour to the museum and requires students to line up for the visit. His classmates can be divided into four categories: some love to sing, some love to dance, some love to rap, and some love basketball. If the students at positions $k, k+1, k+2, k+3$ in the queue respectively love to sing, dance, rap, and basketball, they will gather together to discuss Cai Xukun. The center-forward does not want this to happen because it will make the queue look messy. The center-forward wants to know how many ways there are to line up without students gathering to discuss Cai Xukun. Two student queues are considered different if and only if at least one student's preference is different in the two queues. As there may be many valid queues, count the number of types for which the result should be taken modulo $998244353$.\n\ninput_format:\nThere is only one line of input data. Each line is an integer of $5, with the first integer of $n$representing how many people the Big Center's Academy is organizing to visit the museum. The next four integers, $a$, $b$, $c$, and $d$, represent the number of students who like to sing the most, jump the most, rap the most, and basketball the most. Guarantee $a+b+c+d \\ge n$.\n\noutput_format:\nEach set of data outputs an integer representing how many different groups of students you can arrange so that no students in the group get together to talk about CAI. The result is $998244353.\n*/\n\n#include<sstream>\n#include<stdlib.h>\n#include<algorithm>\n#include<math.h>\n#include<stdio.h>\n#include<vector>\n#include<string>\n#include<climits>\n#include<cstring>\n#include<iostream>\nusing namespace std;\n\n             \nstring solution(string std_in){\n    istringstream iss(std_in);\n             ", "constraints": "对于20%的数据，有$n=a=b=c=d\\le500$\n\n对于100%的数据，有$n \\le 1000$ ， $a, b, c, d \\le 500$", "samples": [["4 4 3 2 1\n", "174\n"], ["996 208 221 132 442\n", "442572391\n"]], "limits": {"time": [4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000, 4000], "memory": [131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072]}}
{"task_id": "P1722", "title": "矩阵 II", "difficulty": "challenge", "nl": "If you have a spare moment to look at this problem, please skip to the sixth line.\n\nAs we all know, in the ancient Chinese abacus, red represents positive and black represents negative...\n\nGiven a $1\\times 2n$ matrix (usqwedf: isn't this just a queue of $2n$ elements?), you are free to put in red and black beads to make the matrix balanced (i.e., for all $i\\in[1, 2n]$, the number of red beads in the first $i$ positions is greater than or equal to the number of black beads).\n\nDetermine the number of ways to achieve a balanced matrix (note that there must be an equal number of red and black beads).", "code": "#include <cstdio>\n#include <cstring>\n#include <cmath>\n#include <iostream>\n#include <algorithm>\nusing namespace std;\nint n,f[505][505];\nint main(){\n\tscanf(\"%d\",&n);\n\tf[1][1]=1;\n\tfor (int i=2;i<=n+n;i++)\n\t\tfor (int j=(i+1)>>1;j<=i;j++)\n\t\t\tf[i][j]=(f[i-1][j]+f[i-1][j-1])%100;\n\tprintf(\"%d\",f[n+n][n]);\n\treturn 0;\n}", "step": ["Take input of a single integer 'n'", "Initialize a 2D array f with dimensions 505 x 505", "Initialize the first element of the array f[1][1] with 1", "For each index i in the array f, starting from 2 to n+n", "  For each index j in row i, starting from (i+1)>>1 to i", "    Calculate the value of f[i][j] by adding f[i-1][j] and f[i-1][j-1]", "Print the calculated value of f[n+n][n]"], "nl_cn": "\n如果你在百忙之中抽空看题，请自动跳到第六行。\n\n众所周知，在中国古代算筹中，红为正，黑为负……\n\n给定一个 $1\\times 2n$ 的矩阵（usqwedf：这不是一个 $2n$ 的队列么），现让你自由地放入红色算筹和黑色算筹，使矩阵平衡[即 $\\forall i \\in[1, 2n]$，$1\\sim i$ 格中红色算筹个数大于等于黑色算筹]。\n\n问有多少种方案满足矩阵平衡（注意红色算筹和黑色算筹的数量必须相等）。", "test_cases": [{"input": "2", "output": "2"}, {"input": "1\n", "output": "1"}, {"input": "3\n", "output": "5"}, {"input": "4\n", "output": "14"}, {"input": "5\n", "output": "42"}, {"input": "13\n", "output": "0"}], "test": "#undef NDEBUG\n#include<assert.h>\nint main(){\n    assert(solution(\"2\") == \"2\");\n    assert(solution(\"1\\n\") == \"1\");\n    assert(solution(\"3\\n\") == \"5\");\n    assert(solution(\"4\\n\") == \"14\");\n    assert(solution(\"5\\n\") == \"42\");\n    assert(solution(\"13\\n\") == \"0\");\n    return 0; \n}", "prompt": "/*If you have a spare moment to look at this problem, please skip to the sixth line.\n\nAs we all know, in the ancient Chinese abacus, red represents positive and black represents negative...\n\nGiven a $1\\times 2n$ matrix (usqwedf: isn't this just a queue of $2n$ elements?), you are free to put in red and black beads to make the matrix balanced (i.e., for all $i\\in[1, 2n]$, the number of red beads in the first $i$ positions is greater than or equal to the number of black beads).\n\nDetermine the number of ways to achieve a balanced matrix (note that there must be an equal number of red and black beads).\n\ninput_format:\nPositive integer $n$.\n\noutput_format:\nScheme number $t$is the result of modulating $100$.\n*/\n\n#include<sstream>\n#include<stdlib.h>\n#include<algorithm>\n#include<math.h>\n#include<stdio.h>\n#include<vector>\n#include<string>\n#include<climits>\n#include<cstring>\n#include<iostream>\nusing namespace std;\n\n             \nstring solution(string std_in){\n    istringstream iss(std_in);\n             ", "constraints": "样例解释： \n\n- 方案一：红，黑，红，黑\n\n- 方案二：红，红，黑，黑\n\n数据范围：\n\n$1\\le n\\le 100$", "samples": [["2", "2"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000]}}
{"task_id": "P5613", "title": "[MtOI2019]黑蚊子多", "difficulty": "basic", "nl": "Hikari is standing in front of $n(1\\leq n\\leq 1000)$ stairs. She can jump up $m(1\\leq m\\leq n)$ stairs in $1s$ (without stopping on the middle stairs).\n\nThere are $k(k\\leq 10)$ special platforms $a_i$ on the stairs. When Hikari **stops** on a platform, $m$ will increase by $1$.\n\nWhat is the time cost for Hikari to reach the top of the stairs?", "code": "#include<bits/stdc++.h>\nusing namespace std;\nint main(){\n\tint n,m,k,a[1001],ans=0,s=0;\n\tcin>>n>>m>>k;\n\tfor(int i=1;i<=k;i++)\n\t\tcin>>a[i];\n\twhile(s<n){\n\t\tfor(int i=1;i<=k;i++){\n\t\t\tif(a[i]==s)\n\t\t\t\tm++;\n\t\t}\n\t\ts+=m;\n\t\tans++;\n\t}\n\tcout<<ans;\n\treturn 0;\n}", "step": ["Define n, m, k, a, ans, and s.", "Read n, m, and k values from the user.", "Accept k checkpoints input from the user.", "Iterate through the checkpoints to calculate m and s values.", "Increment ans after every iteration.", "Display ans value."], "nl_cn": "Hikari 的面前有 $n(1\\leq n\\leq 1000)$ 级台阶，每 $1s$ 她可以向上跳 $m(1\\leq m\\leq n)$ 级台阶。（不在中间的台阶上停留）\n\n台阶上有 $k(k\\leq 10)$ 个特殊的平台 $a_i$，Hikari 在该平台 **停留** 时会使得 $m$ 增加 $1$。\n\n请问 Hikari 到达台阶顶部花费的时间。", "test_cases": [{"input": "10 5 0", "output": "2"}, {"input": "31 4 2\n8 13", "output": "6"}, {"input": "1 1 0\n", "output": "1"}, {"input": "5 3 1\n3\n", "output": "2"}, {"input": "100 1 0\n", "output": "100"}, {"input": "50 5 0\n", "output": "10"}, {"input": "7 4 0\n", "output": "2"}, {"input": "1000 50 1\n765\n", "output": "20"}, {"input": "1000 100 5\n10 50 200 500 900\n", "output": "10"}, {"input": "30 1 0\n", "output": "30"}, {"input": "200 10 0\n", "output": "20"}, {"input": "5 3 3\n1 2 3", "output": "2"}, {"input": "100 2 1\n99", "output": "50"}, {"input": "50 10 2\n30 40", "output": "5"}, {"input": "8 4 0", "output": "2"}, {"input": "1000 20 10\n5 15 25 35 45 55 65 75 85 95", "output": "50"}, {"input": "12 3 1\n8", "output": "4"}, {"input": "30 10 0", "output": "3"}, {"input": "1000 100 5\n150 280 400 520 700", "output": "10"}, {"input": "1000 1 0\n", "output": "1000"}, {"input": "500 50 5\n1 100 200 300 400\n", "output": "10"}, {"input": "64 8 3\n2 5 9\n", "output": "8"}, {"input": "123 7 4\n13 29 47 65\n", "output": "18"}, {"input": "150 12 4\n15 35 75 100\n", "output": "13"}, {"input": "678 9 1\n556\n", "output": "76"}, {"input": "5 5 0\n", "output": "1"}, {"input": "7 3 0\n", "output": "3"}, {"input": "25 3 1\n10\n", "output": "9"}, {"input": "15 5 0\n", "output": "3"}, {"input": "30 5 3\n10 15 23\n", "output": "6"}, {"input": "40 8 4\n2 8 14 20\n", "output": "5"}, {"input": "3 3 0\n", "output": "1"}, {"input": "35 4 0\n", "output": "9"}, {"input": "5 2 1\n3\n", "output": "3"}, {"input": "7 3 2\n1 5\n", "output": "3"}, {"input": "20 5 0\n", "output": "4"}, {"input": "15 4 1\n7\n", "output": "4"}, {"input": "77 7 1\n30\n", "output": "11"}, {"input": "25 5 2\n5 15\n", "output": "5"}, {"input": "12 3 1\n4\n", "output": "4"}, {"input": "80 8 1\n40\n", "output": "10"}], "test": "#undef NDEBUG\n#include<assert.h>\nint main(){\n    assert(solution(\"10 5 0\") == \"2\");\n    assert(solution(\"31 4 2\\n8 13\") == \"6\");\n    assert(solution(\"1 1 0\\n\") == \"1\");\n    assert(solution(\"5 3 1\\n3\\n\") == \"2\");\n    assert(solution(\"100 1 0\\n\") == \"100\");\n    assert(solution(\"50 5 0\\n\") == \"10\");\n    assert(solution(\"7 4 0\\n\") == \"2\");\n    assert(solution(\"1000 50 1\\n765\\n\") == \"20\");\n    assert(solution(\"1000 100 5\\n10 50 200 500 900\\n\") == \"10\");\n    assert(solution(\"30 1 0\\n\") == \"30\");\n    assert(solution(\"200 10 0\\n\") == \"20\");\n    assert(solution(\"5 3 3\\n1 2 3\") == \"2\");\n    assert(solution(\"100 2 1\\n99\") == \"50\");\n    assert(solution(\"50 10 2\\n30 40\") == \"5\");\n    assert(solution(\"8 4 0\") == \"2\");\n    assert(solution(\"1000 20 10\\n5 15 25 35 45 55 65 75 85 95\") == \"50\");\n    assert(solution(\"12 3 1\\n8\") == \"4\");\n    assert(solution(\"30 10 0\") == \"3\");\n    assert(solution(\"1000 100 5\\n150 280 400 520 700\") == \"10\");\n    assert(solution(\"1000 1 0\\n\") == \"1000\");\n    assert(solution(\"500 50 5\\n1 100 200 300 400\\n\") == \"10\");\n    assert(solution(\"64 8 3\\n2 5 9\\n\") == \"8\");\n    assert(solution(\"123 7 4\\n13 29 47 65\\n\") == \"18\");\n    assert(solution(\"150 12 4\\n15 35 75 100\\n\") == \"13\");\n    assert(solution(\"678 9 1\\n556\\n\") == \"76\");\n    assert(solution(\"5 5 0\\n\") == \"1\");\n    assert(solution(\"7 3 0\\n\") == \"3\");\n    assert(solution(\"25 3 1\\n10\\n\") == \"9\");\n    assert(solution(\"15 5 0\\n\") == \"3\");\n    assert(solution(\"30 5 3\\n10 15 23\\n\") == \"6\");\n    assert(solution(\"40 8 4\\n2 8 14 20\\n\") == \"5\");\n    assert(solution(\"3 3 0\\n\") == \"1\");\n    assert(solution(\"35 4 0\\n\") == \"9\");\n    assert(solution(\"5 2 1\\n3\\n\") == \"3\");\n    assert(solution(\"7 3 2\\n1 5\\n\") == \"3\");\n    assert(solution(\"20 5 0\\n\") == \"4\");\n    assert(solution(\"15 4 1\\n7\\n\") == \"4\");\n    assert(solution(\"77 7 1\\n30\\n\") == \"11\");\n    assert(solution(\"25 5 2\\n5 15\\n\") == \"5\");\n    assert(solution(\"12 3 1\\n4\\n\") == \"4\");\n    assert(solution(\"80 8 1\\n40\\n\") == \"10\");\n    return 0; \n}", "prompt": "/*Hikari is standing in front of $n(1\\leq n\\leq 1000)$ stairs. She can jump up $m(1\\leq m\\leq n)$ stairs in $1s$ (without stopping on the middle stairs).\n\nThere are $k(k\\leq 10)$ special platforms $a_i$ on the stairs. When Hikari **stops** on a platform, $m$ will increase by $1$.\n\nWhat is the time cost for Hikari to reach the top of the stairs?\n\ninput_format:\nTotal $2$rows.\n\nIn line $1$, enter $3$non-negative integers $n,m,k$.\n\nEnter a positive integer of $k$in line $2, and the positive integer of $i$represents $a_i$, ensuring that the input $a_i$is monotonically increasing.\n\noutput_format:\nThere are $1$lines, and $1$is printed as a positive integer indicating the time spent.\n*/\n\n#include<sstream>\n#include<stdlib.h>\n#include<algorithm>\n#include<math.h>\n#include<stdio.h>\n#include<vector>\n#include<string>\n#include<climits>\n#include<cstring>\n#include<iostream>\nusing namespace std;\n\n             \nstring solution(string std_in){\n    istringstream iss(std_in);\n             ", "constraints": "### 子任务\n\n对于 $60\\%$ 的数据，$k=0$。\n\n对于 $100\\%$ 的数据，$1\\leq m\\leq n\\leq 1000$，$k\\leq 10$。\n\n### 题目来源\n\n[MtOI2019 Extra Round](https://www.luogu.org/contest/22614) T1\n\n出题人：disangan233\n", "samples": [["10 5 0", "2"], ["31 4 2\n8 13", "6"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}}
{"task_id": "P5721", "title": "【深基4.例6】数字直角三角形", "difficulty": "basic", "nl": "Given an integer $n$, output a right-angled triangle of numbers with one of the legs of length $n$. All numbers should consist of two digits and if a number does not have two digits, add a leading zero.", "code": "#include <iostream>\n#include <algorithm>\n\nusing namespace std;\n\nint a,b;\n\nint main()\n{\n    int i,j,k;\n    cin>>a;\n    b=a;\n    a=a*(a+1)/2;\n    j=1;\n    i=1;\n    while(i<=a)\n    {\n        if(i<10)\n        {\n            cout<<0<<i;\n        }\n        else\n        {\n            cout<<i;\n        }\n        i++;\n        j++;\n        if(j>b)\n        {\n            b--;\n            j=1;\n            cout<<endl;\n        }\n    }\n    return 0;\n}", "step": ["Declare and initialize variables a, b, i, j, and k.", "Read user input into variable a.", "Set b equal to a.", "Calculate sum of integers from 1 to a and store it in variable a.", "While i is less than or equal to a:", "If i is less than 10, print 0 followed by i. Otherwise, print i.", "Increment i by 1 and j by 1.", "If j is greater than b, decrement b by 1, set j to 1, and print a new line."], "nl_cn": "给出 $n$，请输出一个直角边长度是 $n$ 的数字直角三角形。所有数字都是 $2$ 位组成的，如果没有 $2$ 位则加上前导 $0$。", "test_cases": [{"input": "5", "output": "0102030405\n06070809\n101112\n1314\n15"}, {"input": "1", "output": "01"}], "test": "#undef NDEBUG\n#include<assert.h>\nint main(){\n    assert(solution(\"5\") == \"0102030405\\n06070809\\n101112\\n1314\\n15\");\n    assert(solution(\"1\") == \"01\");\n    return 0; \n}", "prompt": "/*Given an integer $n$, output a right-angled triangle of numbers with one of the legs of length $n$. All numbers should consist of two digits and if a number does not have two digits, add a leading zero.\n\ninput_format:\nEnter a positive integer $n$.\n\noutput_format:\nOutput a digital right triangle as required by the problem.\n*/\n\n#include<sstream>\n#include<stdlib.h>\n#include<algorithm>\n#include<math.h>\n#include<stdio.h>\n#include<vector>\n#include<string>\n#include<climits>\n#include<cstring>\n#include<iostream>\nusing namespace std;\n\n             \nstring solution(string std_in){\n    istringstream iss(std_in);\n             ", "constraints": "数据保证，$1\\le n\\le13$。", "samples": [["5", "0102030405\n06070809\n101112\n1314\n15"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000]}}
{"task_id": "P2577", "title": "[ZJOI2004]午餐", "difficulty": "advanced", "nl": "The THU ACM team finished the morning training and went to have lunch together at the famous Shi Shitang. There are two window for serving food, each window can only serve one person at the same time. Since everyone has different taste (and appetite), they want to eat different dishes, the time it takes to serve food varies from person to person. In addition, everyone eats at different speeds, so the time it takes to finish the meal may also be different.\n\nThe eating plan for THU ACM team is as follows: first divide all the people into two teams, arrange the order of each person in each team, then team one goes to window one to queue up and team two goes to window two. Everyone starts eating immediately after getting their food, and all people gather together in the underground hall of building 6 for the afternoon training after finishing eating.\n\nNow, given the serving time and eating time for each person, we need to arrange the best team and queue plan to minimize the time for everyone to finish eating.\n\nAssume that the THU ACM team arrives at Shi Shitang at time 0, and there are no other students eating (only the chefs serving food). Each person can only be assigned to one team. The two windows operate in parallel without affecting each other, and the time it takes for each person to get their food is independent of the window, and they start eating immediately after getting their food, without any delay.\n\nGiven the serving time and eating time for N people, output the time when everyone finishes eating under the optimal plan.", "code": "#include<bits/stdc++.h>\nusing namespace std;\nconst int N = 210;\nint f[N][N*N];\nstruct node\n{\n    int a, b;\n    bool operator <(node z) const\n    {\n        return b>z.b;\n    }\n}s[N];\nint sum[N];\nint main()\n{\n    int n;\n    scanf(\"%d\", &n);\n    for(int i = 1; i <= n; i++)\n        scanf(\"%d %d\", &s[i].a, &s[i].b);\n    sort(s+1, s+1+n);\n    for(int i = 1; i <= n; i++)\n        sum[i] = sum[i-1] + s[i].a;\n    memset(f, 127, sizeof(f));\n    f[0][0] = 0;\n    for(int i = 1; i <= n; i++)\n    {\n        for(int j = 0; j <= sum[i]; j++)\n        {\n            if(j>=s[i].a) f[i][j] = min(f[i][j], max(f[i-1][j-s[i].a], j+s[i].b));\n            f[i][j] = min(f[i][j], max(f[i-1][j], sum[i]-j+s[i].b));\n        }\n    }\n    int ans = 2147483647;\n    for(int i = 0; i <= sum[n]; i++)\n        ans = min(ans, f[n][i]);\n    printf(\"%d\\n\", ans);\n    return 0;\n}", "step": ["Read the number of items, weight, and value of each item", "Sort the items in descending order of value", "Calculate the cumulative weight of the items", "Initialize the f array with a large number and f[0][0]=0", "Fill in the f array using dynamic programming", "Find the minimum cost among all values of the last row of the f array and print it"], "nl_cn": "上午的训练结束了，THU ACM小组集体去吃午餐，他们一行N人来到了著名的十食堂。这里有两个打饭的窗口，每个窗口同一时刻只能给一个人打饭。由于每个人的口味（以及胃口）不同，所以他们要吃的菜各有不同，打饭所要花费的时间是因人而异的。另外每个人吃饭的速度也不尽相同，所以吃饭花费的时间也是可能有所不同的。\n\nTHU ACM小组的吃饭计划是这样的：先把所有的人分成两队，并安排好每队中各人的排列顺序，然后一号队伍到一号窗口去排队打饭，二号队伍到二号窗口去排队打饭。每个人打完饭后立刻开始吃，所有人都吃完饭后立刻集合去六教地下室进行下午的训练。\n\n现在给定了每个人的打饭时间和吃饭时间，要求安排一种最佳的分队和排队方案使得所有人都吃完饭的时间尽量早。\n\n假设THU ACM小组在时刻0到达十食堂，而且食堂里面没有其他吃饭的同学（只有打饭的师傅）。每个人必须而且只能被分在一个队伍里。两个窗口是并行操作互不影响的，而且每个人打饭的时间是和窗口无关的，打完饭之后立刻就开始吃饭，中间没有延迟。\n\n现在给定N个人各自的打饭时间和吃饭时间，要求输出最佳方案下所有人吃完饭的时刻。\n", "test_cases": [{"input": "5\r\n2 2\r\n7 7\r\n1 3\r\n6 4\r\n8 5\r\n", "output": "17"}, {"input": "2\n10 4\n6 2\n", "output": "14"}, {"input": "4\n2 1\n3 2\n4 3\n5 4\n", "output": "9"}, {"input": "3\n2 1\n3 2\n4 3\n", "output": "7"}, {"input": "2\n2 3\n4 5\n", "output": "9"}, {"input": "2\n1 1\n2 2\n", "output": "4"}, {"input": "1\n10 5\n", "output": "15"}, {"input": "0\n", "output": "0"}, {"input": "1\n1 1\n", "output": "2"}, {"input": "2\n10 10\n20 20\n", "output": "40"}, {"input": "1\n100 50\n", "output": "150"}, {"input": "5\n2 2\n7 7\n1 3\n6 4\n8 5\n", "output": "17"}, {"input": "3\n1 1\n2 2\n3 3\n", "output": "6"}, {"input": "1\n8 3\n", "output": "11"}], "test": "#undef NDEBUG\n#include<assert.h>\nint main(){\n    assert(solution(\"5\\r\\n2 2\\r\\n7 7\\r\\n1 3\\r\\n6 4\\r\\n8 5\\r\\n\") == \"17\");\n    assert(solution(\"2\\n10 4\\n6 2\\n\") == \"14\");\n    assert(solution(\"4\\n2 1\\n3 2\\n4 3\\n5 4\\n\") == \"9\");\n    assert(solution(\"3\\n2 1\\n3 2\\n4 3\\n\") == \"7\");\n    assert(solution(\"2\\n2 3\\n4 5\\n\") == \"9\");\n    assert(solution(\"2\\n1 1\\n2 2\\n\") == \"4\");\n    assert(solution(\"1\\n10 5\\n\") == \"15\");\n    assert(solution(\"0\\n\") == \"0\");\n    assert(solution(\"1\\n1 1\\n\") == \"2\");\n    assert(solution(\"2\\n10 10\\n20 20\\n\") == \"40\");\n    assert(solution(\"1\\n100 50\\n\") == \"150\");\n    assert(solution(\"5\\n2 2\\n7 7\\n1 3\\n6 4\\n8 5\\n\") == \"17\");\n    assert(solution(\"3\\n1 1\\n2 2\\n3 3\\n\") == \"6\");\n    assert(solution(\"1\\n8 3\\n\") == \"11\");\n    return 0; \n}", "prompt": "/*The THU ACM team finished the morning training and went to have lunch together at the famous Shi Shitang. There are two window for serving food, each window can only serve one person at the same time. Since everyone has different taste (and appetite), they want to eat different dishes, the time it takes to serve food varies from person to person. In addition, everyone eats at different speeds, so the time it takes to finish the meal may also be different.\n\nThe eating plan for THU ACM team is as follows: first divide all the people into two teams, arrange the order of each person in each team, then team one goes to window one to queue up and team two goes to window two. Everyone starts eating immediately after getting their food, and all people gather together in the underground hall of building 6 for the afternoon training after finishing eating.\n\nNow, given the serving time and eating time for each person, we need to arrange the best team and queue plan to minimize the time for everyone to finish eating.\n\nAssume that the THU ACM team arrives at Shi Shitang at time 0, and there are no other students eating (only the chefs serving food). Each person can only be assigned to one team. The two windows operate in parallel without affecting each other, and the time it takes for each person to get their food is independent of the window, and they start eating immediately after getting their food, without any delay.\n\nGiven the serving time and eating time for N people, output the time when everyone finishes eating under the optimal plan.\n\ninput_format:\nThe first line contains an integer N, which represents the total number of people.\n\nThe following N lines each contain two integers Ai and Bi, representing the time it takes for the i-th person to queue for food and the time it takes for them to eat, respectively.\n\noutput_format:\nAn integer, T, represents the earliest moment when everyone finishes eating.\n*/\n\n#include<sstream>\n#include<stdlib.h>\n#include<algorithm>\n#include<math.h>\n#include<stdio.h>\n#include<vector>\n#include<string>\n#include<climits>\n#include<cstring>\n#include<iostream>\nusing namespace std;\n\n             \nstring solution(string std_in){\n    istringstream iss(std_in);\n             ", "constraints": "所有输入数据均为不超过200的正整数。\n", "samples": [["5\r\n2 2\r\n7 7\r\n1 3\r\n6 4\r\n8 5\r\n", "17"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}}
{"task_id": "P4370", "title": "[Code+#4]组合数问题2", "difficulty": "advanced", "nl": "It is well known that Xiaocong is good at calculation, especially at combination. Therefore, Xiaocong gives you two numbers n and k, and hopes you can find k different combinations with the maximum sum of the k combinations. The so-called different combinations mean that for combinations Cab1 and Cab2, if a1≠a2 or b1≠b2, we consider these two combinations are different. Now Xiaocong hopes you can find k such different combinations, so that they are mutually exclusive and for any combination Ca,b, 0≤b≤a≤n. What is the maximum sum of these k combinations?", "code": "#include<iostream>\n#include<cstdio>\n#include<algorithm>\n#include<cstring>\n#include<cmath>\n#include<queue>\n#define db double\n#define ll long long\n#define fo(i,x,y) for(register int i=x;i<=y;++i)\n#define go(i,x,y) for(register int i=x;i>=y;--i)\nusing namespace std;\n\nconst int N=1e6+5,yrz=1e9+7;\nconst db eps=1e-6;\ndb sum[N];\nint jc[N],inv[N];\nstruct zhs{//组合数 （钟皓曦x） \n\tdb v;\n\tint n,m,vv;\n\tbool operator<(const zhs &x)const{return x.v-v>eps;} \n\tzhs(){} \n\tzhs(int x,int y){\n\t\tn=x,m=y;\n\t\tv=sum[n]-sum[m]-sum[n-m];\n\t\tvv=1ll*jc[n]*inv[m]%yrz*inv[n-m]%yrz;\n\t}\n}t;\npriority_queue<zhs> q;\n\nint ksm(int x,int y){\n\tint ret=1,t=x;\n\twhile(y){\n\t\tif(y&1) ret=1ll*ret*t%yrz;\n\t\tt=1ll*t*t%yrz;\n\t\ty>>=1;\n\t}\n\treturn ret;\n}\n\nint main(){\n\tint n,k;\n\tcin>>n>>k;\n\tjc[0]=jc[1]=1;\n\tfo(i,2,n) sum[i]=sum[i-1]+log(i),jc[i]=1ll*jc[i-1]*i%yrz;\n\tinv[n]=ksm(jc[n],yrz-2);\n\tgo(i,n-1,0) inv[i]=1ll*inv[i+1]*(i+1)%yrz;\n\tfo(i,0,n) q.push(zhs(i,i/2));\n\tint ans=0;\n\twhile(k){//堆贪心\n\t\tt=q.top();q.pop();\n\t\tk--;\n\t\tans=(ans+t.vv)%yrz;//膜拜yrz！！1 \n\t\tint n=t.n,m=t.m,w=(n+1)/2;\n\t\t//printf(\"(%d,%d)=%d w=%d\\n\",n,m,t.vv,w);\n\t\tif(m<w){\n\t\t\tint qwq=n-m;\n\t\t\tq.push(zhs(n,qwq));\n\t\t}else{\n\t\t\tint qwq=n-m-1;\n\t\t\tif(qwq>=0) q.push(zhs(n,qwq));  \n\t\t}\n\t}\n\tcout<<ans;\n\treturn 0;\n}\n/*\n-------------------------------------------------\n*/", "step": ["Initialize factorial and inverse factorials.", "Get user input.", "Create a priority queue, push the first value, and set its validity.", "Repeat k times, generating new values for n and m and adding them to the priority queue.", "Calculate using the combinatorics formula.", "Output the answer."], "nl_cn": "众所周知，小葱同学擅长计算，尤其擅长计算组合数，所以小葱给了你两个数 $n$ 和 $k$，希望你找到 $k$ 个不同的组合数使得这 $k$ 个组合数的和最大。所谓不同的组合数，即对于组合数 $C_{a_1}^{b_1}$​​​ 和 $C_{a_2}^{b_2}$，若 $a_1\\neq a_2$ 或者 $b_1\\neq b_2$​​，则我们认为这两个组合数是不同的。现在小葱希望你找到这样 $k$ 个不同的组合数，使得它们互不相同且对于其中任何一个组合数 $C_a^b$ 有 $0\\leq b\\leq a\\leq n$。问这 $k$ 个组合数的和最大是多少？", "test_cases": [{"input": "2 3", "output": "4"}, {"input": "1 1\n", "output": "1"}], "test": "#undef NDEBUG\n#include<assert.h>\nint main(){\n    assert(solution(\"2 3\") == \"4\");\n    assert(solution(\"1 1\\n\") == \"1\");\n    return 0; \n}", "prompt": "/*It is well known that Xiaocong is good at calculation, especially at combination. Therefore, Xiaocong gives you two numbers n and k, and hopes you can find k different combinations with the maximum sum of the k combinations. The so-called different combinations mean that for combinations Cab1 and Cab2, if a1≠a2 or b1≠b2, we consider these two combinations are different. Now Xiaocong hopes you can find k such different combinations, so that they are mutually exclusive and for any combination Ca,b, 0≤b≤a≤n. What is the maximum sum of these k combinations?\n\ninput_format:\nReads data from standard input.\n\nThe first row has two integers $n,k$.\n\noutput_format:\nOutput to standard output.\n\nAn integer in a row represents the sum of $k$combinations modulo $10^9+7$; Data is guaranteed to have at least $k$number to choose from.\n*/\n\n#include<sstream>\n#include<stdlib.h>\n#include<algorithm>\n#include<math.h>\n#include<stdio.h>\n#include<vector>\n#include<string>\n#include<climits>\n#include<cstring>\n#include<iostream>\nusing namespace std;\n\n             \nstring solution(string std_in){\n    istringstream iss(std_in);\n             ", "constraints": "对于 $20\\%$ 的数据，$n\\leq 10$。\n\n对于 $40\\%$ 的数据，$n\\leq 500$。\n\n对于另外 $20\\%$ 的数据，$k=1$。\n\n对于 $100\\%$ 的数据，$1\\leq n\\leq 10^6,1\\leq k\\leq 10^5.$\n\nCredit: https://www.luogu.org/discuss/show/38908", "samples": [["2 3", "4"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000]}}
{"task_id": "P1743", "title": "矩阵 III", "difficulty": "challenge", "nl": "Given an $n\\times m$ matrix, how many paths are there from the top-left corner to the bottom-right corner, with a precision of 17 digits (i.e. output $0$ after the $18$th digit)?", "code": "#include<stdio.h>\nint n,m,len,i,j;\n__int128_t x=1;\nchar s[51];\nint main()\n{\n    scanf(\"%d%d\",&n,&m);\n    for(int i=n+m;i>=n+1;i--)x*=i;\n    for(int i=m;i;i--)x/=i;\n    while(x)\n    {\n        s[len++]+=x%10+48;//方法与前者类似，只需改动下标，并同时将其用作保存字符数组长度的变量\n        x/=10;\n    }\n    for(i=len-1,j=0;i>=0&&j<17;i--,j++)putchar(s[i]);//同时控制字符数组没有输出完+只输出前 17 位\n    for(;i>=0;i--)putchar('0');//由于 i 为全局变量，因而可以沿用上次的值，如果 i >= 0 则说明输出尚未结束，应当输出直到下标 0 为止\n    return 0;\n}", "step": ["Accept input for n and m", "Calculate the value of n based on m", "Divide n by 10 until it is less than 1e17 and count the number of divisions", "Print n with trailing zeros to match the number of divisions done", "Exit the program"], "nl_cn": "给定一个 $n\\times m$ 的矩阵，问从左上角走到右下角有多少条路径，保留 $17$ 位有效数字（也就是从第 $18$ 位有效数字以后均输出 $0$）。\n", "test_cases": [{"input": "6 4", "output": "210"}, {"input": "2 1\n", "output": "3"}, {"input": "1 2\n", "output": "3"}, {"input": "2 2\n", "output": "6"}, {"input": "3 2\n", "output": "10"}, {"input": "4 2\n", "output": "15"}, {"input": "2 3\n", "output": "10"}, {"input": "2 4\n", "output": "15"}, {"input": "1 1", "output": "2"}, {"input": "3 1", "output": "4"}, {"input": "1 3", "output": "4"}, {"input": "3 3", "output": "20"}, {"input": "1 4", "output": "5"}, {"input": "3 4", "output": "35"}], "test": "#undef NDEBUG\n#include<assert.h>\nint main(){\n    assert(solution(\"6 4\") == \"210\");\n    assert(solution(\"2 1\\n\") == \"3\");\n    assert(solution(\"1 2\\n\") == \"3\");\n    assert(solution(\"2 2\\n\") == \"6\");\n    assert(solution(\"3 2\\n\") == \"10\");\n    assert(solution(\"4 2\\n\") == \"15\");\n    assert(solution(\"2 3\\n\") == \"10\");\n    assert(solution(\"2 4\\n\") == \"15\");\n    assert(solution(\"1 1\") == \"2\");\n    assert(solution(\"3 1\") == \"4\");\n    assert(solution(\"1 3\") == \"4\");\n    assert(solution(\"3 3\") == \"20\");\n    assert(solution(\"1 4\") == \"5\");\n    assert(solution(\"3 4\") == \"35\");\n    return 0; \n}", "prompt": "/*Given an $n\\times m$ matrix, how many paths are there from the top-left corner to the bottom-right corner, with a precision of 17 digits (i.e. output $0$ after the $18$th digit)?\n\ninput_format:\nA row of two positive integers $n,m$.\n\noutput_format:\nNumber of paths $t$.\n*/\n\n#include<sstream>\n#include<stdlib.h>\n#include<algorithm>\n#include<math.h>\n#include<stdio.h>\n#include<vector>\n#include<string>\n#include<climits>\n#include<cstring>\n#include<iostream>\nusing namespace std;\n\n             \nstring solution(string std_in){\n    istringstream iss(std_in);\n             ", "constraints": "$1\\le n\\le 10^8,1\\le m\\le 4$。\n\n", "samples": [["6 4", "210"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000]}}
{"task_id": "P9160", "title": "multiset", "difficulty": "challenge", "nl": "Given a **multiset** $S$, find a maximum multiset $T$ that is a **proper subset** of $S$, and for each $i \\in T$, either $i$ has no predecessor in $S$ or its predecessor is in $T$. If there are multiple sets of the same size that satisfy the conditions, choose the one with the largest sum of elements. Output the size and sum of elements of $T$.\n\n---\n\nThe predecessor of an element $x$ in a set $S$ is defined as the maximum value of all elements $y \\in S$ such that $y < x$.", "code": "#include <iostream>\n#include <algorithm>\nusing namespace std;\n\nint n, s[100005];\nlong long sum = 0;//不开long long见祖宗\n\nint main()\n{\n    cin >> n;\n    for (int i = 1; i <= n; i++)\n        cin >> s[i], sum += s[i];\n    sort(s + 1, s + n + 1);//按从大到小排序，否则不好确定是否有重复以及元素的最大值\n    for (int i = 2; i <= n; i++)\n        if (s[i] == s[i - 1] || i == n)//减去重复的或最大的\n        {\n            sum -= s[i];\n            break;//取了一个直接结束\n        }\n    cout << n - 1 << \" \" << sum << endl;//由于只去掉一个元素，所以T的大小为n - 1\n    return 0;\n}", "step": ["Read the integer n.", "Print n-1.", "Read an array of n integers and calculate its sum.", "Sort the array.", "Find the largest non-unique element and save it as del.", "Print the sum minus the value of del."], "nl_cn": "给定一个 **多重集合**（集合中元素可重复）$S$，请求出一个最大的多重集合 $T$，满足 $T$ 是 $S$ 的一个 **真子集**，且对于 $T$ 中的每一个元素 $i$，要么 $i$ 在 $S$ 中没有前驱，要么 $i$ 在 $S$ 中的前驱 $\\in T$。若有多个大小相同的集合满足条件，则 $T$ 为所有元素之和最大的一个。请输出 $T$ 的大小和其中元素之和。\n\n---\n\n一个数 $x$ 在一个集合 $S$ 中的前驱的定义为所有在 $S$ 中且 $<x$ 的元素 $y$ 的最大值。", "test_cases": [{"input": "4\n4 5 1 4", "output": "3 10"}, {"input": "6\n1 4 2 8 5 7", "output": "5 19"}, {"input": "3\n3 3 3\n", "output": "2 6"}, {"input": "2\n1 1\n", "output": "1 1"}, {"input": "6\n1 2 3 4 5 6\n", "output": "5 15"}, {"input": "2\n5 6\n", "output": "1 5"}, {"input": "3\n1 2 2\n", "output": "2 3"}, {"input": "6\n9 10 8 6 5 7", "output": "5 35"}, {"input": "8\n6 9 7 10 5 3 8 4", "output": "7 42"}, {"input": "3\n9 9 9", "output": "2 18"}, {"input": "4\n3 2 1 4", "output": "3 6"}, {"input": "10\n8 7 6 5 4 3 2 1 10 9", "output": "9 45"}, {"input": "3\n3 2 1", "output": "2 3"}, {"input": "2\n7 9\n", "output": "1 7"}, {"input": "5\n1 2 3 4 5\n", "output": "4 10"}, {"input": "4\n3 1 2 1\n", "output": "3 6"}, {"input": "8\n2 3 5 1 4 4 4 4\n", "output": "7 23"}, {"input": "2\n1 2\n", "output": "1 1"}, {"input": "3\n2 1 2\n", "output": "2 3"}, {"input": "5\n2 3 4 5 6\n", "output": "4 14"}], "test": "#undef NDEBUG\n#include<assert.h>\nint main(){\n    assert(solution(\"4\\n4 5 1 4\") == \"3 10\");\n    assert(solution(\"6\\n1 4 2 8 5 7\") == \"5 19\");\n    assert(solution(\"3\\n3 3 3\\n\") == \"2 6\");\n    assert(solution(\"2\\n1 1\\n\") == \"1 1\");\n    assert(solution(\"6\\n1 2 3 4 5 6\\n\") == \"5 15\");\n    assert(solution(\"2\\n5 6\\n\") == \"1 5\");\n    assert(solution(\"3\\n1 2 2\\n\") == \"2 3\");\n    assert(solution(\"6\\n9 10 8 6 5 7\") == \"5 35\");\n    assert(solution(\"8\\n6 9 7 10 5 3 8 4\") == \"7 42\");\n    assert(solution(\"3\\n9 9 9\") == \"2 18\");\n    assert(solution(\"4\\n3 2 1 4\") == \"3 6\");\n    assert(solution(\"10\\n8 7 6 5 4 3 2 1 10 9\") == \"9 45\");\n    assert(solution(\"3\\n3 2 1\") == \"2 3\");\n    assert(solution(\"2\\n7 9\\n\") == \"1 7\");\n    assert(solution(\"5\\n1 2 3 4 5\\n\") == \"4 10\");\n    assert(solution(\"4\\n3 1 2 1\\n\") == \"3 6\");\n    assert(solution(\"8\\n2 3 5 1 4 4 4 4\\n\") == \"7 23\");\n    assert(solution(\"2\\n1 2\\n\") == \"1 1\");\n    assert(solution(\"3\\n2 1 2\\n\") == \"2 3\");\n    assert(solution(\"5\\n2 3 4 5 6\\n\") == \"4 14\");\n    return 0; \n}", "prompt": "/*Given a **multiset** $S$, find a maximum multiset $T$ that is a **proper subset** of $S$, and for each $i \\in T$, either $i$ has no predecessor in $S$ or its predecessor is in $T$. If there are multiple sets of the same size that satisfy the conditions, choose the one with the largest sum of elements. Output the size and sum of elements of $T$.\n\n---\n\nThe predecessor of an element $x$ in a set $S$ is defined as the maximum value of all elements $y \\in S$ such that $y < x$.\n\ninput_format:\nThe first line contains a positive integer $n$, indicating the size of $S$.\n\nThe second row of $n$is a positive integer representing the elements in $S$.\n\noutput_format:\nTwo integers in a row. The first number represents the size of $T$, and the second number represents the sum of all elements of $T$.\n*/\n\n#include<sstream>\n#include<stdlib.h>\n#include<algorithm>\n#include<math.h>\n#include<stdio.h>\n#include<vector>\n#include<string>\n#include<climits>\n#include<cstring>\n#include<iostream>\nusing namespace std;\n\n             \nstring solution(string std_in){\n    istringstream iss(std_in);\n             ", "constraints": "**样例 $1$ 解释**\n\n$T$ 为 $\\{5,1,4\\}$。\n\n**样例 $2$ 解释**\n\n$T$ 为 $\\{1,4,2,5,7\\}$。\n\n### 数据范围\n\n对于 $30\\%$ 的数据，$n \\le 15$。\n\n对于 $100\\%$ 的数据，$2 \\le n \\le 10^5$，$1 \\le S$ 中的元素 $\\le 10^9$。", "samples": [["4\n4 5 1 4", "3 10"], ["6\n1 4 2 8 5 7", "5 19"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072]}}
{"task_id": "P2192", "title": "HXY玩卡片", "difficulty": "basic", "nl": "HXY has some cards with numbers either 0 or 5 on them. Now she can choose some of the cards to arrange in a row, so that the resulting number is the largest possible and is divisible by 90. At the same time, the number must be a legal non-negative integer, that is, it cannot have leading 0s, and 0 can't be the first digit of the number. However, the integer 0 satisfies the condition. If it is impossible to arrange such a number, output \"-1\".", "code": "#include<iostream>\nusing namespace std;\nint n,a,t5,t0;\nint main()\n{\n    cin>>n;\n    for(int i=1;i<=n;i++)\n    {\n        cin>>a;\n        if(a==5)\n            t5++;//统计5个数\n        else\n            t0++;//统计0个数\n    }\n    if(!t0)\n        cout<<-1;//情况1，没有0，输出-1\n    else\n    {\n        if(t5>=9)//情况3，有0,5的个数多于9个\n        {\n            for(int i=1;i<=t5/9*9;i++)//控制输出\n                cout<<5;\n            for(int i=1;i<=t0;i++)//0全部跟上\n                cout<<0;\n        }\n        else//情况2，有0，5的个数不足9个\n            cout<<0;//输出0\n    }\n    return 0;//♪(^∇^*)\n}", "step": ["Take an integer n as input from the user.", "For i=1 to n, take an integer a as input.", "If a is 5, increment the count of t5 else increment the count of t0.", "If there are no zeros, output -1.", "Otherwise, if the count of t5 is greater than or equal to 9:", "For i=1 to t5/9*9, output 5.", "For i=1 to t0, output 0.", "Else, output 0."], "nl_cn": "HXY得到了一些卡片，这些卡片上标有数字 $0$ 或 $5$ 。现在她可以选择其中一些卡片排成一列，使得排出的一列数字组成的数最大，且满足被 $90$ 整除这个条件。同时，这个数必须为合法的某个非负整数，即不能含有前导 $0$ ，即 $0$ 不能作为这串数的首位。但是特殊地，整数 $0$ 满足条件。如果不能排出这样的数，输出“$-1$”。", "test_cases": [{"input": "4\n5 0 5 0", "output": "0"}, {"input": "11\n5 5 5 5 5 5 5 5 0 5 5", "output": "5555555550"}, {"input": "2\n5 5", "output": "-1"}, {"input": "1\n0\n", "output": "0"}, {"input": "1\n5\n", "output": "-1"}, {"input": "13\n0 0 0 0 0 0 0 0 0 0 0 0 0\n", "output": "0"}, {"input": "14\n0 0 0 0 0 0 0 0 0 0 0 0 0 0\n", "output": "0"}, {"input": "15\n0 0 0 0 0 0 0 0 0 0 0 0 0 0 0\n", "output": "0"}, {"input": "16\n0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0\n", "output": "0"}, {"input": "17\n0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0\n", "output": "0"}, {"input": "18\n0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0\n", "output": "0"}, {"input": "19\n0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0\n", "output": "0"}, {"input": "20\n0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0\n", "output": "0"}, {"input": "10\n5 5 5 5 5 0 5 5 5 5\n", "output": "5555555550"}, {"input": "3\n0 5 0\n", "output": "0"}, {"input": "5\n0 0 0 0 5\n", "output": "0"}, {"input": "3\n5 5 5\n", "output": "-1"}, {"input": "4\n0 0 0 5\n", "output": "0"}], "test": "#undef NDEBUG\n#include<assert.h>\nint main(){\n    assert(solution(\"4\\n5 0 5 0\") == \"0\");\n    assert(solution(\"11\\n5 5 5 5 5 5 5 5 0 5 5\") == \"5555555550\");\n    assert(solution(\"2\\n5 5\") == \"-1\");\n    assert(solution(\"1\\n0\\n\") == \"0\");\n    assert(solution(\"1\\n5\\n\") == \"-1\");\n    assert(solution(\"13\\n0 0 0 0 0 0 0 0 0 0 0 0 0\\n\") == \"0\");\n    assert(solution(\"14\\n0 0 0 0 0 0 0 0 0 0 0 0 0 0\\n\") == \"0\");\n    assert(solution(\"15\\n0 0 0 0 0 0 0 0 0 0 0 0 0 0 0\\n\") == \"0\");\n    assert(solution(\"16\\n0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0\\n\") == \"0\");\n    assert(solution(\"17\\n0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0\\n\") == \"0\");\n    assert(solution(\"18\\n0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0\\n\") == \"0\");\n    assert(solution(\"19\\n0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0\\n\") == \"0\");\n    assert(solution(\"20\\n0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0\\n\") == \"0\");\n    assert(solution(\"10\\n5 5 5 5 5 0 5 5 5 5\\n\") == \"5555555550\");\n    assert(solution(\"3\\n0 5 0\\n\") == \"0\");\n    assert(solution(\"5\\n0 0 0 0 5\\n\") == \"0\");\n    assert(solution(\"3\\n5 5 5\\n\") == \"-1\");\n    assert(solution(\"4\\n0 0 0 5\\n\") == \"0\");\n    return 0; \n}", "prompt": "/*HXY has some cards with numbers either 0 or 5 on them. Now she can choose some of the cards to arrange in a row, so that the resulting number is the largest possible and is divisible by 90. At the same time, the number must be a legal non-negative integer, that is, it cannot have leading 0s, and 0 can't be the first digit of the number. However, the integer 0 satisfies the condition. If it is impossible to arrange such a number, output \"-1\".\n\ninput_format:\nIn the first row, the number of cards is $n$.\n\nThe second line, respectively, gives the number of $n$(can only be the number $5$or $0$).\n\noutput_format:\nOnly one line, if it can be expelled, output this number. Otherwise output '-1'.\n*/\n\n#include<sstream>\n#include<stdlib.h>\n#include<algorithm>\n#include<math.h>\n#include<stdio.h>\n#include<vector>\n#include<string>\n#include<climits>\n#include<cstring>\n#include<iostream>\nusing namespace std;\n\n             \nstring solution(string std_in){\n    istringstream iss(std_in);\n             ", "constraints": "数据范围：\n\n对于 $30\\%$ 的数据，$n\\le 10$ ；\n\n对于 $20\\%$ 的数据，仅含数字 $5$ ；\n\n对于 $100\\%$ 的数据，$n\\le 1000$ 。", "samples": [["4\n5 0 5 0", "0\n"], ["11\n5 5 5 5 5 5 5 5 0 5 5", "5555555550"], ["2\n5 5", "-1\n"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}}
{"task_id": "P2689", "title": "东南西北", "difficulty": "basic", "nl": "Given the coordinates of the starting point and the end point, as well as the wind direction (east, south, west, north) for the next T moments, you can choose to offset by 1 unit with the wind or stay in place each time. Find the minimum time to reach the end point.\n\nIf unable to reach the end point with offset, output \"-1\".", "code": "#include<cmath>\n#include<cstdio>\n#include<cstring>\n#include<iostream>\n#include<algorithm>\n#include<map>\nusing namespace std;\nmap<char,int>fx; //定义方向 \nint main()\n{\n//    freopen(\".in\",\"r\",stdin);\n//    freopen(\".out\",\"w\",stdout);\n    int x,y,x1,y1;\n    scanf(\"%d%d\",&x,&y);\n    scanf(\"%d%d\",&x1,&y1);\n    if(x1>x)fx['E']=1,fx['W']=0;//如果终点横坐标比起点大，那么风向E是正方向，W不动 \n    if(y1>y)fx['N']=1,fx['S']=0;//如果终点纵坐标比起点大，那么风向N是正方向，S不动 \n    if(x1<x)fx['E']=0,fx['W']=-1;//反之 \n    if(y1<y)fx['N']=0,fx['S']=-1;//反之 \n    int t;\n    scanf(\"%d\",&t);\n    int sum=0;\n    for(int i=1;i<=t;i++)\n    {\n        char c;\n        cin>>c;//读入风向 \n        if((c=='E'||c=='W')&&x!=x1)\n        {\n        x+=fx[c];\n        if(fx[c]!=0)sum++;//如果移动累加次数 \n}//如果是东西方向移动，直接处理\n        if((c=='N'||c=='S')&&y!=y1)\n        {\n\n        y+=fx[c];\n\n        if(fx[c]!=0)sum++;//如果移动累加次数 \n\n}//如果是南北方向移动，直接处理\n    }\n    if(x==x1&&y==y1)cout<<sum;\n    else cout<<-1;//输出结果 \n    return 0;\n}", "step": ["Take input values of positions A and B and number of directions from user.", "Loop through the directions given in input.", "Determine if moving following the input direction for position B gets closer to A.", "Return the number of steps taken to reach position B from A.", "If it's impossible to reach position B from A, then return -1."], "nl_cn": "给出起点和终点的坐标及接下来T个时刻的风向(东南西北)，每次可以选择顺风偏移1个单位或者停在原地。求到达终点的最少时间。\n\n如果无法偏移至终点，输出“-1”。\n", "test_cases": [{"input": "1 1\n2 2\n5\nE\nN\nW\nW\nN", "output": "2"}, {"input": "1 1\n2 2\n1\nW", "output": "-1"}, {"input": "1 1\n2 2\n3\nW\nW\nW", "output": "-1"}, {"input": "2 5\n5 8\n7\nW\nW\nW\nW\nW\nW\nW\n", "output": "-1"}, {"input": "-1 -9\n-5 -5\n6\nS\nS\nE\nE\nN\nN\n", "output": "-1"}, {"input": "0 0\n0 5\n4\nS\nS\nS\nS\n", "output": "-1"}, {"input": "-100 0\n100 0\n5\nE\nE\nE\nE\nE\n", "output": "-1"}, {"input": "10 10\n10 20\n2\nN\nS", "output": "-1"}, {"input": "-10 -20\n-5 10\n4\nN\nN\nE\nN", "output": "-1"}, {"input": "-10 -10\n-20 -20\n2\nE\nN", "output": "-1"}, {"input": "0 0\n1 1\n1\nS\n", "output": "-1"}, {"input": "100 100\n200 200\n10\nN\nN\nN\nN\nN\nN\nN\nN\nN\nN\n", "output": "-1"}, {"input": "0 0\n0 0\n1\nE\n", "output": "0"}, {"input": "1 1\n20 20\n2\nE\nN\n", "output": "-1"}, {"input": "5 5\n10 10\n10\nE\nE\nE\nE\nE\nE\nE\nE\nE\nE\n", "output": "-1"}, {"input": "1 1\n2 2\n1\nS\n", "output": "-1"}, {"input": "1 1\n10 10\n5\nN\nN\nN\nN\nN\n", "output": "-1"}, {"input": "0 0\n10 10\n5\nE\nE\nE\nE\nE\n", "output": "-1"}, {"input": "1 1\n2 2\n3\nS\nN\nN\n", "output": "-1"}, {"input": "0 0\n0 0\n1\nN\n", "output": "0"}, {"input": "0 0\n5 5\n2\nW\nN\n", "output": "-1"}, {"input": "0 0\n1 1\n10\nE\nE\nE\nE\nE\nE\nE\nE\nE\nE\n", "output": "-1"}, {"input": "0 0\n1 1\n5\nS\nS\nS\nS\nS\n", "output": "-1"}, {"input": "3 5\n4 7\n2\nE\nE\n", "output": "-1"}, {"input": "3 5\n3 5\n10\nW\nW\nW\n", "output": "0"}, {"input": "1 1\n10 10\n2\nS\nW\n", "output": "-1"}, {"input": "10 10\n10 10\n1\nN\n", "output": "0"}, {"input": "10 10\n1 1\n3\nE\nE\nE\n", "output": "-1"}, {"input": "0 0\n0 1\n2\nE\nN\n", "output": "1"}, {"input": "0 0\n1 1\n1\nN\n", "output": "-1"}, {"input": "0 0\n1 1\n2\nE\nS\n", "output": "-1"}, {"input": "0 0\n2 2\n1\nW\n", "output": "-1"}, {"input": "0 0\n2 2\n1\nS\n", "output": "-1"}], "test": "#undef NDEBUG\n#include<assert.h>\nint main(){\n    assert(solution(\"1 1\\n2 2\\n5\\nE\\nN\\nW\\nW\\nN\") == \"2\");\n    assert(solution(\"1 1\\n2 2\\n1\\nW\") == \"-1\");\n    assert(solution(\"1 1\\n2 2\\n3\\nW\\nW\\nW\") == \"-1\");\n    assert(solution(\"2 5\\n5 8\\n7\\nW\\nW\\nW\\nW\\nW\\nW\\nW\\n\") == \"-1\");\n    assert(solution(\"-1 -9\\n-5 -5\\n6\\nS\\nS\\nE\\nE\\nN\\nN\\n\") == \"-1\");\n    assert(solution(\"0 0\\n0 5\\n4\\nS\\nS\\nS\\nS\\n\") == \"-1\");\n    assert(solution(\"-100 0\\n100 0\\n5\\nE\\nE\\nE\\nE\\nE\\n\") == \"-1\");\n    assert(solution(\"10 10\\n10 20\\n2\\nN\\nS\") == \"-1\");\n    assert(solution(\"-10 -20\\n-5 10\\n4\\nN\\nN\\nE\\nN\") == \"-1\");\n    assert(solution(\"-10 -10\\n-20 -20\\n2\\nE\\nN\") == \"-1\");\n    assert(solution(\"0 0\\n1 1\\n1\\nS\\n\") == \"-1\");\n    assert(solution(\"100 100\\n200 200\\n10\\nN\\nN\\nN\\nN\\nN\\nN\\nN\\nN\\nN\\nN\\n\") == \"-1\");\n    assert(solution(\"0 0\\n0 0\\n1\\nE\\n\") == \"0\");\n    assert(solution(\"1 1\\n20 20\\n2\\nE\\nN\\n\") == \"-1\");\n    assert(solution(\"5 5\\n10 10\\n10\\nE\\nE\\nE\\nE\\nE\\nE\\nE\\nE\\nE\\nE\\n\") == \"-1\");\n    assert(solution(\"1 1\\n2 2\\n1\\nS\\n\") == \"-1\");\n    assert(solution(\"1 1\\n10 10\\n5\\nN\\nN\\nN\\nN\\nN\\n\") == \"-1\");\n    assert(solution(\"0 0\\n10 10\\n5\\nE\\nE\\nE\\nE\\nE\\n\") == \"-1\");\n    assert(solution(\"1 1\\n2 2\\n3\\nS\\nN\\nN\\n\") == \"-1\");\n    assert(solution(\"0 0\\n0 0\\n1\\nN\\n\") == \"0\");\n    assert(solution(\"0 0\\n5 5\\n2\\nW\\nN\\n\") == \"-1\");\n    assert(solution(\"0 0\\n1 1\\n10\\nE\\nE\\nE\\nE\\nE\\nE\\nE\\nE\\nE\\nE\\n\") == \"-1\");\n    assert(solution(\"0 0\\n1 1\\n5\\nS\\nS\\nS\\nS\\nS\\n\") == \"-1\");\n    assert(solution(\"3 5\\n4 7\\n2\\nE\\nE\\n\") == \"-1\");\n    assert(solution(\"3 5\\n3 5\\n10\\nW\\nW\\nW\\n\") == \"0\");\n    assert(solution(\"1 1\\n10 10\\n2\\nS\\nW\\n\") == \"-1\");\n    assert(solution(\"10 10\\n10 10\\n1\\nN\\n\") == \"0\");\n    assert(solution(\"10 10\\n1 1\\n3\\nE\\nE\\nE\\n\") == \"-1\");\n    assert(solution(\"0 0\\n0 1\\n2\\nE\\nN\\n\") == \"1\");\n    assert(solution(\"0 0\\n1 1\\n1\\nN\\n\") == \"-1\");\n    assert(solution(\"0 0\\n1 1\\n2\\nE\\nS\\n\") == \"-1\");\n    assert(solution(\"0 0\\n2 2\\n1\\nW\\n\") == \"-1\");\n    assert(solution(\"0 0\\n2 2\\n1\\nS\\n\") == \"-1\");\n    return 0; \n}", "prompt": "/*Given the coordinates of the starting point and the end point, as well as the wind direction (east, south, west, north) for the next T moments, you can choose to offset by 1 unit with the wind or stay in place each time. Find the minimum time to reach the end point.\n\nIf unable to reach the end point with offset, output \"-1\".\n\ninput_format:\nThe first line consists of two positive integers x1 and y1, indicating Xiao Ming's current location.\n\nThe second line consists of two positive integers x2 and y2, indicating the location Xiao Ming wants to go to.\n\nThe third line consists of an integer T, representing T moments.\n\nThe fourth line to the N+3 line consists of a character each, representing the initial of the English word for wind direction, i.e., E (east), S (south), W (west), and N (north).\n\noutput_format:\nMinimum number of steps.\n*/\n\n#include<sstream>\n#include<stdlib.h>\n#include<algorithm>\n#include<math.h>\n#include<stdio.h>\n#include<vector>\n#include<string>\n#include<climits>\n#include<cstring>\n#include<iostream>\nusing namespace std;\n\n             \nstring solution(string std_in){\n    istringstream iss(std_in);\n             ", "constraints": "### 样例解释\n\n- 样例 $1$：向东走一步，向北走一步。\n- 样例 $2,3$：无法到达。\n\n### 数据范围\n\n对于全部数据，$1\\le T\\le 50$。\n", "samples": [["1 1\n2 2\n5\nE\nN\nW\nW\nN", "2"], ["1 1\n2 2\n1\nW", "-1"], ["1 1\n2 2\n3\nW\nW\nW", "-1"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000]}}
{"task_id": "P4711", "title": "「化学」相对分子质量", "difficulty": "advanced", "nl": "When doing chemistry problems, Little F always calculates the relative molecular mass incorrectly, which makes him very distressed.\n\nLittle F has found you to help him calculate the relative molecular mass of the given substance.\n\nIf you haven't learned the relevant content, it doesn't matter. You can understand the content of this problem from the examples and tips.", "code": "#include<cstdio>\n#include<cstring>\n#include<string>\n#include<map>\nusing namespace std;\nchar a[110],b[10];//a是读进来的整个字符串，b是临时字符数组，存当前元素\nint l,ll;//l为a的长度，ll为b的长度\nmap<string,double>mp;//map大法好，存元素对应的相对原子质量\nint cs(int &i)//类似快读，将字符转化为数字，同时将主函数的i同步扫过\n{\n\tint x=0;\n\tfor(;a[i]>='0'&&a[i]<='9';i++)\n\t\tx=x*10+(a[i]-'0');\n\treturn x;\n}\ndouble js(int &i)//计算当前扫到的元素的相对原子质量，同样将主函数的i同步\n{\n\tdouble s=0;//记录质量\n\tmemset(b,0,sizeof(b));//清空临时字符数组\n\tfor(ll=-1;((a[i]>='A'&&a[i]<='Z')||(a[i]>='a'&&a[i]<='z'))&&(ll<0||(ll>=0&&(a[i]>='a'&&a[i]<='z')));i++)\n\t\tb[++ll]=a[i];\n    //找到目前扫到的元素\n    //因为元素开头必是大写字母\n    //所以当扫到的字符不为小写字母(已将这个元素的首字母读入)说明当前元素已扫完\n\tif(a[i]=='_')//若这元素后面有下标，就将数字读入并乘上该元素相对原子质量\n\t{\n\t\ti+=2;//直接跳过'_{'\n\t\ts+=mp[b]*cs(i);\n\t}\n\telse//若没有下标，直接累加上该元素相对原子质量\n\t{\n\t\ts+=mp[b];\n\t\ti--;\n\t}\n\treturn s;\n}\nint main()\n{\n\tint i,o;\n\tdouble s,k;\n\tmp[\"H\"]=1;//以下为初始化\n\tmp[\"C\"]=12;\n\tmp[\"N\"]=14;\n\tmp[\"O\"]=16;\n\tmp[\"F\"]=19;\n    mp[\"Na\"]=23;\n\tmp[\"Mg\"]=24;\n\tmp[\"Al\"]=27;\n\tmp[\"Si\"]=28;\n    mp[\"P\"]=31;\n\tmp[\"S\"]=32;\n\tmp[\"Cl\"]=35.5;\n\tmp[\"K\"]=39;\n    mp[\"Ca\"]=40;\n\tmp[\"Mn\"]=55;\n\tmp[\"Fe\"]=56;\n\tmp[\"Cu\"]=64;\n    mp[\"Zn\"]=65;\n\tmp[\"Ag\"]=108;\n\tmp[\"I\"]=127;\n\tmp[\"Ba\"]=137;\n    mp[\"Hf\"]=178.5;\n\tmp[\"Pt\"]=195;\n\tmp[\"Au\"]=197;\n\tmp[\"Hg\"]=201;\n\tscanf(\"%s\",a);//合法字符串直接%s读入\n\tl=strlen(a);//计算长度\n\tfor(i=0;i<l;i++)//直接扫\n\t{\n\t\tif(a[i]>='A'&&a[i]<='Z')//若为大写字母，说明扫到一个元素，直接累加上去\n\t\t\ts+=js(i);\n\t\tif(a[i]=='(')//若为左括号，则计算括号内的质量\n\t\t{\n\t\t\ti++;//跳过'('\n\t\t\tfor(k=0;a[i]!=')';i++)//因为没有括号嵌套或是水合物，里面必是各种元素，所以直接累加至遇到')'\n\t\t\t\tk+=js(i);\n\t\t\tif(a[i+1]=='_')//判断是否有下标\n\t\t\t\ts+=k*cs(i+=3);//有则将数字乘上，i+=3是为跳过'_{'\n\t\t\telse\n\t\t\t\ts+=k;//没有就直接加上\n\t\t}\n\t\tif(a[i]=='~')//若有水合物\n\t\t{\n\t\t\ti++;//跳过'~'\n\t\t\tif(a[i]=='H')//若为'H'，说明只含一个水分子，直接累加\n\t\t\t\ts+=18;//一个水分子的相对分子质量为18\n\t\t\telse\n\t\t\t\ts+=cs(i)*18;//不为'H'说明有数量，将其乘上即可\n\t\t\tbreak;//因为水合物肯定在最后，所以直接跳出即可\n\t\t}\n\t}\n\to=s;//利用int强制转换来判断是否有.5\n\tif(o==s)\n\t\tprintf(\"%d\",o);\n\telse\n\t\tprintf(\"%.1f\",s);\n\treturn 0;\n}", "step": ["The code initializes variables and sets scores for certain elements.", "If water is present in the compound, its weight is added to the final weight.", "The compound string is processed to calculate the weight.", "The weight is printed as output."], "nl_cn": "做化学题时，小 F 总是里算错相对分子质量，这让他非常苦恼。\n\n小 F 找到了你，请你来帮他算一算给定物质的相对分子质量。\n\n如果你没有学过相关内容也没有关系，你可以从样例和提示里理解该题所求内容。", "test_cases": [{"input": "Au", "output": "197"}, {"input": "HfO_{2}", "output": "210.5"}, {"input": "Ca(OH)_{2}", "output": "74"}, {"input": "CuSO_{4}~5H_{2}O", "output": "250"}, {"input": "KAl(SO_{4})_{2}~12H_{2}O", "output": "474"}, {"input": "NaCl", "output": "58.5"}, {"input": "MgSO_{4}", "output": "120"}, {"input": "Al(NO_{3})_{3}", "output": "213"}, {"input": "ZnS", "output": "97"}, {"input": "HCl", "output": "36.5"}, {"input": "SiO_{2}", "output": "60"}, {"input": "(CH_{3})_{2}CO", "output": "58"}, {"input": "Mg(OH)_{2}", "output": "58"}, {"input": "Al(OH)_{3}", "output": "78"}, {"input": "ZnCl_{2}", "output": "136"}, {"input": "I_{2}", "output": "254"}, {"input": "H", "output": "1"}, {"input": "C", "output": "12"}, {"input": "N", "output": "14"}, {"input": "O", "output": "16"}, {"input": "F", "output": "19"}, {"input": "Na", "output": "23"}, {"input": "Mg", "output": "24"}, {"input": "Si", "output": "28"}, {"input": "P", "output": "31"}, {"input": "S", "output": "32"}, {"input": "Cl", "output": "35.5"}, {"input": "K", "output": "39"}, {"input": "Ca", "output": "40"}, {"input": "Mn", "output": "55"}, {"input": "Al\n", "output": "27"}], "test": "#undef NDEBUG\n#include<assert.h>\nint main(){\n    assert(solution(\"Au\") == \"197\");\n    assert(solution(\"HfO_{2}\") == \"210.5\");\n    assert(solution(\"Ca(OH)_{2}\") == \"74\");\n    assert(solution(\"CuSO_{4}~5H_{2}O\") == \"250\");\n    assert(solution(\"KAl(SO_{4})_{2}~12H_{2}O\") == \"474\");\n    assert(solution(\"NaCl\") == \"58.5\");\n    assert(solution(\"MgSO_{4}\") == \"120\");\n    assert(solution(\"Al(NO_{3})_{3}\") == \"213\");\n    assert(solution(\"ZnS\") == \"97\");\n    assert(solution(\"HCl\") == \"36.5\");\n    assert(solution(\"SiO_{2}\") == \"60\");\n    assert(solution(\"(CH_{3})_{2}CO\") == \"58\");\n    assert(solution(\"Mg(OH)_{2}\") == \"58\");\n    assert(solution(\"Al(OH)_{3}\") == \"78\");\n    assert(solution(\"ZnCl_{2}\") == \"136\");\n    assert(solution(\"I_{2}\") == \"254\");\n    assert(solution(\"H\") == \"1\");\n    assert(solution(\"C\") == \"12\");\n    assert(solution(\"N\") == \"14\");\n    assert(solution(\"O\") == \"16\");\n    assert(solution(\"F\") == \"19\");\n    assert(solution(\"Na\") == \"23\");\n    assert(solution(\"Mg\") == \"24\");\n    assert(solution(\"Si\") == \"28\");\n    assert(solution(\"P\") == \"31\");\n    assert(solution(\"S\") == \"32\");\n    assert(solution(\"Cl\") == \"35.5\");\n    assert(solution(\"K\") == \"39\");\n    assert(solution(\"Ca\") == \"40\");\n    assert(solution(\"Mn\") == \"55\");\n    assert(solution(\"Al\\n\") == \"27\");\n    return 0; \n}", "prompt": "/*When doing chemistry problems, Little F always calculates the relative molecular mass incorrectly, which makes him very distressed.\n\nLittle F has found you to help him calculate the relative molecular mass of the given substance.\n\nIf you haven't learned the relevant content, it doesn't matter. You can understand the content of this problem from the examples and tips.\n\ninput_format:\nEnter a line, a blank string of length $L$$(L\\leq 100)$, representing the chemical formula of the given substance.\n\nThe chemical formula consists only of the following:\n\n* Elements: such as' Au '(gold),' Hf '(hafnium), ** All elements appearing and their relative atomic masses are shown in the table **.\n* subscript ` _ {} ` : it means the number of an atom, ion, or groups of atoms, such as ` H_ ` said $H_2O ${2} O (water), ` C_ {60} ` said $C_ {60} $(soccer).\n* Parentheses' () ': indicates an atomic group, and the subscript takes effect on the matter in the group. For example, 'Ca(OH)_{2}' means $Ca(OH)_2$(hydrated lime).\n* hydrate ` ~ ` : such as ` CuSO_ {4} ~ 5 h_ {2} O ` said $5 h_2o CuSO_4 \\ cdot $(bluestone). If there is a number before the water, it must be a positive integer greater than $2$. If this part is omitted, it defaults to $1$. As in the above bilialum, represents the number of water '5'.\n\nFormally, the formula you are dealing with satisfies the following rules:\n\n> Number of molecules H_{2}O '\n\nThe quantity or hydration part can be saved.\n\nFor molecules, satisfy:\n\n> Part '_' quantity '} 'part' _ 'quantity'} '... Part '_{' quantity'} '\n\nThe quantity can be saved.\n\nFor each \"part\" (atom, group, ion...) Meet:\n\n> Elements\n\nor\n\n> '(' element' _{' quantity '} 'element' _{' quantity '} '... Element '_{' quantity'}) '\n\nThe quantity can be saved.\n\nNote that chemical formulas that meet the above conditions do not have parentheses nested; The \"quantity\" appearing above refers to a number not exceeding $10,000 $.\n\noutput_format:\nOutput a line containing an integer or a real number with a decimal part of '.5 'for the result of your calculation.\n\nGuaranteed results do not exceed $10000$.\n*/\n\n#include<sstream>\n#include<stdlib.h>\n#include<algorithm>\n#include<math.h>\n#include<stdio.h>\n#include<vector>\n#include<string>\n#include<climits>\n#include<cstring>\n#include<iostream>\nusing namespace std;\n\n             \nstring solution(string std_in){\n    istringstream iss(std_in);\n             ", "constraints": "### 样例解释\n金 $Au : 197$\n\n二氧化铪 $HfO_{2}: 178.5 + 2 \\times 16= 210.5$\n\n氢氧化钙（熟石灰）$Ca(OH)_2 : 40 + (1 + 16) \\times 2 = 74$\n\n五水硫酸铜（胆矾）$CuSO_4 \\cdot 5H_2O: 64 + 32 + 16 \\times 4 + 5 \\times (1 \\times 2 + 16) = 250$\n\n十二水合硫酸铝钾（明矾）$KAl(SO_{4})_{2} \\cdot 12H_{2}O$ （嗯 用心感受 $474$ 是对的）\n\n### 附表：可能用到的相对原子质量\n\n|元素|相对原子质量|\n|:-:|:-:|\n|H|1|\n|C|12|\n|N|14|\n|O|16|\n|F|19|\n|Na|23|\n|Mg|24|\n|Al|27|\n|Si|28|\n|P|31|\n|S|32|\n|Cl|35.5|\n|K|39|\n|Ca|40|\n|Mn|55|\n|Fe|56|\n|Cu|64|\n|Zn|65|\n|Ag|108|\n|I|127|\n|Ba|137|\n|Hf|178.5|\n|Pt|195|\n|Au|197|\n|Hg|201|\n\n### 提示\n\n如果你没有学习过相关内容，下面的内容可能有帮助：\n\n> zcy 教你算相对分子质量\n\n1. 每个元素以大写开头；\n2. 计算分子质量的方法就是对每个原子出现的次数乘对应的相对原子质量求和；\n3. ~( $\\cdot$ ) 相当于加；\n4. 下标相当于乘。", "samples": [["Au", "197"], ["HfO_{2}", "210.5"], ["Ca(OH)_{2}", "74"], ["CuSO_{4}~5H_{2}O", "250"], ["KAl(SO_{4})_{2}~12H_{2}O", "474"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}}
{"task_id": "P1220", "title": "关路灯", "difficulty": "advanced", "nl": "A certain village has installed n street lights on a route, each with different power (i.e. some consume more electricity than others within the same period of time). Old Zhang lives near one of the street lights in the middle of the route and it is his job to turn them off one by one every morning when it gets bright.\n\nIn order to save electricity for the village, Old Zhang records the position and power of each street light. Every time he turns off the lights, he tries to do it as quickly as possible to save electricity. However, he does not know how to turn off the lights to be the most energy-efficient. Every day, when it gets bright, he turns off the street light he is next to first, and then he can go left or right to turn off the other lights. At first, he thought he would calculate the total power of the left and right street lights separately and choose to turn off the side with the higher power first, and then turn around and turn off the lights on the other side. However, this is not necessarily the case because turning around at the right time can actually save more electricity.\n\nNow, it is known that Old Zhang walks at a speed of 1 meter per second, the position of each street light (as an integer distance from the starting point of the route, in meters), its power (in W), and the time it takes for Old Zhang to turn off a light is negligible.\n\nPlease write a program for Old Zhang to arrange the order of turning off the lights so that the total electricity consumed by all lights from the moment he starts turning them off until all lights are turned off is minimized (the lights no longer consume electricity once they are turned off).", "code": "#include<bits/stdc++.h>\n\ntemplate <class T>\ninline void read(T &x) {\n\tstatic char c;\n\tstatic bool op;\n\twhile(!isdigit(c = getchar()) && c != '-');\n\tx = (op = c == '-')? 0 : c - '0';\n\twhile(isdigit(c = getchar()))\n\t\tx = x * 10 + c - '0';\n\tif(op) x = ~x + 1;\n}\n\ntemplate <class T>\nvoid putint(T x) {\n\tstatic char buf[15], *tail = buf;\n\tif(!x) putchar('0');\n\telse {\n\t\tif(x < 0) putchar('-'), x = ~x + 1;\n\t\tfor(; x; x /= 10) *++tail = x % 10 + '0';\n\t\tfor(; tail != buf; --tail) putchar(*tail);\n\t}\n\tputchar('\\n');\n}\n\nconst int N = 55;\nint n, c, ans;\n\nnamespace DP {\n\tstatic int d[N],sum[N];\n\tstatic int f[N][N][2];\n\tvoid in() {\n\t\tstd::memset(sum, 0, sizeof(sum));\n\t\tread(n), read(c); \n\t\tfor(int i = 1; i <= n; ++i) {\n\t\t\tread(d[i]), read(sum[i]);\n\t\t\tsum[i] += sum[i - 1];\n\t\t}\n\t}\n\tinline int count(int l, int r, int i, int j) {\n\t\treturn (sum[l] + sum[n] - sum[r - 1]) * (d[j] - d[i]);\n\t} \n\tvoid solve(int &ans) {\n\t\tstd::memset(f, 0x3f, sizeof(f));   \n\t\tf[c][c][0] = f[c][c][1] = 0;\n        \n\t\tfor(int r = c; r <= n; ++r) {\n\t\t\tfor(int l = r - 1; l; --l) {\n\t\t\t\tint k1, k2;\n                \n\t\t\t\tk1 = f[l + 1][r][0] + count(l, r + 1, l, l + 1);\n\t\t\t\tk2 = f[l + 1][r][1] + count(l, r + 1, l, r);\n\t\t\t\tf[l][r][0] = std::min(k1, k2);\n\t\t\t\t\n\t\t\t\tk1 = f[l][r - 1][0] + count(l - 1, r, l, r);\n\t\t\t\tk2 = f[l][r - 1][1] + count(l - 1, r, r - 1, r);\n\t\t\t\tf[l][r][1] = std::min(k1, k2);\n\t\t\t}\n\t\t}\n\t\tans = std::min(f[1][n][1], f[1][n][0]);\n\t}\n} \n\nusing DP::in;\nusing DP::solve;\n\nint main() {\n\tin();\n\tsolve(ans);\n\tputint(ans);\n\treturn 0;\n}", "step": ["Initialize necessary variables and array", "Read input values and calculate cumulative sum", "Calculate minimum cost for traversing with two conditions using dynamic programming approach", "Find and print the minimum cost"], "nl_cn": "某一村庄在一条路线上安装了 $n$ 盏路灯，每盏灯的功率有大有小（即同一段时间内消耗的电量有多有少）。老张就住在这条路中间某一路灯旁，他有一项工作就是每天早上天亮时一盏一盏地关掉这些路灯。\n\n为了给村里节省电费，老张记录下了每盏路灯的位置和功率，他每次关灯时也都是尽快地去关，但是老张不知道怎样去关灯才能够最节省电。他每天都是在天亮时首先关掉自己所处位置的路灯，然后可以向左也可以向右去关灯。开始他以为先算一下左边路灯的总功率再算一下右边路灯的总功率，然后选择先关掉功率大的一边，再回过头来关掉另一边的路灯，而事实并非如此，因为在关的过程中适当地调头有可能会更省一些。\n\n现在已知老张走的速度为 $1m/s$，每个路灯的位置（是一个整数，即距路线起点的距离，单位：$m$）、功率（$W$），老张关灯所用的时间很短而可以忽略不计。\n\n请你为老张编一程序来安排关灯的顺序，使从老张开始关灯时刻算起所有灯消耗电最少（灯关掉后便不再消耗电了）。", "test_cases": [{"input": "5 3\n2 10\n3 20\n5 20\n6 30\n8 10", "output": "270"}, {"input": "1 1\n1 5", "output": "0"}, {"input": "1 1\n1 10\n", "output": "0"}, {"input": "5 4\n1 20\n2 30\n4 10\n6 25\n8 15\n", "output": "420"}], "test": "#undef NDEBUG\n#include<assert.h>\nint main(){\n    assert(solution(\"5 3\\n2 10\\n3 20\\n5 20\\n6 30\\n8 10\") == \"270\");\n    assert(solution(\"1 1\\n1 5\") == \"0\");\n    assert(solution(\"1 1\\n1 10\\n\") == \"0\");\n    assert(solution(\"5 4\\n1 20\\n2 30\\n4 10\\n6 25\\n8 15\\n\") == \"420\");\n    return 0; \n}", "prompt": "/*A certain village has installed n street lights on a route, each with different power (i.e. some consume more electricity than others within the same period of time). Old Zhang lives near one of the street lights in the middle of the route and it is his job to turn them off one by one every morning when it gets bright.\n\nIn order to save electricity for the village, Old Zhang records the position and power of each street light. Every time he turns off the lights, he tries to do it as quickly as possible to save electricity. However, he does not know how to turn off the lights to be the most energy-efficient. Every day, when it gets bright, he turns off the street light he is next to first, and then he can go left or right to turn off the other lights. At first, he thought he would calculate the total power of the left and right street lights separately and choose to turn off the side with the higher power first, and then turn around and turn off the lights on the other side. However, this is not necessarily the case because turning around at the right time can actually save more electricity.\n\nNow, it is known that Old Zhang walks at a speed of 1 meter per second, the position of each street light (as an integer distance from the starting point of the route, in meters), its power (in W), and the time it takes for Old Zhang to turn off a light is negligible.\n\nPlease write a program for Old Zhang to arrange the order of turning off the lights so that the total electricity consumed by all lights from the moment he starts turning them off until all lights are turned off is minimized (the lights no longer consume electricity once they are turned off).\n\ninput_format:\nThe first line consists of two numbers: $n$ (represents the total number of streetlights) and $c$ (the number of the streetlight at the location where Mr. Zhang is).\n\nFollowing that are $n$ lines, each containing two values, representing the position and power of streetlight number $1$ through streetlight number $n$. The data guarantees that the positions of the streetlights are in increasing order.\n\noutput_format:\nOne data, that is, the minimum power consumption (unit: $J$, $1J=1W\\times s$).\n*/\n\n#include<sstream>\n#include<stdlib.h>\n#include<algorithm>\n#include<math.h>\n#include<stdio.h>\n#include<vector>\n#include<string>\n#include<climits>\n#include<cstring>\n#include<iostream>\nusing namespace std;\n\n             \nstring solution(string std_in){\n    istringstream iss(std_in);\n             ", "constraints": "### 样例解释\n\n此时关灯顺序为 `3 4 2 1 5`。\n\n### 数据范围\n\n$1\\le n\\le50$，$1\\le c\\le n$，$1\\le W_i \\le 100$。", "samples": [["5 3\n2 10\n3 20\n5 20\n6 30\n8 10", "270  "]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288]}}
{"task_id": "P1755", "title": "斐波那契的拆分", "difficulty": "challenge", "nl": "Given a positive integer, it can always be split into several Fibonacci numbers. Now, your task is to find the ways to split number n.", "code": "#include <string.h>\n#include <cstdio>\nusing namespace std;\nint main()\n{\n    int a[50],b[50],n,t,w,x,y;\n    a[1]=1;a[2]=1;\n    for (int i=3;i<=45;i++) \n        a[i]=a[i-1]+a[i-2];  //a数组保存斐波那契数列\n    scanf(\"%d\",&n);\n    for (int i=1;i<=n;i++)\n    {\n        w=0;\n        scanf(\"%d\",&t);\n        x=t;\n        memset(b,0,sizeof(b));  //初始化\n        while (t>0)\n        {\n            y=45;\n            while (y>0)\n            {\n                if (a[y]<=t)  //可以取\n                {\n                    w++;  //统计取的数量\n                    b[w]=a[y];  //将取的数保存\n                    t=t-a[y];\n                }\n                else y=y-1;  //有可能会有两个相同的数，如4=2+2，要注意这种情况\n            }\n        }\n        printf(\"%d%s\",x,\"=\");\n        for (int j=w;j>0;j--)  //因为b里是从大到小排序的，所以我们反着输出\n            if (j==1) printf(\"%d\\n\",b[j]);  \n            else printf(\"%d%s\",b[j],\"+\");\n    }\n}", "step": ["Initialize an array 'f' with 1's and 45 elements", "Populate the 'f' array with fibonacci numbers", "Read input 'T' - number of test cases, read 'n' - input number to convert to fibonacci representation", "Iterate from last index of 'f' to first index and check if n is greater than or equal to f[i]", "If yes, add f[i] into stack 's' and decrement n by f[i]", "If n equals 0, exit the loop", "Print the elements of stack 's' as the fibonacci representation of given integer"], "nl_cn": "已知任意一个正整数都可以拆分为若干个斐波纳契数，现在，让你求出n的拆分方法\n", "test_cases": [{"input": "1\n1\n", "output": "1=1"}, {"input": "1\n10", "output": "10=2+8"}, {"input": "1\n5\n", "output": "5=5"}, {"input": "1\n13\n", "output": "13=13"}, {"input": "1\n55\n", "output": "55=55"}, {"input": "1\n89\n", "output": "89=89"}, {"input": "1\n144\n", "output": "144=144"}, {"input": "1\n377\n", "output": "377=377"}, {"input": "1\n610\n", "output": "610=610"}, {"input": "1\n987\n", "output": "987=987"}, {"input": "1\n1597\n", "output": "1597=1597"}, {"input": "1\n2584\n", "output": "2584=2584"}, {"input": "1\n4181\n", "output": "4181=4181"}, {"input": "1\n6765\n", "output": "6765=6765"}, {"input": "1\n10946\n", "output": "10946=10946"}, {"input": "1\n17711\n", "output": "17711=17711"}, {"input": "1\n28657\n", "output": "28657=28657"}, {"input": "1\n46368\n", "output": "46368=46368"}, {"input": "1\n8\n", "output": "8=8"}, {"input": "1\n3\n", "output": "3=3"}, {"input": "1\n2\n", "output": "2=2"}, {"input": "1\n21\n", "output": "21=21"}, {"input": "1\n34\n", "output": "34=34"}, {"input": "1\n233\n", "output": "233=233"}], "test": "#undef NDEBUG\n#include<assert.h>\nint main(){\n    assert(solution(\"1\\n1\\n\") == \"1=1\");\n    assert(solution(\"1\\n10\") == \"10=2+8\");\n    assert(solution(\"1\\n5\\n\") == \"5=5\");\n    assert(solution(\"1\\n13\\n\") == \"13=13\");\n    assert(solution(\"1\\n55\\n\") == \"55=55\");\n    assert(solution(\"1\\n89\\n\") == \"89=89\");\n    assert(solution(\"1\\n144\\n\") == \"144=144\");\n    assert(solution(\"1\\n377\\n\") == \"377=377\");\n    assert(solution(\"1\\n610\\n\") == \"610=610\");\n    assert(solution(\"1\\n987\\n\") == \"987=987\");\n    assert(solution(\"1\\n1597\\n\") == \"1597=1597\");\n    assert(solution(\"1\\n2584\\n\") == \"2584=2584\");\n    assert(solution(\"1\\n4181\\n\") == \"4181=4181\");\n    assert(solution(\"1\\n6765\\n\") == \"6765=6765\");\n    assert(solution(\"1\\n10946\\n\") == \"10946=10946\");\n    assert(solution(\"1\\n17711\\n\") == \"17711=17711\");\n    assert(solution(\"1\\n28657\\n\") == \"28657=28657\");\n    assert(solution(\"1\\n46368\\n\") == \"46368=46368\");\n    assert(solution(\"1\\n8\\n\") == \"8=8\");\n    assert(solution(\"1\\n3\\n\") == \"3=3\");\n    assert(solution(\"1\\n2\\n\") == \"2=2\");\n    assert(solution(\"1\\n21\\n\") == \"21=21\");\n    assert(solution(\"1\\n34\\n\") == \"34=34\");\n    assert(solution(\"1\\n233\\n\") == \"233=233\");\n    return 0; \n}", "prompt": "/*Given a positive integer, it can always be split into several Fibonacci numbers. Now, your task is to find the ways to split number n.\n\ninput_format:\nA number t indicates that there are t sets of data\n\nNext t lines, each line has a number n.\n\noutput_format:\nt lines, one string per line, representing the split method (format :n=a1+a2+a3+.. +an), requiring output from small to large\n*/\n\n#include<sstream>\n#include<stdlib.h>\n#include<algorithm>\n#include<math.h>\n#include<stdio.h>\n#include<vector>\n#include<string>\n#include<climits>\n#include<cstring>\n#include<iostream>\nusing namespace std;\n\n             \nstring solution(string std_in){\n    istringstream iss(std_in);\n             ", "constraints": "若有多组数据，以个数最小的为准，若仍有多组，输出右边尽量大的一组。\n\n对于$100\\%$的数据，$t \\leq 1000$，$1 \\leq n \\leq 10^{9}$。", "samples": [["1\n1\n", "1=1"], ["1\n10", "10=2+8"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000]}}
{"task_id": "P1075", "title": "[NOIP2012 普及组] 质因数分解", "difficulty": "basic", "nl": "Given a positive integer $n$ which is the product of two distinct prime numbers, find the larger one of the two.", "code": "#include<cstdio>\nint main()\n{\n    int n;\n    scanf(\"%d\",&n);\n    for(int i=2;i<=n;++i)\n            if(n%i==0)\n            {\n                    printf(\"%d\",n/i);\n                    return 0;\n            }\n}", "step": ["Input an integer value.", "Start a for loop starting from 2 to n.", "If the integer is divisible by i, print the quotient n/i.", "Exit the program."], "nl_cn": "已知正整数 $n$ 是两个不同的质数的乘积，试求出两者中较大的那个质数。\n", "test_cases": [{"input": "21", "output": "7"}, {"input": "15\n", "output": "5"}, {"input": "33\n", "output": "11"}, {"input": "77\n", "output": "11"}, {"input": "91\n", "output": "13"}, {"input": "143\n", "output": "13"}, {"input": "187\n", "output": "17"}, {"input": "247\n", "output": "19"}, {"input": "289\n", "output": "17"}, {"input": "961\n", "output": "31"}, {"input": "35", "output": "7"}, {"input": "221", "output": "17"}, {"input": "323", "output": "19"}, {"input": "2021", "output": "47"}, {"input": "10\n", "output": "5"}, {"input": "30\n", "output": "15"}, {"input": "39\n", "output": "13"}, {"input": "42\n", "output": "21"}, {"input": "55\n", "output": "11"}, {"input": "57\n", "output": "19"}, {"input": "62\n", "output": "31"}, {"input": "69\n", "output": "23"}, {"input": "74\n", "output": "37"}, {"input": "85\n", "output": "17"}, {"input": "95\n", "output": "19"}, {"input": "100\n", "output": "50"}, {"input": "65\n", "output": "13"}, {"input": "115\n", "output": "23"}, {"input": "133\n", "output": "19"}, {"input": "203\n", "output": "29"}, {"input": "209\n", "output": "19"}, {"input": "253\n", "output": "23"}], "test": "#undef NDEBUG\n#include<assert.h>\nint main(){\n    assert(solution(\"21\") == \"7\");\n    assert(solution(\"15\\n\") == \"5\");\n    assert(solution(\"33\\n\") == \"11\");\n    assert(solution(\"77\\n\") == \"11\");\n    assert(solution(\"91\\n\") == \"13\");\n    assert(solution(\"143\\n\") == \"13\");\n    assert(solution(\"187\\n\") == \"17\");\n    assert(solution(\"247\\n\") == \"19\");\n    assert(solution(\"289\\n\") == \"17\");\n    assert(solution(\"961\\n\") == \"31\");\n    assert(solution(\"35\") == \"7\");\n    assert(solution(\"221\") == \"17\");\n    assert(solution(\"323\") == \"19\");\n    assert(solution(\"2021\") == \"47\");\n    assert(solution(\"10\\n\") == \"5\");\n    assert(solution(\"30\\n\") == \"15\");\n    assert(solution(\"39\\n\") == \"13\");\n    assert(solution(\"42\\n\") == \"21\");\n    assert(solution(\"55\\n\") == \"11\");\n    assert(solution(\"57\\n\") == \"19\");\n    assert(solution(\"62\\n\") == \"31\");\n    assert(solution(\"69\\n\") == \"23\");\n    assert(solution(\"74\\n\") == \"37\");\n    assert(solution(\"85\\n\") == \"17\");\n    assert(solution(\"95\\n\") == \"19\");\n    assert(solution(\"100\\n\") == \"50\");\n    assert(solution(\"65\\n\") == \"13\");\n    assert(solution(\"115\\n\") == \"23\");\n    assert(solution(\"133\\n\") == \"19\");\n    assert(solution(\"203\\n\") == \"29\");\n    assert(solution(\"209\\n\") == \"19\");\n    assert(solution(\"253\\n\") == \"23\");\n    return 0; \n}", "prompt": "/*Given a positive integer $n$ which is the product of two distinct prime numbers, find the larger one of the two.\n\ninput_format:\nEnter a positive integer $n$.\n\noutput_format:\nOutput a positive integer $p$, which is the larger prime number.\n*/\n\n#include<sstream>\n#include<stdlib.h>\n#include<algorithm>\n#include<math.h>\n#include<stdio.h>\n#include<vector>\n#include<string>\n#include<climits>\n#include<cstring>\n#include<iostream>\nusing namespace std;\n\n             \nstring solution(string std_in){\n    istringstream iss(std_in);\n             ", "constraints": "$1 \\le n\\le 2\\times 10^9$\n\nNOIP 2012 普及组 第一题\n", "samples": [["21", "7"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072]}}
{"task_id": "P7085", "title": "[NWRRC2013] Garage", "difficulty": "challenge", "nl": "Your company has won the social contract to build a garage complex - what a lucky day! Almost all procedures have been completed: the contract payments have been transferred to your account.\n\nNow is the appropriate time to read the contract. Okay, here is a space arranged in a $W \\times H$ rectangle, and you need to place some garages on it. The garages are rectangles with dimensions $w \\times h$, and their edges are parallel to the edges of the space (you cannot even rotate the garages by $90^\\circ$). The coordinates of the garages can be non-integer.\n\nYou know that economy must come first, so you decide to place as few garages as possible. Unfortunately, there is a contrary requirement in the contract: place as many garages as possible.\n\nNow let's see how these requirements are checked... Accept the plan if new garages cannot be added without moving other garages (the edges of the new garage must also be parallel to the corresponding edges of the space). \n\nTime is money, find the minimum number of garages that must be ordered so that you can place them on the space without any extra space.", "code": "#include <cstdio>\n#include <cmath>\nint W, H, w, h;\nint main() {\n\tscanf(\"%d%d%d%d\", &W, &H, &w, &h);\n\tint a = (int)ceil( (double)(W - w + 0.000001) / (double)(2 * w - 0.000001) );\n\tint b = (int)ceil( (double)(H - h + 0.000001) / (double)(2 * h - 0.000001) );\n\tprintf(\"%d\\n\", a * b);\n\treturn 0;\n}", "step": ["Read the width, height, width of the small rectangle and height of the small rectangle from standard input.", "Calculate the number of small rectangles that can be placed horizontally (a) using given formula and store it in a variable.", "Calculate the number of small rectangles that can be placed vertically (b) using given formula and store it in a variable.", "Calculate the total number of small rectangles that can be fitted inside the given rectangle by multiplying the values of a and b and store the result in a variable.", "Print the total number of small rectangles that can be fitted inside the given rectangle.", "Terminate the program."], "nl_cn": "\n\nWow! What a lucky day! Your company has just won a social contract for building a garage complex. Almost all formalities are done: contract payment is already transferred to your account.\n\nSo now it is the right time to read the contract. Okay, there is a sandlot in the form of $W \\times H$ rectangle and you have to place some garages there. Garages are $w \\times h$ rectangles and their edges must be parallel to the corresponding edges of the sandlot (you may not rotate garages, even by $90^{◦}).$ The coordinates of garages may be non-integer.\n\nYou know that the economy must be economical, so you decided to place as few garages as possible. Unfortunately, there is an opposite requirement in the contract: placing maximum possible number of garages.\n\nNow let's see how these requirements are checked. . . The plan is accepted if it is impossible to add a new garage without moving the other garages (the new garage must also have edges parallel to corresponding sandlot edges).\n\n\n\nTime is money, find the minimal number of garages that must be ordered, so that you can place them on the sandlot and there is no place for an extra garage.\n\n", "test_cases": [{"input": "11 4 3 2\n", "output": "2"}, {"input": "10 8 3 4\n", "output": "2"}, {"input": "15 7 4 2\n", "output": "4"}, {"input": "20 10 5 3\n", "output": "4"}, {"input": "18 7 4 2\n", "output": "4"}, {"input": "10 10 3 3\n", "output": "4"}, {"input": "10 5 2 2\n", "output": "3"}, {"input": "16 8 4 2\n", "output": "4"}, {"input": "18 9 5 3\n", "output": "4"}, {"input": "20 10 4 3\n", "output": "6"}, {"input": "13 7 4 2\n", "output": "4"}, {"input": "9 4 3 2\n", "output": "2"}, {"input": "15 8 5 2\n", "output": "4"}, {"input": "5 5 3 3\n", "output": "1"}, {"input": "7 7 2 2\n", "output": "4"}, {"input": "9 9 4 4\n", "output": "1"}, {"input": "20 10 5 5\n", "output": "2"}, {"input": "14 4 6 2\n", "output": "1"}, {"input": "7 9 3 4\n", "output": "1"}, {"input": "13 7 6 3\n", "output": "1"}, {"input": "2 2 1 1\n", "output": "1"}, {"input": "15 10 5 3\n", "output": "4"}, {"input": "11 9 3 3\n", "output": "4"}, {"input": "7 4 2 1\n", "output": "4"}, {"input": "5 6 1 2\n", "output": "6"}, {"input": "8 7 2 1\n", "output": "8"}], "test": "#undef NDEBUG\n#include<assert.h>\nint main(){\n    assert(solution(\"11 4 3 2\\n\") == \"2\");\n    assert(solution(\"10 8 3 4\\n\") == \"2\");\n    assert(solution(\"15 7 4 2\\n\") == \"4\");\n    assert(solution(\"20 10 5 3\\n\") == \"4\");\n    assert(solution(\"18 7 4 2\\n\") == \"4\");\n    assert(solution(\"10 10 3 3\\n\") == \"4\");\n    assert(solution(\"10 5 2 2\\n\") == \"3\");\n    assert(solution(\"16 8 4 2\\n\") == \"4\");\n    assert(solution(\"18 9 5 3\\n\") == \"4\");\n    assert(solution(\"20 10 4 3\\n\") == \"6\");\n    assert(solution(\"13 7 4 2\\n\") == \"4\");\n    assert(solution(\"9 4 3 2\\n\") == \"2\");\n    assert(solution(\"15 8 5 2\\n\") == \"4\");\n    assert(solution(\"5 5 3 3\\n\") == \"1\");\n    assert(solution(\"7 7 2 2\\n\") == \"4\");\n    assert(solution(\"9 9 4 4\\n\") == \"1\");\n    assert(solution(\"20 10 5 5\\n\") == \"2\");\n    assert(solution(\"14 4 6 2\\n\") == \"1\");\n    assert(solution(\"7 9 3 4\\n\") == \"1\");\n    assert(solution(\"13 7 6 3\\n\") == \"1\");\n    assert(solution(\"2 2 1 1\\n\") == \"1\");\n    assert(solution(\"15 10 5 3\\n\") == \"4\");\n    assert(solution(\"11 9 3 3\\n\") == \"4\");\n    assert(solution(\"7 4 2 1\\n\") == \"4\");\n    assert(solution(\"5 6 1 2\\n\") == \"6\");\n    assert(solution(\"8 7 2 1\\n\") == \"8\");\n    return 0; \n}", "prompt": "/*Your company has won the social contract to build a garage complex - what a lucky day! Almost all procedures have been completed: the contract payments have been transferred to your account.\n\nNow is the appropriate time to read the contract. Okay, here is a space arranged in a $W \\times H$ rectangle, and you need to place some garages on it. The garages are rectangles with dimensions $w \\times h$, and their edges are parallel to the edges of the space (you cannot even rotate the garages by $90^\\circ$). The coordinates of the garages can be non-integer.\n\nYou know that economy must come first, so you decide to place as few garages as possible. Unfortunately, there is a contrary requirement in the contract: place as many garages as possible.\n\nNow let's see how these requirements are checked... Accept the plan if new garages cannot be added without moving other garages (the edges of the new garage must also be parallel to the corresponding edges of the space). \n\nTime is money, find the minimum number of garages that must be ordered so that you can place them on the space without any extra space.\n\ninput_format:\n\n\nThe only line contains four integers: $W , H , w , h$ -- dimensions of sandlot and garage in meters. You may assume that $1 \\le w \\le W \\le 30 000$ and $1 \\le h \\le H \\le Thirty thousand dollars.\n\noutput_format:\n\n\nOutput the optimal number of garages.\n*/\n\n#include<sstream>\n#include<stdlib.h>\n#include<algorithm>\n#include<math.h>\n#include<stdio.h>\n#include<vector>\n#include<string>\n#include<climits>\n#include<cstring>\n#include<iostream>\nusing namespace std;\n\n             \nstring solution(string std_in){\n    istringstream iss(std_in);\n             ", "constraints": "Time limit: 2 s, Memory limit: 256 MB. \n\n", "samples": [["11 4 3 2\n", "2\n"], ["10 8 3 4\n", "2\n"], ["15 7 4 2\n", "4\n"]], "limits": {"time": [2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000], "memory": [262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144]}}
{"task_id": "P2888", "title": "[USACO07NOV]Cow Hurdles S", "difficulty": "challenge", "nl": "Farmer John wants his cows to prepare for the county jumping competition, and Bessie and her friends are practicing jumping over hurdles. They want to use as little energy as possible to jump over the hurdles. For the cows, it is easy to jump over several short hurdles, but a tall hurdle is very stressful. Therefore, the cows are only concerned about the height of the tallest hurdle they have to jump over.\n\nThe cows' practice room has N stations labeled 1 to N. There are M one-way paths labeled 1 to M connecting pairs of stations. Path i goes from station Si to station Ei and contains exactly one hurdle of height Hi. Cows must jump hurdles in any path they traverse.\n\nThe cows have T tasks to complete. Task i consists of two distinct numbers, Ai and Bi, which mean that a cow has to travel from station Ai to station Bi by traversing one or more paths over some route. The cows want to take the path that minimizes the height of the tallest hurdle they jump over when traveling from Ai to Bi. Your task is to write a program to determine the path whose tallest hurdle is the smallest and report that height.", "code": "#include<iostream>\n#include<cstdio>\n#include<algorithm>\n#include<cmath>\n#include<cstring>\n#include<map>\n#include<queue>\n#define mod 100000007\n#define inf 336860180\n#define PI 3.1415926\n#define ll long long\nusing namespace std;\nint T,s,t,n,m,d[400][400];\nint main()\n{\n    memset(d,20,sizeof(d));\n    scanf(\"%d%d%d\",&n,&m,&T);\n    for(int i=1;i<=m;i++)\n    {\n     int x,y,h;scanf(\"%d%d%d\",&x,&y,&h);\n      d[x][y]=h;    \n    }\n    for(int k=1;k<=n;k++)\n     for(int i=1;i<=n;i++)\n      for(int j=1;j<=n;j++)\n       d[i][j]=min(max(d[i][k],d[k][j]),d[i][j]);\n       //重点 \n    for(int i=1;i<=T;i++)\n    {\n      int x,y;scanf(\"%d%d\",&x,&y);    \n      if(d[x][y]!=inf) cout<<d[x][y]<<endl;\n      else cout<<\"-1\"<<endl;//不要忘记这种情况啊 \n    }\n    return 0;\n}", "step": ["Read input values of n, m, T", "Assign h to d[x][y]", "Pick the smallest among the maximum of two paths as the distance between i and j", "Print out the elements in d[x][y]"], "nl_cn": "Farmer John wants the cows to prepare for the county jumping competition, so Bessie and the gang are practicing jumping over hurdles. They are getting tired, though, so they want to be able to use as little energy as possible to jump over the hurdles.\n\nObviously, it is not very difficult for a cow to jump over several very short hurdles, but one tall hurdle can be very stressful. Thus, the cows are only concerned about the height of the tallest hurdle they have to jump over.\n\nThe cows' practice room has $N$ stations, conveniently labeled $1,\\dots,N$. A set of $M$ one-way paths connects pairs of stations; the paths are also conveniently labeled $1,\\dots,M$. Path $i$ travels from station $S_i$ to station $E_i$ and contains exactly one hurdle of height $H_i$. Cows must jump hurdles in any path they traverse.\n\nThe cows have $T$ tasks to complete. Task $i$ comprises two distinct numbers, $A_i$ and $B_i$, which connote that a cow has to travel from station $A_i$ to station $B_i$ (by traversing over one or more paths over some route). The cows want to take a path the minimizes the height of the tallest hurdle they jump over when traveling from $A_i$ to $B_i$ . Your job is to write a program that determines the path whose tallest hurdle is smallest and report that height.\n\n\nFarmer John 想让她的奶牛准备郡级跳跃比赛，Bessie 和她的伙伴们正在练习跨栏。她们很累，所以她们想消耗最少的能量来跨栏。 显然，对于一头奶牛跳过几个矮栏是很容易的，但是高栏却很难。于是，奶牛们总是关心路径上最高的栏的高度。 \n\n奶牛的训练场中有 $N$ 个站台，分别标记为 $1,\\dots,N$。所有站台之间有 $M$ 条单向路径，第 $i$ 条路经是从站台 $S_i$ 开始，到站台 $E_i$，其中最高的栏的高度为 $H_i$。无论如何跑，奶牛们都要跨栏。 \n\n奶牛们有 $T$ 个训练任务要完成。第 $i$ 个任务包含两个数字 $A_i$ 和 $B_i$，表示奶牛必须从站台 $A_i$ 跑到站台 $B_i$，可以路过别的站台。奶牛们想找一条路径从站台 $A_i$ 到站台 $B_i$，使路径上最高的栏的高度最小。 你的任务就是写一个程序，计算出路径上最高的栏的高度的最小值。\n", "test_cases": [{"input": "5 6 3\n1 2 12\n3 2 8\n1 3 5\n2 5 3\n3 4 4\n2 4 8\n3 4\n1 2\n5 1\n", "output": "4\n8\n-1"}, {"input": "2 1 1\n1 2 5\n1 2\n", "output": "5"}, {"input": "3 3 2\n1 2 10\n2 3 12\n1 3 8\n1 2\n2 3\n", "output": "10\n12"}, {"input": "4 4 2\n1 2 5\n2 3 3\n3 4 6\n2 4 8\n1 3\n4 1\n", "output": "5\n-1"}, {"input": "3 2 2\n1 2 6\n2 3 4\n1 3\n3 1\n", "output": "6\n-1"}, {"input": "2 1 1\n1 2 10\n1 2\n", "output": "10"}, {"input": "3 3 3\n1 2 6\n2 3 3\n3 1 7\n1 2\n2 3\n1 3\n", "output": "6\n3\n6"}, {"input": "2 1 1\n1 2 4\n1 2\n", "output": "4"}, {"input": "3 3 2\n1 2 7\n2 3 8\n3 1 9\n1 2\n3 1\n", "output": "7\n9"}, {"input": "4 3 3\n1 2 1\n2 3 2\n3 1 3\n1 2\n2 3\n3 1\n", "output": "1\n2\n3"}, {"input": "2 1 1\n1 2 3\n1 2\n", "output": "3"}, {"input": "6 8 4\n1 2 1\n2 3 3\n3 4 5\n4 5 7\n5 6 9\n1 3 2\n2 4 4\n3 5 6\n1 6\n2 6\n3 6\n4 6\n", "output": "9\n9\n9\n9"}, {"input": "4 6 3\n1 2 12\n3 2 8\n1 3 5\n2 5 3\n3 4 4\n2 4 8\n3 4\n1 2\n2 4\n", "output": "4\n8\n8"}], "test": "#undef NDEBUG\n#include<assert.h>\nint main(){\n    assert(solution(\"5 6 3\\n1 2 12\\n3 2 8\\n1 3 5\\n2 5 3\\n3 4 4\\n2 4 8\\n3 4\\n1 2\\n5 1\\n\") == \"4\\n8\\n-1\");\n    assert(solution(\"2 1 1\\n1 2 5\\n1 2\\n\") == \"5\");\n    assert(solution(\"3 3 2\\n1 2 10\\n2 3 12\\n1 3 8\\n1 2\\n2 3\\n\") == \"10\\n12\");\n    assert(solution(\"4 4 2\\n1 2 5\\n2 3 3\\n3 4 6\\n2 4 8\\n1 3\\n4 1\\n\") == \"5\\n-1\");\n    assert(solution(\"3 2 2\\n1 2 6\\n2 3 4\\n1 3\\n3 1\\n\") == \"6\\n-1\");\n    assert(solution(\"2 1 1\\n1 2 10\\n1 2\\n\") == \"10\");\n    assert(solution(\"3 3 3\\n1 2 6\\n2 3 3\\n3 1 7\\n1 2\\n2 3\\n1 3\\n\") == \"6\\n3\\n6\");\n    assert(solution(\"2 1 1\\n1 2 4\\n1 2\\n\") == \"4\");\n    assert(solution(\"3 3 2\\n1 2 7\\n2 3 8\\n3 1 9\\n1 2\\n3 1\\n\") == \"7\\n9\");\n    assert(solution(\"4 3 3\\n1 2 1\\n2 3 2\\n3 1 3\\n1 2\\n2 3\\n3 1\\n\") == \"1\\n2\\n3\");\n    assert(solution(\"2 1 1\\n1 2 3\\n1 2\\n\") == \"3\");\n    assert(solution(\"6 8 4\\n1 2 1\\n2 3 3\\n3 4 5\\n4 5 7\\n5 6 9\\n1 3 2\\n2 4 4\\n3 5 6\\n1 6\\n2 6\\n3 6\\n4 6\\n\") == \"9\\n9\\n9\\n9\");\n    assert(solution(\"4 6 3\\n1 2 12\\n3 2 8\\n1 3 5\\n2 5 3\\n3 4 4\\n2 4 8\\n3 4\\n1 2\\n2 4\\n\") == \"4\\n8\\n8\");\n    return 0; \n}", "prompt": "/*Farmer John wants his cows to prepare for the county jumping competition, and Bessie and her friends are practicing jumping over hurdles. They want to use as little energy as possible to jump over the hurdles. For the cows, it is easy to jump over several short hurdles, but a tall hurdle is very stressful. Therefore, the cows are only concerned about the height of the tallest hurdle they have to jump over.\n\nThe cows' practice room has N stations labeled 1 to N. There are M one-way paths labeled 1 to M connecting pairs of stations. Path i goes from station Si to station Ei and contains exactly one hurdle of height Hi. Cows must jump hurdles in any path they traverse.\n\nThe cows have T tasks to complete. Task i consists of two distinct numbers, Ai and Bi, which mean that a cow has to travel from station Ai to station Bi by traversing one or more paths over some route. The cows want to take the path that minimizes the height of the tallest hurdle they jump over when traveling from Ai to Bi. Your task is to write a program to determine the path whose tallest hurdle is the smallest and report that height.\n\ninput_format:\nLine 1: Three space-separated integers: N, M, and T.\n\nLines 2 to M+1: Line i+1 contains three space-separated integers: Si, Ei, and Hi.\n\nLines M+2 to M+T+1: Line i+M+1 contains two space-separated integers that describe task i: Ai and Bi.\n\noutput_format:\n\\* Lines $1,\\dots,T$: Line $i$ contains the result for task $i$ and tells the smallest possible maximum height necessary to travel between the  stations. Output `-1` if it is impossible to travel between the two stations.\n\n$T$line: The first $i$is an integer that represents the minimum of the height of the highest column on the task $i$path. If it cannot be reached, output '-1'.\n*/\n\n#include<sstream>\n#include<stdlib.h>\n#include<algorithm>\n#include<math.h>\n#include<stdio.h>\n#include<vector>\n#include<string>\n#include<climits>\n#include<cstring>\n#include<iostream>\nusing namespace std;\n\n             \nstring solution(string std_in){\n    istringstream iss(std_in);\n             ", "constraints": "对于 $100\\%$ 的数据，$1 \\le N \\le 300$，$1 \\le M \\le 2.5 \\times 10^4$，$1 \\le H_i \\le 1 \\times 10^6$，$1 \\le T \\le 4 \\times 10^4$，$1 \\le A_i,B_i \\le N$。\n\n感谢 @gaozhiyong @_Cppsteve_ 提供翻译\n", "samples": [["5 6 3\n1 2 12\n3 2 8\n1 3 5\n2 5 3\n3 4 4\n2 4 8\n3 4\n1 2\n5 1\n", "4\n8\n-1\n"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}}
{"task_id": "P8835", "title": "[传智杯 #3 决赛] 子串", "difficulty": "challenge", "nl": "In the development classroom at Chuanzhi, we hope you can develop a document processing software.\n\nGiven T groups of inquiries, each time giving two strings a and b of length n and m, respectively, containing only English letters, find the number of occurrences of a in b, ignoring case sensitivity. Note that a is a contiguous subsequence of b.\n\nFor all data, T is less than or equal to 100, and the sum of n is less than or equal to the sum of m which is less than or equal to 1000. The strings are only composed of uppercase or lowercase English letters.", "code": "#include<iostream>\nusing namespace std;\nint t,n,m,ans;\nstring b_sm(string s){//刚才的函数\n    int l=s.size();\n    for(int i=0;i<l;i++){\n        if(s[i]>='A'&&s[i]<='Z')s[i]+=32;\n    }\n    return s;\n}\nstring s1,s2;//题目中的A和B\nint main(){\n    cin>>t;\n    while(t--){\n        ans=0;\n        cin>>n>>m>>s1>>s2;//输入\n        s1=b_sm(s1);s2=b_sm(s2);\n        int l2=s2.size(),l1=s1.size();\n        for(int i=0;i<l2;i++){\n            if(s2.substr(i,l1)==s1)ans++;//截取，如果是就把答案增加\n        }\n        cout<<ans<<endl;//输出答案\n    }\n    return 0;\n}", "step": ["Declare necessary variables.", "Take input values and two strings.", "Convert the strings to lowercase using the 'b_sm' function.", "Loop through the second string to find occurrences of the first string using the 'substr' function.", "Print the number of occurrences of the first string.", "Repeat the above steps until all test cases are completed."], "nl_cn": "在传智的开发课堂上，希望您开发一款文档处理软件。\n\n给定 $T$ 组询问，每次给定 $2$ 个长度为 $n,m$ 的只含英文字母的字符串 $a,b$，求 $a$ 在 $b$ 中的出现次数，相同字符不区分大小写。注意 $a$ 是 $b$ 中连续子序列。\n\n对于所有数据，$T\\leq 100$，$\\sum n\\leq \\sum m\\leq 10^3$。字符串仅由大小或者小写的英文字母组成。", "test_cases": [{"input": "5\n3 10\nabc\nabcabcabca\n2 10\naa\nAAaAaaAaAa\n5 5\nAbCdE\neDcBa\n5 5\nabcde\nABCDE\n3 10\naba\nABaBaAbaBA", "output": "3\n9\n0\n1\n4"}, {"input": "3\n3 10\nabc\nabcabcabca\n2 10\naa\nAAaAaaAaAa\n5 5\nAbCdE\neDcBa\n", "output": "3\n9\n0"}, {"input": "1\n3 7\nabc\njhahjabc\n", "output": "1"}, {"input": "1\n2 2\nab\naa\n", "output": "0"}, {"input": "2\n3 6\nabc\njhahab\n4 8\nabcd\njhabijhg\n", "output": "0\n0"}, {"input": "1\n2 3\nab\ncd\n", "output": "0"}, {"input": "1\n5 5\nABCDE\nABCDE\n", "output": "1"}, {"input": "1\n5 10\nHELLO\nhellohello\n", "output": "2"}, {"input": "1\n5 9\nworld\nhelloworld\n", "output": "1"}, {"input": "1\n3 12\nbar\nfoobarfoobar\n", "output": "2"}, {"input": "1\n2 4\naa\naaaa\n", "output": "3"}, {"input": "1\n3 6\nabc\nabcabc\n", "output": "2"}, {"input": "1\n4 8\ndefg\nabcdefg\n", "output": "1"}, {"input": "1\n3 6\nxyz\nxyzxyz\n", "output": "2"}, {"input": "1\n5 9\nhello\nworldhello\n", "output": "1"}, {"input": "1\n4 7\ndefg\nabcdefgh\n", "output": "1"}, {"input": "1\n3 9\nbar\nbarfoobar\n", "output": "2"}, {"input": "1\n2 4\naa\nabbb\n", "output": "0"}, {"input": "1\n2 4\nab\naabb\n", "output": "1"}, {"input": "2\n8 14\nabcdefgh\naBcDefGhIjklM\n3 9\nabc\nABCabcABC\n", "output": "1\n3"}, {"input": "2\n8 14\nabcdefgh\nabcdefGhijklm\n3 9\nabc\nabcAbcABC\n", "output": "1\n3"}, {"input": "2\n8 14\nabcdefgh\naBcDefGhijKlm\n3 9\nabc\nABCABCabc\n", "output": "1\n3"}], "test": "#undef NDEBUG\n#include<assert.h>\nint main(){\n    assert(solution(\"5\\n3 10\\nabc\\nabcabcabca\\n2 10\\naa\\nAAaAaaAaAa\\n5 5\\nAbCdE\\neDcBa\\n5 5\\nabcde\\nABCDE\\n3 10\\naba\\nABaBaAbaBA\") == \"3\\n9\\n0\\n1\\n4\");\n    assert(solution(\"3\\n3 10\\nabc\\nabcabcabca\\n2 10\\naa\\nAAaAaaAaAa\\n5 5\\nAbCdE\\neDcBa\\n\") == \"3\\n9\\n0\");\n    assert(solution(\"1\\n3 7\\nabc\\njhahjabc\\n\") == \"1\");\n    assert(solution(\"1\\n2 2\\nab\\naa\\n\") == \"0\");\n    assert(solution(\"2\\n3 6\\nabc\\njhahab\\n4 8\\nabcd\\njhabijhg\\n\") == \"0\\n0\");\n    assert(solution(\"1\\n2 3\\nab\\ncd\\n\") == \"0\");\n    assert(solution(\"1\\n5 5\\nABCDE\\nABCDE\\n\") == \"1\");\n    assert(solution(\"1\\n5 10\\nHELLO\\nhellohello\\n\") == \"2\");\n    assert(solution(\"1\\n5 9\\nworld\\nhelloworld\\n\") == \"1\");\n    assert(solution(\"1\\n3 12\\nbar\\nfoobarfoobar\\n\") == \"2\");\n    assert(solution(\"1\\n2 4\\naa\\naaaa\\n\") == \"3\");\n    assert(solution(\"1\\n3 6\\nabc\\nabcabc\\n\") == \"2\");\n    assert(solution(\"1\\n4 8\\ndefg\\nabcdefg\\n\") == \"1\");\n    assert(solution(\"1\\n3 6\\nxyz\\nxyzxyz\\n\") == \"2\");\n    assert(solution(\"1\\n5 9\\nhello\\nworldhello\\n\") == \"1\");\n    assert(solution(\"1\\n4 7\\ndefg\\nabcdefgh\\n\") == \"1\");\n    assert(solution(\"1\\n3 9\\nbar\\nbarfoobar\\n\") == \"2\");\n    assert(solution(\"1\\n2 4\\naa\\nabbb\\n\") == \"0\");\n    assert(solution(\"1\\n2 4\\nab\\naabb\\n\") == \"1\");\n    assert(solution(\"2\\n8 14\\nabcdefgh\\naBcDefGhIjklM\\n3 9\\nabc\\nABCabcABC\\n\") == \"1\\n3\");\n    assert(solution(\"2\\n8 14\\nabcdefgh\\nabcdefGhijklm\\n3 9\\nabc\\nabcAbcABC\\n\") == \"1\\n3\");\n    assert(solution(\"2\\n8 14\\nabcdefgh\\naBcDefGhijKlm\\n3 9\\nabc\\nABCABCabc\\n\") == \"1\\n3\");\n    return 0; \n}", "prompt": "/*In the development classroom at Chuanzhi, we hope you can develop a document processing software.\n\nGiven T groups of inquiries, each time giving two strings a and b of length n and m, respectively, containing only English letters, find the number of occurrences of a in b, ignoring case sensitivity. Note that a is a contiguous subsequence of b.\n\nFor all data, T is less than or equal to 100, and the sum of n is less than or equal to the sum of m which is less than or equal to 1000. The strings are only composed of uppercase or lowercase English letters.\n\ninput_format:\nEnter a total of $3T+1$lines.\n\nEnter $1$as a positive integer $T$in line $1$.\n\nNext, a total of $T$groups of input, each group of input a total of $3$lines.\n\nEnter $2$as a positive integer $n,m$for line $1.\n\nFor line $2$, enter a string $a$of length $n$.\n\nFor line $3, enter a string $b$of length $m$.\n\noutput_format:\nOutput a total of $T$line, the first $i$output $1$integer, indicating the answer to the query $i$.\n*/\n\n#include<sstream>\n#include<stdlib.h>\n#include<algorithm>\n#include<math.h>\n#include<stdio.h>\n#include<vector>\n#include<string>\n#include<climits>\n#include<cstring>\n#include<iostream>\nusing namespace std;\n\n             \nstring solution(string std_in){\n    istringstream iss(std_in);\n             ", "constraints": "对于第一组输入，出现了 $3$ 次，分别是 `[abc]abcabca`，`abc[abc]abca`，`abcabc[abc]a`；\n\n对于第二组输入，出现了 $9$ 次，分别是 `[Aa]AaaAaAa`，`A[aA]aaAaAa`，`Aa[Aa]aAaAa`，`AaA[aa]AaAa`，`AaAa[aA]aAa`，`AaAaa[Aa]Aa`，`AaAaaA[aA]a`，`AaAaaA[aA]a`，`AaAaaAa[Aa]`。", "samples": [["5\n3 10\nabc\nabcabcabca\n2 10\naa\nAAaAaaAaAa\n5 5\nAbCdE\neDcBa\n5 5\nabcde\nABCDE\n3 10\naba\nABaBaAbaBA", "3\n9\n0\n1\n4"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072]}}
{"task_id": "P3090", "title": "[USACO13NOV]Empty Stalls G", "difficulty": "advanced", "nl": "Farmer John has a large circular barn consisting of N stalls (2 <= N <= 3,000,000), numbered 0..N-1, with stall N-1 adjacent to stall 0.\n\nEach evening, the cows return to the barn one by one, with each cow having a preferred stall it would like to occupy. However, if a cow's preferred stall is already occupied by another cow, she will sequentially scan forward from that stall until she finds the next unoccupied stall, at which point she will occupy it instead. If she scans all the way back to stall 0 without finding an unoccupied stall, she will scan forward again starting from stall 0.\n\nGiven the preferred stalls of each of the cows, determine the smallest unoccupied stall after all of the cows have returned to the barn. Note that the answer to this problem is independent of the order in which the cows return to the barn.\n\nTo avoid reading a large amount of input, the input format for this problem is streamlined. There are K lines of input, each in the form:\n\nX Y A B\n\nwhere X is the number of cows that like all of the stalls f(1),...,f(Y), where f(i) = (Ai + B) mod N. The values of A and B are between 0 and 1,000,000,000.\n\nNote that all problems have a standard memory limit of 64MB.", "code": "#include<bits/stdc++.h>\nusing namespace std;\nint n,k;\nlong long x,y,a,b;//注意数据范围，a*y是有可能爆int的\nint room[3333333];\nint p[3333333];\nint q[3333333];\nint main()\n{\n\tscanf(\"%d%d\",&n,&k);\n\tfor(int i=0;i<n-1;i++)p[i]=i+1;\n\tp[n-1]=0;//因为是环形的，所以最后一个房间最开始要指向第一个房间\n\tfor(int i=n-1;i>0;i--)q[i]=i-1;\n\tq[0]=n-1;//同上\n\tfor(int i=1;i<=k;i++)\n\t{\n\t\tscanf(\"%lld%lld%lld%lld\",&x,&y,&a,&b);\n\t\tfor(int j=1;j<=y;j++)\n\t\t{\n\t\t\tfor(int l=1;l<=x;l++)\n\t\t\t{\n\t\t\t\tint t=(j*a+b)%n;//不要忘记取模\n\t\t\t\twhile(room[t])//寻找下一个空房间\n\t\t\t\t{\n\t\t\t\t\tt=p[t];\n\t\t\t\t}\n\t\t\t\troom[t]=1;//住进这个房间\n\t\t\t\tp[q[t]]=p[t];\n\t\t\t\tq[p[t]]=q[t];//前后重新标记\n\t\t\t}\n\t\t}\n\t}\n\tfor(int i=0;i<n;i++)\n\t{\n\t\tif(!room[i])//寻找第一个空的房间\n\t\t{\n\t\t\tcout<<i;\n\t\t\treturn 0;\n\t\t}\n\t}\n\treturn 0;\n}", "step": ["Read input values n and k.", "For every query, read the values x, y, a and b.", "Update the array by adding x to (a*i + b) % n for i ranging from 1 to y.", "Carry over the excess values in the array by incrementing the next index.", "Return the index of the first element with a value of 0."], "nl_cn": "Farmer John's new barn consists of a huge circle of N stalls (2 <= N <= 3,000,000), numbered 0..N-1, with stall N-1 being adjacent to stall 0.\n\nAt the end of each day, FJ's cows arrive back at the barn one by one, each with a preferred stall they would like to occupy.  However, if a cow's preferred stall is already occupied by another cow, she scans forward sequentially from this stall until she finds the first unoccupied stall, which she then claims.  If she scans past stall N-1, she continues scanning from stall 0.\n\nGiven the preferred stall of each cow, please determine the smallest index of a stall that remains unoccupied after all the cows have returned to the barn.  Notice that the answer to this question does not depend on the order in which the cows return to the barn.\n\nIn order to avoid issues with reading huge amounts of input, the input to this problem is specified in a concise format using K lines (1 <= K <= 10,000) each of the form:\n\nX Y A B\n\nOne of these lines specifies the preferred stall for XY total cows: X cows prefer each of the stalls f(1) .. f(Y), where f(i) = (Ai + B) mod N.  The values of A and B lie in the range 0...1,000,000,000.\n\nDo not forget the standard memory limit of 64MB for all problems.\n\n约翰的谷仓中有N(2 <= N <=3,000,000)个房间，编号0到N-1，这些房间排布成环状,编号0的和编号N-1的相邻。\n\n每天傍晚，奶牛们一只一只排队回到谷仓，每头奶牛都有一个喜欢的房间，但是，如果它喜欢的房间已被其他奶牛占了，它会向前挨个探索其他房间（如果它探索过了N-1号房间，它会继续探索0号房间，以此继续下去）直到探到第一个没有被占用的房间，这时它会宣布占用这个房间。\n\n告诉你每头奶牛喜欢的房间，当所有奶牛都找到房间后，剩下的没被占用的房间中，编号最小的是哪个。很明显，问题的答案与奶牛进入谷仓的顺序无关。\n\n\n为避免输入内容过多。本题的输入数据采用一种简洁的方式：一共K(1 <= K <=10,000)行，每行格式如下：\n\nX Y A B\n\n表示有Y批奶牛，每批X头，也就是总共X\\*Y只奶牛喜欢的房间号。Y批奶牛编号1到Y，第i批X头奶牛喜欢的房间号为(A\\*i+B) Mod N.\n\nA和B的取值范围为0...1,000,000,000\n\n注意，只有64M的空间。\n", "test_cases": [{"input": "10 3 \n3 2 2 4 \n2 1 0 1 \n1 1 1 7 \n", "output": "5"}, {"input": "10 3\n3 2 2 4\n2 1 0 1\n1 1 1 7\n", "output": "5"}, {"input": "20 4\n2 1 1 1\n4 2 0 0\n3 2 2 4\n1 1 1 7\n", "output": "17"}], "test": "#undef NDEBUG\n#include<assert.h>\nint main(){\n    assert(solution(\"10 3 \\n3 2 2 4 \\n2 1 0 1 \\n1 1 1 7 \\n\") == \"5\");\n    assert(solution(\"10 3\\n3 2 2 4\\n2 1 0 1\\n1 1 1 7\\n\") == \"5\");\n    assert(solution(\"20 4\\n2 1 1 1\\n4 2 0 0\\n3 2 2 4\\n1 1 1 7\\n\") == \"17\");\n    return 0; \n}", "prompt": "/*Farmer John has a large circular barn consisting of N stalls (2 <= N <= 3,000,000), numbered 0..N-1, with stall N-1 adjacent to stall 0.\n\nEach evening, the cows return to the barn one by one, with each cow having a preferred stall it would like to occupy. However, if a cow's preferred stall is already occupied by another cow, she will sequentially scan forward from that stall until she finds the next unoccupied stall, at which point she will occupy it instead. If she scans all the way back to stall 0 without finding an unoccupied stall, she will scan forward again starting from stall 0.\n\nGiven the preferred stalls of each of the cows, determine the smallest unoccupied stall after all of the cows have returned to the barn. Note that the answer to this problem is independent of the order in which the cows return to the barn.\n\nTo avoid reading a large amount of input, the input format for this problem is streamlined. There are K lines of input, each in the form:\n\nX Y A B\n\nwhere X is the number of cows that like all of the stalls f(1),...,f(Y), where f(i) = (Ai + B) mod N. The values of A and B are between 0 and 1,000,000,000.\n\nNote that all problems have a standard memory limit of 64MB.\n\ninput_format:\n\\* Line 1: Two space-separated integers: N and K.\n\n\\* Lines 2.. 1+K: Each line contains integers X Y A B, interpreted as above.  The total number of cows specified by all these lines will be at most N-1.  Cows can be added to the same stall by several of these lines.\n\noutput_format:\n\\* Line 1: The minimum index of an unoccupied stall.\n*/\n\n#include<sstream>\n#include<stdlib.h>\n#include<algorithm>\n#include<math.h>\n#include<stdio.h>\n#include<vector>\n#include<string>\n#include<climits>\n#include<cstring>\n#include<iostream>\nusing namespace std;\n\n             \nstring solution(string std_in){\n    istringstream iss(std_in);\n             ", "constraints": "There are 10 stalls in the barn, numbered 0..9.  The second line of input states that 3 cows prefer stall (2\\*1+4) mod 10 = 6, and 3 cows prefer stall (2\\*2+4) mod 10 = 8.  The third line states that 2 cows prefer stall (0\\*1+1) mod 10 = 1.  Line four specifies that 1 cow prefers stall (1\\*1+7) mod 10 = 8 (so a total of 4 cows prefer this stall).\n\n\nAll stalls will end up occupied except stall 5. \n\n", "samples": [["10 3 \n3 2 2 4 \n2 1 0 1 \n1 1 1 7 \n", "5 \n"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}}
{"task_id": "P8722", "title": "[蓝桥杯 2020 省 AB3] 日期识别", "difficulty": "basic", "nl": "Blue needs to process a large amount of data, some of which are dates.\n\nThere are two common formats for the dates processed by Blue: English format and numeric format.\n\nThe English format uses the first three letters of the English name of each month as the month identifier, followed by two digits indicating the date. The first letter of the month identifier is capitalized, and the rest are lowercase. If the date is less than 10, there should be a leading zero. The first three letters of the English name of the months from January to December are `Jan`, `Feb`, `Mar`, `Apr`, `May`, `Jun`, `Jul`, `Aug`, `Sep`, `Oct`, `Nov`, and `Dec`, respectively.\n\nThe numeric format is represented by two integers separated by a space, without any leading zeros. The first integer represents the month from 1 to 12.\n\nGiven a date in English format, please output it in numeric format.", "code": "#include<bits/stdc++.h>\nusing namespace std;\nstring a[12]={\"Jan\",\"Feb\",\"Mar\",\"Apr\",\"May\",\"Jun\",\"Jul\",\"Aug\",\"Sep\",\"Oct\",\"Nov\",\"Dec\"};\nint main()\n{\n    int m=0,d=0;\n    string st,month=\"\";\n    cin>>st;\n    month=st.substr(0,3);\n    for(int i=0;i<12;i++){\n\t\tif(month==a[i]){\n\t\t\tm=i+1;\n\t\t\tbreak;\n\t\t}\n    }\n    d=int(st[3]-48)*10+int(st[4]-48);\n    cout<<m<<' '<<d;\n}", "step": ["Read in the input string using cin.", "Determine the month by looking at the first one or two characters of the input string.", "Determine the day by converting the last two characters of the input string to an integer.", "Output the numerical values of the month and day using cout."], "nl_cn": "小蓝要处理非常多的数据, 其中有一些数据是日期。\n\n在小蓝处理的日期中有两种常用的形式：英文形式和数字形式。\n\n英文形式采用每个月的英文的前三个字母作为月份标识，后面跟两位数字表示日期，月份标识第一个字母大写，后两个字母小写, 日期小于 $10$ 时要补前导 $0$。$1$ 月到 $12$ 月英文的前三个字母分别是 `Jan`、`Feb`、`Mar`、`Apr`、`May`、`Jun`、`Jul`、`Aug`、`Sep`、`Oct`、`Nov`、`Dec`。\n\n数字形式直接用两个整数表达，中间用一个空格分隔，两个整数都不写前 导 `0`。其中月份用 $1$ 至 $12$ 分别表示 $1$ 月到 $12$ 月。\n\n输入一个日期的英文形式, 请输出它的数字形式。", "test_cases": [{"input": "Feb08", "output": "2 8"}, {"input": "Oct18", "output": "10 18"}, {"input": "Jan01\n", "output": "1 1"}, {"input": "Mar30\n", "output": "3 30"}, {"input": "May12\n", "output": "5 12"}, {"input": "Jul04\n", "output": "7 4"}, {"input": "Sep15\n", "output": "9 15"}, {"input": "Nov25\n", "output": "11 25"}, {"input": "Dec31\n", "output": "12 31"}, {"input": "Jan09\n", "output": "1 9"}, {"input": "Feb15\n", "output": "2 15"}, {"input": "Mar20\n", "output": "3 20"}, {"input": "Apr01\n", "output": "4 1"}, {"input": "May31\n", "output": "5 31"}, {"input": "Jun10\n", "output": "6 10"}, {"input": "Jul25\n", "output": "7 25"}, {"input": "Aug14\n", "output": "8 14"}, {"input": "Sep30\n", "output": "9 30"}, {"input": "Oct05\n", "output": "10 5"}, {"input": "Nov11\n", "output": "11 11"}, {"input": "Dec24\n", "output": "12 24"}, {"input": "Jun30\n", "output": "6 30"}, {"input": "Mar29", "output": "3 29"}, {"input": "Aug31", "output": "8 31"}, {"input": "Dec25", "output": "12 25"}, {"input": "Apr06", "output": "4 6"}, {"input": "Jun15", "output": "6 15"}, {"input": "Sep22", "output": "9 22"}, {"input": "Jan29", "output": "1 29"}, {"input": "Mar10", "output": "3 10"}, {"input": "May23", "output": "5 23"}, {"input": "Aug07", "output": "8 7"}, {"input": "Apr14", "output": "4 14"}, {"input": "Jun26", "output": "6 26"}, {"input": "Jul18", "output": "7 18"}, {"input": "Sep09", "output": "9 9"}, {"input": "Nov30", "output": "11 30"}, {"input": "Mar31", "output": "3 31"}, {"input": "May10", "output": "5 10"}, {"input": "Sep20", "output": "9 20"}, {"input": "Feb29", "output": "2 29"}, {"input": "Apr15", "output": "4 15"}, {"input": "Oct30", "output": "10 30"}, {"input": "Jan31", "output": "1 31"}, {"input": "Mar11", "output": "3 11"}, {"input": "Dec01", "output": "12 1"}, {"input": "Jun23", "output": "6 23"}, {"input": "Nov05", "output": "11 5"}, {"input": "Apr02", "output": "4 2"}, {"input": "Oct19", "output": "10 19"}, {"input": "Jul30", "output": "7 30"}, {"input": "Sep10", "output": "9 10"}, {"input": "Mar12\n", "output": "3 12"}, {"input": "Dec03\n", "output": "12 3"}, {"input": "Apr30\n", "output": "4 30"}, {"input": "May09\n", "output": "5 9"}, {"input": "Jun20\n", "output": "6 20"}, {"input": "Jul31\n", "output": "7 31"}, {"input": "Aug25\n", "output": "8 25"}, {"input": "Sep13\n", "output": "9 13"}, {"input": "Nov16\n", "output": "11 16"}, {"input": "Oct22\n", "output": "10 22"}, {"input": "Jan28\n", "output": "1 28"}, {"input": "Mar07\n", "output": "3 7"}, {"input": "May14\n", "output": "5 14"}, {"input": "Jun29\n", "output": "6 29"}, {"input": "Aug17\n", "output": "8 17"}, {"input": "Aug13\n", "output": "8 13"}, {"input": "Jun12\n", "output": "6 12"}, {"input": "Mar05\n", "output": "3 5"}, {"input": "Aug05\n", "output": "8 5"}, {"input": "May01\n", "output": "5 1"}, {"input": "Jan19\n", "output": "1 19"}], "test": "#undef NDEBUG\n#include<assert.h>\nint main(){\n    assert(solution(\"Feb08\") == \"2 8\");\n    assert(solution(\"Oct18\") == \"10 18\");\n    assert(solution(\"Jan01\\n\") == \"1 1\");\n    assert(solution(\"Mar30\\n\") == \"3 30\");\n    assert(solution(\"May12\\n\") == \"5 12\");\n    assert(solution(\"Jul04\\n\") == \"7 4\");\n    assert(solution(\"Sep15\\n\") == \"9 15\");\n    assert(solution(\"Nov25\\n\") == \"11 25\");\n    assert(solution(\"Dec31\\n\") == \"12 31\");\n    assert(solution(\"Jan09\\n\") == \"1 9\");\n    assert(solution(\"Feb15\\n\") == \"2 15\");\n    assert(solution(\"Mar20\\n\") == \"3 20\");\n    assert(solution(\"Apr01\\n\") == \"4 1\");\n    assert(solution(\"May31\\n\") == \"5 31\");\n    assert(solution(\"Jun10\\n\") == \"6 10\");\n    assert(solution(\"Jul25\\n\") == \"7 25\");\n    assert(solution(\"Aug14\\n\") == \"8 14\");\n    assert(solution(\"Sep30\\n\") == \"9 30\");\n    assert(solution(\"Oct05\\n\") == \"10 5\");\n    assert(solution(\"Nov11\\n\") == \"11 11\");\n    assert(solution(\"Dec24\\n\") == \"12 24\");\n    assert(solution(\"Jun30\\n\") == \"6 30\");\n    assert(solution(\"Mar29\") == \"3 29\");\n    assert(solution(\"Aug31\") == \"8 31\");\n    assert(solution(\"Dec25\") == \"12 25\");\n    assert(solution(\"Apr06\") == \"4 6\");\n    assert(solution(\"Jun15\") == \"6 15\");\n    assert(solution(\"Sep22\") == \"9 22\");\n    assert(solution(\"Jan29\") == \"1 29\");\n    assert(solution(\"Mar10\") == \"3 10\");\n    assert(solution(\"May23\") == \"5 23\");\n    assert(solution(\"Aug07\") == \"8 7\");\n    assert(solution(\"Apr14\") == \"4 14\");\n    assert(solution(\"Jun26\") == \"6 26\");\n    assert(solution(\"Jul18\") == \"7 18\");\n    assert(solution(\"Sep09\") == \"9 9\");\n    assert(solution(\"Nov30\") == \"11 30\");\n    assert(solution(\"Mar31\") == \"3 31\");\n    assert(solution(\"May10\") == \"5 10\");\n    assert(solution(\"Sep20\") == \"9 20\");\n    assert(solution(\"Feb29\") == \"2 29\");\n    assert(solution(\"Apr15\") == \"4 15\");\n    assert(solution(\"Oct30\") == \"10 30\");\n    assert(solution(\"Jan31\") == \"1 31\");\n    assert(solution(\"Mar11\") == \"3 11\");\n    assert(solution(\"Dec01\") == \"12 1\");\n    assert(solution(\"Jun23\") == \"6 23\");\n    assert(solution(\"Nov05\") == \"11 5\");\n    assert(solution(\"Apr02\") == \"4 2\");\n    assert(solution(\"Oct19\") == \"10 19\");\n    assert(solution(\"Jul30\") == \"7 30\");\n    assert(solution(\"Sep10\") == \"9 10\");\n    assert(solution(\"Mar12\\n\") == \"3 12\");\n    assert(solution(\"Dec03\\n\") == \"12 3\");\n    assert(solution(\"Apr30\\n\") == \"4 30\");\n    assert(solution(\"May09\\n\") == \"5 9\");\n    assert(solution(\"Jun20\\n\") == \"6 20\");\n    assert(solution(\"Jul31\\n\") == \"7 31\");\n    assert(solution(\"Aug25\\n\") == \"8 25\");\n    assert(solution(\"Sep13\\n\") == \"9 13\");\n    assert(solution(\"Nov16\\n\") == \"11 16\");\n    assert(solution(\"Oct22\\n\") == \"10 22\");\n    assert(solution(\"Jan28\\n\") == \"1 28\");\n    assert(solution(\"Mar07\\n\") == \"3 7\");\n    assert(solution(\"May14\\n\") == \"5 14\");\n    assert(solution(\"Jun29\\n\") == \"6 29\");\n    assert(solution(\"Aug17\\n\") == \"8 17\");\n    assert(solution(\"Aug13\\n\") == \"8 13\");\n    assert(solution(\"Jun12\\n\") == \"6 12\");\n    assert(solution(\"Mar05\\n\") == \"3 5\");\n    assert(solution(\"Aug05\\n\") == \"8 5\");\n    assert(solution(\"May01\\n\") == \"5 1\");\n    assert(solution(\"Jan19\\n\") == \"1 19\");\n    return 0; \n}", "prompt": "/*Blue needs to process a large amount of data, some of which are dates.\n\nThere are two common formats for the dates processed by Blue: English format and numeric format.\n\nThe English format uses the first three letters of the English name of each month as the month identifier, followed by two digits indicating the date. The first letter of the month identifier is capitalized, and the rest are lowercase. If the date is less than 10, there should be a leading zero. The first three letters of the English name of the months from January to December are `Jan`, `Feb`, `Mar`, `Apr`, `May`, `Jun`, `Jul`, `Aug`, `Sep`, `Oct`, `Nov`, and `Dec`, respectively.\n\nThe numeric format is represented by two integers separated by a space, without any leading zeros. The first integer represents the month from 1 to 12.\n\nGiven a date in English format, please output it in numeric format.\n\ninput_format:\nEnter a date in English.\n\noutput_format:\nThe output line contains two integers representing the month and day of the date.\n*/\n\n#include<sstream>\n#include<stdlib.h>\n#include<algorithm>\n#include<math.h>\n#include<stdio.h>\n#include<vector>\n#include<string>\n#include<climits>\n#include<cstring>\n#include<iostream>\nusing namespace std;\n\n             \nstring solution(string std_in){\n    istringstream iss(std_in);\n             ", "constraints": "蓝桥杯 2020 第三轮省赛 AB 组 F 题。", "samples": [["Feb08", "2 8"], ["Oct18", "10 18"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072]}}
{"task_id": "P6489", "title": "[COCI2010-2011#6] USPON", "difficulty": "basic", "nl": "The mountain road he walked can be regarded as a digital sequence of length $n$, where $P_i$ represents the height of position $i$.\n\nA continuous mountain road that goes from low to high with strictly increasing heights is called a climbing.\n\nIn order to exercise, he wants to walk a climbing with the largest possible drop.\n\nThe drop of a mountain road is defined as the difference between the end point and the starting point of this road.\n\nYou need to find out the maximum drop he can achieve by walking a mountain road.", "code": "#include<bits/stdc++.h>\nusing namespace std;\ninline int read(){\n\tint x=0,f=1;char c=getchar();\n\twhile(c<'0'||c>'9'){if(c=='-')f=-1;c=getchar();}\n\twhile(c>='0'&&c<='9'){x=(x<<1)+(x<<3)+(c^48);c=getchar();}\n\treturn x*f;\n}\nint n,a[1005],ans;\nint main(){\n\tn=read();\n\tfor(int i=1;i<=n;i++)a[i]=read();\n\tfor(int i=2,j=1;i<=n;i++)//j表示该连续子序列的第一项 \n\t    if(a[i]<=a[i-1])ans=max(ans,a[i-1]-a[j]),j=i;//当该数不大于上一个数 ，说明上一个数是当前连续子序列的最后一项，而该数是下一个连续子序列的第一项 \n\t    else if(i==n)ans=max(ans,a[i]-a[j]);//特判，当i==n时，再统计一次，否则会忽略最后一段连续子序列的值 \n\tprintf(\"%d\\n\",ans);\n\treturn 0;\n}", "step": ["Read input integer n.", "Read n integers and store them in array a.", "Initialize variables i=2, j=1, ans=0.", "If a[i]<=a[i-1], update ans=max(ans,a[i-1]-a[j]) and set j=i.", "If i==n, update ans=max(ans,a[i]-a[j]).", "Print ans."], "nl_cn": "他所走的山路可以看做一个长度为 $n$ 的数字序列 $P_i$，$P_i$ 表示位置 $i$ 的高度为 $P_i$。\n\n从低处往高处走一段**连续的高度严格递增的**山路称为一次爬升。\n\n为了锻炼身体，他想走一段落差尽量大的爬升。\n\n一段山路的落差定义为这段山路的结束点与起始点的差。\n\n你需要求出他走一段山路所能达到最大的落差是多少。", "test_cases": [{"input": "5\n1 2 1 4 6", "output": "5"}, {"input": "8\n12 20 1 3 4 4 11 1", "output": "8"}, {"input": "6\n10 8 8 6 4 3", "output": "0"}, {"input": "3\n1 2 3\n", "output": "2"}, {"input": "4\n10 9 8 7\n", "output": "0"}, {"input": "4\n3 2 1 4\n", "output": "3"}, {"input": "6\n5 4 5 3 2 1\n", "output": "1"}, {"input": "2\n5 5\n", "output": "0"}, {"input": "1\n10\n", "output": "0"}, {"input": "10\n1 2 3 4 5 6 7 8 9 10\n", "output": "9"}, {"input": "7\n1 1 2 3 2 1 1\n", "output": "2"}, {"input": "9\n7 5 2 4 6 8 7 3 1\n", "output": "6"}, {"input": "5\n3 2 3 2 3\n", "output": "1"}, {"input": "6\n2 4 6 8 10 12\n", "output": "10"}, {"input": "3\n6 4 2\n", "output": "0"}, {"input": "4\n1 2 3 4\n", "output": "3"}, {"input": "5\n5 4 3 2 1\n", "output": "0"}, {"input": "8\n1 2 3 2 1 4 3 2\n", "output": "3"}, {"input": "6\n1 2 3 4 3 2\n", "output": "3"}, {"input": "4\n1 2 3 2\n", "output": "2"}, {"input": "1\n1", "output": "0"}, {"input": "2\n1 2", "output": "1"}, {"input": "3\n2 1 3", "output": "2"}, {"input": "6\n1 2 3 1 2 3", "output": "2"}, {"input": "8\n10 10 10 10 10 10 10 10", "output": "0"}, {"input": "9\n5 5 5 6 5 5 5 5 5", "output": "1"}, {"input": "30\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 19 18 17 16 15 14 13 12 11 10", "output": "19"}, {"input": "50\n10 9 8 7 6 5 4 3 2 1 1 2 3 4 5 6 7 8 9 10 1 2 3 4 5 6 7 8 9 10 1 2 3 4 5 6 7 8 9 10 1 2 3 4 5 6 7 8 9 10", "output": "9"}, {"input": "100\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100", "output": "99"}, {"input": "100\n100 99 98 97 96 95 94 93 92 91 90 89 88 87 86 85 84 83 82 81 80 79 78 77 76 75 74 73 72 71 70 69 68 67 66 65 64 63 62 61 60 59 58 57 56 55 54 53 52 51 50 49 48 47 46 45 44 43 42 41 40 39 38 37 36 35 34 33 32 31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10 9 8 7 6 5 4 3 2 1", "output": "0"}, {"input": "4\n1 1 1 1\n", "output": "0"}, {"input": "3\n10 20 30\n", "output": "20"}, {"input": "7\n100 90 80 70 60 50 40\n", "output": "0"}, {"input": "6\n15 12 17 21 15 10\n", "output": "9"}, {"input": "3\n5 3 7\n", "output": "4"}, {"input": "5\n10 8 6 5 3\n", "output": "0"}, {"input": "5\n2 3 4 6 3\n", "output": "4"}, {"input": "8\n8 12 10 15 11 16 9 18\n", "output": "9"}, {"input": "1\n5\n", "output": "0"}, {"input": "4\n4 3 2 1\n", "output": "0"}, {"input": "2\n7 6\n", "output": "0"}, {"input": "6\n4 1 5 7 2 3\n", "output": "6"}, {"input": "7\n1 2 3 4 5 6 7\n", "output": "6"}, {"input": "3\n5 3 1\n", "output": "0"}, {"input": "4\n3 5 8 2\n", "output": "5"}, {"input": "6\n9 5 3 7 2 6\n", "output": "4"}, {"input": "5\n1 6 4 2 5\n", "output": "5"}, {"input": "4\n10 9 7 1\n", "output": "0"}, {"input": "3\n1 1 1\n", "output": "0"}, {"input": "4\n5 4 3 2\n", "output": "0"}, {"input": "7\n10 20 30 40 50 60 70\n", "output": "60"}, {"input": "6\n6 5 4 5 6 5\n", "output": "2"}, {"input": "4\n10 8 6 4\n", "output": "0"}, {"input": "8\n5 4 4 7 7 5 6 7\n", "output": "3"}, {"input": "3\n7 9 5\n", "output": "2"}, {"input": "5\n5 5 5 10 15\n", "output": "10"}, {"input": "6\n2 5 4 3 6 7\n", "output": "4"}, {"input": "4\n100 80 70 50\n", "output": "0"}], "test": "#undef NDEBUG\n#include<assert.h>\nint main(){\n    assert(solution(\"5\\n1 2 1 4 6\") == \"5\");\n    assert(solution(\"8\\n12 20 1 3 4 4 11 1\") == \"8\");\n    assert(solution(\"6\\n10 8 8 6 4 3\") == \"0\");\n    assert(solution(\"3\\n1 2 3\\n\") == \"2\");\n    assert(solution(\"4\\n10 9 8 7\\n\") == \"0\");\n    assert(solution(\"4\\n3 2 1 4\\n\") == \"3\");\n    assert(solution(\"6\\n5 4 5 3 2 1\\n\") == \"1\");\n    assert(solution(\"2\\n5 5\\n\") == \"0\");\n    assert(solution(\"1\\n10\\n\") == \"0\");\n    assert(solution(\"10\\n1 2 3 4 5 6 7 8 9 10\\n\") == \"9\");\n    assert(solution(\"7\\n1 1 2 3 2 1 1\\n\") == \"2\");\n    assert(solution(\"9\\n7 5 2 4 6 8 7 3 1\\n\") == \"6\");\n    assert(solution(\"5\\n3 2 3 2 3\\n\") == \"1\");\n    assert(solution(\"6\\n2 4 6 8 10 12\\n\") == \"10\");\n    assert(solution(\"3\\n6 4 2\\n\") == \"0\");\n    assert(solution(\"4\\n1 2 3 4\\n\") == \"3\");\n    assert(solution(\"5\\n5 4 3 2 1\\n\") == \"0\");\n    assert(solution(\"8\\n1 2 3 2 1 4 3 2\\n\") == \"3\");\n    assert(solution(\"6\\n1 2 3 4 3 2\\n\") == \"3\");\n    assert(solution(\"4\\n1 2 3 2\\n\") == \"2\");\n    assert(solution(\"1\\n1\") == \"0\");\n    assert(solution(\"2\\n1 2\") == \"1\");\n    assert(solution(\"3\\n2 1 3\") == \"2\");\n    assert(solution(\"6\\n1 2 3 1 2 3\") == \"2\");\n    assert(solution(\"8\\n10 10 10 10 10 10 10 10\") == \"0\");\n    assert(solution(\"9\\n5 5 5 6 5 5 5 5 5\") == \"1\");\n    assert(solution(\"30\\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 19 18 17 16 15 14 13 12 11 10\") == \"19\");\n    assert(solution(\"50\\n10 9 8 7 6 5 4 3 2 1 1 2 3 4 5 6 7 8 9 10 1 2 3 4 5 6 7 8 9 10 1 2 3 4 5 6 7 8 9 10 1 2 3 4 5 6 7 8 9 10\") == \"9\");\n    assert(solution(\"100\\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100\") == \"99\");\n    assert(solution(\"100\\n100 99 98 97 96 95 94 93 92 91 90 89 88 87 86 85 84 83 82 81 80 79 78 77 76 75 74 73 72 71 70 69 68 67 66 65 64 63 62 61 60 59 58 57 56 55 54 53 52 51 50 49 48 47 46 45 44 43 42 41 40 39 38 37 36 35 34 33 32 31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10 9 8 7 6 5 4 3 2 1\") == \"0\");\n    assert(solution(\"4\\n1 1 1 1\\n\") == \"0\");\n    assert(solution(\"3\\n10 20 30\\n\") == \"20\");\n    assert(solution(\"7\\n100 90 80 70 60 50 40\\n\") == \"0\");\n    assert(solution(\"6\\n15 12 17 21 15 10\\n\") == \"9\");\n    assert(solution(\"3\\n5 3 7\\n\") == \"4\");\n    assert(solution(\"5\\n10 8 6 5 3\\n\") == \"0\");\n    assert(solution(\"5\\n2 3 4 6 3\\n\") == \"4\");\n    assert(solution(\"8\\n8 12 10 15 11 16 9 18\\n\") == \"9\");\n    assert(solution(\"1\\n5\\n\") == \"0\");\n    assert(solution(\"4\\n4 3 2 1\\n\") == \"0\");\n    assert(solution(\"2\\n7 6\\n\") == \"0\");\n    assert(solution(\"6\\n4 1 5 7 2 3\\n\") == \"6\");\n    assert(solution(\"7\\n1 2 3 4 5 6 7\\n\") == \"6\");\n    assert(solution(\"3\\n5 3 1\\n\") == \"0\");\n    assert(solution(\"4\\n3 5 8 2\\n\") == \"5\");\n    assert(solution(\"6\\n9 5 3 7 2 6\\n\") == \"4\");\n    assert(solution(\"5\\n1 6 4 2 5\\n\") == \"5\");\n    assert(solution(\"4\\n10 9 7 1\\n\") == \"0\");\n    assert(solution(\"3\\n1 1 1\\n\") == \"0\");\n    assert(solution(\"4\\n5 4 3 2\\n\") == \"0\");\n    assert(solution(\"7\\n10 20 30 40 50 60 70\\n\") == \"60\");\n    assert(solution(\"6\\n6 5 4 5 6 5\\n\") == \"2\");\n    assert(solution(\"4\\n10 8 6 4\\n\") == \"0\");\n    assert(solution(\"8\\n5 4 4 7 7 5 6 7\\n\") == \"3\");\n    assert(solution(\"3\\n7 9 5\\n\") == \"2\");\n    assert(solution(\"5\\n5 5 5 10 15\\n\") == \"10\");\n    assert(solution(\"6\\n2 5 4 3 6 7\\n\") == \"4\");\n    assert(solution(\"4\\n100 80 70 50\\n\") == \"0\");\n    return 0; \n}", "prompt": "/*The mountain road he walked can be regarded as a digital sequence of length $n$, where $P_i$ represents the height of position $i$.\n\nA continuous mountain road that goes from low to high with strictly increasing heights is called a climbing.\n\nIn order to exercise, he wants to walk a climbing with the largest possible drop.\n\nThe drop of a mountain road is defined as the difference between the end point and the starting point of this road.\n\nYou need to find out the maximum drop he can achieve by walking a mountain road.\n\ninput_format:\nEnter an integer $n$on the first line to indicate the length of the mountain path.\n\nThe second row of $n$has an integer $P_i$, indicating that the height of the location $i$is $P_i$.\n\noutput_format:\nOutput a line of an integer, representing the maximum drop.\n\nIf the entire mountain path does not contain any climb, the output '0'.\n*/\n\n#include<sstream>\n#include<stdlib.h>\n#include<algorithm>\n#include<math.h>\n#include<stdio.h>\n#include<vector>\n#include<string>\n#include<climits>\n#include<cstring>\n#include<iostream>\nusing namespace std;\n\n             \nstring solution(string std_in){\n    istringstream iss(std_in);\n             ", "constraints": "#### 数据规模与约定\n\n对于 $100\\%$ 的数据，保证 $1\\le n\\le 1000$，$1\\le P_i\\le 1000$。\n\n#### 说明\n\n**题目译自 [COCI2010-2011](https://hsin.hr/coci/archive/2010_2011/) [CONTEST #6](https://hsin.hr/coci/archive/2010_2011/contest6_tasks.pdf) *T2 USPON***。", "samples": [["5\n1 2 1 4 6", "5"], ["8\n12 20 1 3 4 4 11 1", "8"], ["6\n10 8 8 6 4 3", "0"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [32768, 32768, 32768, 32768, 32768, 32768, 32768, 32768, 32768, 32768]}}
{"task_id": "P6833", "title": "[Cnoi2020]雷雨", "difficulty": "challenge", "nl": "The cross-sectional view of Gensokyo can be abstracted as an $n \\times m$ rectangular grid.\n\nEach $1 \\times 1$ cell $(i,j)$ has a resistance measurement value $R_{i,j}$.\n\nLightning strikes from the thundercloud at $\\texttt{O}(n,a)$ and hits the Scarlet Devil Mansion at $\\texttt{A}(1,b)$ and the Bamboo Forest of the Lost at $\\texttt{B}(1,c)$ on the ground.\n\nAs lightning is a natural creation, the sum of resistance measurement values in the covered area is minimized, i.e., the sum of resistance measurement values of the union of the two paths from $\\texttt{O}$ to $\\texttt{A}$ and $\\texttt{B}$ is minimized.\n\nGiven the resistance measurement values for all cells, Cirno wants to know the minimum sum of resistance measurement values of the path taken by lightning.", "code": "#include<cstdio>\n#include<algorithm>\n#include<queue>\nusing namespace std;\nstruct node\n{\n\tlong long x,y,dis;\n\tbool operator <(const node &b)const\n\t{\n\t\treturn dis>b.dis;\n\t}\n};\nlong long num[1001][1001],dis[3][1001][1001];\nint n,m,a,b,c,dx[4]={-1,1,0,0},dy[4]={0,0,-1,1};\nvoid dijkstra(int k,int sx,int sy)\n{\n\tpriority_queue<node> q;\n\tq.push((node){sx,sy,num[sx][sy]});\n\tbool vis[1001][1001]={0};\n\tfor(int i=1;i<=1000;i++)\n\t{\n\t\tfor(int j=1;j<=1000;j++)\n\t\t{\n\t\t\tdis[k][i][j]=1e18;\n\t\t}\n\t}\n\tdis[k][sx][sy]=num[sx][sy];\n\twhile(!q.empty())\n\t{\n\t\tint x=q.top().x,y=q.top().y;\n\t\tq.pop();\n\t\tif(vis[x][y])\n\t\t{\n\t\t\tcontinue;\n\t\t}\n\t\tvis[x][y]=1;\n\t\tfor(int i=0;i<4;i++)\n\t\t{\n\t\t\tint tx=x+dx[i],ty=y+dy[i];\n\t\t\tif(tx<1||tx>n||ty<1||ty>m)\n\t\t\t{\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif(dis[k][tx][ty]>dis[k][x][y]+num[tx][ty])\n\t\t\t{\n\t\t\t\tdis[k][tx][ty]=dis[k][x][y]+num[tx][ty];\n\t\t\t\tq.push((node){tx,ty,dis[k][tx][ty]});\n\t\t\t}\n\t\t}\n\t}\n}\nint main()\n{\n\tscanf(\"%d%d%d%d%d\",&n,&m,&a,&b,&c);\n\tfor(int i=1;i<=n;i++)\n\t{\n\t\tfor(int j=1;j<=m;j++)\n\t\t{\n\t\t\tscanf(\"%lld\",&num[i][j]);\n\t\t}\n\t}\n\tdijkstra(0,1,a);\n\tdijkstra(1,n,b);\n\tdijkstra(2,n,c);\n\tlong long ans=1e18;\n\tfor(int i=1;i<=n;i++)\n\t{\n\t\tfor(int j=1;j<=n;j++)\n\t\t{\n\t\t\tans=min(ans,dis[0][i][j]+dis[1][i][j]+dis[2][i][j]-2*num[i][j]);//注意这里交叉点的部分会多算两次，所以要减掉\n\t\t}\n\t}\n\tprintf(\"%lld\",ans);\n    return 0;\n}", "step": ["Initialize the input values of n, m, and 3 variables: a, b, and c.", "Read the values from the input.", "Call the dijkstra function thrice with different values of starting vertices to obtain shortest distance in an undirected graph.", "Calculate the total distance in the vector and store the minimum distance in 'ans'.", "Output the obtained value of ans."], "nl_cn": "幻想乡的纵切面可以抽象成一个 $n\\times m$ 的矩形。\n\n其中每一个 $1\\times 1$ 的单元格 $(i,j)$ 都有一个**电阻计量值**(虚构的概念) $R_{i,j}$。\n\n闪电从**雷雨云**上的 $\\texttt{O}(n,a)$ 发出，击中了**地面**上的*红魔馆* $\\texttt{A}(1,b)$ 与*迷途竹林* $\\texttt{B}(1,c)$。\n\n雷电是自然的造物，所以覆盖的位置电阻计量值总和最小，即从 $\\texttt{O}$ 到 $\\texttt{A}$ 与 $\\texttt{B}$ 的**两条路径的并集**的电阻计量值的和最小。\n\n所以在所有位置电阻计量已知的情况下，Cirno 想知道雷电的经过的路径的最小电阻计量值的和。", "test_cases": [{"input": "5 5 1 2 4\n1 8 1 6 6\n1 1 1 2 4\n8 3 1 2 2\n1 2 1 9 1\n1 0 9 1 1", "output": "15"}, {"input": "2 2 1 1 1\n1 1 1 1\n1 1 1 1\n0 0 0", "output": "2"}, {"input": "2 2 1 1 1\n1 1 1 1\n0 0 0 1\n0 0 0", "output": "2"}, {"input": "2 2 2 2 2\n1 1 1 1\n1 1 1 1\n1 1 1", "output": "2"}, {"input": "2 2 1 1 1\n1 1 1 1\n0 0 0 1\n1 1 1", "output": "2"}, {"input": "2 2 2 2 2\n1 1 1 1\n0 0 0 1\n1 1 1", "output": "2"}, {"input": "2 2 1 1 1\n1 1\n1 1\n", "output": "2"}, {"input": "2 3 1 1 3\n1 2 3\n1 2 3\n", "output": "7"}, {"input": "1 1 1 1 1\n1", "output": "1"}, {"input": "5 5 1 2 4\n1 2 1 2 2\n1 1 1 2 4\n8 3 1 2 2\n1 2 1 9 1\n1 0 9 1 1\n", "output": "15"}, {"input": "2 2 1 1 2\n1 3\n3 1\n", "output": "5"}], "test": "#undef NDEBUG\n#include<assert.h>\nint main(){\n    assert(solution(\"5 5 1 2 4\\n1 8 1 6 6\\n1 1 1 2 4\\n8 3 1 2 2\\n1 2 1 9 1\\n1 0 9 1 1\") == \"15\");\n    assert(solution(\"2 2 1 1 1\\n1 1 1 1\\n1 1 1 1\\n0 0 0\") == \"2\");\n    assert(solution(\"2 2 1 1 1\\n1 1 1 1\\n0 0 0 1\\n0 0 0\") == \"2\");\n    assert(solution(\"2 2 2 2 2\\n1 1 1 1\\n1 1 1 1\\n1 1 1\") == \"2\");\n    assert(solution(\"2 2 1 1 1\\n1 1 1 1\\n0 0 0 1\\n1 1 1\") == \"2\");\n    assert(solution(\"2 2 2 2 2\\n1 1 1 1\\n0 0 0 1\\n1 1 1\") == \"2\");\n    assert(solution(\"2 2 1 1 1\\n1 1\\n1 1\\n\") == \"2\");\n    assert(solution(\"2 3 1 1 3\\n1 2 3\\n1 2 3\\n\") == \"7\");\n    assert(solution(\"1 1 1 1 1\\n1\") == \"1\");\n    assert(solution(\"5 5 1 2 4\\n1 2 1 2 2\\n1 1 1 2 4\\n8 3 1 2 2\\n1 2 1 9 1\\n1 0 9 1 1\\n\") == \"15\");\n    assert(solution(\"2 2 1 1 2\\n1 3\\n3 1\\n\") == \"5\");\n    return 0; \n}", "prompt": "/*The cross-sectional view of Gensokyo can be abstracted as an $n \\times m$ rectangular grid.\n\nEach $1 \\times 1$ cell $(i,j)$ has a resistance measurement value $R_{i,j}$.\n\nLightning strikes from the thundercloud at $\\texttt{O}(n,a)$ and hits the Scarlet Devil Mansion at $\\texttt{A}(1,b)$ and the Bamboo Forest of the Lost at $\\texttt{B}(1,c)$ on the ground.\n\nAs lightning is a natural creation, the sum of resistance measurement values in the covered area is minimized, i.e., the sum of resistance measurement values of the union of the two paths from $\\texttt{O}$ to $\\texttt{A}$ and $\\texttt{B}$ is minimized.\n\nGiven the resistance measurement values for all cells, Cirno wants to know the minimum sum of resistance measurement values of the path taken by lightning.\n\ninput_format:\nIn the first row, five integers $n,m,a,b,c$. $(0<a,b,c\\le m)$\n\nThe following $n$lines, each $m$integer, represent resistance metering $R_{i,j}$, where the first line represents a thunderstorm cloud and the last line represents the ground.\n\noutput_format:\nOne line, an integer, represents the answer.\n*/\n\n#include<sstream>\n#include<stdlib.h>\n#include<algorithm>\n#include<math.h>\n#include<stdio.h>\n#include<vector>\n#include<string>\n#include<climits>\n#include<cstring>\n#include<iostream>\nusing namespace std;\n\n             \nstring solution(string std_in){\n    istringstream iss(std_in);\n             ", "constraints": "## 样例解释\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/7ozs40i3.png)\n\n如图黄色线为闪电的路径。\n\n## 数据范围与约定\n\n对于 $100\\%$ 的数据保证：$0<n,m \\le 1000$，$0 \\le R_{i,j}\\le 10^9$，$0< a,b,c \\le m$。\n\n#### 子任务「本题采用捆绑测试」\n\n - Subtask1（$10\\%$）: $R_{i,j}\\in\\{1\\}$。\n - Subtask2（$10\\%$）: $R_{i,j}\\in\\{0,1\\}$。\n - Subtask3（$10\\%$）: $a=b=c$。\n - Subtask4（$10\\%$）: $n,m \\le 5$。\n - Subtask5（$60\\%$）: 无特殊限制。\n ", "samples": [["5 5 1 2 4\n1 8 1 6 6\n1 1 1 2 4\n8 3 1 2 2\n1 2 1 9 1\n1 0 9 1 1", "15"]], "limits": {"time": [2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000], "memory": [131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072]}}
{"task_id": "P2052", "title": "[NOI2011] 道路修建", "difficulty": "challenge", "nl": "There are n countries on planet W. In order to promote their economic development, they decide to build bidirectional roads between countries to connect them. However, each country's king is very stingy, and they are only willing to build exactly n-1 bidirectional roads.\n\nThe construction of each road requires a certain cost, which is equal to the absolute value of the difference between the product of the length of the road and the number of countries at each end. For example, in the graph below, if the length of the dashed road is 1 and the two ends have 2 and 4 countries respectively, then the cost is 1×|2-4|=2. The numbers in the circles represent the country numbers.\n\n![image]\n\nSince the number of countries is very large, there are many road construction plans, and it is difficult to calculate the construction costs manually. The kings decide to find someone to design a software that can calculate the costs for a given construction plan. Please help the kings design such a software.", "code": "#include<algorithm>\n#include<cmath>\n#include<cstdio>\nusing namespace std;\n#define NR 1000002\n#define MR 1000002\nstruct edge{\n\tint to,nxt,w;\n}g[2*MR];\nint gsz;\nint fte[NR];\nlong long ans;\nbool flag[NR];\nint n;\nvoid addedge(int u,int v,int w){\n\tg[++gsz]=(edge){v,fte[u],w};\n\tfte[u]=gsz;\n}\nint dfs(int x){\n\tflag[x]=1;//记忆化\n\tint sum=1;\n\tfor(int i=fte[x];i;i=g[i].nxt){\n\t\tint y=g[i].to;\n\t\tif(flag[y])continue;//如果已经搜过了就跳过\n\t\tint num=dfs(y);\n\t\tans+=1ll*abs(n-2*num)*g[i].w;\n\t\tsum+=num;\n\t}return sum;\n}\nint main(){ \n\tscanf(\"%d\",&n);\n\tfor(int i=1;i<n;++i){\n\t\tint u,v,w;\n\t\tscanf(\"%d%d%d\",&u,&v,&w);\n\t\taddedge(u,v,w);\n\t\taddedge(v,u,w);\n\t}\n\tdfs(1);\n\tprintf(\"%lld\\n\",ans);\n\treturn 0;\n}", "step": ["Declare necessary variables and constants", "Create a struct for edges", "Implement a function to add edges to the tree", "Implement a depth-first search on the tree to calculate subtree sizes and the sum", "Take user input for the number of nodes and edge information", "Call the dfs function with appropriate arguments and print the calculated sum."], "nl_cn": "在 W 星球上有 $n$ 个国家。为了各自国家的经济发展，他们决定在各个国家之间建设双向道路使得国家之间连通。但是每个国家的国王都很吝啬，他们只愿意修建恰好 $n - 1$ 条双向道路。\n\n每条道路的修建都要付出一定的费用，这个费用等于道路长度乘以道路两端 的国家个数之差的绝对值。例如，在下图中，虚线所示道路两端分别有 $2$ 个、$4$ 个国家，如果该道路长度为 $1$，则费用为 $1×|2 - 4|=2$。图中圆圈里的数字表示国家的编号。\n \n  \n\n由于国家的数量十分庞大，道路的建造方案有很多种，同时每种方案的修建费用难以用人工计算，国王们决定找人设计一个软件，对于给定的建造方案，计算出所需要的费用。请你帮助国王们设计一个这样的软件。\n", "test_cases": [{"input": "6\n1 2 1\n1 3 1\n1 4 2\n6 3 1\n5 2 1", "output": "20"}, {"input": "4\n1 2 1\n1 3 1\n1 4 1\n", "output": "6"}, {"input": "5\n1 2 1\n1 3 1\n1 4 1\n1 5 1\n", "output": "12"}, {"input": "5\n1 2 3\n2 3 4\n1 4 2\n4 5 1\n", "output": "20"}], "test": "#undef NDEBUG\n#include<assert.h>\nint main(){\n    assert(solution(\"6\\n1 2 1\\n1 3 1\\n1 4 2\\n6 3 1\\n5 2 1\") == \"20\");\n    assert(solution(\"4\\n1 2 1\\n1 3 1\\n1 4 1\\n\") == \"6\");\n    assert(solution(\"5\\n1 2 1\\n1 3 1\\n1 4 1\\n1 5 1\\n\") == \"12\");\n    assert(solution(\"5\\n1 2 3\\n2 3 4\\n1 4 2\\n4 5 1\\n\") == \"20\");\n    return 0; \n}", "prompt": "/*There are n countries on planet W. In order to promote their economic development, they decide to build bidirectional roads between countries to connect them. However, each country's king is very stingy, and they are only willing to build exactly n-1 bidirectional roads.\n\nThe construction of each road requires a certain cost, which is equal to the absolute value of the difference between the product of the length of the road and the number of countries at each end. For example, in the graph below, if the length of the dashed road is 1 and the two ends have 2 and 4 countries respectively, then the cost is 1×|2-4|=2. The numbers in the circles represent the country numbers.\n\n![image]\n\nSince the number of countries is very large, there are many road construction plans, and it is difficult to calculate the construction costs manually. The kings decide to find someone to design a software that can calculate the costs for a given construction plan. Please help the kings design such a software.\n\ninput_format:\nThe first line of input contains an integer $n$, representing the number of countries on planet W, with countries numbered from $1$to $n$.\n\nThe next $N-1 $line describes the road construction situation, where the $i$line contains three integers $a_i,b_i$and $c_i$, indicating that the $i$two-way road is built between the two countries of $a_i$and $b_i$, and the length is $c_i$.\n\noutput_format:\nOutputs an integer representing the total cost of building all roads.\n*/\n\n#include<sstream>\n#include<stdlib.h>\n#include<algorithm>\n#include<math.h>\n#include<stdio.h>\n#include<vector>\n#include<string>\n#include<climits>\n#include<cstring>\n#include<iostream>\nusing namespace std;\n\n             \nstring solution(string std_in){\n    istringstream iss(std_in);\n             ", "constraints": "对于 $100\\%$ 的数据，$1\\leq a_i, b_i\\leq n$，$0\\leq c_i\\leq10^6$，$2\\leq n\\leq 10^6$。\n|测试点编号|$n=$|\n|:-:|:-:|\n|$1$|$2$|\n|$2$|$10$|\n|$3$|$100$|\n|$4$|$200$|\n|$5$|$500$|\n|$6$|$600$|\n|$7$|$800$|\n|$8$|$1000$|\n|$9$|$10^4$|\n|$10$|$2\\times 10^4$|\n|$11$|$5\\times 10^4$|\n|$12$|$6\\times 10^4$|\n|$13$|$8\\times 10^4$|\n|$14$|$10^5$|\n|$15$|$6\\times 10^5$|\n|$16$|$7\\times 10^5$|\n|$17$|$8\\times 10^5$|\n|$18$|$9\\times 10^5$|\n|$19,20$|$10^6$|\n\n", "samples": [["6\n1 2 1\n1 3 1\n1 4 2\n6 3 1\n5 2 1", "20"]], "limits": {"time": [2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000], "memory": [256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000, 256000]}}
{"task_id": "P4327", "title": "[COCI2006-2007#1] Okviri", "difficulty": "basic", "nl": "\"Peter Pan frames\" is a way of decorating text where each character is framed by a diamond-shaped border, with the borders of adjacent characters overlapping. A Peter Pan frame for a single letter (where 'X' is the letter we want to decorate) looks like this:\n\n```\n..#..\n.#.#.\n#.X.#\n.#.#.\n..#..\n```\n\nHowever, this kind of decoration is a bit monotonous, so we will use \"Wendyframe\" to add frames for every three letters. The Wendy frame looks like this:\n\n```\n..*..\n.*.*.\n*.X.*\n.*.*.\n..*..\n```\n\nWhen Wendy frames and Peter Pan frames overlap, Wendy frames (which are more beautiful) are placed on top. See the examples for overlapping.", "code": "#include <bits/stdc++.h>//万能头，好东西\nusing namespace std;\nint len,lena,ll=3,aa;//ll为第一个字母的初始位置\nchar a[20],b[1000][100],c;\nint main(){\n\tcin>>a;//输入初始字符串\n\tlen=strlen(a);//求出字符串长度，strlen()函数能求出字符串长度\n\tlena=4*len+1;//求出输出字符矩阵的长度，宽度恒为五\n\tmemset(b,'.',sizeof(b));//将b数组全赋值为‘.’,以便后来使用\n\twhile(ll<=lena){//开始循环\n\t\taa++;//到第aa个字母\n\t\tif(aa%3==0)c='*';\n\t\telse c='#';//若为3的倍数个，则用‘*’\n\t\tb[3][ll]=a[aa-1];//把字母填入b数组中\n\t\tb[1][ll]=c;\n\t\tb[5][ll]=c;\n\t\tb[2][ll-1]=c;\n\t\tb[2][ll+1]=c;\n\t\tb[4][ll-1]=c;\n\t\tb[4][ll+1]=c;//根据字母的位置推出其他字符的位置，并填入b数组中\n\t\tif(b[3][ll-2]!='*')b[3][ll-2]=c;\n\t\tif(b[3][ll+2]!='*')b[3][ll+2]=c;//特判，若以被‘*’覆盖，则不能被‘#’覆盖\n\t\tll+=4;//之后每个字母的为止为前一个加4\n\t}\n\tfor(int i=1;i<=5;i++){\n\t\tfor(int j=1;j<=lena;j++)\n\t\t\tcout<<b[i][j];//输出\n\t\tcout<<endl;//不要忘了每行要加回车\n\t}\n\treturn 0;//end\n}\n//wdcxz", "step": ["Initialize a 2D array of size 6 x 62 and a string variable.", "Loop through each character in the input string.", "Skip characters that are in the position 2 modulo 3 and create a frame for the other characters.", "Loop through the input string again and create frames for characters in position 2 modulo 3.", "Loop through each element in the 2D array and print it to the console.", "End the program."], "nl_cn": "“Peter Pan frames” are a way of decorating text in which every character is framed by a diamond shaped frame, with frames of neigbhouring characters interleaving. A Peter Pan frame for one letter looks like this ('X' is the letter we are framing):\n```\n..#..\n.#.#.\n#.X.#\n.#.#.\n..#..\n```\nHowever, such a framing would be somewhat dull so we'll frame every third letter using a “Wendyframe”. A Wendy frame looks like this:\n\n```\n..*..\n.*.*.\n*.X.*\n.*.*.\n..*..\n```\nWhen a Wendy frame interleaves with a Peter Pan frame, the Wendy frame (being much nicer) is put on top. For an example of the interleaving check the sample cases.", "test_cases": [{"input": "A", "output": "..#..\n.#.#.\n#.A.#\n.#.#.\n..#.."}, {"input": "DOG", "output": "..#...#...*..\n.#.#.#.#.*.*.\n#.D.#.O.*.G.*\n.#.#.#.#.*.*.\n..#...#...*.."}, {"input": "ABCD", "output": "..#...#...*...#..\n.#.#.#.#.*.*.#.#.\n#.A.#.B.*.C.*.D.#\n.#.#.#.#.*.*.#.#.\n..#...#...*...#.."}, {"input": "B", "output": "..#..\n.#.#.\n#.B.#\n.#.#.\n..#.."}, {"input": "C", "output": "..#..\n.#.#.\n#.C.#\n.#.#.\n..#.."}, {"input": "D", "output": "..#..\n.#.#.\n#.D.#\n.#.#.\n..#.."}, {"input": "E", "output": "..#..\n.#.#.\n#.E.#\n.#.#.\n..#.."}, {"input": "F", "output": "..#..\n.#.#.\n#.F.#\n.#.#.\n..#.."}, {"input": "G", "output": "..#..\n.#.#.\n#.G.#\n.#.#.\n..#.."}, {"input": "H", "output": "..#..\n.#.#.\n#.H.#\n.#.#.\n..#.."}, {"input": "I", "output": "..#..\n.#.#.\n#.I.#\n.#.#.\n..#.."}, {"input": "J", "output": "..#..\n.#.#.\n#.J.#\n.#.#.\n..#.."}, {"input": "K", "output": "..#..\n.#.#.\n#.K.#\n.#.#.\n..#.."}, {"input": "L", "output": "..#..\n.#.#.\n#.L.#\n.#.#.\n..#.."}, {"input": "M", "output": "..#..\n.#.#.\n#.M.#\n.#.#.\n..#.."}, {"input": "N", "output": "..#..\n.#.#.\n#.N.#\n.#.#.\n..#.."}, {"input": "O", "output": "..#..\n.#.#.\n#.O.#\n.#.#.\n..#.."}, {"input": "P", "output": "..#..\n.#.#.\n#.P.#\n.#.#.\n..#.."}, {"input": "Q", "output": "..#..\n.#.#.\n#.Q.#\n.#.#.\n..#.."}, {"input": "R", "output": "..#..\n.#.#.\n#.R.#\n.#.#.\n..#.."}, {"input": "S", "output": "..#..\n.#.#.\n#.S.#\n.#.#.\n..#.."}, {"input": "T", "output": "..#..\n.#.#.\n#.T.#\n.#.#.\n..#.."}], "test": "#undef NDEBUG\n#include<assert.h>\nint main(){\n    assert(solution(\"A\") == \"..#..\\n.#.#.\\n#.A.#\\n.#.#.\\n..#..\");\n    assert(solution(\"DOG\") == \"..#...#...*..\\n.#.#.#.#.*.*.\\n#.D.#.O.*.G.*\\n.#.#.#.#.*.*.\\n..#...#...*..\");\n    assert(solution(\"ABCD\") == \"..#...#...*...#..\\n.#.#.#.#.*.*.#.#.\\n#.A.#.B.*.C.*.D.#\\n.#.#.#.#.*.*.#.#.\\n..#...#...*...#..\");\n    assert(solution(\"B\") == \"..#..\\n.#.#.\\n#.B.#\\n.#.#.\\n..#..\");\n    assert(solution(\"C\") == \"..#..\\n.#.#.\\n#.C.#\\n.#.#.\\n..#..\");\n    assert(solution(\"D\") == \"..#..\\n.#.#.\\n#.D.#\\n.#.#.\\n..#..\");\n    assert(solution(\"E\") == \"..#..\\n.#.#.\\n#.E.#\\n.#.#.\\n..#..\");\n    assert(solution(\"F\") == \"..#..\\n.#.#.\\n#.F.#\\n.#.#.\\n..#..\");\n    assert(solution(\"G\") == \"..#..\\n.#.#.\\n#.G.#\\n.#.#.\\n..#..\");\n    assert(solution(\"H\") == \"..#..\\n.#.#.\\n#.H.#\\n.#.#.\\n..#..\");\n    assert(solution(\"I\") == \"..#..\\n.#.#.\\n#.I.#\\n.#.#.\\n..#..\");\n    assert(solution(\"J\") == \"..#..\\n.#.#.\\n#.J.#\\n.#.#.\\n..#..\");\n    assert(solution(\"K\") == \"..#..\\n.#.#.\\n#.K.#\\n.#.#.\\n..#..\");\n    assert(solution(\"L\") == \"..#..\\n.#.#.\\n#.L.#\\n.#.#.\\n..#..\");\n    assert(solution(\"M\") == \"..#..\\n.#.#.\\n#.M.#\\n.#.#.\\n..#..\");\n    assert(solution(\"N\") == \"..#..\\n.#.#.\\n#.N.#\\n.#.#.\\n..#..\");\n    assert(solution(\"O\") == \"..#..\\n.#.#.\\n#.O.#\\n.#.#.\\n..#..\");\n    assert(solution(\"P\") == \"..#..\\n.#.#.\\n#.P.#\\n.#.#.\\n..#..\");\n    assert(solution(\"Q\") == \"..#..\\n.#.#.\\n#.Q.#\\n.#.#.\\n..#..\");\n    assert(solution(\"R\") == \"..#..\\n.#.#.\\n#.R.#\\n.#.#.\\n..#..\");\n    assert(solution(\"S\") == \"..#..\\n.#.#.\\n#.S.#\\n.#.#.\\n..#..\");\n    assert(solution(\"T\") == \"..#..\\n.#.#.\\n#.T.#\\n.#.#.\\n..#..\");\n    return 0; \n}", "prompt": "/*\"Peter Pan frames\" is a way of decorating text where each character is framed by a diamond-shaped border, with the borders of adjacent characters overlapping. A Peter Pan frame for a single letter (where 'X' is the letter we want to decorate) looks like this:\n\n```\n..#..\n.#.#.\n#.X.#\n.#.#.\n..#..\n```\n\nHowever, this kind of decoration is a bit monotonous, so we will use \"Wendyframe\" to add frames for every three letters. The Wendy frame looks like this:\n\n```\n..*..\n.*.*.\n*.X.*\n.*.*.\n..*..\n```\n\nWhen Wendy frames and Peter Pan frames overlap, Wendy frames (which are more beautiful) are placed on top. See the examples for overlapping.\n\ninput_format:\nThe first and only line of input will contain at most 15 capital letters of the English alphabet.\n\noutput_format:\nOutput the word written using Peter Pan and Wendy frames on 5 lines.\n*/\n\n#include<sstream>\n#include<stdlib.h>\n#include<algorithm>\n#include<math.h>\n#include<stdio.h>\n#include<vector>\n#include<string>\n#include<climits>\n#include<cstring>\n#include<iostream>\nusing namespace std;\n\n             \nstring solution(string std_in){\n    istringstream iss(std_in);\n             ", "constraints": "", "samples": [["A", "..#..\n.#.#.\n#.A.#\n.#.#.\n..#.."], ["DOG", "..#...#...*..\n.#.#.#.#.*.*.\n#.D.#.O.*.G.*\n.#.#.#.#.*.*.\n..#...#...*.."], ["ABCD", "..#...#...*...#..\n.#.#.#.#.*.*.#.#.\n#.A.#.B.*.C.*.D.#\n.#.#.#.#.*.*.#.#.\n..#...#...*...#.."]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [32000, 32000, 32000, 32000, 32000, 32000, 32000, 32000, 32000, 32000]}}
{"task_id": "P1045", "title": "[NOIP2003 普及组] 麦森数", "difficulty": "challenge", "nl": "Mersenne prime is a prime number in the form of $2^P-1$, where $P$ is also a prime number. However, the reverse is not necessarily true, that is, if $P$ is a prime number, $2^P-1$ is not necessarily a prime number. By the end of 1998, 37 Mersenne primes had been found. The largest one is $P=3021377$, which has 909526 digits. Mersenne primes have many important applications and are closely related to perfect numbers.\n\nTask: Given $P(1000<P<3100000)$, calculate the number of digits and the last 500 digits (represented in decimal high precision number) of $2^P-1$.", "code": "#include<cstdio>\n#include<cmath>\n#include<cstring>\nusing namespace std;\nint f[1001],p,res[1001],sav[1001];//乘法要开两倍长度\nvoid result_1()\n{\n    memset(sav,0,sizeof(sav));\n    for(register int i=1;i<=500;i+=1)\n        for(register int j=1;j<=500;j+=1)\n            sav[i+j-1]+=res[i]*f[j];//先计算每一位上的值（不进位）\n    for(register int i=1;i<=500;i+=1)\n    {\n        sav[i+1]+=sav[i]/10;//单独处理进位问题，不容易出错\n        sav[i]%=10;\n    }\n    memcpy(res,sav,sizeof(res));//cstring库里的赋值函数，把sav的值赋给res\n}\nvoid result_2()//只是在result_1的基础上进行了细微的修改\n{\n    memset(sav,0,sizeof(sav));\n    for(register int i=1;i<=500;i+=1)\n        for(register int j=1;j<=500;j+=1)\n            sav[i+j-1]+=f[i]*f[j];\n    for(register int i=1;i<=500;i+=1)\n    {\n        sav[i+1]+=sav[i]/10;\n        sav[i]%=10;\n    }\n    memcpy(f,sav,sizeof(f));\n}\nint main()\n{\n    scanf(\"%d\",&p);\n    printf(\"%d\\n\",(int)(log10(2)*p+1));\n    res[1]=1;\n    f[1]=2;//高精度赋初值\n    while(p!=0)//快速幂模板\n    {\n        if(p%2==1)result_1();\n        p/=2;\n        result_2();\n    }\n    res[1]-=1;\n    for(register int i=500;i>=1;i-=1)//注意输出格式，50个换一行，第一个不用\n        if(i!=500&&i%50==0)printf(\"\\n%d\",res[i]);\n        else printf(\"%d\",res[i]);\n    return 0;\n}", "step": ["Initialize variables and arrays.", "Obtain the value of p from user input.", "Calculate the number of digits in 2^p.", "Perform binary exponentiation to get the value of 2^p.", "Subtract 1 from res.", "Print the value of 2^p."], "nl_cn": "形如 $2^{P}-1$ 的素数称为麦森数，这时 $P$ 一定也是个素数。但反过来不一定，即如果 $P$ 是个素数，$2^{P}-1$ 不一定也是素数。到 1998 年底，人们已找到了 37 个麦森数。最大的一个是 $P=3021377$，它有 909526 位。麦森数有许多重要应用，它与完全数密切相关。\n\n任务：输入 $P(1000<P<3100000)$，计算 $2^{P}-1$ 的位数和最后 $500$ 位数字（用十进制高精度数表示）\n", "test_cases": [{"input": "1279\n", "output": "386\n00000000000000000000000000000000000000000000000000\n00000000000000000000000000000000000000000000000000\n00000000000000104079321946643990819252403273640855\n38615262247266704805319112350403608059673360298012\n23944173232418484242161395428100779138356624832346\n49081399066056773207629241295093892203457731833496\n61583550472959420547689811211693677147548478866962\n50138443826029173234888531116082853841658502825560\n46662248318909188018470682222031405210266984354887\n32958028878050869736186900714720710555703168729087"}], "test": "#undef NDEBUG\n#include<assert.h>\nint main(){\n    assert(solution(\"1279\\n\") == \"386\\n00000000000000000000000000000000000000000000000000\\n00000000000000000000000000000000000000000000000000\\n00000000000000104079321946643990819252403273640855\\n38615262247266704805319112350403608059673360298012\\n23944173232418484242161395428100779138356624832346\\n49081399066056773207629241295093892203457731833496\\n61583550472959420547689811211693677147548478866962\\n50138443826029173234888531116082853841658502825560\\n46662248318909188018470682222031405210266984354887\\n32958028878050869736186900714720710555703168729087\");\n    return 0; \n}", "prompt": "/*Mersenne prime is a prime number in the form of $2^P-1$, where $P$ is also a prime number. However, the reverse is not necessarily true, that is, if $P$ is a prime number, $2^P-1$ is not necessarily a prime number. By the end of 1998, 37 Mersenne primes had been found. The largest one is $P=3021377$, which has 909526 digits. Mersenne primes have many important applications and are closely related to perfect numbers.\n\nTask: Given $P(1000<P<3100000)$, calculate the number of digits and the last 500 digits (represented in decimal high precision number) of $2^P-1$.\n\ninput_format:\nThe file contains only one integer P (1000 < P < 3100000).\n\noutput_format:\nFirst line: decimal high precision $2^{P}-1$digits.\n\nLine $2\\sim 11$: The last $500 digit of the decimal high precision $2^{P}-1$. (Each line output $50 bits, a total of $10 lines output, less than $500 when the upper $0)\n\nIt is not necessary to verify that $2^{P}-1$and $P$are prime numbers.\n*/\n\n#include<sstream>\n#include<stdlib.h>\n#include<algorithm>\n#include<math.h>\n#include<stdio.h>\n#include<vector>\n#include<string>\n#include<climits>\n#include<cstring>\n#include<iostream>\nusing namespace std;\n\n             \nstring solution(string std_in){\n    istringstream iss(std_in);\n             ", "constraints": "**【题目来源】**\n\nNOIP 2003 普及组第四题", "samples": [["1279\n", "386\n00000000000000000000000000000000000000000000000000\n00000000000000000000000000000000000000000000000000\n00000000000000104079321946643990819252403273640855\n38615262247266704805319112350403608059673360298012\n23944173232418484242161395428100779138356624832346\n49081399066056773207629241295093892203457731833496\n61583550472959420547689811211693677147548478866962\n50138443826029173234888531116082853841658502825560\n46662248318909188018470682222031405210266984354887\n32958028878050869736186900714720710555703168729087\n"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}}
{"task_id": "P2393", "title": "yyy loves Maths II", "difficulty": "basic", "nl": "Redbag has given yyy a lot of numbers and wants yyy to calculate their sum. \n\nIt must be done quickly as Redbag has only given yyy one second to complete the task!!!", "code": "#include <cstdio>\n\nint main() {\n    __float128 sum = 0;\n    for (long double x; ~scanf(\"%Lf\", &x); sum += x);\n    \n    printf(\"%.5Lf\\n\", (long double)sum);\n}", "step": ["Read input and add it to sum multiplied by 1000000.", "Call main() recursively until there is no more input.", "Print the sum divided by 1000000.", "Return 0."], "nl_cn": "redbag 给了 yyy 很多个数，要 yyy 计算这些数的和。\n\n必须要快，redbag 只给了 yyy $1$ 秒的时间！！！\n", "test_cases": [{"input": "1\n", "output": "1.00000"}, {"input": "2\n", "output": "2.00000"}, {"input": "0\n", "output": "0.00000"}, {"input": "10\n", "output": "10.00000"}, {"input": "-1\n", "output": "-1.00000"}, {"input": "0.5\n", "output": "0.50000"}, {"input": "-0.5\n", "output": "-0.50000"}, {"input": "100\n", "output": "100.00000"}, {"input": "3.14159\n", "output": "3.14159"}, {"input": "1000000\n", "output": "1000000.00000"}, {"input": "-1000000\n", "output": "-1000000.00000"}, {"input": "0.00001\n", "output": "0.00001"}, {"input": "-0.00001\n", "output": "-0.00001"}, {"input": "123456789\n", "output": "123456789.00000"}, {"input": "-123456789\n", "output": "-123456789.00000"}, {"input": "999999999.99999\n", "output": "999999999.99999"}, {"input": "5.5\n", "output": "5.50000"}, {"input": "0.123456\n", "output": "0.12346"}, {"input": "1000\n", "output": "1000.00000"}, {"input": "123.456\n", "output": "123.45600"}, {"input": "0.0001\n", "output": "0.00010"}, {"input": "-10\n", "output": "-10.00000"}, {"input": "10000\n", "output": "10000.00000"}, {"input": "0.000001\n", "output": "0.00000"}, {"input": "-5.5\n", "output": "-5.50000"}, {"input": "-123.456\n", "output": "-123.45600"}, {"input": "-100\n", "output": "-100.00000"}, {"input": "10 20\n", "output": "30.00000"}, {"input": "3.14\n", "output": "3.14000"}, {"input": "-5\n", "output": "-5.00000"}, {"input": "100 200 300\n", "output": "600.00000"}, {"input": "10  -20\n", "output": "-10.00000"}, {"input": "2.5 3.5\n", "output": "6.00000"}, {"input": "0.5 0.5 0.5\n", "output": "1.50000"}, {"input": "0 0 0 0\n", "output": "0.00000"}, {"input": "-1 -2 -3 -4 -5\n", "output": "-15.00000"}, {"input": "1 2 3 4 5 6 7 8 9 10\n", "output": "55.00000"}, {"input": "2 -4 6 -8 10 -12\n", "output": "-6.00000"}, {"input": "0.001 0.001 0.001 0.001 0.001 0.001 0.001 0.001 0.001 0.001\n", "output": "0.01000"}, {"input": "-10 -20 -30 -40\n", "output": "-100.00000"}, {"input": "0.5 1.5 2.5 3.5 4.5\n", "output": "12.50000"}, {"input": "12345\n", "output": "12345.00000"}, {"input": "1e10\n", "output": "10000000000.00000"}, {"input": "1000.123\n", "output": "1000.12300"}, {"input": "-1000.123\n", "output": "-1000.12300"}, {"input": "2.71828\n", "output": "2.71828"}, {"input": "-2.71828\n", "output": "-2.71828"}, {"input": "-3.14159\n", "output": "-3.14159"}, {"input": "999999.99999\n", "output": "999999.99999"}, {"input": "-3.14\n", "output": "-3.14000"}, {"input": "1234567890\n", "output": "1234567890.00000"}, {"input": "-1234567890\n", "output": "-1234567890.00000"}, {"input": "0.123\n", "output": "0.12300"}, {"input": "-0.123\n", "output": "-0.12300"}, {"input": "100.001\n", "output": "100.00100"}, {"input": "-100.001\n", "output": "-100.00100"}, {"input": "999999.999\n", "output": "999999.99900"}, {"input": "-999999.999\n", "output": "-999999.99900"}, {"input": "1000000000\n", "output": "1000000000.00000"}, {"input": "-1000000000\n", "output": "-1000000000.00000"}], "test": "#undef NDEBUG\n#include<assert.h>\nint main(){\n    assert(solution(\"1\\n\") == \"1.00000\");\n    assert(solution(\"2\\n\") == \"2.00000\");\n    assert(solution(\"0\\n\") == \"0.00000\");\n    assert(solution(\"10\\n\") == \"10.00000\");\n    assert(solution(\"-1\\n\") == \"-1.00000\");\n    assert(solution(\"0.5\\n\") == \"0.50000\");\n    assert(solution(\"-0.5\\n\") == \"-0.50000\");\n    assert(solution(\"100\\n\") == \"100.00000\");\n    assert(solution(\"3.14159\\n\") == \"3.14159\");\n    assert(solution(\"1000000\\n\") == \"1000000.00000\");\n    assert(solution(\"-1000000\\n\") == \"-1000000.00000\");\n    assert(solution(\"0.00001\\n\") == \"0.00001\");\n    assert(solution(\"-0.00001\\n\") == \"-0.00001\");\n    assert(solution(\"123456789\\n\") == \"123456789.00000\");\n    assert(solution(\"-123456789\\n\") == \"-123456789.00000\");\n    assert(solution(\"999999999.99999\\n\") == \"999999999.99999\");\n    assert(solution(\"5.5\\n\") == \"5.50000\");\n    assert(solution(\"0.123456\\n\") == \"0.12346\");\n    assert(solution(\"1000\\n\") == \"1000.00000\");\n    assert(solution(\"123.456\\n\") == \"123.45600\");\n    assert(solution(\"0.0001\\n\") == \"0.00010\");\n    assert(solution(\"-10\\n\") == \"-10.00000\");\n    assert(solution(\"10000\\n\") == \"10000.00000\");\n    assert(solution(\"0.000001\\n\") == \"0.00000\");\n    assert(solution(\"-5.5\\n\") == \"-5.50000\");\n    assert(solution(\"-123.456\\n\") == \"-123.45600\");\n    assert(solution(\"-100\\n\") == \"-100.00000\");\n    assert(solution(\"10 20\\n\") == \"30.00000\");\n    assert(solution(\"3.14\\n\") == \"3.14000\");\n    assert(solution(\"-5\\n\") == \"-5.00000\");\n    assert(solution(\"100 200 300\\n\") == \"600.00000\");\n    assert(solution(\"10  -20\\n\") == \"-10.00000\");\n    assert(solution(\"2.5 3.5\\n\") == \"6.00000\");\n    assert(solution(\"0.5 0.5 0.5\\n\") == \"1.50000\");\n    assert(solution(\"0 0 0 0\\n\") == \"0.00000\");\n    assert(solution(\"-1 -2 -3 -4 -5\\n\") == \"-15.00000\");\n    assert(solution(\"1 2 3 4 5 6 7 8 9 10\\n\") == \"55.00000\");\n    assert(solution(\"2 -4 6 -8 10 -12\\n\") == \"-6.00000\");\n    assert(solution(\"0.001 0.001 0.001 0.001 0.001 0.001 0.001 0.001 0.001 0.001\\n\") == \"0.01000\");\n    assert(solution(\"-10 -20 -30 -40\\n\") == \"-100.00000\");\n    assert(solution(\"0.5 1.5 2.5 3.5 4.5\\n\") == \"12.50000\");\n    assert(solution(\"12345\\n\") == \"12345.00000\");\n    assert(solution(\"1e10\\n\") == \"10000000000.00000\");\n    assert(solution(\"1000.123\\n\") == \"1000.12300\");\n    assert(solution(\"-1000.123\\n\") == \"-1000.12300\");\n    assert(solution(\"2.71828\\n\") == \"2.71828\");\n    assert(solution(\"-2.71828\\n\") == \"-2.71828\");\n    assert(solution(\"-3.14159\\n\") == \"-3.14159\");\n    assert(solution(\"999999.99999\\n\") == \"999999.99999\");\n    assert(solution(\"-3.14\\n\") == \"-3.14000\");\n    assert(solution(\"1234567890\\n\") == \"1234567890.00000\");\n    assert(solution(\"-1234567890\\n\") == \"-1234567890.00000\");\n    assert(solution(\"0.123\\n\") == \"0.12300\");\n    assert(solution(\"-0.123\\n\") == \"-0.12300\");\n    assert(solution(\"100.001\\n\") == \"100.00100\");\n    assert(solution(\"-100.001\\n\") == \"-100.00100\");\n    assert(solution(\"999999.999\\n\") == \"999999.99900\");\n    assert(solution(\"-999999.999\\n\") == \"-999999.99900\");\n    assert(solution(\"1000000000\\n\") == \"1000000000.00000\");\n    assert(solution(\"-1000000000\\n\") == \"-1000000000.00000\");\n    return 0; \n}", "prompt": "/*Redbag has given yyy a lot of numbers and wants yyy to calculate their sum. \n\nIt must be done quickly as Redbag has only given yyy one second to complete the task!!!\n\ninput_format:\nOne line, many numbers.\n\noutput_format:\nA row, a real number (rounded to the exact $5 decimal place), represents the sum of these numbers.\n*/\n\n#include<sstream>\n#include<stdlib.h>\n#include<algorithm>\n#include<math.h>\n#include<stdio.h>\n#include<vector>\n#include<string>\n#include<climits>\n#include<cstring>\n#include<iostream>\nusing namespace std;\n\n             \nstring solution(string std_in){\n    istringstream iss(std_in);\n             ", "constraints": "对于 $100\\%$ 的数据，所有数 $ \\le 233,333,333 $，保证在小数点后最多有 $6$ 位数，最多共有 $5\\times 10^4$ 个数。", "samples": [["1\n", "1.00000\n"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}}
{"task_id": "P1023", "title": "[NOIP2000 普及组] 税收与补贴问题", "difficulty": "challenge", "nl": "You are a project manager of a consulting company. You have been given information on the government's expected price for a certain commodity, as well as the sales situation at various price points. Your task is to determine the minimum amount of tax or subsidy that the government needs to impose on this commodity in order for the business to obtain the maximum total profit relative to other price points at this expected government price.\n\nTotal profit = unit commodity profit $ \\times $ sales volume\n\nUnit commodity profit = unit commodity price - unit commodity cost (- tax or + subsidy)", "code": "//时间紧迫，没有整理码风，见谅\n#include <bits/stdc++.h>\n#define MAX (100000+100)\nusing namespace std;\n\nint x,r,m,n,p,d[MAX];//r代表成本价,x代表期望价格，d代表价位\ndouble Min=-1e9,Max=1e9;//答案区间，开始无穷大\n\ninline void read(int &a)\n{\n    register char c=getchar(); bool f=0; \n    for (a=0; c<'0'||'9'<c; c=getchar())\n        if (c=='-') f=1;//要写快读记得判负数，有-1\n    for (; '0'<=c && c<='9'; c=getchar())\n        a=(a<<3)+(a<<1)+(c^48);\n    if (f) a=-a;\n}\n\nint main()\n{\n    read(x); read(m); read(n); r=m;//记录成本价\n    while (m!=-1 && n!=-1)\n    {\n        d[m]=n; \n        for (int i=p+1; i<m; i++)\n            d[i]=d[i-1]+(n-d[p])/(m-p);//此处递推、未知价格销量，(n-d[p])/(m-p)是公差\n        p=m;//记录上一次的m。\n        read(m); read(n);\n    }read(m);//此时m是最后输入的数\n    while (d[p]>m)\n        p++,d[p]=d[p-1]-m;//继续递推，递推完成后p就是d>0的范围\n    for (register int i=r; i<=p; i++)//从成本到p的递推\n    {\n        double ans=(d[x]*(x-r)-d[i]*(i-r))*1.0/(d[i]-d[x]);\n\t\t//求(x+d[i])*(i-r)<=（x+d[x_])+(x_-r)的通解，x_是期望价格\n        double g=d[i]-d[x];//判断解的符号,g为正是小于，反之为大于。\n        if (g>0) Max=min(Max,ans);//取所有\"x<=...\"中的最小值\n        else Min=max(Min,ans);//取所有\"x>=...\"中的最大值\n    }\n\t//此时[Min,Max]就是答案的范围，取绝对值最小的输出。\n    if (Min>0) printf(\"%d\",(int)ceil(Min));//Max>Min>0，答案为Min上取整\n    else if (Max<0) printf(\"%d\",(int)floor(Max));//Min<Max<0，答案为Max下取整\n    else puts(\"0\");//Min<0<Max，显然是0绝对值最小\n\t//此处应有Min>Max，输出\"NO SOLUTION\"的情况，不过其实并没有这个点，所以就省略了。\n    return 0;\n}", "step": ["Read input values x,m,n, set r=m and initialize Min and Max variables.", "Store n in array d at mth index.", "Fill the gap between p+1 and mth index in the array d using linear interpolation.", "Set p=m and repeat step 2 and 3 untill m and n are not -1.", "Update values in array d to be below m as required and iterate over the range of values to compute Minimum and Maximum of the function f(x).", "Print the result by checking if Min is positive, or Max is negative and if both, then print 0."], "nl_cn": "你是某家咨询公司的项目经理，现在你已经知道政府对某种商品的预期价格，以及在各种价位上的销售情况。要求你确定政府对此商品是应收税还是补贴的最少金额（也为整数），才能使商家在这样一种政府预期的价格上，获取相对其他价位上的最大总利润。\n\n总利润=单位商品利润   $ \\times  $ 销量\n\n单位商品利润=单位商品价格 - 单位商品成本 （- 税金  or  + 补贴）\n", "test_cases": [{"input": "31\n28 130\n30 120\n31 110\n-1  -1\n15", "output": "4"}, {"input": "30\n28 100\n27 150\n29 120\n26 80\n30 200\n-1  -1\n32\n", "output": "4"}, {"input": "31\n28 130\n30 120\n31 110\n-1 -1\n15", "output": "4"}, {"input": "100\n95 150\n90 200\n85 250\n-1  -1\n95\n", "output": "0"}], "test": "#undef NDEBUG\n#include<assert.h>\nint main(){\n    assert(solution(\"31\\n28 130\\n30 120\\n31 110\\n-1  -1\\n15\") == \"4\");\n    assert(solution(\"30\\n28 100\\n27 150\\n29 120\\n26 80\\n30 200\\n-1  -1\\n32\\n\") == \"4\");\n    assert(solution(\"31\\n28 130\\n30 120\\n31 110\\n-1 -1\\n15\") == \"4\");\n    assert(solution(\"100\\n95 150\\n90 200\\n85 250\\n-1  -1\\n95\\n\") == \"0\");\n    return 0; \n}", "prompt": "/*You are a project manager of a consulting company. You have been given information on the government's expected price for a certain commodity, as well as the sales situation at various price points. Your task is to determine the minimum amount of tax or subsidy that the government needs to impose on this commodity in order for the business to obtain the maximum total profit relative to other price points at this expected government price.\n\nTotal profit = unit commodity profit $ \\times $ sales volume\n\nUnit commodity profit = unit commodity price - unit commodity cost (- tax or + subsidy)\n\ninput_format:\nThe first line of input is the government's expected price for a certain commodity. The second line consists of two integers: the first integer represents the cost of the commodity, and the second integer represents the sales volume when sold at cost price. Following these lines, there are multiple lines, each containing two integers: the first integer represents the unit price at a certain price point, and the second integer represents the sales volume at that price point. The input is completed by a line containing \"-1 -1\", indicating that all known price points and corresponding sales volumes have been entered. The last line of input is a single integer representing the decrease in sales volume for every increase of one dollar beyond the highest known unit price.\n\noutput_format:\nThere are two cases of output: if the maximum total profit can be obtained at the government's expected price, the output is a separate integer, the positive or negative number indicates whether the subsidy or tax is collected, and the size of the number indicates the minimum amount of subsidy or tax. If there are multiple solutions, take the output with the smallest absolute value.\n\nIf the maximum total profit cannot be obtained at the government's expected price, the 'NO SOLUTION' is exported.\n*/\n\n#include<sstream>\n#include<stdlib.h>\n#include<algorithm>\n#include<math.h>\n#include<stdio.h>\n#include<vector>\n#include<string>\n#include<climits>\n#include<cstring>\n#include<iostream>\nusing namespace std;\n\n             \nstring solution(string std_in){\n    istringstream iss(std_in);\n             ", "constraints": "### 数据范围及约定\n\n保证输入的所有数字均小于 $10^5$。\n\n### 样例解释（2023/6/22 更新）\n\n如下图所示是输入样例所对应的价格变化图，横轴表示销售价格，纵轴表示销量。\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/21mhtm5i.png)\n\n根据题意，$28$ 元是商品的成本。销售价格不应该低于 $28$ 元；当销售价格大于给出的价格的最大值 $31$ 元后，按照售价每提高一元，销量降低 $15$ 计算，例如当售价为 $33$ 元时，销量为 $110-15\\times (33-31)=80$。在给出来的价位之间，销量呈线性变化。\n\n当政府给该商品补贴 $4$ 元后，企业将该商品定价为 $31$ 元时，取得的利润为 $31-28+4=7$ 元，销量为 $110$ 件，总利润为 $7\\times 110=770$ 元，是企业在所有定价下能够取得的最大的总利润。此时企业的售价为政府的期望售价，因此是一个合法方案。", "samples": [["31\n28 130\n30 120\n31 110\n-1  -1\n15", "4\n"]], "limits": {"time": [1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000]}}
{"task_id": "P1508", "title": "Likecloud-吃、吃、吃", "difficulty": "challenge", "nl": "Li Dashuiniu, who is in a certain period of time and has a well-developed digestive system, has been hungry recently. One day in class, when he was dizzy and hungry, a giant dining table of $n \\times m(n,m \\le 200)$ suddenly appeared in front of him, and he was on the midpoint below one side of the table. The table is divided into $n \\times m$ small squares, each of which contains a circular giant plate filled with food that Li Dashuiniu has longed for. Li Dashuiniu has divided all the food on the table according to the energy he can provide (some of which are negative because eating will cause diarrhea). He decided to eat from his position to the other side of the table, but he has a habit of only eating the food in the plate in front of him or in the front left or front right.\n\nAs Li Dashuiniu is too hungry to think and he wants to obtain the maximum energy, he has entrusted this problem to you.\n\nThe starting point of each set of data is below the middle position of the last row!", "code": "#include<iostream>\n#include<cstring>                             //头文件\nusing namespace std;\nint n,m,a[201][201],f[201][201]={0},x,y;\nint main()\n{\n    cin>>n>>m;\n    y=m/2+1;x=n;                           //求出李大水牛最开始的位置\n    memset(a,-9999,sizeof(a));               //设置边界，为了避免李大水牛吃到餐桌外面去。。\n    for(int i=1;i<=n;i++)\n    {\n        for(int j=1;j<=m;j++)\n        {\n            cin>>a[i][j];               //输入\n        }\n    }\n    for(int i=1;i<=n;i++)\n    {\n        for(int j=1;j<=m;j++)\n        {\n            f[i][j]=max(max(f[i-1][j],f[i-1][j-1]),f[i-1][j+1])+a[i][j];         //动态方程\n        }\n    }\n    cout<<max(max(f[x][y],f[x][y-1]),f[x][y+1])<<endl;       //因为最大值只可能在李大水牛的前方、左前方、右前方，所以只要找这三个的最大就行了\n    return 0;\n}", "step": ["Initialize variables m, n, a, f.", "Read m and n.", "Read the values of elements of the grid.", "Implement dfs function to compute the maximum sum path.", "Initialize and print the maximum sum path using print function.", "Return 0."], "nl_cn": "正处在某一特定时期之中的李大水牛由于消化系统比较发达，最近一直处在饥饿的状态中。某日上课，正当他饿得头昏眼花之时，眼前突然闪现出了一个 $n \\times m(n,m \\le 200)$ 的矩型的巨型大餐桌，而自己正处在这个大餐桌的一侧的中点下边。餐桌被划分为了 $n \\times m$ 个小方格，每一个方格中都有一个圆形的巨型大餐盘，上面盛满了令李大水牛朝思暮想的食物。李大水牛已将餐桌上所有的食物按其所能提供的能量打了分（有些是负的，因为吃了要拉肚子），他决定从自己所处的位置吃到餐桌的另一侧，但他吃东西有一个习惯——只吃自己前方或左前方或右前方的盘中的食物。\n\n由于李大水牛已饿得不想动脑了，而他又想获得最大的能量，因此，他将这个问题交给了你。\n\n每组数据的出发点都是最后一行的中间位置的下方！", "test_cases": [{"input": "6 7\n16 4 3 12 6 0 3\n4 -5 6 7 0 0 2\n6 0 -1 -2 3 6 8\n5 3 4 0 0 -2 7\n-1 7 4 0 7 -5 6\n0 -1 3 4 12 4 2\n", "output": "41"}, {"input": "1 1\n5\n", "output": "5"}, {"input": "4 4\n1 0 -1 0\n0 1 0 -1\n-1 0 1 0\n0 -1 0 1\n", "output": "4"}, {"input": "3 1\n1\n2\n3\n", "output": "6"}, {"input": "2 2\n0 0\n0 0\n", "output": "0"}, {"input": "2 3\n1 -1 1\n-1 1 -1\n", "output": "2"}, {"input": "1 1\n1\n", "output": "1"}, {"input": "2 2\n1 2\n3 4\n", "output": "6"}, {"input": "3 2\n1 2\n3 4\n5 6\n", "output": "12"}, {"input": "2 1\n1\n1\n", "output": "2"}, {"input": "1 3\n1 2 3\n", "output": "3"}, {"input": "1 1\n0\n", "output": "0"}], "test": "#undef NDEBUG\n#include<assert.h>\nint main(){\n    assert(solution(\"6 7\\n16 4 3 12 6 0 3\\n4 -5 6 7 0 0 2\\n6 0 -1 -2 3 6 8\\n5 3 4 0 0 -2 7\\n-1 7 4 0 7 -5 6\\n0 -1 3 4 12 4 2\\n\") == \"41\");\n    assert(solution(\"1 1\\n5\\n\") == \"5\");\n    assert(solution(\"4 4\\n1 0 -1 0\\n0 1 0 -1\\n-1 0 1 0\\n0 -1 0 1\\n\") == \"4\");\n    assert(solution(\"3 1\\n1\\n2\\n3\\n\") == \"6\");\n    assert(solution(\"2 2\\n0 0\\n0 0\\n\") == \"0\");\n    assert(solution(\"2 3\\n1 -1 1\\n-1 1 -1\\n\") == \"2\");\n    assert(solution(\"1 1\\n1\\n\") == \"1\");\n    assert(solution(\"2 2\\n1 2\\n3 4\\n\") == \"6\");\n    assert(solution(\"3 2\\n1 2\\n3 4\\n5 6\\n\") == \"12\");\n    assert(solution(\"2 1\\n1\\n1\\n\") == \"2\");\n    assert(solution(\"1 3\\n1 2 3\\n\") == \"3\");\n    assert(solution(\"1 1\\n0\\n\") == \"0\");\n    return 0; \n}", "prompt": "/*Li Dashuiniu, who is in a certain period of time and has a well-developed digestive system, has been hungry recently. One day in class, when he was dizzy and hungry, a giant dining table of $n \\times m(n,m \\le 200)$ suddenly appeared in front of him, and he was on the midpoint below one side of the table. The table is divided into $n \\times m$ small squares, each of which contains a circular giant plate filled with food that Li Dashuiniu has longed for. Li Dashuiniu has divided all the food on the table according to the energy he can provide (some of which are negative because eating will cause diarrhea). He decided to eat from his position to the other side of the table, but he has a habit of only eating the food in the plate in front of him or in the front left or front right.\n\nAs Li Dashuiniu is too hungry to think and he wants to obtain the maximum energy, he has entrusted this problem to you.\n\nThe starting point of each set of data is below the middle position of the last row!\n\ninput_format:\nThe first behavior m n (n is odd), the Li big buffalo starts at the bottom of the middle of the last row\n\nThis is followed by m\\*n digital matrix.\n\nThere are m lines, each containing n numbers. Numbers are separated by Spaces. Represents the energy provided by the food on the plate on the grid.\n\nThe numbers are all integers.\n\noutput_format:\nA number, the maximum energy value that you find.\n*/\n\n#include<sstream>\n#include<stdlib.h>\n#include<algorithm>\n#include<math.h>\n#include<stdio.h>\n#include<vector>\n#include<string>\n#include<climits>\n#include<cstring>\n#include<iostream>\nusing namespace std;\n\n             \nstring solution(string std_in){\n    istringstream iss(std_in);\n             ", "constraints": "快吃！快吃！快吃！\n", "samples": [["6 7\n16 4 3 12 6 0 3\n4 -5 6 7 0 0 2\n6 0 -1 -2 3 6 8\n5 3 4 0 0 -2 7\n-1 7 4 0 7 -5 6\n0 -1 3 4 12 4 2\n", "41\n"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}}
{"task_id": "P8752", "title": "[蓝桥杯 2021 省 B2] 特殊年份", "difficulty": "basic", "nl": "This year is 2021, which is a very special number. Its thousand digit and ten digit are equal, and its unit digit is greater than its hundred digit by $1$. We call years that meet this condition special years. \n\nPlease input 5 years and calculate how many of them are special years.", "code": "#include<bits/stdc++.h>\nusing namespace std;\nint main()\n{\n\tint ans=0;\n\tfor(int i=1;i<=5;i++)\n\t{\n\t\tchar a,b,c,d;\n\t\tcin>>a>>b>>c>>d;\n\t\tif(a==c&&d-b==1) ans++;\n\t}\n\tcout<<ans;\n   \treturn 0;\n}", "step": ["Create a variable called ans and initialize it to 0.", "For each set of characters (looping 5 times):", "Read in 4 characters from the user.", "Check if the first and third characters are the same and if the second character is one less than the fourth character.", "If the condition is satisfied, increment the ans variable by 1.", "Output the value of the ans variable."], "nl_cn": "今年是 2021 年，2021 这个数字非常特殊, 它的千位和十位相等, 个位比百位大 $1$，我们称满足这样条件的年份为特殊年份。\n\n输入 $5$ 个年份，请计算这里面有多少个特殊年份。\n", "test_cases": [{"input": "2019\n2021\n1920\n2120\n9899", "output": "2"}, {"input": "2222\n2021\n3333\n4444\n5555\n", "output": "1"}, {"input": "1234\n4321\n5432\n6543\n7654\n", "output": "0"}, {"input": "1999\n2000\n2001\n2002\n2003\n", "output": "0"}, {"input": "1987\n1988\n1989\n1990\n1991\n", "output": "0"}, {"input": "1901\n1902\n1903\n1904\n1905\n", "output": "0"}, {"input": "1717\n1718\n1719\n1720\n1721\n", "output": "1"}, {"input": "3030\n2023\n4050\n2009\n3004", "output": "0"}, {"input": "7777\n8888\n6666\n5555\n1111", "output": "0"}, {"input": "1998\n2000\n2021\n2030\n2022", "output": "1"}, {"input": "2021\n2021\n2021\n2021\n2021", "output": "5"}, {"input": "2023\n2024\n2025\n2026\n2027", "output": "0"}, {"input": "1000\n1099\n2021\n5000\n6000", "output": "1"}, {"input": "1878\n1867\n1859\n1873\n1880", "output": "0"}, {"input": "1899\n2011\n2012\n2013\n2014", "output": "0"}, {"input": "2021\n2122\n2020\n2121\n2000", "output": "2"}, {"input": "3102\n3050\n3080\n2110\n3103", "output": "0"}, {"input": "4005\n5500\n2025\n8000\n9000", "output": "0"}, {"input": "2021\n2022\n2023\n2024\n2025", "output": "1"}, {"input": "2020\n2021\n2022\n2023\n2024\n", "output": "1"}, {"input": "1980\n1990\n2000\n2010\n2020\n", "output": "0"}, {"input": "2030\n2031\n2032\n2033\n2034\n", "output": "0"}, {"input": "2100\n2101\n2102\n2103\n2104\n", "output": "0"}, {"input": "2050\n2051\n2052\n2053\n2054\n", "output": "0"}, {"input": "2110\n2111\n2112\n2113\n2114\n", "output": "0"}, {"input": "2090\n2091\n2092\n2093\n2094\n", "output": "0"}, {"input": "2015\n2016\n2017\n2018\n2019\n", "output": "0"}, {"input": "2095\n2096\n2097\n2098\n2099\n", "output": "0"}, {"input": "1947\n1950\n1953\n1956\n1959\n", "output": "0"}, {"input": "2001\n2010\n2021\n2030\n2041\n", "output": "1"}, {"input": "1964\n1966\n1968\n1970\n1972\n", "output": "0"}, {"input": "1910\n2121\n2322\n2523\n2724\n", "output": "0"}, {"input": "2065\n2067\n2069\n2071\n2073\n", "output": "0"}, {"input": "3030\n3131\n3232\n3333\n3434\n", "output": "0"}, {"input": "2087\n3087\n4087\n5087\n6087\n", "output": "0"}, {"input": "2020\n2021\n2000\n2010\n2022\n", "output": "1"}, {"input": "2100\n2101\n2354\n2376\n2019\n", "output": "0"}, {"input": "1925\n1930\n1935\n1940\n1945\n", "output": "0"}, {"input": "1919\n1921\n1923\n1925\n1927\n", "output": "0"}, {"input": "1911\n1913\n1915\n1917\n1919\n", "output": "0"}, {"input": "2921\n2922\n2923\n2924\n2925\n", "output": "0"}, {"input": "1912\n1913\n1914\n1915\n1916\n", "output": "0"}], "test": "#undef NDEBUG\n#include<assert.h>\nint main(){\n    assert(solution(\"2019\\n2021\\n1920\\n2120\\n9899\") == \"2\");\n    assert(solution(\"2222\\n2021\\n3333\\n4444\\n5555\\n\") == \"1\");\n    assert(solution(\"1234\\n4321\\n5432\\n6543\\n7654\\n\") == \"0\");\n    assert(solution(\"1999\\n2000\\n2001\\n2002\\n2003\\n\") == \"0\");\n    assert(solution(\"1987\\n1988\\n1989\\n1990\\n1991\\n\") == \"0\");\n    assert(solution(\"1901\\n1902\\n1903\\n1904\\n1905\\n\") == \"0\");\n    assert(solution(\"1717\\n1718\\n1719\\n1720\\n1721\\n\") == \"1\");\n    assert(solution(\"3030\\n2023\\n4050\\n2009\\n3004\") == \"0\");\n    assert(solution(\"7777\\n8888\\n6666\\n5555\\n1111\") == \"0\");\n    assert(solution(\"1998\\n2000\\n2021\\n2030\\n2022\") == \"1\");\n    assert(solution(\"2021\\n2021\\n2021\\n2021\\n2021\") == \"5\");\n    assert(solution(\"2023\\n2024\\n2025\\n2026\\n2027\") == \"0\");\n    assert(solution(\"1000\\n1099\\n2021\\n5000\\n6000\") == \"1\");\n    assert(solution(\"1878\\n1867\\n1859\\n1873\\n1880\") == \"0\");\n    assert(solution(\"1899\\n2011\\n2012\\n2013\\n2014\") == \"0\");\n    assert(solution(\"2021\\n2122\\n2020\\n2121\\n2000\") == \"2\");\n    assert(solution(\"3102\\n3050\\n3080\\n2110\\n3103\") == \"0\");\n    assert(solution(\"4005\\n5500\\n2025\\n8000\\n9000\") == \"0\");\n    assert(solution(\"2021\\n2022\\n2023\\n2024\\n2025\") == \"1\");\n    assert(solution(\"2020\\n2021\\n2022\\n2023\\n2024\\n\") == \"1\");\n    assert(solution(\"1980\\n1990\\n2000\\n2010\\n2020\\n\") == \"0\");\n    assert(solution(\"2030\\n2031\\n2032\\n2033\\n2034\\n\") == \"0\");\n    assert(solution(\"2100\\n2101\\n2102\\n2103\\n2104\\n\") == \"0\");\n    assert(solution(\"2050\\n2051\\n2052\\n2053\\n2054\\n\") == \"0\");\n    assert(solution(\"2110\\n2111\\n2112\\n2113\\n2114\\n\") == \"0\");\n    assert(solution(\"2090\\n2091\\n2092\\n2093\\n2094\\n\") == \"0\");\n    assert(solution(\"2015\\n2016\\n2017\\n2018\\n2019\\n\") == \"0\");\n    assert(solution(\"2095\\n2096\\n2097\\n2098\\n2099\\n\") == \"0\");\n    assert(solution(\"1947\\n1950\\n1953\\n1956\\n1959\\n\") == \"0\");\n    assert(solution(\"2001\\n2010\\n2021\\n2030\\n2041\\n\") == \"1\");\n    assert(solution(\"1964\\n1966\\n1968\\n1970\\n1972\\n\") == \"0\");\n    assert(solution(\"1910\\n2121\\n2322\\n2523\\n2724\\n\") == \"0\");\n    assert(solution(\"2065\\n2067\\n2069\\n2071\\n2073\\n\") == \"0\");\n    assert(solution(\"3030\\n3131\\n3232\\n3333\\n3434\\n\") == \"0\");\n    assert(solution(\"2087\\n3087\\n4087\\n5087\\n6087\\n\") == \"0\");\n    assert(solution(\"2020\\n2021\\n2000\\n2010\\n2022\\n\") == \"1\");\n    assert(solution(\"2100\\n2101\\n2354\\n2376\\n2019\\n\") == \"0\");\n    assert(solution(\"1925\\n1930\\n1935\\n1940\\n1945\\n\") == \"0\");\n    assert(solution(\"1919\\n1921\\n1923\\n1925\\n1927\\n\") == \"0\");\n    assert(solution(\"1911\\n1913\\n1915\\n1917\\n1919\\n\") == \"0\");\n    assert(solution(\"2921\\n2922\\n2923\\n2924\\n2925\\n\") == \"0\");\n    assert(solution(\"1912\\n1913\\n1914\\n1915\\n1916\\n\") == \"0\");\n    return 0; \n}", "prompt": "/*This year is 2021, which is a very special number. Its thousand digit and ten digit are equal, and its unit digit is greater than its hundred digit by $1$. We call years that meet this condition special years. \n\nPlease input 5 years and calculate how many of them are special years.\n\ninput_format:\nEnter a $5$line with a $4$decimal number (ranging from $1000 to $9999) to represent a year.\n\noutput_format:\nOutput an integer indicating how many special years there are out of the entered $5$years.\n*/\n\n#include<sstream>\n#include<stdlib.h>\n#include<algorithm>\n#include<math.h>\n#include<stdio.h>\n#include<vector>\n#include<string>\n#include<climits>\n#include<cstring>\n#include<iostream>\nusing namespace std;\n\n             \nstring solution(string std_in){\n    istringstream iss(std_in);\n             ", "constraints": "**【样例说明】** \n\n2021 和 9899 是特殊年份，其它不是特殊年份。 \n\n蓝桥杯 2021 第二轮省赛 B 组 F 题。", "samples": [["2019\n2021\n1920\n2120\n9899", "2"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072]}}
{"task_id": "P5087", "title": "数学", "difficulty": "challenge", "nl": "Xiaoben is obsessed with multiplication. His favorite thing to do is to take K numbers from a sequence of N elements (Note: each element can only be taken once, but taking different elements with same value is allowed), and then calculate the product of these K numbers as the score of this combination. \n\nXiaoben wants to try all these combinations and calculate the sum of scores of all of them. But he also needs to prepare for the mock competition to crush us rookies, so he can only assign this task to you. \n\nXiaoben (in some aspects) is still very kind, so you don't need to use high-precision calculation. Just output the answer modulo 10^9+7.", "code": "#include<bits/stdc++.h>\nusing namespace std;\nlong long f[100010],a[100010],n,k;\nint main() {\n\tcin>>n>>k;\n\tfor(int i=1;i<=n;i++) scanf(\"%d\",&a[i]);\n\tf[0]=1;//这一点很重要，不要忘了\n\tfor(int i=1;i<=n;i++) {\n\t\tfor(int j=k;j>=0;j--) {\n\t\t\tf[j]=(f[j]+f[j-1]*a[i])%1000000007;\n\t\t}\n\t}\n\tcout<<f[k];\n\treturn 0;\n}", "step": ["Initialize variables including an array f and read input n and k", "Read array a", "Set f[0] to 1", "Loop through i from 1 to n and loop through j from k to 0", "Update f[j] with a formula involving f[j] and a[i]", "Print the value of f[k]"], "nl_cn": "小奔热衷于乘法，他最喜欢做的事情是：从一个有 $N$ 个元素的序列里取出 $K$ 个数，（注意：不能取同一个元素好几次，取不同但是值相同的元素则是允许的）\n然后算出这$K$个数的积作为这个组合的分数。\n\n小奔想试遍所有的这些组合，然后算出所有这些组合的分数之和。但是他还要\n出模拟赛虐爆我们这些蒟蒻，所以他只好把这个任务交给了你。\n\n小奔（~~在某些方面~~）还是很仁慈的，所以你不用写高精度，只要输出答案膜 $10^9+7$ 的结果就可以了。", "test_cases": [{"input": "3 3\n1 1 1", "output": "1"}, {"input": "4 3\n1 1 1 2", "output": "7"}, {"input": "0 0\n", "output": "1"}, {"input": "5 1\n2 2 2 2 2", "output": "10"}, {"input": "2 2\n5 6", "output": "30"}, {"input": "5 5\n1 1 1 1 1", "output": "1"}, {"input": "2 1\n9 9", "output": "18"}, {"input": "3 3\n9 9 9", "output": "729"}, {"input": "4 1\n2 2 2 2", "output": "8"}, {"input": "1 1\n5\n", "output": "5"}, {"input": "4 4\n1 2 3 4\n", "output": "24"}, {"input": "2 1\n10 5\n", "output": "15"}, {"input": "3 1\n9 8 7\n", "output": "24"}, {"input": "1 1\n1000000\n", "output": "1000000"}, {"input": "2 2\n10 20\n", "output": "200"}, {"input": "10 10\n1 1 1 1 1 1 1 1 1 1\n", "output": "1"}], "test": "#undef NDEBUG\n#include<assert.h>\nint main(){\n    assert(solution(\"3 3\\n1 1 1\") == \"1\");\n    assert(solution(\"4 3\\n1 1 1 2\") == \"7\");\n    assert(solution(\"0 0\\n\") == \"1\");\n    assert(solution(\"5 1\\n2 2 2 2 2\") == \"10\");\n    assert(solution(\"2 2\\n5 6\") == \"30\");\n    assert(solution(\"5 5\\n1 1 1 1 1\") == \"1\");\n    assert(solution(\"2 1\\n9 9\") == \"18\");\n    assert(solution(\"3 3\\n9 9 9\") == \"729\");\n    assert(solution(\"4 1\\n2 2 2 2\") == \"8\");\n    assert(solution(\"1 1\\n5\\n\") == \"5\");\n    assert(solution(\"4 4\\n1 2 3 4\\n\") == \"24\");\n    assert(solution(\"2 1\\n10 5\\n\") == \"15\");\n    assert(solution(\"3 1\\n9 8 7\\n\") == \"24\");\n    assert(solution(\"1 1\\n1000000\\n\") == \"1000000\");\n    assert(solution(\"2 2\\n10 20\\n\") == \"200\");\n    assert(solution(\"10 10\\n1 1 1 1 1 1 1 1 1 1\\n\") == \"1\");\n    return 0; \n}", "prompt": "/*Xiaoben is obsessed with multiplication. His favorite thing to do is to take K numbers from a sequence of N elements (Note: each element can only be taken once, but taking different elements with same value is allowed), and then calculate the product of these K numbers as the score of this combination. \n\nXiaoben wants to try all these combinations and calculate the sum of scores of all of them. But he also needs to prepare for the mock competition to crush us rookies, so he can only assign this task to you. \n\nXiaoben (in some aspects) is still very kind, so you don't need to use high-precision calculation. Just output the answer modulo 10^9+7.\n\ninput_format:\nThe first line has two integers $N$and $K$.\n\nThe second row of $N$integers $A_i$describes the sequence.\n\noutput_format:\nA line with an integer represents the answer.\n*/\n\n#include<sstream>\n#include<stdlib.h>\n#include<algorithm>\n#include<math.h>\n#include<stdio.h>\n#include<vector>\n#include<string>\n#include<climits>\n#include<cstring>\n#include<iostream>\nusing namespace std;\n\n             \nstring solution(string std_in){\n    istringstream iss(std_in);\n             ", "constraints": "#### 样例#2解释：\n\n```小奔```可以取```{A[1],A[2],A[3]},{A[1],A[2],A[4]},{A[1],A[3],A[4]},{A[2],A[3],A[4]}```四种组合，它们的分值分别是$1,2,2,2$。加起来就是$7$。\n\n#### 数据范围：\n\n对于10%的数据，$N\\le 5000,K\\le 2$；\n\n对于30%的数据，$N\\le 10^5,K\\le 3$；\n\n对于50%的数据，$N\\le 10^5,K\\le 5$；\n\n对于100%的数据，$1\\le N\\le 10^5,1\\le K \\le 300 \\& \\& K\\le N,1\\le A[i]\\le 10^8$。", "samples": [["3 3\n1 1 1", "1"], ["4 3\n1 1 1 2", "7"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}}
{"task_id": "P7042", "title": "「MCOI-03」正方", "difficulty": "basic", "nl": "Given a square, find the number of points inside the square that satisfy the following condition: the ratio of the areas formed by dividing the square into four parts by the four vertices is $a:b:c:d$ (where $a$, $b$, $c$, $d$ are not necessarily in order).\n\nFor example, in the following figure, a point $E$ that divides the square into four parts with areas in the ratio of $a:b:c:d$ satisfies the condition. Since order does not matter, the ratio $d:b:a:c$ is also valid. However, $E$ is not the unique solution. You need to output the number of solutions.\n\n\n\nThere are $q$ sets of queries in total due to the curiosity of S, Q, U, A, R and E.", "code": "#include<iostream>\nusing namespace std;\nint main(){\n    int n;\n    cin>>n;\n    for(int i=1;i<=n;i++){\n        unsigned long long a,b,c,d;\n        cin>>a>>b>>c>>d;\n        if(a==b&&a==c&&a==d&&b==c&&b==d&&c==d) cout<<1<<endl;\n        else if(a+b==c+d||a+c==b+d||a+d==b+c){\n            if(a==b||a==c||a==d||b==c||b==d||c==d) cout<<4<<endl;\n            else if(a!=b||a!=c||a!=d||b!=c||b!=d||c!=d) cout<<8<<endl;\n        }\n        else cout<<0<<endl;\n    }\n    return 0;\n}", "step": ["Take integer input n", "For i in range 1 to n, take 4 integers a, b, c, d as input", "If all four inputs are equal, output 1", "Else if the sum of any two inputs is equal to the sum of another two, check for four or eight sides, output accordingly", "Else, output 0", "Repeat for all n inputs"], "nl_cn": "给定一个正方形，求有多少个正方形内的点满足与正方形四个顶点划分出来的四块面积的比为 $a:b:c:d$。四个数不分顺序。\n\n比如如下图所示假设一个点 E 使得分成的四个三角形的面积之比为 $a:b:c:d$，那么这个点 E 就符合要求。因为不分顺序，所以分出来的比是 $d:b:a:c$ 也可以。但是点 E 不是唯一解，你要输出的是解的个数。\n\n\n\n因为小 S 和小 Q 和小 U 和小 A 和小 R 和小 E 很喜欢询问，所以本题给定了 $q$ 组询问。", "test_cases": [{"input": "3\n1 3 3 1\n2 4 7 8\n2 3 1 4", "output": "4\n0\n8"}, {"input": "1 1 1 2\n", "output": "0"}, {"input": "1\n5 5 5 5", "output": "1"}, {"input": "3\n1 2 1 2\n3 4 4 3\n5 5 5 5", "output": "4\n4\n1"}, {"input": "2\n5 2 3 4\n8 8 8 8", "output": "8\n1"}, {"input": "1\n7 5 3 8", "output": "0"}, {"input": "1\n5 3 7 2", "output": "0"}, {"input": "1 2 2 3\n", "output": "0"}, {"input": "1 1 2 2\n", "output": "0"}, {"input": "1 2 3 4\n", "output": "0"}], "test": "#undef NDEBUG\n#include<assert.h>\nint main(){\n    assert(solution(\"3\\n1 3 3 1\\n2 4 7 8\\n2 3 1 4\") == \"4\\n0\\n8\");\n    assert(solution(\"1 1 1 2\\n\") == \"0\");\n    assert(solution(\"1\\n5 5 5 5\") == \"1\");\n    assert(solution(\"3\\n1 2 1 2\\n3 4 4 3\\n5 5 5 5\") == \"4\\n4\\n1\");\n    assert(solution(\"2\\n5 2 3 4\\n8 8 8 8\") == \"8\\n1\");\n    assert(solution(\"1\\n7 5 3 8\") == \"0\");\n    assert(solution(\"1\\n5 3 7 2\") == \"0\");\n    assert(solution(\"1 2 2 3\\n\") == \"0\");\n    assert(solution(\"1 1 2 2\\n\") == \"0\");\n    assert(solution(\"1 2 3 4\\n\") == \"0\");\n    return 0; \n}", "prompt": "/*Given a square, find the number of points inside the square that satisfy the following condition: the ratio of the areas formed by dividing the square into four parts by the four vertices is $a:b:c:d$ (where $a$, $b$, $c$, $d$ are not necessarily in order).\n\nFor example, in the following figure, a point $E$ that divides the square into four parts with areas in the ratio of $a:b:c:d$ satisfies the condition. Since order does not matter, the ratio $d:b:a:c$ is also valid. However, $E$ is not the unique solution. You need to output the number of solutions.\n\n\n\nThere are $q$ sets of queries in total due to the curiosity of S, Q, U, A, R and E.\n\ninput_format:\nAn integer $q$in the first line represents the number of queries.\nNext line $q$each has four integers $a,b,c,d$.\n\noutput_format:\n$q One integer per line represents the answer.\n*/\n\n#include<sstream>\n#include<stdlib.h>\n#include<algorithm>\n#include<math.h>\n#include<stdio.h>\n#include<vector>\n#include<string>\n#include<climits>\n#include<cstring>\n#include<iostream>\nusing namespace std;\n\n             \nstring solution(string std_in){\n    istringstream iss(std_in);\n             ", "constraints": "#### 数据规模与约定\n\n对于 $20\\%$ 的数据，$a=b=c=d$。    \n对于 $100\\%$ 的数据，$1 \\le a,b,c,d \\le 9 \\times 10^{18}$，$1 \\le q \\le 100$，不保证 $a:b:c:d$ 为最简比，不保证 $a,b,c,d$ 为升序。", "samples": [["3\n1 3 3 1\n2 4 7 8\n2 3 1 4", "4\n0\n8"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072]}}
{"task_id": "P3150", "title": "pb的游戏（1）", "difficulty": "basic", "nl": "The rules of the game are as follows: Each player can split a given number into two non-zero natural numbers, and then the other player chooses one of the two numbers. This process is repeated until one player is unable to split the number, and the other player wins.\n\nNow you are required to determine the winner of N games.\n\nFor each game, pb splits the number first. Output \"pb wins\" if pb wins, and \"zs wins\" if zs wins.\n\nNote: Both players are extremely smart.", "code": "#include <iostream>\nusing namespace std;\n\nint main()\n{\n\tint n, x;\n\tcin >> n;\n\twhile (n--) {\n\t\tcin >> x;\n\t\tif (x & 1) cout << \"zs wins\" << endl;\n\t\telse cout << \"pb wins\" << endl;\n\t}\n}", "step": ["Accept an integer n.", "Start a while loop which runs n times.", "Within the loop, take input of an integer x.", "Check if x is odd or even using bitwise operator &.", "If odd, print \"zs wins\".", "If even, print \"pb wins\"."], "nl_cn": "游戏规则是这样的：  每次一个人可以对给出的数进行分割，将其割成两个非零自然数，之后由另一个人选择留下两个数中的其中一个；之后由另一个人进行分割这个剩下的数，重复步骤……\n\n当一个人无法对数进行分割的时候游戏结束，另一个人获胜\n\n现在要你求出N次游戏的胜败\n\n每局由pb先进行分割，如果pb赢输出\"pb wins\" 如果zs赢输出\"zs wins\"\n\n注：双方都是绝顶聪明的\n", "test_cases": [{"input": "5\n1\n3\n7\n20\n5", "output": "zs wins\nzs wins\nzs wins\npb wins\nzs wins"}, {"input": "1\n1\n", "output": "zs wins"}, {"input": "1\n2\n", "output": "pb wins"}, {"input": "1\n3\n", "output": "zs wins"}, {"input": "1\n4\n", "output": "pb wins"}, {"input": "1\n5\n", "output": "zs wins"}, {"input": "1\n6\n", "output": "pb wins"}, {"input": "1\n7\n", "output": "zs wins"}, {"input": "1\n8\n", "output": "pb wins"}, {"input": "1\n9\n", "output": "zs wins"}, {"input": "1\n10\n", "output": "pb wins"}, {"input": "1\n11\n", "output": "zs wins"}, {"input": "1\n12\n", "output": "pb wins"}, {"input": "1\n13\n", "output": "zs wins"}, {"input": "1\n14\n", "output": "pb wins"}, {"input": "1\n15\n", "output": "zs wins"}, {"input": "1\n16\n", "output": "pb wins"}, {"input": "1\n17\n", "output": "zs wins"}, {"input": "1\n18\n", "output": "pb wins"}, {"input": "1\n19\n", "output": "zs wins"}, {"input": "1\n20\n", "output": "pb wins"}, {"input": "3\n2\n4\n6", "output": "pb wins\npb wins\npb wins"}, {"input": "2\n10\n13", "output": "pb wins\nzs wins"}, {"input": "3\n8\n21\n24", "output": "pb wins\nzs wins\npb wins"}, {"input": "2\n27\n30", "output": "zs wins\npb wins"}, {"input": "4\n32\n35\n38\n41", "output": "pb wins\nzs wins\npb wins\nzs wins"}, {"input": "3\n33\n36\n39", "output": "zs wins\npb wins\nzs wins"}, {"input": "1\n49", "output": "zs wins"}, {"input": "6\n52\n55\n58\n61\n64\n67", "output": "pb wins\nzs wins\npb wins\nzs wins\npb wins\nzs wins"}, {"input": "2\n78\n81", "output": "pb wins\nzs wins"}, {"input": "4\n84\n87\n90\n93", "output": "pb wins\nzs wins\npb wins\nzs wins"}, {"input": "3\n109\n112\n115", "output": "zs wins\npb wins\nzs wins"}, {"input": "2\n118\n121", "output": "pb wins\nzs wins"}, {"input": "1\n123", "output": "zs wins"}, {"input": "2\n1\n1\n", "output": "zs wins\nzs wins"}, {"input": "2\n1\n3\n", "output": "zs wins\nzs wins"}, {"input": "2\n1\n7\n", "output": "zs wins\nzs wins"}, {"input": "2\n1\n20\n", "output": "zs wins\npb wins"}, {"input": "2\n1\n5\n", "output": "zs wins\nzs wins"}, {"input": "3\n1\n1\n1\n", "output": "zs wins\nzs wins\nzs wins"}, {"input": "3\n1\n3\n7\n", "output": "zs wins\nzs wins\nzs wins"}, {"input": "3\n1\n20\n5\n", "output": "zs wins\npb wins\nzs wins"}, {"input": "4\n1\n5\n1\n3\n", "output": "zs wins\nzs wins\nzs wins\nzs wins"}, {"input": "4\n1\n1\n3\n7\n", "output": "zs wins\nzs wins\nzs wins\nzs wins"}, {"input": "4\n1\n7\n20\n5\n", "output": "zs wins\nzs wins\npb wins\nzs wins"}, {"input": "5\n1\n1\n1\n3\n7\n", "output": "zs wins\nzs wins\nzs wins\nzs wins\nzs wins"}, {"input": "5\n1\n1\n3\n7\n20\n", "output": "zs wins\nzs wins\nzs wins\nzs wins\npb wins"}, {"input": "6\n1\n1\n1\n3\n7\n20\n", "output": "zs wins\nzs wins\nzs wins\nzs wins\nzs wins\npb wins"}, {"input": "6\n1\n1\n3\n7\n20\n5\n", "output": "zs wins\nzs wins\nzs wins\nzs wins\npb wins\nzs wins"}, {"input": "2\n7\n20\n", "output": "zs wins\npb wins"}, {"input": "2\n5\n1\n", "output": "zs wins\nzs wins"}, {"input": "3\n20\n5\n1\n", "output": "pb wins\nzs wins\nzs wins"}, {"input": "4\n1\n3\n7\n20\n", "output": "zs wins\nzs wins\nzs wins\npb wins"}, {"input": "4\n5\n1\n3\n7\n", "output": "zs wins\nzs wins\nzs wins\nzs wins"}, {"input": "5\n20\n5\n1\n3\n7\n", "output": "pb wins\nzs wins\nzs wins\nzs wins\nzs wins"}, {"input": "6\n1\n3\n7\n20\n5\n1\n", "output": "zs wins\nzs wins\nzs wins\npb wins\nzs wins\nzs wins"}, {"input": "6\n5\n1\n3\n7\n20\n5\n", "output": "zs wins\nzs wins\nzs wins\nzs wins\npb wins\nzs wins"}, {"input": "7\n1\n3\n7\n20\n5\n1\n7\n", "output": "zs wins\nzs wins\nzs wins\npb wins\nzs wins\nzs wins\nzs wins"}, {"input": "7\n7\n20\n5\n1\n3\n7\n20\n", "output": "zs wins\npb wins\nzs wins\nzs wins\nzs wins\nzs wins\npb wins"}, {"input": "8\n1\n3\n7\n20\n5\n1\n7\n3\n", "output": "zs wins\nzs wins\nzs wins\npb wins\nzs wins\nzs wins\nzs wins\nzs wins"}, {"input": "8\n20\n5\n1\n3\n7\n20\n5\n1\n", "output": "pb wins\nzs wins\nzs wins\nzs wins\nzs wins\npb wins\nzs wins\nzs wins"}, {"input": "9\n1\n3\n7\n20\n5\n1\n7\n3\n7\n", "output": "zs wins\nzs wins\nzs wins\npb wins\nzs wins\nzs wins\nzs wins\nzs wins\nzs wins"}, {"input": "9\n5\n1\n3\n7\n20\n5\n1\n7\n3\n", "output": "zs wins\nzs wins\nzs wins\nzs wins\npb wins\nzs wins\nzs wins\nzs wins\nzs wins"}, {"input": "10\n1\n3\n7\n20\n5\n1\n7\n3\n7\n20\n", "output": "zs wins\nzs wins\nzs wins\npb wins\nzs wins\nzs wins\nzs wins\nzs wins\nzs wins\npb wins"}], "test": "#undef NDEBUG\n#include<assert.h>\nint main(){\n    assert(solution(\"5\\n1\\n3\\n7\\n20\\n5\") == \"zs wins\\nzs wins\\nzs wins\\npb wins\\nzs wins\");\n    assert(solution(\"1\\n1\\n\") == \"zs wins\");\n    assert(solution(\"1\\n2\\n\") == \"pb wins\");\n    assert(solution(\"1\\n3\\n\") == \"zs wins\");\n    assert(solution(\"1\\n4\\n\") == \"pb wins\");\n    assert(solution(\"1\\n5\\n\") == \"zs wins\");\n    assert(solution(\"1\\n6\\n\") == \"pb wins\");\n    assert(solution(\"1\\n7\\n\") == \"zs wins\");\n    assert(solution(\"1\\n8\\n\") == \"pb wins\");\n    assert(solution(\"1\\n9\\n\") == \"zs wins\");\n    assert(solution(\"1\\n10\\n\") == \"pb wins\");\n    assert(solution(\"1\\n11\\n\") == \"zs wins\");\n    assert(solution(\"1\\n12\\n\") == \"pb wins\");\n    assert(solution(\"1\\n13\\n\") == \"zs wins\");\n    assert(solution(\"1\\n14\\n\") == \"pb wins\");\n    assert(solution(\"1\\n15\\n\") == \"zs wins\");\n    assert(solution(\"1\\n16\\n\") == \"pb wins\");\n    assert(solution(\"1\\n17\\n\") == \"zs wins\");\n    assert(solution(\"1\\n18\\n\") == \"pb wins\");\n    assert(solution(\"1\\n19\\n\") == \"zs wins\");\n    assert(solution(\"1\\n20\\n\") == \"pb wins\");\n    assert(solution(\"3\\n2\\n4\\n6\") == \"pb wins\\npb wins\\npb wins\");\n    assert(solution(\"2\\n10\\n13\") == \"pb wins\\nzs wins\");\n    assert(solution(\"3\\n8\\n21\\n24\") == \"pb wins\\nzs wins\\npb wins\");\n    assert(solution(\"2\\n27\\n30\") == \"zs wins\\npb wins\");\n    assert(solution(\"4\\n32\\n35\\n38\\n41\") == \"pb wins\\nzs wins\\npb wins\\nzs wins\");\n    assert(solution(\"3\\n33\\n36\\n39\") == \"zs wins\\npb wins\\nzs wins\");\n    assert(solution(\"1\\n49\") == \"zs wins\");\n    assert(solution(\"6\\n52\\n55\\n58\\n61\\n64\\n67\") == \"pb wins\\nzs wins\\npb wins\\nzs wins\\npb wins\\nzs wins\");\n    assert(solution(\"2\\n78\\n81\") == \"pb wins\\nzs wins\");\n    assert(solution(\"4\\n84\\n87\\n90\\n93\") == \"pb wins\\nzs wins\\npb wins\\nzs wins\");\n    assert(solution(\"3\\n109\\n112\\n115\") == \"zs wins\\npb wins\\nzs wins\");\n    assert(solution(\"2\\n118\\n121\") == \"pb wins\\nzs wins\");\n    assert(solution(\"1\\n123\") == \"zs wins\");\n    assert(solution(\"2\\n1\\n1\\n\") == \"zs wins\\nzs wins\");\n    assert(solution(\"2\\n1\\n3\\n\") == \"zs wins\\nzs wins\");\n    assert(solution(\"2\\n1\\n7\\n\") == \"zs wins\\nzs wins\");\n    assert(solution(\"2\\n1\\n20\\n\") == \"zs wins\\npb wins\");\n    assert(solution(\"2\\n1\\n5\\n\") == \"zs wins\\nzs wins\");\n    assert(solution(\"3\\n1\\n1\\n1\\n\") == \"zs wins\\nzs wins\\nzs wins\");\n    assert(solution(\"3\\n1\\n3\\n7\\n\") == \"zs wins\\nzs wins\\nzs wins\");\n    assert(solution(\"3\\n1\\n20\\n5\\n\") == \"zs wins\\npb wins\\nzs wins\");\n    assert(solution(\"4\\n1\\n5\\n1\\n3\\n\") == \"zs wins\\nzs wins\\nzs wins\\nzs wins\");\n    assert(solution(\"4\\n1\\n1\\n3\\n7\\n\") == \"zs wins\\nzs wins\\nzs wins\\nzs wins\");\n    assert(solution(\"4\\n1\\n7\\n20\\n5\\n\") == \"zs wins\\nzs wins\\npb wins\\nzs wins\");\n    assert(solution(\"5\\n1\\n1\\n1\\n3\\n7\\n\") == \"zs wins\\nzs wins\\nzs wins\\nzs wins\\nzs wins\");\n    assert(solution(\"5\\n1\\n1\\n3\\n7\\n20\\n\") == \"zs wins\\nzs wins\\nzs wins\\nzs wins\\npb wins\");\n    assert(solution(\"6\\n1\\n1\\n1\\n3\\n7\\n20\\n\") == \"zs wins\\nzs wins\\nzs wins\\nzs wins\\nzs wins\\npb wins\");\n    assert(solution(\"6\\n1\\n1\\n3\\n7\\n20\\n5\\n\") == \"zs wins\\nzs wins\\nzs wins\\nzs wins\\npb wins\\nzs wins\");\n    assert(solution(\"2\\n7\\n20\\n\") == \"zs wins\\npb wins\");\n    assert(solution(\"2\\n5\\n1\\n\") == \"zs wins\\nzs wins\");\n    assert(solution(\"3\\n20\\n5\\n1\\n\") == \"pb wins\\nzs wins\\nzs wins\");\n    assert(solution(\"4\\n1\\n3\\n7\\n20\\n\") == \"zs wins\\nzs wins\\nzs wins\\npb wins\");\n    assert(solution(\"4\\n5\\n1\\n3\\n7\\n\") == \"zs wins\\nzs wins\\nzs wins\\nzs wins\");\n    assert(solution(\"5\\n20\\n5\\n1\\n3\\n7\\n\") == \"pb wins\\nzs wins\\nzs wins\\nzs wins\\nzs wins\");\n    assert(solution(\"6\\n1\\n3\\n7\\n20\\n5\\n1\\n\") == \"zs wins\\nzs wins\\nzs wins\\npb wins\\nzs wins\\nzs wins\");\n    assert(solution(\"6\\n5\\n1\\n3\\n7\\n20\\n5\\n\") == \"zs wins\\nzs wins\\nzs wins\\nzs wins\\npb wins\\nzs wins\");\n    assert(solution(\"7\\n1\\n3\\n7\\n20\\n5\\n1\\n7\\n\") == \"zs wins\\nzs wins\\nzs wins\\npb wins\\nzs wins\\nzs wins\\nzs wins\");\n    assert(solution(\"7\\n7\\n20\\n5\\n1\\n3\\n7\\n20\\n\") == \"zs wins\\npb wins\\nzs wins\\nzs wins\\nzs wins\\nzs wins\\npb wins\");\n    assert(solution(\"8\\n1\\n3\\n7\\n20\\n5\\n1\\n7\\n3\\n\") == \"zs wins\\nzs wins\\nzs wins\\npb wins\\nzs wins\\nzs wins\\nzs wins\\nzs wins\");\n    assert(solution(\"8\\n20\\n5\\n1\\n3\\n7\\n20\\n5\\n1\\n\") == \"pb wins\\nzs wins\\nzs wins\\nzs wins\\nzs wins\\npb wins\\nzs wins\\nzs wins\");\n    assert(solution(\"9\\n1\\n3\\n7\\n20\\n5\\n1\\n7\\n3\\n7\\n\") == \"zs wins\\nzs wins\\nzs wins\\npb wins\\nzs wins\\nzs wins\\nzs wins\\nzs wins\\nzs wins\");\n    assert(solution(\"9\\n5\\n1\\n3\\n7\\n20\\n5\\n1\\n7\\n3\\n\") == \"zs wins\\nzs wins\\nzs wins\\nzs wins\\npb wins\\nzs wins\\nzs wins\\nzs wins\\nzs wins\");\n    assert(solution(\"10\\n1\\n3\\n7\\n20\\n5\\n1\\n7\\n3\\n7\\n20\\n\") == \"zs wins\\nzs wins\\nzs wins\\npb wins\\nzs wins\\nzs wins\\nzs wins\\nzs wins\\nzs wins\\npb wins\");\n    return 0; \n}", "prompt": "/*The rules of the game are as follows: Each player can split a given number into two non-zero natural numbers, and then the other player chooses one of the two numbers. This process is repeated until one player is unable to split the number, and the other player wins.\n\nNow you are required to determine the winner of N games.\n\nFor each game, pb splits the number first. Output \"pb wins\" if pb wins, and \"zs wins\" if zs wins.\n\nNote: Both players are extremely smart.\n\ninput_format:\nThe number N in the first row indicates the number of data groups\n\nAfter N lines, each line has a number M, indicating the initial number of each game\n\noutput_format:\nThere are N lines, each with a string of characters representing the result of the game\n*/\n\n#include<sstream>\n#include<stdlib.h>\n#include<algorithm>\n#include<math.h>\n#include<stdio.h>\n#include<vector>\n#include<string>\n#include<climits>\n#include<cstring>\n#include<iostream>\nusing namespace std;\n\n             \nstring solution(string std_in){\n    istringstream iss(std_in);\n             ", "constraints": "对于全部数据，$1<N<50$，$1\\le M\\le 10^9$。\n", "samples": [["5\n1\n3\n7\n20\n5", "zs wins\nzs wins\nzs wins\npb wins\nzs wins\n"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}}
{"task_id": "P7686", "title": "[CEOI2005] Multi-key Sorting", "difficulty": "challenge", "nl": "Consider a table with rows and columns. Columns are numbered from $1$ to $C$. For simplicity, a project in the table is a string composed of lowercase letters.  \n![TuLi]  \nYou will be given a Sort($k$) operation on this type of table: Sort($k$) sorts the rows of the table according to the order of the values in column $k$ (without changing the order of columns). The sorting is stable, i.e., rows with equal values in column $k$ keep their original order. For example, applying Sort($2$) on table $1$ yields table $2$.  \nWe are interested in sequences of such sorting operations. These operations are applied successively to the same table. For example, applying the sequence Sort($2$); Sort($1$) on table $1$ yields table $3$.  \nIf two sequences of sorting operations have the same effect on any table, they are called equivalent. For example, Sort($2$); Sort($2$); Sort($1$) is equivalent to Sort($2$); Sort($1$). However, it is not equivalent to Sort($1$); Sort($2$) because their effect on table $1$ is different.", "code": "#include<bits/stdc++.h>\nusing namespace std;\nint n,c;\nmap<int,int>mp;\nvector<pair<int,int> >v;\nbool cmp(pair<int,int> a,pair<int,int> b){\n\treturn a.second<b.second;\n}//自定义排序\nint main(){\n\tcin>>c>>n;\n\tfor(int i=1;i<=n;i++){\n\t\tint x;\n\t\tcin>>x;\n\t\tmp[x]=i;\n\t}\n\tmap<int,int>::iterator it;\n\tfor(it=mp.begin();it!=mp.end();it++)\n\t\tv.push_back(pair<int,int>(it->first,it->second));//遍历map,将值存入vector\n\tsort(v.begin(),v.end(),cmp);//排序\n\tcout<<v.size()<<\"\\n\";\n\tfor(auto&it:v)\n\t\tcout<<it.first<<\" \";\n\treturn 0;\n}", "step": ["Read the input values for two integers from standard input.", "Use a loop to iterate through the array and count the number of unique integers.", "If an integer is not in the 'last' array, increment the count.", "Store the index of the last occurrence of the integer in the 'last' array.", "Print the count of unique integers.", "Print the unique integers found, by checking if the current index is the same as the 'last' index for a given integer."], "nl_cn": "考虑一个包含行和列的表。列从 $1$ 到 $C$ 编号。为简单起见，表中的项目是由小写字母组成的字符串。  \n![TuLi]  \n您将获得对此类表的 Sort($k$) 操作：Sort($k$) 按照列 $k$ 中的值的顺序对表的行进行排序（而列的顺序不会改变）。排序是稳定的，即在第 $k$ 列中具有相等值的行保持其原始顺序。例如，将 Sort($2$) 应用于表 $1$ 会产生表 $2$。  \n我们对此类排序操作的序列感兴趣。这些操作依次应用于同一个表。例如，应用序列 Sort($2$)；Sort($1$) 到表 $1$ 产生表 $3$。  \n如果两个排序操作序列对于任何表具有相同的效果，则它们被称为等效。例如，Sort($2$)；Sort($2$)；Sort($1$) 等效于 Sort($2$)；Sort($1$)。但是，它不等效于 Sort($1$)；Sort($2$)，因为对表 $1$ 的影响不同。", "test_cases": [{"input": "4 6\n1 2 1 2 3 3", "output": "3\n1 2 3"}, {"input": "4 6\n4 4 3 2 1 1\n", "output": "4\n4 3 2 1"}, {"input": "3 6\n2 3 2 3 1 1\n", "output": "3\n2 3 1"}, {"input": "2 5\n1 2 2 1 2\n", "output": "2\n1 2"}, {"input": "4 8\n4 4 3 2 1 1 2 1\n", "output": "4\n4 3 2 1"}, {"input": "2 7\n2 1 2 1 1 2 1\n", "output": "2\n2 1"}, {"input": "2 8\n1 2 2 1 1 2 1 2\n", "output": "2\n1 2"}, {"input": "2 2\n2 2\n", "output": "1\n2"}, {"input": "1 3\n1 1 1\n", "output": "1\n1"}, {"input": "3 6\n1 2 1 2 1 2\n", "output": "2\n1 2"}, {"input": "2 4\n1 2 1 2\n", "output": "2\n1 2"}, {"input": "4 2\n4 3\n", "output": "2\n4 3"}, {"input": "1 1\n1\n", "output": "1\n1"}, {"input": "2 3\n1 2 2\n", "output": "2\n1 2"}, {"input": "4 3\n3 2 1\n", "output": "3\n3 2 1"}, {"input": "5 6\n1 1 2 2 3 4\n", "output": "4\n1 2 3 4"}, {"input": "2 4\n1 1 1 1\n", "output": "1\n1"}, {"input": "3 7\n1 2 3 4 5 6 7\n", "output": "7\n1 2 3 4 5 6 7"}, {"input": "4 8\n1 1 2 2 3 3 4 4\n", "output": "4\n1 2 3 4"}, {"input": "5 5\n1 1 1 1 1\n", "output": "1\n1"}, {"input": "2 4\n1 2 3 4\n", "output": "4\n1 2 3 4"}], "test": "#undef NDEBUG\n#include<assert.h>\nint main(){\n    assert(solution(\"4 6\\n1 2 1 2 3 3\") == \"3\\n1 2 3\");\n    assert(solution(\"4 6\\n4 4 3 2 1 1\\n\") == \"4\\n4 3 2 1\");\n    assert(solution(\"3 6\\n2 3 2 3 1 1\\n\") == \"3\\n2 3 1\");\n    assert(solution(\"2 5\\n1 2 2 1 2\\n\") == \"2\\n1 2\");\n    assert(solution(\"4 8\\n4 4 3 2 1 1 2 1\\n\") == \"4\\n4 3 2 1\");\n    assert(solution(\"2 7\\n2 1 2 1 1 2 1\\n\") == \"2\\n2 1\");\n    assert(solution(\"2 8\\n1 2 2 1 1 2 1 2\\n\") == \"2\\n1 2\");\n    assert(solution(\"2 2\\n2 2\\n\") == \"1\\n2\");\n    assert(solution(\"1 3\\n1 1 1\\n\") == \"1\\n1\");\n    assert(solution(\"3 6\\n1 2 1 2 1 2\\n\") == \"2\\n1 2\");\n    assert(solution(\"2 4\\n1 2 1 2\\n\") == \"2\\n1 2\");\n    assert(solution(\"4 2\\n4 3\\n\") == \"2\\n4 3\");\n    assert(solution(\"1 1\\n1\\n\") == \"1\\n1\");\n    assert(solution(\"2 3\\n1 2 2\\n\") == \"2\\n1 2\");\n    assert(solution(\"4 3\\n3 2 1\\n\") == \"3\\n3 2 1\");\n    assert(solution(\"5 6\\n1 1 2 2 3 4\\n\") == \"4\\n1 2 3 4\");\n    assert(solution(\"2 4\\n1 1 1 1\\n\") == \"1\\n1\");\n    assert(solution(\"3 7\\n1 2 3 4 5 6 7\\n\") == \"7\\n1 2 3 4 5 6 7\");\n    assert(solution(\"4 8\\n1 1 2 2 3 3 4 4\\n\") == \"4\\n1 2 3 4\");\n    assert(solution(\"5 5\\n1 1 1 1 1\\n\") == \"1\\n1\");\n    assert(solution(\"2 4\\n1 2 3 4\\n\") == \"4\\n1 2 3 4\");\n    return 0; \n}", "prompt": "/*Consider a table with rows and columns. Columns are numbered from $1$ to $C$. For simplicity, a project in the table is a string composed of lowercase letters.  \n![TuLi]  \nYou will be given a Sort($k$) operation on this type of table: Sort($k$) sorts the rows of the table according to the order of the values in column $k$ (without changing the order of columns). The sorting is stable, i.e., rows with equal values in column $k$ keep their original order. For example, applying Sort($2$) on table $1$ yields table $2$.  \nWe are interested in sequences of such sorting operations. These operations are applied successively to the same table. For example, applying the sequence Sort($2$); Sort($1$) on table $1$ yields table $3$.  \nIf two sequences of sorting operations have the same effect on any table, they are called equivalent. For example, Sort($2$); Sort($2$); Sort($1$) is equivalent to Sort($2$); Sort($1$). However, it is not equivalent to Sort($1$); Sort($2$) because their effect on table $1$ is different.\n\ninput_format:\nThe first line contains two integers, $C$and $N$. $C$is the number of columns, and $N$is the sort operand. The second line contains $N$integers, $k_i$. It defines the order of the Sort operations Sort($k_1$); $\\cdots$; Sort($k_N$).\n\noutput_format:\nThe first line contains an integer $M$, which is the length of the shortest equivalent sorting operation sequence of the input operation sequence. The second line contains $M$integers, representing its shortest sequence of operations.\n*/\n\n#include<sstream>\n#include<stdlib.h>\n#include<algorithm>\n#include<math.h>\n#include<stdio.h>\n#include<vector>\n#include<string>\n#include<climits>\n#include<cstring>\n#include<iostream>\nusing namespace std;\n\n             \nstring solution(string std_in){\n    istringstream iss(std_in);\n             ", "constraints": "#### 数据规模与约定  \n对于 $100 \\%$ 的数据，$1 \\leq C \\leq 10^6$，$1 \\leq N \\leq 3×10^6$，$1 \\leq k_i \\leq C$。  \n#### 题目说明  \n来源于 CENTRAL-EUROPEAN OLYMPIAD IN INFORMATICS 2005 的 Multi-key Sorting。  \n由 @[求学的企鹅](/user/271784) 翻译整理。", "samples": [["4 6\n1 2 1 2 3 3", "3\n1 2 3"]], "limits": {"time": [6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000], "memory": [10240, 10240, 10240, 10240, 10240, 10240, 10240, 10240, 10240, 10240, 10240, 10240, 10240, 10240, 10240, 10240]}}
{"task_id": "P7222", "title": "[RC-04] 信息学竞赛", "difficulty": "basic", "nl": "Today, Xiao R has learned about the concept of complementary angles in mathematics. Can you help him calculate the complementary angle of a given angle?\n\nThe formula for calculating the complementary angle is as follows:\n$$\\angle B=90\\degree -\\angle A$$\nWhere A is the given angle and B is the complementary angle you need to calculate.", "code": "#include<bits/stdc++.h>\nusing namespace std;\nlong long a;\nint main()\n{\n\tcin>>a;\n\tcout<<90-a<<endl;\n\treturn 0;\n}", "step": ["Declare an integer variable x.", "Read a value and store it in x.", "Subtract x from the value 90.", "Output the result of the subtraction.", "Return 0 to indicate successful execution."], "nl_cn": "小 R 今天学习了余角有关的数学知识，请你帮帮他计算一个角的余角吧！\n\n一个角的余角的计算公式如下：\n\n$$\\angle B=90\\degree -\\angle A$$\n\n其中 A 是给出的角，B 是你要计算的角。", "test_cases": [{"input": "100", "output": "-10"}, {"input": "90", "output": "0"}, {"input": "45", "output": "45"}, {"input": "30", "output": "60"}, {"input": "60", "output": "30"}, {"input": "75", "output": "15"}, {"input": "10", "output": "80"}, {"input": "120", "output": "-30"}, {"input": "135", "output": "-45"}, {"input": "20", "output": "70"}, {"input": "50", "output": "40"}, {"input": "165", "output": "-75"}, {"input": "170", "output": "-80"}, {"input": "80", "output": "10"}, {"input": "25", "output": "65"}, {"input": "15", "output": "75"}, {"input": "5", "output": "85"}, {"input": "115", "output": "-25"}, {"input": "85", "output": "5"}, {"input": "40", "output": "50"}, {"input": "55", "output": "35"}, {"input": "65", "output": "25"}, {"input": "35", "output": "55"}, {"input": "70", "output": "20"}, {"input": "0", "output": "90"}, {"input": "180\n", "output": "-90"}, {"input": "89\n", "output": "1"}, {"input": "150\n", "output": "-60"}, {"input": "59\n", "output": "31"}, {"input": "74\n", "output": "16"}, {"input": "169\n", "output": "-79"}, {"input": "1\n", "output": "89"}, {"input": "12\n", "output": "78"}, {"input": "95\n", "output": "-5"}, {"input": "110\n", "output": "-20"}, {"input": "125\n", "output": "-35"}, {"input": "140\n", "output": "-50"}], "test": "#undef NDEBUG\n#include<assert.h>\nint main(){\n    assert(solution(\"100\") == \"-10\");\n    assert(solution(\"90\") == \"0\");\n    assert(solution(\"45\") == \"45\");\n    assert(solution(\"30\") == \"60\");\n    assert(solution(\"60\") == \"30\");\n    assert(solution(\"75\") == \"15\");\n    assert(solution(\"10\") == \"80\");\n    assert(solution(\"120\") == \"-30\");\n    assert(solution(\"135\") == \"-45\");\n    assert(solution(\"20\") == \"70\");\n    assert(solution(\"50\") == \"40\");\n    assert(solution(\"165\") == \"-75\");\n    assert(solution(\"170\") == \"-80\");\n    assert(solution(\"80\") == \"10\");\n    assert(solution(\"25\") == \"65\");\n    assert(solution(\"15\") == \"75\");\n    assert(solution(\"5\") == \"85\");\n    assert(solution(\"115\") == \"-25\");\n    assert(solution(\"85\") == \"5\");\n    assert(solution(\"40\") == \"50\");\n    assert(solution(\"55\") == \"35\");\n    assert(solution(\"65\") == \"25\");\n    assert(solution(\"35\") == \"55\");\n    assert(solution(\"70\") == \"20\");\n    assert(solution(\"0\") == \"90\");\n    assert(solution(\"180\\n\") == \"-90\");\n    assert(solution(\"89\\n\") == \"1\");\n    assert(solution(\"150\\n\") == \"-60\");\n    assert(solution(\"59\\n\") == \"31\");\n    assert(solution(\"74\\n\") == \"16\");\n    assert(solution(\"169\\n\") == \"-79\");\n    assert(solution(\"1\\n\") == \"89\");\n    assert(solution(\"12\\n\") == \"78\");\n    assert(solution(\"95\\n\") == \"-5\");\n    assert(solution(\"110\\n\") == \"-20\");\n    assert(solution(\"125\\n\") == \"-35\");\n    assert(solution(\"140\\n\") == \"-50\");\n    return 0; \n}", "prompt": "/*Today, Xiao R has learned about the concept of complementary angles in mathematics. Can you help him calculate the complementary angle of a given angle?\n\nThe formula for calculating the complementary angle is as follows:\n$$\\angle B=90\\degree -\\angle A$$\nWhere A is the given angle and B is the complementary angle you need to calculate.\n\ninput_format:\nA row with an integer $x$indicates that $\\angle A=x\\degree$.\n\noutput_format:\nA row with an integer $y$indicates that $\\angle B=y\\degree$. You need to follow the formula exactly.\n*/\n\n#include<sstream>\n#include<stdlib.h>\n#include<algorithm>\n#include<math.h>\n#include<stdio.h>\n#include<vector>\n#include<string>\n#include<climits>\n#include<cstring>\n#include<iostream>\nusing namespace std;\n\n             \nstring solution(string std_in){\n    istringstream iss(std_in);\n             ", "constraints": "对于 $100\\%$ 的数据，$x$ 在 C++ 语言的 `int` 范围内。即，$x\\in[-2^{31},2^{31}-1]$。", "samples": [["100", "-10"]], "limits": {"time": [1000, 1000], "memory": [128000, 128000]}}
{"task_id": "P1496", "title": "火烧赤壁", "difficulty": "challenge", "nl": "Given the starting and ending points of each section that is on fire, please calculate the total length of the burned area.", "code": "#include<iostream>\n#include<cstdio>\n#include<algorithm>\nusing namespace std;\nint main()\n{\n    int n;\n    cin>>n;\n    long long a[20001],b[20001],l=0;//a数组存储起点，b数组存储终点，l表示最终长度\n    for(int i=0;i<n;i++)\n        cin>>a[i]>>b[i];//输入\n    sort(a,a+n);\n    sort(b,b+n);//由于起点终点的顺序对答案不产生影响，对a数组和b数组进行排序\n    for(int i=0;i<n;i++)\n    {\n        l+=b[i]-a[i];//加上当前线段长度\n        if(i+1<n)//如果这条线段不是最后一条线段\n            if(b[i]>a[i+1])//如果这条线段与前一条线段有重复\n                l-=b[i]-a[i+1];//减去重复部分\n    }\n    cout<<l;//输出\n    return 0;\n}", "step": ["Read in integer input n.", "Read in arrays a and b of size n.", "Sort arrays a and b.", "Loop through arrays to calculate the difference between b[i] and a[i], adding it to a running total l.", "If b[i] is greater than a[i+1], subtract the difference between them from l.", "Output the value l."], "nl_cn": "给定每个起火部分的起点和终点，请你求出燃烧位置的长度之和。", "test_cases": [{"input": "3\n-1 1\n5 11\n2 9", "output": "11"}, {"input": "2\n0 5\n10 15\n", "output": "10"}, {"input": "1\n-10 -5\n", "output": "5"}, {"input": "0\n", "output": "0"}, {"input": "4\n1 3\n5 7\n9 11\n13 15\n", "output": "8"}, {"input": "1\n1 5\n", "output": "4"}, {"input": "1\n0 0\n", "output": "0"}, {"input": "2\n-1 1\n3 5", "output": "4"}, {"input": "1\n-10 10\n", "output": "20"}, {"input": "5\n-4 6\n-2 -1\n0 3\n7 9\n11 12\n", "output": "13"}, {"input": "1\n-5 0\n", "output": "5"}, {"input": "3\n-5 10\n2 6\n12 20\n", "output": "23"}, {"input": "1\n-1000000 1000000\n", "output": "2000000"}, {"input": "1\n1 1\n", "output": "0"}, {"input": "4\n1 3\n2 4\n3 5\n4 6\n", "output": "5"}, {"input": "2\n-100 100\n-200 200\n", "output": "400"}, {"input": "3\n-1000 100\n-200 2000\n-30000 30000\n", "output": "60000"}, {"input": "1\n1 1000000000\n", "output": "999999999"}, {"input": "3\n10 20\n30 40\n50 60\n", "output": "30"}, {"input": "2\n-10 -5\n-3 2\n", "output": "10"}, {"input": "1\n-1000000000 1000000000\n", "output": "2000000000"}, {"input": "6\n1 2\n2 3\n3 4\n4 5\n5 6\n6 7\n", "output": "6"}, {"input": "2\n-10 10\n-20 20\n", "output": "40"}, {"input": "1\n100000 1000000\n", "output": "900000"}, {"input": "2\n-5 5\n-10 -2\n", "output": "15"}, {"input": "2\n-5 10\n-3 7\n", "output": "15"}, {"input": "1\n0 100\n", "output": "100"}, {"input": "2\n1 2\n4 5\n", "output": "2"}, {"input": "4\n-2 2\n-4 3\n-6 6\n-8 8\n", "output": "16"}, {"input": "3\n2 3\n0 2\n-1 4\n", "output": "5"}, {"input": "2\n0 1000\n-1000 0\n", "output": "2000"}], "test": "#undef NDEBUG\n#include<assert.h>\nint main(){\n    assert(solution(\"3\\n-1 1\\n5 11\\n2 9\") == \"11\");\n    assert(solution(\"2\\n0 5\\n10 15\\n\") == \"10\");\n    assert(solution(\"1\\n-10 -5\\n\") == \"5\");\n    assert(solution(\"0\\n\") == \"0\");\n    assert(solution(\"4\\n1 3\\n5 7\\n9 11\\n13 15\\n\") == \"8\");\n    assert(solution(\"1\\n1 5\\n\") == \"4\");\n    assert(solution(\"1\\n0 0\\n\") == \"0\");\n    assert(solution(\"2\\n-1 1\\n3 5\") == \"4\");\n    assert(solution(\"1\\n-10 10\\n\") == \"20\");\n    assert(solution(\"5\\n-4 6\\n-2 -1\\n0 3\\n7 9\\n11 12\\n\") == \"13\");\n    assert(solution(\"1\\n-5 0\\n\") == \"5\");\n    assert(solution(\"3\\n-5 10\\n2 6\\n12 20\\n\") == \"23\");\n    assert(solution(\"1\\n-1000000 1000000\\n\") == \"2000000\");\n    assert(solution(\"1\\n1 1\\n\") == \"0\");\n    assert(solution(\"4\\n1 3\\n2 4\\n3 5\\n4 6\\n\") == \"5\");\n    assert(solution(\"2\\n-100 100\\n-200 200\\n\") == \"400\");\n    assert(solution(\"3\\n-1000 100\\n-200 2000\\n-30000 30000\\n\") == \"60000\");\n    assert(solution(\"1\\n1 1000000000\\n\") == \"999999999\");\n    assert(solution(\"3\\n10 20\\n30 40\\n50 60\\n\") == \"30\");\n    assert(solution(\"2\\n-10 -5\\n-3 2\\n\") == \"10\");\n    assert(solution(\"1\\n-1000000000 1000000000\\n\") == \"2000000000\");\n    assert(solution(\"6\\n1 2\\n2 3\\n3 4\\n4 5\\n5 6\\n6 7\\n\") == \"6\");\n    assert(solution(\"2\\n-10 10\\n-20 20\\n\") == \"40\");\n    assert(solution(\"1\\n100000 1000000\\n\") == \"900000\");\n    assert(solution(\"2\\n-5 5\\n-10 -2\\n\") == \"15\");\n    assert(solution(\"2\\n-5 10\\n-3 7\\n\") == \"15\");\n    assert(solution(\"1\\n0 100\\n\") == \"100\");\n    assert(solution(\"2\\n1 2\\n4 5\\n\") == \"2\");\n    assert(solution(\"4\\n-2 2\\n-4 3\\n-6 6\\n-8 8\\n\") == \"16\");\n    assert(solution(\"3\\n2 3\\n0 2\\n-1 4\\n\") == \"5\");\n    assert(solution(\"2\\n0 1000\\n-1000 0\\n\") == \"2000\");\n    return 0; \n}", "prompt": "/*Given the starting and ending points of each section that is on fire, please calculate the total length of the burned area.\n\ninput_format:\nThe first line is an integer, indicating the number of fire messages $n$.\nNext is the $n$line, each line with two integers $a, b$, indicating the start and end of a fire location (** Note: left closed and right open **).\n\noutput_format:\nOutput a line with an integer representing the answer.\n*/\n\n#include<sstream>\n#include<stdlib.h>\n#include<algorithm>\n#include<math.h>\n#include<stdio.h>\n#include<vector>\n#include<string>\n#include<climits>\n#include<cstring>\n#include<iostream>\nusing namespace std;\n\n             \nstring solution(string std_in){\n    istringstream iss(std_in);\n             ", "constraints": "### 数据规模与约定\n\n对于全部的测试点，保证 $1 \\leq n \\leq 2 \\times 10^4$，$-2^{31} \\leq a <  b \\lt 2^{31}$，且答案小于 $2^{31}$。\n\n\n", "samples": [["3\n-1 1\n5 11\n2 9", "11"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}}
{"task_id": "P6581", "title": "远大目标", "difficulty": "basic", "nl": "Given $O$, find the number of integers $A$ such that $|A|<O$.\n\nBecause little Z is too inexperienced, he is unable to handle even the condition of $|A|<|O|$, and could only attempt to study the problem with the condition of $|A|<O$.", "code": "#include <iostream>\nusing namespace std;\nint main()\n{\n    long long a;\n    cin >> a;\n    if(a <= 0) { cout << 0; return 0; }\n    unsigned long long b = a;\n    cout << 2 * b - 1;\n    return 0;\n}", "step": ["Declare a variable: 'a' as a long long integer", "Take input for 'a'", "If 'a' is less than or equal to 0, print 0 and return 0", "Declare a variable: 'b' as an unsigned long long integer and assign the value of 'a' to it", "Print the output as 2 times 'b' minus 1", "End the program"], "nl_cn": "给你 $O$，求出满足 $|A|<O$ 且 $A$ 为整数的 $A$ 的个数。 \n\n由于小 Z 太菜了，于是连 `|A|<|O|` 都不敢说了，只好来研究这 `|A|<O` 的问题。", "test_cases": [{"input": "3", "output": "5"}, {"input": "1145141919810", "output": "2290283839619"}, {"input": "12345", "output": "24689"}, {"input": "-1\n", "output": "0"}, {"input": "0\n", "output": "0"}, {"input": "1\n", "output": "1"}, {"input": "2\n", "output": "3"}, {"input": "4\n", "output": "7"}, {"input": "10\n", "output": "19"}, {"input": "100\n", "output": "199"}, {"input": "1000\n", "output": "1999"}, {"input": "10000\n", "output": "19999"}, {"input": "100000\n", "output": "199999"}, {"input": "1000000\n", "output": "1999999"}, {"input": "10000000\n", "output": "19999999"}, {"input": "100000000\n", "output": "199999999"}, {"input": "1000000000\n", "output": "1999999999"}, {"input": "10000000000\n", "output": "19999999999"}, {"input": "100000000000\n", "output": "199999999999"}, {"input": "1000000000000\n", "output": "1999999999999"}, {"input": "-5", "output": "0"}, {"input": "-20", "output": "0"}, {"input": "-500", "output": "0"}, {"input": "-10000", "output": "0"}, {"input": "50000", "output": "99999"}, {"input": "-100000", "output": "0"}, {"input": "-2", "output": "0"}, {"input": "500000", "output": "999999"}, {"input": "-1000000", "output": "0"}, {"input": "9999", "output": "19997"}, {"input": "-100", "output": "0"}, {"input": "5000000", "output": "9999999"}, {"input": "-10000000", "output": "0"}, {"input": "1234", "output": "2467"}, {"input": "-567", "output": "0"}, {"input": "-12345\n", "output": "0"}, {"input": "9876543210\n", "output": "19753086419"}, {"input": "999999999999\n", "output": "1999999999997"}, {"input": "999\n", "output": "1997"}, {"input": "987654321\n", "output": "1975308641"}, {"input": "-987654321\n", "output": "0"}, {"input": "-999999999999\n", "output": "0"}, {"input": "12345678987654321\n", "output": "24691357975308641"}, {"input": "-12345678987654321\n", "output": "0"}, {"input": "9876543219876543\n", "output": "19753086439753085"}, {"input": "-9876543219876543\n", "output": "0"}, {"input": "-1000000000000\n", "output": "0"}, {"input": "-123\n", "output": "0"}, {"input": "999999999\n", "output": "1999999997"}, {"input": "1234567890\n", "output": "2469135779"}, {"input": "-999\n", "output": "0"}, {"input": "-999999999\n", "output": "0"}, {"input": "-1000000000\n", "output": "0"}, {"input": "-1234567890\n", "output": "0"}, {"input": "-9876543210\n", "output": "0"}], "test": "#undef NDEBUG\n#include<assert.h>\nint main(){\n    assert(solution(\"3\") == \"5\");\n    assert(solution(\"1145141919810\") == \"2290283839619\");\n    assert(solution(\"12345\") == \"24689\");\n    assert(solution(\"-1\\n\") == \"0\");\n    assert(solution(\"0\\n\") == \"0\");\n    assert(solution(\"1\\n\") == \"1\");\n    assert(solution(\"2\\n\") == \"3\");\n    assert(solution(\"4\\n\") == \"7\");\n    assert(solution(\"10\\n\") == \"19\");\n    assert(solution(\"100\\n\") == \"199\");\n    assert(solution(\"1000\\n\") == \"1999\");\n    assert(solution(\"10000\\n\") == \"19999\");\n    assert(solution(\"100000\\n\") == \"199999\");\n    assert(solution(\"1000000\\n\") == \"1999999\");\n    assert(solution(\"10000000\\n\") == \"19999999\");\n    assert(solution(\"100000000\\n\") == \"199999999\");\n    assert(solution(\"1000000000\\n\") == \"1999999999\");\n    assert(solution(\"10000000000\\n\") == \"19999999999\");\n    assert(solution(\"100000000000\\n\") == \"199999999999\");\n    assert(solution(\"1000000000000\\n\") == \"1999999999999\");\n    assert(solution(\"-5\") == \"0\");\n    assert(solution(\"-20\") == \"0\");\n    assert(solution(\"-500\") == \"0\");\n    assert(solution(\"-10000\") == \"0\");\n    assert(solution(\"50000\") == \"99999\");\n    assert(solution(\"-100000\") == \"0\");\n    assert(solution(\"-2\") == \"0\");\n    assert(solution(\"500000\") == \"999999\");\n    assert(solution(\"-1000000\") == \"0\");\n    assert(solution(\"9999\") == \"19997\");\n    assert(solution(\"-100\") == \"0\");\n    assert(solution(\"5000000\") == \"9999999\");\n    assert(solution(\"-10000000\") == \"0\");\n    assert(solution(\"1234\") == \"2467\");\n    assert(solution(\"-567\") == \"0\");\n    assert(solution(\"-12345\\n\") == \"0\");\n    assert(solution(\"9876543210\\n\") == \"19753086419\");\n    assert(solution(\"999999999999\\n\") == \"1999999999997\");\n    assert(solution(\"999\\n\") == \"1997\");\n    assert(solution(\"987654321\\n\") == \"1975308641\");\n    assert(solution(\"-987654321\\n\") == \"0\");\n    assert(solution(\"-999999999999\\n\") == \"0\");\n    assert(solution(\"12345678987654321\\n\") == \"24691357975308641\");\n    assert(solution(\"-12345678987654321\\n\") == \"0\");\n    assert(solution(\"9876543219876543\\n\") == \"19753086439753085\");\n    assert(solution(\"-9876543219876543\\n\") == \"0\");\n    assert(solution(\"-1000000000000\\n\") == \"0\");\n    assert(solution(\"-123\\n\") == \"0\");\n    assert(solution(\"999999999\\n\") == \"1999999997\");\n    assert(solution(\"1234567890\\n\") == \"2469135779\");\n    assert(solution(\"-999\\n\") == \"0\");\n    assert(solution(\"-999999999\\n\") == \"0\");\n    assert(solution(\"-1000000000\\n\") == \"0\");\n    assert(solution(\"-1234567890\\n\") == \"0\");\n    assert(solution(\"-9876543210\\n\") == \"0\");\n    return 0; \n}", "prompt": "/*Given $O$, find the number of integers $A$ such that $|A|<O$.\n\nBecause little Z is too inexperienced, he is unable to handle even the condition of $|A|<|O|$, and could only attempt to study the problem with the condition of $|A|<O$.\n\ninput_format:\nOne line is an integer $O$.\n\noutput_format:\nOne line is an integer. The number of the integer $A$that meets the condition.\n*/\n\n#include<sstream>\n#include<stdlib.h>\n#include<algorithm>\n#include<math.h>\n#include<stdio.h>\n#include<vector>\n#include<string>\n#include<climits>\n#include<cstring>\n#include<iostream>\nusing namespace std;\n\n             \nstring solution(string std_in){\n    istringstream iss(std_in);\n             ", "constraints": "**样例 1 解释**\n\n$A$ 的取值可以是 $-1, 0$ 和 $1$。\n\n**数据规模和约定**\n\n* Subtask 1（30 分）：$0 \\le |O| \\le 2^{10}-1$；\n* Subtask 2（60 分）：$0 \\le |O| \\le 2^{31}-1$；\n* Subtask 3（10 分）：$0 \\le |O| \\le 2^{63}-1$。\n\n$|O|$ 表示 $O$ 的绝对值。\n\n**提示**\n\n如果您不了解绝对值是什么，可以理解为：\n\n$$|x| = \\begin{cases} x & (x > 0) \\\\ 0 & (x = 0) \\\\ -x & (x < 0)\\end{cases}$$\n\n原idea: [Meatherm](https://www.luogu.com.cn/user/108949)", "samples": [["3", "5"], ["1145141919810", "2290283839619"], ["12345", "24689"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072, 131072]}}
{"task_id": "P1548", "title": "[NOIP1997 普及组] 棋盘问题", "difficulty": "basic", "nl": "Given a chessboard of $N \\times M$ squares $(1 \\leq N \\leq 100, 1 \\leq M \\leq 100)$, find how many squares and rectangles (excluding squares) are there on the chessboard.\n\nFor example, when $N=2, M=3$: \n\nThere are 8 squares in total: 6 squares with a side length of 1, and 2 squares with a side length of 2.\n\nThere are 10 rectangles in total:\n\n4 rectangles with the size of $2 \\times 1$: \n\n3 rectangles with the size of $1 \\times 2$: \n\n2 rectangles with the size of $3 \\times 1$: \n\n1 rectangle with the size of $3 \\times 2$: \n\nFor the example above, given input $2,3$, the output should be $8,10$.", "code": "#include<bits/stdc++.h>\nusing namespace std;\nint m,n,z,c,i,j,k,l;    //z用来记正方形个数，c来记长方形\nint main()\n{\n\tcin>>m>>n;           //输入\n\tfor(i=0;i<=m;i++)    //枚举\n\tfor(j=0;j<=n;j++)    //枚举\n\tfor(k=i+1;k<=m;k++)  //还是枚举\n\tfor(l=j+1;l<=n;l++)  //仍然是枚举\n\tif(k-i==l-j)z++;     //是正方形\n\telse c++;            //是长方形\n\tcout<<z<<\" \"<<c;     //输出\n}", "step": ["Declare variables n, m, s1, and s2.", "Read values of n and m from user input.", "Calculate s2 using the formula ((m+1)*(n+1)*m*n)/4.", "Calculate s1 using a for loop that iterates m and n simultaneously as they decrease to 1, and adds their product to s1 in each iteration.", "Output the values of s1 and s2-s1."], "nl_cn": "设有一个$N \\times M$方格的棋盘$(1≤N≤100,1≤M≤100)$\n\n求出该棋盘中包含有多少个正方形、多少个长方形（不包括正方形）。\n\n例如：当 $N=2, M=3$时：  \n\n   \n正方形的个数有$8$个：即边长为$1$的正方形有$6$个；\n\n边长为$2$的正方形有$2$个。\n\n长方形的个数有$10$个：\n\n即  \n\n$2 \\times 1$的长方形有$4$个  \n\n$1 \\times 2$的长方形有$3$个： \n\n$3 \\times 1$的长方形有$2$个： \n\n$3 \\times 2$的长方形有$1$个： \n\n如上例：输入：$2,3$\n\n输出：$8,10$\n", "test_cases": [{"input": "2 3", "output": "8 10"}, {"input": "1 1\n", "output": "1 0"}, {"input": "10 1\n", "output": "10 45"}, {"input": "1 5\n", "output": "5 10"}], "test": "#undef NDEBUG\n#include<assert.h>\nint main(){\n    assert(solution(\"2 3\") == \"8 10\");\n    assert(solution(\"1 1\\n\") == \"1 0\");\n    assert(solution(\"10 1\\n\") == \"10 45\");\n    assert(solution(\"1 5\\n\") == \"5 10\");\n    return 0; \n}", "prompt": "/*Given a chessboard of $N \\times M$ squares $(1 \\leq N \\leq 100, 1 \\leq M \\leq 100)$, find how many squares and rectangles (excluding squares) are there on the chessboard.\n\nFor example, when $N=2, M=3$: \n\nThere are 8 squares in total: 6 squares with a side length of 1, and 2 squares with a side length of 2.\n\nThere are 10 rectangles in total:\n\n4 rectangles with the size of $2 \\times 1$: \n\n3 rectangles with the size of $1 \\times 2$: \n\n2 rectangles with the size of $3 \\times 1$: \n\n1 rectangle with the size of $3 \\times 2$: \n\nFor the example above, given input $2,3$, the output should be $8,10$.\n\ninput_format:\n$N,M$\n\noutput_format:\nThe number of squares and the number of rectangles\n*/\n\n#include<sstream>\n#include<stdlib.h>\n#include<algorithm>\n#include<math.h>\n#include<stdio.h>\n#include<vector>\n#include<string>\n#include<climits>\n#include<cstring>\n#include<iostream>\nusing namespace std;\n\n             \nstring solution(string std_in){\n    istringstream iss(std_in);\n             ", "constraints": "", "samples": [["2 3", "8 10"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000]}}
{"task_id": "P3471", "title": "[POI2008]POC-Trains", "difficulty": "advanced", "nl": "The Trains of Colour Parade will start tomorrow in Byteotia.\n\nIntense preparations are already underway at the auxiliary tracks of the station. The station has $n$ parallel tracks numbered from 1 to $n$. Train number $i$ occupies the $i^{th}$ track.\n\nEach train consists of $l$ cars, and each car is painted in one of 26 colors (denoted by non-capital letters of the English alphabet).\n\nTwo trains are considered to be the same if their corresponding cars are painted in the same color.\n\nDuring the parade, a crane will swap certain pairs of cars, but the actual parade will take place tomorrow.\n\nToday, the train dispatcher Byteasar watched the dress rehearsal closely and even recorded the sequence of car swaps.\n\nByteasar dislikes trains that look too alike.\n\nFor each train $p$, he wants to calculate the maximum number of trains that can look like train $p$ at any given moment.\n\n## Task\n\nWrite a program that:\n\n- reads the descriptions of the trains occupying the tracks and the sequence of car swaps\n- for each train, determines the maximum number of trains that look like it at any given moment\n- writes out the results.", "code": "#include <bits/stdc++.h>\nusing namespace std;\nconst int bn{2579},b6e0{25165843};\nconst int N(1e3),M(1e5);\nint sz[b6e0],res[N];\nint lst[N];\nint F[b6e0];\nstruct node\n{\n\tint fa,mx;\n\tnode(int _fa=0,int _mx=0):fa{_fa},mx{_mx}{}\n};\nvector<node> dsu[N+M];int cnt;\nint h[N],pl[N],l;\nstring s[N];\nint Find(int u,int x)\n{\n\tif (dsu[u][x].fa==x) return dsu[u][x].mx;\n\tdsu[u][x].mx=max(dsu[u][x].mx,Find(u,dsu[u][x].fa));\n\tdsu[u][x].fa=dsu[u][dsu[u][x].fa].fa;\n\treturn dsu[u][x].mx;\n}\nvoid fresh(int x,int p,int n)\n{\n    h[x]=(h[x]+1LL*pl[l-p-1]*(n-s[x][p])%b6e0)%b6e0;\n    if (h[x]<0) h[x]=(h[x]+b6e0)%b6e0;\n    s[x][p]=n;\n}\nvoid upd(int x)\n{\n\tint H{h[x]};\n\tif (!F[H]) F[H]=cnt++;\n\tlst[x]=dsu[F[H]].size();\n\t++sz[H];\n    if (lst[x]) dsu[F[H]][lst[x]-1].fa=lst[x];\n\tdsu[F[H]].emplace_back(lst[x],sz[H]);\n\t\n}\nint main()\n{\n    int n,m;cin>>n>>l>>m;\n    for (int i{0};i<n;++i)\n    {\n        cin>>s[i];\n        for (char c:s[i])\n            h[i]=(1LL*h[i]*bn%b6e0+c-'a')%b6e0;\n        upd(i); \n    }\n    pl[0]=1;\n    for (int i{1};i<=l;++i)\n        pl[i]=1LL*pl[i-1]*bn%b6e0;\n    while (m--)\n    {\n        int a,i,b,j;\n        scanf(\"%d %d %d %d\",&a,&i,&b,&j);\n        --a;--i;--b;--j;\n        --sz[h[a]];res[a]=max(res[a],Find(F[h[a]],lst[a]));\n        if (a!=b) --sz[h[b]],res[b]=max(res[b],Find(F[h[b]],lst[b]));\n        char x{s[a][i]},y{s[b][j]};\n        fresh(a,i,y);fresh(b,j,x);\n        upd(a);if (a!=b) upd(b);\n    }\n    for (int i{0};i<n;++i)\n        cout<<max(res[i],Find(F[h[i]],lst[i]))<<endl;\n    return 0;\n}", "step": ["Initialize constants and variables.", "Read in the input.", "For each string, hash the string and add it to the disjoint set.", "Update the hash and the disjoint set for each operation, and keep track of the maximum subsequence length.", "Print the maximum subsequence length for each string.", "Terminate the program."], "nl_cn": "The Trains of Colour Parade begins tomorrow in Byteotia.\n\nIntense preparations are already in progress at the station's auxiliary tracks. There are $n$ parallel tracks at the station, numbered from $1$ to $n$. The train no. $i$ occupies the $i^{th}$ track.\n\nEvery train consists of $l$ cars and each car is painted with one of 26 colours (denoted by non-capital letters of the English alphabet).\n\nWe say that two trains look the same, if their corresponding cars are painted the same colour.\n\nThroughout the parade a crane will switch places of certain pairs of cars. The real parade, however, will take place tomorrow.\n\nToday the train dispatcher, Byteasar, watched the general rehearsal    closely. He even wrote down the sequence of car swaps.\n\nByteasar particularly dislikes many trains looking the same.\n\nFor each train $p$ he would like to calculate the maximum number    of trains that at some moment look the same as the train $p$ at the very same moment.\n\n## Task\n\nWrite a programme that:\n\n- reads descriptions of the trains occupying tracks and the sequence of car swaps,\n\n- for each train determines the maximum number of trains that look the same as it at certain moment,\n\n- writes out the result.\n\n\n给出n个字符串，长度均为len；\n\n有m次操作，每次将两个字符交换；\n\n求每个字符串在任何时点上，与相同的它最多的字符串个数；\n", "test_cases": [{"input": "5 6 7\nababbd\nabbbbd\naaabad\ncaabbd\ncabaad\n2 3 5 4\n5 3 5 5\n3 5 2 2\n1 2 4 3\n2 2 5 1\n1 1 3 3\n4 1 5 6\n", "output": "3\n3\n3\n2\n3"}, {"input": "2 2 1\naaa\naaa\n1 1 2 2\n", "output": "2\n2"}, {"input": "1 1 0\na\n", "output": "1"}, {"input": "2 1 0\na\nb\n", "output": "1\n1"}, {"input": "3 2 2\naaa\naaa\naaa\n1 1 2 2\n1 1 3 1\n", "output": "3\n3\n3"}, {"input": "1 3 0\naaa\n", "output": "1"}, {"input": "1 1 0\nd\n", "output": "1"}, {"input": "2 2 0\nda\nde\n", "output": "1\n1"}, {"input": "3 2 0\naaa\nbbb\nccc\n", "output": "1\n1\n1"}, {"input": "3 4 0\nabcde\nbcdea\ncdeab\n", "output": "1\n1\n1"}, {"input": "5 5 0\nabcde\nfghij\nklmno\npqrst\nuwxyz\n", "output": "1\n1\n1\n1\n1"}, {"input": "6 6 0\nabcdef\nghijkl\nmnopqr\nstuvwx\nyzabcd\nefghij\n", "output": "1\n1\n1\n1\n1\n1"}, {"input": "7 7 0\nabcdefg\nhijklmn\nopqrstu\nvwxyzab\ncdefghi\njklmnop\nqrstuvwxyz\n", "output": "1\n1\n1\n1\n1\n1\n1"}, {"input": "2 3 1\nabc\naaa\n1 1 2 2\n", "output": "1\n1"}, {"input": "3 3 1\naaa\nbbb\nccc\n1 1 2 2\n", "output": "1\n1\n1"}, {"input": "3 5 3\ncdeaa\nboabb\ncupse\n2 2 2 4\n1 3 2 4\n2 1 3 3\n", "output": "1\n1\n1"}, {"input": "3 4 3\ndatw\ndsum\nabzz\n3 3 2 2\n1 2 3 4\n1 3 2 1\n", "output": "1\n1\n1"}, {"input": "5 3 4\naas\nfbcd\nezrt\ndzpt\naaf\n4 2 4 1\n3 3 5 1\n2 1 3 1\n2 3 3 3\n", "output": "1\n1\n1\n1\n1"}, {"input": "3 1 2\na\nb\nc\n1 1 2 1\n2 1 3 1\n", "output": "1\n1\n1"}, {"input": "2 1 1\na\nb\n1 1 2 1\n", "output": "1\n1"}, {"input": "5 4 4\nasbc\nxasb\ntflk\ncrqj\ncase\n3 2 5 1\n3 3 5 1\n1 4 2 3\n4 3 4 4\n", "output": "1\n1\n1\n1\n1"}, {"input": "3 2 2\naaa\naaa\naaa\n1 1 2 2\n3 2 1 2\n", "output": "3\n3\n3"}, {"input": "2 3 2\naaa\naaa\n1 2 2 1\n2 3 1 2\n", "output": "2\n2"}, {"input": "4 3 2\naaa\naaa\naaa\naaa\n1 1 4 3\n2 2 3 1\n", "output": "4\n4\n4\n4"}, {"input": "3 3 2\nabc\nabc\nabc\n1 2 2 3\n3 3 1 2\n", "output": "3\n3\n3"}, {"input": "5 5 3\nabcde\nabcde\nabcde\nabcde\nabcde\n1 1 5 5\n2 2 4 4\n3 3 5 1\n", "output": "5\n5\n5\n5\n5"}, {"input": "3 2 3\nab\nab\nab\n1 1 2 2\n3 1 1 2\n2 2 1 1\n", "output": "3\n3\n3"}], "test": "#undef NDEBUG\n#include<assert.h>\nint main(){\n    assert(solution(\"5 6 7\\nababbd\\nabbbbd\\naaabad\\ncaabbd\\ncabaad\\n2 3 5 4\\n5 3 5 5\\n3 5 2 2\\n1 2 4 3\\n2 2 5 1\\n1 1 3 3\\n4 1 5 6\\n\") == \"3\\n3\\n3\\n2\\n3\");\n    assert(solution(\"2 2 1\\naaa\\naaa\\n1 1 2 2\\n\") == \"2\\n2\");\n    assert(solution(\"1 1 0\\na\\n\") == \"1\");\n    assert(solution(\"2 1 0\\na\\nb\\n\") == \"1\\n1\");\n    assert(solution(\"3 2 2\\naaa\\naaa\\naaa\\n1 1 2 2\\n1 1 3 1\\n\") == \"3\\n3\\n3\");\n    assert(solution(\"1 3 0\\naaa\\n\") == \"1\");\n    assert(solution(\"1 1 0\\nd\\n\") == \"1\");\n    assert(solution(\"2 2 0\\nda\\nde\\n\") == \"1\\n1\");\n    assert(solution(\"3 2 0\\naaa\\nbbb\\nccc\\n\") == \"1\\n1\\n1\");\n    assert(solution(\"3 4 0\\nabcde\\nbcdea\\ncdeab\\n\") == \"1\\n1\\n1\");\n    assert(solution(\"5 5 0\\nabcde\\nfghij\\nklmno\\npqrst\\nuwxyz\\n\") == \"1\\n1\\n1\\n1\\n1\");\n    assert(solution(\"6 6 0\\nabcdef\\nghijkl\\nmnopqr\\nstuvwx\\nyzabcd\\nefghij\\n\") == \"1\\n1\\n1\\n1\\n1\\n1\");\n    assert(solution(\"7 7 0\\nabcdefg\\nhijklmn\\nopqrstu\\nvwxyzab\\ncdefghi\\njklmnop\\nqrstuvwxyz\\n\") == \"1\\n1\\n1\\n1\\n1\\n1\\n1\");\n    assert(solution(\"2 3 1\\nabc\\naaa\\n1 1 2 2\\n\") == \"1\\n1\");\n    assert(solution(\"3 3 1\\naaa\\nbbb\\nccc\\n1 1 2 2\\n\") == \"1\\n1\\n1\");\n    assert(solution(\"3 5 3\\ncdeaa\\nboabb\\ncupse\\n2 2 2 4\\n1 3 2 4\\n2 1 3 3\\n\") == \"1\\n1\\n1\");\n    assert(solution(\"3 4 3\\ndatw\\ndsum\\nabzz\\n3 3 2 2\\n1 2 3 4\\n1 3 2 1\\n\") == \"1\\n1\\n1\");\n    assert(solution(\"5 3 4\\naas\\nfbcd\\nezrt\\ndzpt\\naaf\\n4 2 4 1\\n3 3 5 1\\n2 1 3 1\\n2 3 3 3\\n\") == \"1\\n1\\n1\\n1\\n1\");\n    assert(solution(\"3 1 2\\na\\nb\\nc\\n1 1 2 1\\n2 1 3 1\\n\") == \"1\\n1\\n1\");\n    assert(solution(\"2 1 1\\na\\nb\\n1 1 2 1\\n\") == \"1\\n1\");\n    assert(solution(\"5 4 4\\nasbc\\nxasb\\ntflk\\ncrqj\\ncase\\n3 2 5 1\\n3 3 5 1\\n1 4 2 3\\n4 3 4 4\\n\") == \"1\\n1\\n1\\n1\\n1\");\n    assert(solution(\"3 2 2\\naaa\\naaa\\naaa\\n1 1 2 2\\n3 2 1 2\\n\") == \"3\\n3\\n3\");\n    assert(solution(\"2 3 2\\naaa\\naaa\\n1 2 2 1\\n2 3 1 2\\n\") == \"2\\n2\");\n    assert(solution(\"4 3 2\\naaa\\naaa\\naaa\\naaa\\n1 1 4 3\\n2 2 3 1\\n\") == \"4\\n4\\n4\\n4\");\n    assert(solution(\"3 3 2\\nabc\\nabc\\nabc\\n1 2 2 3\\n3 3 1 2\\n\") == \"3\\n3\\n3\");\n    assert(solution(\"5 5 3\\nabcde\\nabcde\\nabcde\\nabcde\\nabcde\\n1 1 5 5\\n2 2 4 4\\n3 3 5 1\\n\") == \"5\\n5\\n5\\n5\\n5\");\n    assert(solution(\"3 2 3\\nab\\nab\\nab\\n1 1 2 2\\n3 1 1 2\\n2 2 1 1\\n\") == \"3\\n3\\n3\");\n    return 0; \n}", "prompt": "/*The Trains of Colour Parade will start tomorrow in Byteotia.\n\nIntense preparations are already underway at the auxiliary tracks of the station. The station has $n$ parallel tracks numbered from 1 to $n$. Train number $i$ occupies the $i^{th}$ track.\n\nEach train consists of $l$ cars, and each car is painted in one of 26 colors (denoted by non-capital letters of the English alphabet).\n\nTwo trains are considered to be the same if their corresponding cars are painted in the same color.\n\nDuring the parade, a crane will swap certain pairs of cars, but the actual parade will take place tomorrow.\n\nToday, the train dispatcher Byteasar watched the dress rehearsal closely and even recorded the sequence of car swaps.\n\nByteasar dislikes trains that look too alike.\n\nFor each train $p$, he wants to calculate the maximum number of trains that can look like train $p$ at any given moment.\n\n## Task\n\nWrite a program that:\n\n- reads the descriptions of the trains occupying the tracks and the sequence of car swaps\n- for each train, determines the maximum number of trains that look like it at any given moment\n- writes out the results.\n\ninput_format:\nThe first line of the input contains three integers $n$, $l$ and $m$ ($2 \\le n \\le 1000$, $1 \\le l \\le 100$, $0 \\le m \\le 100\\ 000$), denoting respectively the number of trains, their common length and the number of car swaps. The following $n$ lines contain descriptions of the trains on successive tracks. The\n\n$k^{th}$ line consists of $l$ small letters of the English alphabet denoting the colours of successive cars of the $k^{th}$ train. Then $m$ lines describing the car swaps follow, in the order of the swaps. The $r^{th}$ line contains four integers $p_1$, $w_1$, $p_2$, $w_2$ ($1 \\le p_1, p_2, \\le n$, $1 \\le w_1, w_2 \\le l$, $p_1 \\ne p_2$ or $w_1 \\ne w_2$) denoting the $r^{th}$ car swap-the car no. $w_1$ of the train no. $p_1$ is swapped with the car no. $w_2$ of the train no. $p_2$.\n\noutput_format:\nYour programme should write out exactly $n$ lines. The $k^[th}$ line should contain one integer-the number of trains looking the same as the train no. $k$ at certain moment.\n*/\n\n#include<sstream>\n#include<stdlib.h>\n#include<algorithm>\n#include<math.h>\n#include<stdio.h>\n#include<vector>\n#include<string>\n#include<climits>\n#include<cstring>\n#include<iostream>\nusing namespace std;\n\n             \nstring solution(string std_in){\n    istringstream iss(std_in);\n             ", "constraints": "The figure presents the successive car swaps:\n\n```cpp\ntrack 1:  ababbd    ababbd    ababbd    ababbd    aaabbd    aaabbd    aaabbd    aaabbd\ntrack 2:  abbbbd    ababbd    ababbd    aaabbd    aaabbd    acabbd    acabbd    acabbd\ntrack 3:  aaabad -> aaabad -> aaabad -> aaabbd -> aaabbd -> aaabbd -> aaabbd -> aaabbd\ntrack 4:  caabbd    caabbd    caabbd    caabbd    cabbbd    cabbbd    cabbbd    dabbbd\ntrack 5:  cabaad    cabbad    caabbd    caabbd    caabbd    aaabbd    aaabbd    aaabbc\n           (0)       (1)       (2)       (3)       (4)       (5)       (6)       (7)\n```\n\nThe number of trains looking the same as either of the trains no. 1, 2 or 3 was maximal at time (4) (when all three looked the same). The number of trains looking the same as the train no. 5 was maximal at time (5) and (6). The number of trains looking the same as the train no. 4 was maximal at time (2).\n", "samples": [["5 6 7\nababbd\nabbbbd\naaabad\ncaabbd\ncabaad\n2 3 5 4\n5 3 5 5\n3 5 2 2\n1 2 4 3\n2 2 5 1\n1 1 3 3\n4 1 5 6\n", "3\n3\n3\n2\n3\n"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144, 262144]}}
{"task_id": "P7625", "title": "[COCI2011-2012#1] JABUKE", "difficulty": "basic", "nl": "Mirko has recently become obsessed with an electronic game.\n\nThe game screen is divided into $N$ columns. At the bottom of the screen, there is a ship that is $M$ columns wide. In the game, the player can move the ship left and right, but it must **always remain completely within the screen**. The ship initially occupies the leftmost $M$ columns of the screen.\n\nApples will drop from the top of the screen. Each apple will drop straight down from one of the $N$ columns at the top. When the current apple drops to the bottom of the screen, the next apple starts to fall.\n\nIf when an apple drops to the bottom, the ship covers the column where the apple is located, we say that **the apple is picked up**. Your task is to minimize the distance the ship moves while picking up all the apples.", "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nint main()\n{\n    int l=1,r,n,m,a[25],sum=0,x;\n    cin >> x >> m >> n;\n    r=m;\n    for(int i=1;i<=n;i++)\n    {\n        cin >> a[i];\n        if(a[i]>r)\n        {\n            sum+=a[i]-r;\n            r=a[i];\n            l=r-m+1;\n        }\n        if(a[i]<l)\n        {\n            sum+=l-a[i];\n            l=a[i];\n            r=l+m-1;\n        }\n    }\n    cout << sum << endl;\n    return 0;\n}", "step": ["Initialize variables l=1, r, n, m, a[25], and sum=0", "Read input of x, m, n", "Set r=m", "For i in range 1 to n, repeat the following:", "Read input of a[i]", "If a[i]>r, calculate the difference between a[i] and r and add it to sum. Set r to a[i] and set l to r-m+1", "If a[i]<l, calculate the difference between a[i] and l and add it to sum. Set l to a[i] and set r to l+m-1", "Print the value of sum", "End the program"], "nl_cn": "Mirko 最近迷上了一款电子游戏。\n\n这款游戏的屏幕被分成 $N$ 列。在屏幕的底部，有一艘 $M$ 列宽的船。游戏中，玩家可以将这艘船左右移动，但船必须**时刻保持完全在屏幕内**。初始时船占据屏幕最左边的 $M$ 列。\n\n有苹果会从屏幕顶部掉落。每个苹果都从顶部的 $N$ 列的其中一列开始以直线掉落。当当前的苹果掉落到屏幕底部时，下一个苹果开始掉落。\n\n如果当一个苹果掉落到底部时，船覆盖了苹果所在的列，那么我们说**这个苹果是被捡起的**。你的任务是在捡起所有苹果的前提下，最小化船移动的距离。", "test_cases": [{"input": "5 1\n3\n1\n5\n3", "output": "6"}, {"input": "5 2\n3\n1\n5\n3", "output": "4"}, {"input": "4 1\n2\n4\n1\n3\n", "output": "6"}, {"input": "9 3\n1\n6\n9\n3\n8\n5\n2\n7\n4\n", "output": "3"}, {"input": "3 1\n1\n2\n1", "output": "1"}, {"input": "10 3\n1\n9\n3\n7\n8", "output": "6"}, {"input": "7 2\n1\n4\n2\n6\n3", "output": "2"}, {"input": "4 1\n1\n2\n1\n3", "output": "1"}, {"input": "10 3\n1\n2\n3\n1", "output": "0"}, {"input": "8 2\n1\n3\n4\n7\n6", "output": "1"}, {"input": "3 1\n2\n1\n2\n", "output": "1"}, {"input": "2 1\n2\n1\n2\n", "output": "1"}, {"input": "2 1\n1\n2\n", "output": "1"}, {"input": "3 1\n2\n3\n1\n", "output": "4"}, {"input": "6 3\n5\n4\n1\n2\n6\n3\n", "output": "6"}, {"input": "3 1\n2\n1\n3\n", "output": "2"}], "test": "#undef NDEBUG\n#include<assert.h>\nint main(){\n    assert(solution(\"5 1\\n3\\n1\\n5\\n3\") == \"6\");\n    assert(solution(\"5 2\\n3\\n1\\n5\\n3\") == \"4\");\n    assert(solution(\"4 1\\n2\\n4\\n1\\n3\\n\") == \"6\");\n    assert(solution(\"9 3\\n1\\n6\\n9\\n3\\n8\\n5\\n2\\n7\\n4\\n\") == \"3\");\n    assert(solution(\"3 1\\n1\\n2\\n1\") == \"1\");\n    assert(solution(\"10 3\\n1\\n9\\n3\\n7\\n8\") == \"6\");\n    assert(solution(\"7 2\\n1\\n4\\n2\\n6\\n3\") == \"2\");\n    assert(solution(\"4 1\\n1\\n2\\n1\\n3\") == \"1\");\n    assert(solution(\"10 3\\n1\\n2\\n3\\n1\") == \"0\");\n    assert(solution(\"8 2\\n1\\n3\\n4\\n7\\n6\") == \"1\");\n    assert(solution(\"3 1\\n2\\n1\\n2\\n\") == \"1\");\n    assert(solution(\"2 1\\n2\\n1\\n2\\n\") == \"1\");\n    assert(solution(\"2 1\\n1\\n2\\n\") == \"1\");\n    assert(solution(\"3 1\\n2\\n3\\n1\\n\") == \"4\");\n    assert(solution(\"6 3\\n5\\n4\\n1\\n2\\n6\\n3\\n\") == \"6\");\n    assert(solution(\"3 1\\n2\\n1\\n3\\n\") == \"2\");\n    return 0; \n}", "prompt": "/*Mirko has recently become obsessed with an electronic game.\n\nThe game screen is divided into $N$ columns. At the bottom of the screen, there is a ship that is $M$ columns wide. In the game, the player can move the ship left and right, but it must **always remain completely within the screen**. The ship initially occupies the leftmost $M$ columns of the screen.\n\nApples will drop from the top of the screen. Each apple will drop straight down from one of the $N$ columns at the top. When the current apple drops to the bottom of the screen, the next apple starts to fall.\n\nIf when an apple drops to the bottom, the ship covers the column where the apple is located, we say that **the apple is picked up**. Your task is to minimize the distance the ship moves while picking up all the apples.\n\ninput_format:\nThe first line contains two integers $N,M$separated by Spaces.\n\nThe second line contains an integer $J$, representing the number of apples to be dropped.\n\nThe next $J$row, row $i$, contains an integer indicating from which column the first $i$apple will fall.\n\noutput_format:\nOutput a line of an integer representing the minimum distance the boat has moved.\n*/\n\n#include<sstream>\n#include<stdlib.h>\n#include<algorithm>\n#include<math.h>\n#include<stdio.h>\n#include<vector>\n#include<string>\n#include<climits>\n#include<cstring>\n#include<iostream>\nusing namespace std;\n\n             \nstring solution(string std_in){\n    istringstream iss(std_in);\n             ", "constraints": "#### 【数据范围】\n\n对于 $100\\%$ 的数据，$1 \\le M < N \\le 10$，$1 \\le J \\le 20$。\n\n#### 【说明】\n\n本题分值按 COCI 原题设置，满分 $50$。\n\n题目译自 **[COCI2011-2012](https://hsin.hr/coci/archive/2011_2012/) [CONTEST #1](https://hsin.hr/coci/archive/2011_2012/contest1_tasks.pdf)** ___T1 JABUKE___。", "samples": [["5 1\n3\n1\n5\n3", "6"], ["5 2\n3\n1\n5\n3", "4"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [32768, 32768, 32768, 32768, 32768, 32768, 32768, 32768, 32768, 32768]}}
{"task_id": "P1014", "title": "[NOIP1999 普及组] Cantor 表", "difficulty": "challenge", "nl": "One of the famous proofs in modern mathematics is Georg Cantor's proof that rational numbers are enumerable. He used the following table to prove this statement:\n\n$1/1$ ,   $1/2$ ,   $1/3$ ,   $1/4$,    $1/5$,   …\n\n$2/1$,   $2/2$ ,   $2/3$,    $2/4$,    …\n\n$3/1$ ,   $3/2$,    $3/3$,    …\n\n$4/1$,    $4/2$,    …\n\n$5/1$,   …\n\n…\n\nWe give each item in the table above a Z-shaped number. The first item is $1/1$, then $1/2, 2/1, 3/1, 2/2,$ and so on.", "code": "#include <bits/stdc++.h>\nusing namespace std; \nint main() {\n\tint n,k=1;\n\tcin>>n;\n\twhile (n>k) {\n\t\tn=n-k;\n\t\tk++;\n\t}\n\tif(k%2==0) cout<<n<<\"/\"<<(k+1-n);\n\telse cout<<k+1-n<<\"/\"<<n;\n\treturn 0;\n}", "step": ["Initialize variables for user input and sequence positions", "Start a loop to determine the sequence position of the fraction to output", "If the loop completes, output the fraction based on the sequence position and parity of the sequence", "If the loop is still active, adjust user input and sequence position variables", "Repeat the loop until the sequence position equals the user input", "Return 0 to end the program"], "nl_cn": "现代数学的著名证明之一是 Georg Cantor 证明了有理数是可枚举的。他是用下面这一张表来证明这一命题的：\n\n$1/1$ ,   $1/2$ ,   $1/3$ ,   $1/4$,    $1/5$,   …\n\n$2/1$,   $2/2$ ,   $2/3$,    $2/4$,    …\n\n$3/1$ ,   $3/2$,    $3/3$,    …\n\n$4/1$,    $4/2$,    …\n\n$5/1$,   …\n\n…\n\n我们以 Z 字形给上表的每一项编号。第一项是 $1/1$，然后是 $1/2$，$2/1$，$3/1$，$2/2$，…\n", "test_cases": [{"input": "7\n", "output": "1/4"}, {"input": "1\n", "output": "1/1"}, {"input": "2\n", "output": "1/2"}, {"input": "3\n", "output": "2/1"}, {"input": "4\n", "output": "3/1"}, {"input": "5\n", "output": "2/2"}, {"input": "6\n", "output": "1/3"}, {"input": "8\n", "output": "2/3"}, {"input": "9\n", "output": "3/2"}, {"input": "10\n", "output": "4/1"}, {"input": "11\n", "output": "5/1"}, {"input": "12\n", "output": "4/2"}, {"input": "13\n", "output": "3/3"}, {"input": "14\n", "output": "2/4"}, {"input": "15\n", "output": "1/5"}, {"input": "16\n", "output": "1/6"}, {"input": "17\n", "output": "2/5"}, {"input": "18\n", "output": "3/4"}, {"input": "19\n", "output": "4/3"}, {"input": "20\n", "output": "5/2"}], "test": "#undef NDEBUG\n#include<assert.h>\nint main(){\n    assert(solution(\"7\\n\") == \"1/4\");\n    assert(solution(\"1\\n\") == \"1/1\");\n    assert(solution(\"2\\n\") == \"1/2\");\n    assert(solution(\"3\\n\") == \"2/1\");\n    assert(solution(\"4\\n\") == \"3/1\");\n    assert(solution(\"5\\n\") == \"2/2\");\n    assert(solution(\"6\\n\") == \"1/3\");\n    assert(solution(\"8\\n\") == \"2/3\");\n    assert(solution(\"9\\n\") == \"3/2\");\n    assert(solution(\"10\\n\") == \"4/1\");\n    assert(solution(\"11\\n\") == \"5/1\");\n    assert(solution(\"12\\n\") == \"4/2\");\n    assert(solution(\"13\\n\") == \"3/3\");\n    assert(solution(\"14\\n\") == \"2/4\");\n    assert(solution(\"15\\n\") == \"1/5\");\n    assert(solution(\"16\\n\") == \"1/6\");\n    assert(solution(\"17\\n\") == \"2/5\");\n    assert(solution(\"18\\n\") == \"3/4\");\n    assert(solution(\"19\\n\") == \"4/3\");\n    assert(solution(\"20\\n\") == \"5/2\");\n    return 0; \n}", "prompt": "/*One of the famous proofs in modern mathematics is Georg Cantor's proof that rational numbers are enumerable. He used the following table to prove this statement:\n\n$1/1$ ,   $1/2$ ,   $1/3$ ,   $1/4$,    $1/5$,   …\n\n$2/1$,   $2/2$ ,   $2/3$,    $2/4$,    …\n\n$3/1$ ,   $3/2$,    $3/3$,    …\n\n$4/1$,    $4/2$,    …\n\n$5/1$,   …\n\n…\n\nWe give each item in the table above a Z-shaped number. The first item is $1/1$, then $1/2, 2/1, 3/1, 2/2,$ and so on.\n\ninput_format:\nAn integer $N$ ($1 \\leq N \\leq 10^7$).\n\noutput_format:\nItem $N$in the table.\n*/\n\n#include<sstream>\n#include<stdlib.h>\n#include<algorithm>\n#include<math.h>\n#include<stdio.h>\n#include<vector>\n#include<string>\n#include<climits>\n#include<cstring>\n#include<iostream>\nusing namespace std;\n\n             \nstring solution(string std_in){\n    istringstream iss(std_in);\n             ", "constraints": "- 2024-11-18 0:30 数据中加入了样例，放在不计分的子任务 2 中。", "samples": [["7\n", "1/4"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000], "memory": [131072, 131072, 131072, 131072, 131072]}}
{"task_id": "P5718", "title": "【深基4.例2】找最小值", "difficulty": "basic", "nl": "Given $n$ and $n$ integers $a_i$, find the minimum value among these $n$ integers.", "code": "#include<bits/stdc++.h>//万能头文件\nusing namespace std;//using\nint main()\n{\n    int n,a[10001];//定义\n    cin>>n;//输入\n    for(int i=1;i<=n;i++) cin>>a[i];//循环输入\n    sort(a+1,a+n+1);//快速排序\n    cout<<a[1];//输出最小答案\n    return 0;//华丽结束\n}", "step": ["Create an integer array 'a' and an integer 'n'", "Take input for n", "Loop through the array and take input for every element into a[]", "Set min as the first element of the array a[0]", "Loop through the array a[] to find the minimum value", "Print the minimum value"], "nl_cn": "给出 $n$ 和 $n$ 个整数 $a_i$，求这 $n$ 个整数中最小值是什么。", "test_cases": [{"input": "8\n1 9 2 6 0 8 1 7", "output": "0"}, {"input": "5\n10 20 30 40 50\n", "output": "10"}, {"input": "3\n-1 -2 -3\n", "output": "-3"}, {"input": "6\n-10 -20 -30 -40 -50 0\n", "output": "-50"}, {"input": "4\n100 200 300 400\n", "output": "100"}, {"input": "2\n7 7\n", "output": "7"}, {"input": "1\n1000\n", "output": "1000"}, {"input": "10\n1 1 1 1 1 1 1 1 1 1\n", "output": "1"}, {"input": "7\n2 3 5 7 11 13 17\n", "output": "2"}, {"input": "4\n5 5 5 5\n", "output": "5"}, {"input": "3\n-10 -10 -10\n", "output": "-10"}, {"input": "6\n0 0 0 0 0 0\n", "output": "0"}, {"input": "12\n-5 -4 -3 -2 -1 0 1 2 3 4 5 6\n", "output": "-5"}, {"input": "9\n99 88 77 66 55 44 33 22 11\n", "output": "11"}, {"input": "2\n1000 -1000\n", "output": "-1000"}, {"input": "4\n-1 -2 -3 -4\n", "output": "-4"}, {"input": "7\n10 20 30 40 50 60 70\n", "output": "10"}, {"input": "12\n1 3 5 7 9 11 13 15 17 19 21 23\n", "output": "1"}, {"input": "3\n7 8 9\n", "output": "7"}, {"input": "6\n-100 -200 -300 -400 -500 0\n", "output": "-500"}, {"input": "5\n1 2 3 4 5", "output": "1"}, {"input": "5\n5 8 3 6 1\n", "output": "1"}, {"input": "3\n10 20 30\n", "output": "10"}, {"input": "4\n-5 -8 -3 -6\n", "output": "-8"}, {"input": "2\n0 -1\n", "output": "-1"}, {"input": "7\n100 200 300 400 500 600 700\n", "output": "100"}, {"input": "10\n-10 -20 -30 -40 -50 -60 -70 -80 -90 -100\n", "output": "-100"}, {"input": "1\n999\n", "output": "999"}, {"input": "9\n1 3 5 7 9 2 4 6 8\n", "output": "1"}, {"input": "4\n-2 -4 -6 -8\n", "output": "-8"}, {"input": "5\n-100 -200 -300 -400 -500\n", "output": "-500"}, {"input": "6\n2 4 6 1 3 5\n", "output": "1"}, {"input": "7\n-7 -6 -5 -4 -3 -2 -1\n", "output": "-7"}, {"input": "8\n10 20 30 40 50 60 70 80\n", "output": "10"}, {"input": "3\n-10 -20 -30\n", "output": "-30"}, {"input": "4\n5 10 15 20\n", "output": "5"}, {"input": "6\n9 8 7 6 5 4\n", "output": "4"}, {"input": "1\n10\n", "output": "10"}, {"input": "5\n3 5 2 4 1\n", "output": "1"}, {"input": "3\n100 50 75\n", "output": "50"}, {"input": "6\n-5 -10 -3 -2 -1 -7\n", "output": "-10"}, {"input": "4\n-6 -7 -8 -5\n", "output": "-8"}, {"input": "3\n0 0 0\n", "output": "0"}, {"input": "7\n7 7 7 7 7 7 7\n", "output": "7"}, {"input": "2\n-1000 1000\n", "output": "-1000"}, {"input": "9\n1 2 3 4 5 6 7 8 9\n", "output": "1"}, {"input": "10\n10 9 8 7 6 5 4 3 2 1\n", "output": "1"}, {"input": "3\n10 10 10\n", "output": "10"}, {"input": "5\n-1 -2 -3 -4 -5\n", "output": "-5"}, {"input": "4\n50 60 70 80\n", "output": "50"}, {"input": "2\n1 1\n", "output": "1"}, {"input": "6\n4 5 6 7 8 3\n", "output": "3"}, {"input": "3\n100 200 300\n", "output": "100"}, {"input": "4\n3 3 4 3\n", "output": "3"}, {"input": "8\n-10 -20 -30 -40 -50 -60 -70 -80\n", "output": "-80"}, {"input": "1\n-1234\n", "output": "-1234"}, {"input": "5\n5 5 5 5 5\n", "output": "5"}, {"input": "6\n-1 -2 -3 -4 -5 -6\n", "output": "-6"}, {"input": "2\n-10 0\n", "output": "-10"}, {"input": "4\n-100 -200 -300 -400\n", "output": "-400"}, {"input": "10\n1 2 3 4 5 -1 -2 -3 -4 -5\n", "output": "-5"}, {"input": "3\n5 1 -10\n", "output": "-10"}, {"input": "6\n10 9 8 7 6 5\n", "output": "5"}, {"input": "4\n0 0 0 0\n", "output": "0"}, {"input": "2\n-999 0\n", "output": "-999"}, {"input": "5\n-5 -10 -2 -7 -1\n", "output": "-10"}, {"input": "3\n1000 2000 3000\n", "output": "1000"}, {"input": "8\n1 2 3 4 5 6 7 8\n", "output": "1"}, {"input": "6\n-10 -9 -8 -7 -6 -5\n", "output": "-10"}, {"input": "1\n0\n", "output": "0"}, {"input": "10\n-10 -9 -8 -7 -6 -5 -4 -3 -2 -1\n", "output": "-10"}], "test": "#undef NDEBUG\n#include<assert.h>\nint main(){\n    assert(solution(\"8\\n1 9 2 6 0 8 1 7\") == \"0\");\n    assert(solution(\"5\\n10 20 30 40 50\\n\") == \"10\");\n    assert(solution(\"3\\n-1 -2 -3\\n\") == \"-3\");\n    assert(solution(\"6\\n-10 -20 -30 -40 -50 0\\n\") == \"-50\");\n    assert(solution(\"4\\n100 200 300 400\\n\") == \"100\");\n    assert(solution(\"2\\n7 7\\n\") == \"7\");\n    assert(solution(\"1\\n1000\\n\") == \"1000\");\n    assert(solution(\"10\\n1 1 1 1 1 1 1 1 1 1\\n\") == \"1\");\n    assert(solution(\"7\\n2 3 5 7 11 13 17\\n\") == \"2\");\n    assert(solution(\"4\\n5 5 5 5\\n\") == \"5\");\n    assert(solution(\"3\\n-10 -10 -10\\n\") == \"-10\");\n    assert(solution(\"6\\n0 0 0 0 0 0\\n\") == \"0\");\n    assert(solution(\"12\\n-5 -4 -3 -2 -1 0 1 2 3 4 5 6\\n\") == \"-5\");\n    assert(solution(\"9\\n99 88 77 66 55 44 33 22 11\\n\") == \"11\");\n    assert(solution(\"2\\n1000 -1000\\n\") == \"-1000\");\n    assert(solution(\"4\\n-1 -2 -3 -4\\n\") == \"-4\");\n    assert(solution(\"7\\n10 20 30 40 50 60 70\\n\") == \"10\");\n    assert(solution(\"12\\n1 3 5 7 9 11 13 15 17 19 21 23\\n\") == \"1\");\n    assert(solution(\"3\\n7 8 9\\n\") == \"7\");\n    assert(solution(\"6\\n-100 -200 -300 -400 -500 0\\n\") == \"-500\");\n    assert(solution(\"5\\n1 2 3 4 5\") == \"1\");\n    assert(solution(\"5\\n5 8 3 6 1\\n\") == \"1\");\n    assert(solution(\"3\\n10 20 30\\n\") == \"10\");\n    assert(solution(\"4\\n-5 -8 -3 -6\\n\") == \"-8\");\n    assert(solution(\"2\\n0 -1\\n\") == \"-1\");\n    assert(solution(\"7\\n100 200 300 400 500 600 700\\n\") == \"100\");\n    assert(solution(\"10\\n-10 -20 -30 -40 -50 -60 -70 -80 -90 -100\\n\") == \"-100\");\n    assert(solution(\"1\\n999\\n\") == \"999\");\n    assert(solution(\"9\\n1 3 5 7 9 2 4 6 8\\n\") == \"1\");\n    assert(solution(\"4\\n-2 -4 -6 -8\\n\") == \"-8\");\n    assert(solution(\"5\\n-100 -200 -300 -400 -500\\n\") == \"-500\");\n    assert(solution(\"6\\n2 4 6 1 3 5\\n\") == \"1\");\n    assert(solution(\"7\\n-7 -6 -5 -4 -3 -2 -1\\n\") == \"-7\");\n    assert(solution(\"8\\n10 20 30 40 50 60 70 80\\n\") == \"10\");\n    assert(solution(\"3\\n-10 -20 -30\\n\") == \"-30\");\n    assert(solution(\"4\\n5 10 15 20\\n\") == \"5\");\n    assert(solution(\"6\\n9 8 7 6 5 4\\n\") == \"4\");\n    assert(solution(\"1\\n10\\n\") == \"10\");\n    assert(solution(\"5\\n3 5 2 4 1\\n\") == \"1\");\n    assert(solution(\"3\\n100 50 75\\n\") == \"50\");\n    assert(solution(\"6\\n-5 -10 -3 -2 -1 -7\\n\") == \"-10\");\n    assert(solution(\"4\\n-6 -7 -8 -5\\n\") == \"-8\");\n    assert(solution(\"3\\n0 0 0\\n\") == \"0\");\n    assert(solution(\"7\\n7 7 7 7 7 7 7\\n\") == \"7\");\n    assert(solution(\"2\\n-1000 1000\\n\") == \"-1000\");\n    assert(solution(\"9\\n1 2 3 4 5 6 7 8 9\\n\") == \"1\");\n    assert(solution(\"10\\n10 9 8 7 6 5 4 3 2 1\\n\") == \"1\");\n    assert(solution(\"3\\n10 10 10\\n\") == \"10\");\n    assert(solution(\"5\\n-1 -2 -3 -4 -5\\n\") == \"-5\");\n    assert(solution(\"4\\n50 60 70 80\\n\") == \"50\");\n    assert(solution(\"2\\n1 1\\n\") == \"1\");\n    assert(solution(\"6\\n4 5 6 7 8 3\\n\") == \"3\");\n    assert(solution(\"3\\n100 200 300\\n\") == \"100\");\n    assert(solution(\"4\\n3 3 4 3\\n\") == \"3\");\n    assert(solution(\"8\\n-10 -20 -30 -40 -50 -60 -70 -80\\n\") == \"-80\");\n    assert(solution(\"1\\n-1234\\n\") == \"-1234\");\n    assert(solution(\"5\\n5 5 5 5 5\\n\") == \"5\");\n    assert(solution(\"6\\n-1 -2 -3 -4 -5 -6\\n\") == \"-6\");\n    assert(solution(\"2\\n-10 0\\n\") == \"-10\");\n    assert(solution(\"4\\n-100 -200 -300 -400\\n\") == \"-400\");\n    assert(solution(\"10\\n1 2 3 4 5 -1 -2 -3 -4 -5\\n\") == \"-5\");\n    assert(solution(\"3\\n5 1 -10\\n\") == \"-10\");\n    assert(solution(\"6\\n10 9 8 7 6 5\\n\") == \"5\");\n    assert(solution(\"4\\n0 0 0 0\\n\") == \"0\");\n    assert(solution(\"2\\n-999 0\\n\") == \"-999\");\n    assert(solution(\"5\\n-5 -10 -2 -7 -1\\n\") == \"-10\");\n    assert(solution(\"3\\n1000 2000 3000\\n\") == \"1000\");\n    assert(solution(\"8\\n1 2 3 4 5 6 7 8\\n\") == \"1\");\n    assert(solution(\"6\\n-10 -9 -8 -7 -6 -5\\n\") == \"-10\");\n    assert(solution(\"1\\n0\\n\") == \"0\");\n    assert(solution(\"10\\n-10 -9 -8 -7 -6 -5 -4 -3 -2 -1\\n\") == \"-10\");\n    return 0; \n}", "prompt": "/*Given $n$ and $n$ integers $a_i$, find the minimum value among these $n$ integers.\n\ninput_format:\nEnter a positive integer $n$in the first line to represent the number of digits.\n\nIn the second line, enter $n$non-negative integers, representing $a_1,a_2 \\dots a_n$, separated by Spaces.\n\noutput_format:\nOutput a non-negative integer representing the smallest of the $n$non-negative integers.\n*/\n\n#include<sstream>\n#include<stdlib.h>\n#include<algorithm>\n#include<math.h>\n#include<stdio.h>\n#include<vector>\n#include<string>\n#include<climits>\n#include<cstring>\n#include<iostream>\nusing namespace std;\n\n             \nstring solution(string std_in){\n    istringstream iss(std_in);\n             ", "constraints": "数据保证，$n\\le100$ 且 $0\\le a_i \\le 1000$。", "samples": [["8\n1 9 2 6 0 8 1 7", "0"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000]}}
{"task_id": "P2369", "title": "EXCEEDED WARNING A", "difficulty": "challenge", "nl": "There are some data, all of which are non-negative integers less than $10^9$, and there are $n$ of them. Now please output the smallest $m$ numbers among them.\n\nBe careful not to overflow and note that Memory Limit = 4000KiB.", "code": "#include <stdio.h>\n#include <queue>\n#include <algorithm>\n\nusing namespace std;\n\npriority_queue<int, vector<int>, less<int> > a;\npriority_queue<int, vector<int>, greater<int> > s;\nint maxn;\n\nint main()\n{\n    int n, m, miss = 0;\n    scanf(\"%d %d\", &n, &m);\n    for (register int i = 1; i <= m; ++i)\n    {\n        int num;\n        scanf(\"%d\", &num);\n        a.push(num);\n    }\n    for (register int i = m + 1, num; i <= n; ++i)\n    {\n        scanf(\"%d\", &num);\n        if (num < a.top())\n        {\n            a.pop();\n            a.push(num);\n        }\n    }\n    for (register int i = 1; i <= m; ++i)\n    {\n        s.push(a.top());\n        a.pop();\n    } \n    while(s.size()) printf(\"%d\\n\", s.top()), s.pop();\n}", "step": ["Initialize two priority queues - one in ascending order (initially empty) and the other in descending order (also initially empty).", "Read in the amount of numbers to be sorted (n) and how many numbers can be stored in the ascending order queue (m).", "Insert the first m numbers into the descending order queue.", "For each subsequent number, if it is smaller than the largest number in the descending order queue, remove that number and add the new number to the queue instead.", "Remove the numbers from the descending order queue and add them to the ascending order queue.", "Print out the sorted numbers in ascending order."], "nl_cn": "有这样一些数据，它们均为小于 $10^9$ 的非负整数，且个数为 $n$，现在请你输出其中最小的 $m$ 个数。\n\n小心溢出，注意 Memory Limit = 4000KiB。\n", "test_cases": [{"input": "10 5\n2\n4\n6\n8\n10\n1\n3\n5\n7\n9", "output": "1\n2\n3\n4\n5"}, {"input": "5 3\n9\n7\n4\n6\n3", "output": "3\n4\n6"}, {"input": "7 4\n1\n5\n3\n9\n2\n8\n6", "output": "1\n2\n3\n5"}, {"input": "6 4\n2\n5\n6\n1\n8\n3", "output": "1\n2\n3\n5"}, {"input": "3 3\n5\n7\n4", "output": "4\n5\n7"}, {"input": "9 5\n4\n1\n6\n3\n8\n5\n2\n7\n9", "output": "1\n2\n3\n4\n5"}, {"input": "8 2\n6\n7\n4\n1\n9\n3\n5\n8", "output": "1\n3"}, {"input": "6 4\n5\n2\n3\n4\n6\n7", "output": "2\n3\n4\n5"}, {"input": "3 2\n4\n5\n1", "output": "1\n4"}, {"input": "5 3\n9\n4\n5\n8\n6", "output": "4\n5\n6"}, {"input": "9 5\n1\n6\n3\n4\n5\n2\n7\n9\n8", "output": "1\n2\n3\n4\n5"}, {"input": "8 2\n7\n4\n6\n1\n9\n3\n5\n8", "output": "1\n3"}, {"input": "6 3\n1\n2\n3\n4\n5\n6\n", "output": "1\n2\n3"}, {"input": "8 4\n9\n1\n5\n3\n7\n2\n8\n4\n", "output": "1\n2\n3\n4"}, {"input": "5 2\n10\n20\n30\n40\n50\n", "output": "10\n20"}, {"input": "7 4\n100\n200\n300\n400\n500\n600\n700\n", "output": "100\n200\n300\n400"}, {"input": "9 3\n5\n3\n2\n7\n8\n1\n9\n4\n6\n", "output": "1\n2\n3"}, {"input": "12 6\n10\n20\n30\n40\n50\n60\n70\n80\n90\n100\n110\n120\n", "output": "10\n20\n30\n40\n50\n60"}, {"input": "4 2\n100\n200\n300\n400\n", "output": "100\n200"}, {"input": "3 1\n4\n2\n3\n", "output": "2"}, {"input": "6 4\n15\n20\n10\n5\n30\n25\n", "output": "5\n10\n15\n20"}, {"input": "5 3\n6\n3\n8\n2\n9\n", "output": "2\n3\n6"}, {"input": "10 5\n10\n20\n30\n40\n50\n60\n70\n80\n90\n100\n", "output": "10\n20\n30\n40\n50"}, {"input": "7 3\n12\n14\n16\n18\n20\n22\n24\n", "output": "12\n14\n16"}, {"input": "8 4\n9\n7\n5\n3\n1\n2\n4\n6\n", "output": "1\n2\n3\n4"}, {"input": "3 2\n5\n8\n3\n", "output": "3\n5"}, {"input": "9 6\n100\n200\n300\n400\n500\n600\n700\n800\n900\n", "output": "100\n200\n300\n400\n500\n600"}, {"input": "6 3\n7\n6\n5\n4\n3\n2\n", "output": "2\n3\n4"}, {"input": "10 4\n1\n9\n2\n8\n3\n7\n4\n6\n5\n10\n", "output": "1\n2\n3\n4"}, {"input": "4 3\n1000\n500\n100\n2000\n", "output": "100\n500\n1000"}, {"input": "12 5\n11\n22\n13\n24\n15\n26\n17\n28\n19\n30\n21\n32\n", "output": "11\n13\n15\n17\n19"}, {"input": "7 3\n5\n2\n6\n7\n3\n4\n1\n", "output": "1\n2\n3"}, {"input": "8 4\n9\n3\n6\n1\n8\n2\n5\n7\n", "output": "1\n2\n3\n5"}, {"input": "6 2\n5\n1\n4\n3\n2\n6\n", "output": "1\n2"}, {"input": "5 1\n2\n4\n3\n5\n1\n", "output": "1"}, {"input": "9 5\n3\n2\n8\n9\n1\n4\n5\n6\n7\n", "output": "1\n2\n3\n4\n5"}, {"input": "10 3\n8\n7\n4\n9\n6\n5\n2\n10\n3\n1\n", "output": "1\n2\n3"}, {"input": "6 4\n1\n4\n6\n3\n2\n5\n", "output": "1\n2\n3\n4"}, {"input": "7 2\n7\n4\n5\n2\n6\n3\n1\n", "output": "1\n2"}, {"input": "8 5\n2\n4\n7\n5\n1\n6\n3\n8\n", "output": "1\n2\n3\n4\n5"}, {"input": "9 3\n9\n6\n5\n3\n4\n7\n2\n1\n8\n", "output": "1\n2\n3"}, {"input": "5 2\n2\n1\n3\n5\n4\n", "output": "1\n2"}, {"input": "10 4\n4\n7\n5\n6\n8\n10\n2\n1\n9\n3\n", "output": "1\n2\n3\n4"}, {"input": "7 3\n5\n2\n7\n3\n4\n1\n6\n", "output": "1\n2\n3"}, {"input": "8 5\n9\n6\n8\n5\n1\n2\n3\n4\n7\n", "output": "1\n2\n3\n4\n5"}, {"input": "6 4\n1\n6\n5\n3\n4\n2\n", "output": "1\n2\n3\n4"}, {"input": "5 1\n3\n4\n2\n1\n5\n", "output": "1"}, {"input": "9 5\n7\n1\n9\n5\n6\n2\n3\n8\n4\n", "output": "1\n2\n3\n4\n5"}, {"input": "10 3\n6\n3\n7\n8\n1\n5\n2\n4\n9\n10\n", "output": "1\n2\n3"}, {"input": "6 3\n3\n6\n5\n2\n4\n1\n", "output": "1\n2\n3"}, {"input": "7 2\n6\n4\n5\n1\n3\n2\n7\n", "output": "1\n2"}, {"input": "9 3\n1\n5\n6\n2\n4\n7\n3\n8\n9", "output": "1\n2\n3"}, {"input": "7 4\n10\n20\n30\n40\n50\n60\n70", "output": "10\n20\n30\n40"}, {"input": "5 2\n8\n4\n1\n6\n7", "output": "1\n4"}, {"input": "12 6\n16\n24\n36\n48\n64\n72\n8\n12\n32\n56\n84\n96", "output": "8\n12\n16\n24\n32\n36"}, {"input": "6 3\n25\n15\n30\n20\n10\n5", "output": "5\n10\n15"}, {"input": "8 4\n2\n7\n9\n3\n5\n1\n6\n8", "output": "1\n2\n3\n5"}, {"input": "3 2\n1\n2\n3", "output": "1\n2"}, {"input": "4 4\n40\n30\n20\n10", "output": "10\n20\n30\n40"}, {"input": "5 5\n100\n200\n300\n400\n500", "output": "100\n200\n300\n400\n500"}, {"input": "10 6\n9\n2\n5\n6\n8\n4\n3\n1\n10\n7", "output": "1\n2\n3\n4\n5\n6"}, {"input": "7 3\n12\n24\n36\n48\n60\n72\n84", "output": "12\n24\n36"}, {"input": "6 2\n50\n70\n30\n20\n40\n60", "output": "20\n30"}, {"input": "9 5\n1\n3\n7\n9\n5\n11\n13\n19\n17", "output": "1\n3\n5\n7\n9"}, {"input": "8 4\n21\n15\n9\n3\n27\n33\n39\n45", "output": "3\n9\n15\n21"}, {"input": "11 3\n17\n9\n27\n33\n7\n11\n21\n13\n29\n23\n25", "output": "7\n9\n11"}, {"input": "4 1\n9\n7\n5\n3", "output": "3"}, {"input": "5 3\n15\n10\n20\n5\n12", "output": "5\n10\n12"}, {"input": "6 4\n8\n4\n2\n6\n10\n12", "output": "2\n4\n6\n8"}, {"input": "3 3\n6\n2\n4", "output": "2\n4\n6"}, {"input": "7 2\n28\n21\n35\n14\n7\n42\n49", "output": "7\n14"}], "test": "#undef NDEBUG\n#include<assert.h>\nint main(){\n    assert(solution(\"10 5\\n2\\n4\\n6\\n8\\n10\\n1\\n3\\n5\\n7\\n9\") == \"1\\n2\\n3\\n4\\n5\");\n    assert(solution(\"5 3\\n9\\n7\\n4\\n6\\n3\") == \"3\\n4\\n6\");\n    assert(solution(\"7 4\\n1\\n5\\n3\\n9\\n2\\n8\\n6\") == \"1\\n2\\n3\\n5\");\n    assert(solution(\"6 4\\n2\\n5\\n6\\n1\\n8\\n3\") == \"1\\n2\\n3\\n5\");\n    assert(solution(\"3 3\\n5\\n7\\n4\") == \"4\\n5\\n7\");\n    assert(solution(\"9 5\\n4\\n1\\n6\\n3\\n8\\n5\\n2\\n7\\n9\") == \"1\\n2\\n3\\n4\\n5\");\n    assert(solution(\"8 2\\n6\\n7\\n4\\n1\\n9\\n3\\n5\\n8\") == \"1\\n3\");\n    assert(solution(\"6 4\\n5\\n2\\n3\\n4\\n6\\n7\") == \"2\\n3\\n4\\n5\");\n    assert(solution(\"3 2\\n4\\n5\\n1\") == \"1\\n4\");\n    assert(solution(\"5 3\\n9\\n4\\n5\\n8\\n6\") == \"4\\n5\\n6\");\n    assert(solution(\"9 5\\n1\\n6\\n3\\n4\\n5\\n2\\n7\\n9\\n8\") == \"1\\n2\\n3\\n4\\n5\");\n    assert(solution(\"8 2\\n7\\n4\\n6\\n1\\n9\\n3\\n5\\n8\") == \"1\\n3\");\n    assert(solution(\"6 3\\n1\\n2\\n3\\n4\\n5\\n6\\n\") == \"1\\n2\\n3\");\n    assert(solution(\"8 4\\n9\\n1\\n5\\n3\\n7\\n2\\n8\\n4\\n\") == \"1\\n2\\n3\\n4\");\n    assert(solution(\"5 2\\n10\\n20\\n30\\n40\\n50\\n\") == \"10\\n20\");\n    assert(solution(\"7 4\\n100\\n200\\n300\\n400\\n500\\n600\\n700\\n\") == \"100\\n200\\n300\\n400\");\n    assert(solution(\"9 3\\n5\\n3\\n2\\n7\\n8\\n1\\n9\\n4\\n6\\n\") == \"1\\n2\\n3\");\n    assert(solution(\"12 6\\n10\\n20\\n30\\n40\\n50\\n60\\n70\\n80\\n90\\n100\\n110\\n120\\n\") == \"10\\n20\\n30\\n40\\n50\\n60\");\n    assert(solution(\"4 2\\n100\\n200\\n300\\n400\\n\") == \"100\\n200\");\n    assert(solution(\"3 1\\n4\\n2\\n3\\n\") == \"2\");\n    assert(solution(\"6 4\\n15\\n20\\n10\\n5\\n30\\n25\\n\") == \"5\\n10\\n15\\n20\");\n    assert(solution(\"5 3\\n6\\n3\\n8\\n2\\n9\\n\") == \"2\\n3\\n6\");\n    assert(solution(\"10 5\\n10\\n20\\n30\\n40\\n50\\n60\\n70\\n80\\n90\\n100\\n\") == \"10\\n20\\n30\\n40\\n50\");\n    assert(solution(\"7 3\\n12\\n14\\n16\\n18\\n20\\n22\\n24\\n\") == \"12\\n14\\n16\");\n    assert(solution(\"8 4\\n9\\n7\\n5\\n3\\n1\\n2\\n4\\n6\\n\") == \"1\\n2\\n3\\n4\");\n    assert(solution(\"3 2\\n5\\n8\\n3\\n\") == \"3\\n5\");\n    assert(solution(\"9 6\\n100\\n200\\n300\\n400\\n500\\n600\\n700\\n800\\n900\\n\") == \"100\\n200\\n300\\n400\\n500\\n600\");\n    assert(solution(\"6 3\\n7\\n6\\n5\\n4\\n3\\n2\\n\") == \"2\\n3\\n4\");\n    assert(solution(\"10 4\\n1\\n9\\n2\\n8\\n3\\n7\\n4\\n6\\n5\\n10\\n\") == \"1\\n2\\n3\\n4\");\n    assert(solution(\"4 3\\n1000\\n500\\n100\\n2000\\n\") == \"100\\n500\\n1000\");\n    assert(solution(\"12 5\\n11\\n22\\n13\\n24\\n15\\n26\\n17\\n28\\n19\\n30\\n21\\n32\\n\") == \"11\\n13\\n15\\n17\\n19\");\n    assert(solution(\"7 3\\n5\\n2\\n6\\n7\\n3\\n4\\n1\\n\") == \"1\\n2\\n3\");\n    assert(solution(\"8 4\\n9\\n3\\n6\\n1\\n8\\n2\\n5\\n7\\n\") == \"1\\n2\\n3\\n5\");\n    assert(solution(\"6 2\\n5\\n1\\n4\\n3\\n2\\n6\\n\") == \"1\\n2\");\n    assert(solution(\"5 1\\n2\\n4\\n3\\n5\\n1\\n\") == \"1\");\n    assert(solution(\"9 5\\n3\\n2\\n8\\n9\\n1\\n4\\n5\\n6\\n7\\n\") == \"1\\n2\\n3\\n4\\n5\");\n    assert(solution(\"10 3\\n8\\n7\\n4\\n9\\n6\\n5\\n2\\n10\\n3\\n1\\n\") == \"1\\n2\\n3\");\n    assert(solution(\"6 4\\n1\\n4\\n6\\n3\\n2\\n5\\n\") == \"1\\n2\\n3\\n4\");\n    assert(solution(\"7 2\\n7\\n4\\n5\\n2\\n6\\n3\\n1\\n\") == \"1\\n2\");\n    assert(solution(\"8 5\\n2\\n4\\n7\\n5\\n1\\n6\\n3\\n8\\n\") == \"1\\n2\\n3\\n4\\n5\");\n    assert(solution(\"9 3\\n9\\n6\\n5\\n3\\n4\\n7\\n2\\n1\\n8\\n\") == \"1\\n2\\n3\");\n    assert(solution(\"5 2\\n2\\n1\\n3\\n5\\n4\\n\") == \"1\\n2\");\n    assert(solution(\"10 4\\n4\\n7\\n5\\n6\\n8\\n10\\n2\\n1\\n9\\n3\\n\") == \"1\\n2\\n3\\n4\");\n    assert(solution(\"7 3\\n5\\n2\\n7\\n3\\n4\\n1\\n6\\n\") == \"1\\n2\\n3\");\n    assert(solution(\"8 5\\n9\\n6\\n8\\n5\\n1\\n2\\n3\\n4\\n7\\n\") == \"1\\n2\\n3\\n4\\n5\");\n    assert(solution(\"6 4\\n1\\n6\\n5\\n3\\n4\\n2\\n\") == \"1\\n2\\n3\\n4\");\n    assert(solution(\"5 1\\n3\\n4\\n2\\n1\\n5\\n\") == \"1\");\n    assert(solution(\"9 5\\n7\\n1\\n9\\n5\\n6\\n2\\n3\\n8\\n4\\n\") == \"1\\n2\\n3\\n4\\n5\");\n    assert(solution(\"10 3\\n6\\n3\\n7\\n8\\n1\\n5\\n2\\n4\\n9\\n10\\n\") == \"1\\n2\\n3\");\n    assert(solution(\"6 3\\n3\\n6\\n5\\n2\\n4\\n1\\n\") == \"1\\n2\\n3\");\n    assert(solution(\"7 2\\n6\\n4\\n5\\n1\\n3\\n2\\n7\\n\") == \"1\\n2\");\n    assert(solution(\"9 3\\n1\\n5\\n6\\n2\\n4\\n7\\n3\\n8\\n9\") == \"1\\n2\\n3\");\n    assert(solution(\"7 4\\n10\\n20\\n30\\n40\\n50\\n60\\n70\") == \"10\\n20\\n30\\n40\");\n    assert(solution(\"5 2\\n8\\n4\\n1\\n6\\n7\") == \"1\\n4\");\n    assert(solution(\"12 6\\n16\\n24\\n36\\n48\\n64\\n72\\n8\\n12\\n32\\n56\\n84\\n96\") == \"8\\n12\\n16\\n24\\n32\\n36\");\n    assert(solution(\"6 3\\n25\\n15\\n30\\n20\\n10\\n5\") == \"5\\n10\\n15\");\n    assert(solution(\"8 4\\n2\\n7\\n9\\n3\\n5\\n1\\n6\\n8\") == \"1\\n2\\n3\\n5\");\n    assert(solution(\"3 2\\n1\\n2\\n3\") == \"1\\n2\");\n    assert(solution(\"4 4\\n40\\n30\\n20\\n10\") == \"10\\n20\\n30\\n40\");\n    assert(solution(\"5 5\\n100\\n200\\n300\\n400\\n500\") == \"100\\n200\\n300\\n400\\n500\");\n    assert(solution(\"10 6\\n9\\n2\\n5\\n6\\n8\\n4\\n3\\n1\\n10\\n7\") == \"1\\n2\\n3\\n4\\n5\\n6\");\n    assert(solution(\"7 3\\n12\\n24\\n36\\n48\\n60\\n72\\n84\") == \"12\\n24\\n36\");\n    assert(solution(\"6 2\\n50\\n70\\n30\\n20\\n40\\n60\") == \"20\\n30\");\n    assert(solution(\"9 5\\n1\\n3\\n7\\n9\\n5\\n11\\n13\\n19\\n17\") == \"1\\n3\\n5\\n7\\n9\");\n    assert(solution(\"8 4\\n21\\n15\\n9\\n3\\n27\\n33\\n39\\n45\") == \"3\\n9\\n15\\n21\");\n    assert(solution(\"11 3\\n17\\n9\\n27\\n33\\n7\\n11\\n21\\n13\\n29\\n23\\n25\") == \"7\\n9\\n11\");\n    assert(solution(\"4 1\\n9\\n7\\n5\\n3\") == \"3\");\n    assert(solution(\"5 3\\n15\\n10\\n20\\n5\\n12\") == \"5\\n10\\n12\");\n    assert(solution(\"6 4\\n8\\n4\\n2\\n6\\n10\\n12\") == \"2\\n4\\n6\\n8\");\n    assert(solution(\"3 3\\n6\\n2\\n4\") == \"2\\n4\\n6\");\n    assert(solution(\"7 2\\n28\\n21\\n35\\n14\\n7\\n42\\n49\") == \"7\\n14\");\n    return 0; \n}", "prompt": "/*There are some data, all of which are non-negative integers less than $10^9$, and there are $n$ of them. Now please output the smallest $m$ numbers among them.\n\nBe careful not to overflow and note that Memory Limit = 4000KiB.\n\ninput_format:\nThe first line consists of two non-negative integers separated by a space: $n, m$\n\nThe following $n$ lines contain randomly generated $n$ numbers, ensuring that they can fit in a 32-bit integer variable.\n\noutput_format:\nA total of $m$lines, that is, the number of $m$in the description of the problem, are output in order from smallest to largest.\n*/\n\n#include<sstream>\n#include<stdlib.h>\n#include<algorithm>\n#include<math.h>\n#include<stdio.h>\n#include<vector>\n#include<string>\n#include<climits>\n#include<cstring>\n#include<iostream>\nusing namespace std;\n\n             \nstring solution(string std_in){\n    istringstream iss(std_in);\n             ", "constraints": "数据范围：$m<10^5, n<10^6$。", "samples": [["10 5\n2\n4\n6\n8\n10\n1\n3\n5\n7\n9", "1\n2\n3\n4\n5"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [4096, 4096, 4096, 4096, 4096, 4096, 4096, 4096, 4096]}}
{"task_id": "P3212", "title": "[HNOI2011]任务调度", "difficulty": "advanced", "nl": "There are n tasks and two machines A and B. Each task needs to be executed on both machines A and B.\n\nThe i-th task needs to be executed for time a_i on machine A, and for time b_i on machine B. The ultimate goal is to complete all tasks on both A and B machines, and the total time taken to complete all tasks should be as short as possible. Of course, the problem is not that simple, as some tasks have certain restrictions on whether they should be executed on machine A or machine B first. Based on this, all tasks can be divided into three categories:\n\n1. The task must be completed on machine A first and then on machine B.\n2. The task must be completed on machine B first and then on machine A.\n3. There are no restrictions on the task, it can be executed on machine A or machine B first.\n\nNow, given the category of each task and the time required to be executed on machines A and B, the question is what is the minimum total time required to complete all tasks according to the rules.", "code": "#include <bits/stdc++.h>\nusing namespace std;\nconst int MAX_N = 30;\nconst int inf = INT_MAX / 3;\nint n, a[MAX_N], b[MAX_N], t[MAX_N], ans = inf;\nint que_a[MAX_N], que_b[MAX_N], top_a, top_b;\nbool flag[MAX_N];\nint read()\n{\n    int x = 0, f = 1; char ch = getchar();\n    while (!isdigit(ch)) { if (ch == '-') f = -1; ch = getchar(); }\n    while (isdigit(ch)) { x = x * 10 + ch - '0'; ch = getchar(); }\n    return x * f;\n}\nbool cmp_a(int x, int y)\n{\n    return b[x] == b[y] ? a[x] < a[y] : b[x] > b[y];\n}\nbool cmp_b(int x, int y)\n{\n    return a[x] == a[y] ? b[x] < b[y] : a[x] > a[y];\n}\nint calc()\n{\n    int sum_a = 0, sum_b = 0, re = 0;\n    for (int i = 1; i <= top_a; i++)\n        sum_a += a[que_a[i]];\n    for (int i = 1; i <= top_b; i++)\n    {\n        sum_b += b[que_b[i]];\n        if (sum_a > sum_b) sum_a += a[que_b[i]];\n        else sum_a = sum_b + a[que_b[i]];\n    }\n    re = max(sum_a, sum_b);\n    sum_a = sum_b = 0;\n    for (int i = 1; i <= top_b; i++)\n        sum_b += b[que_b[i]];\n    for (int i = 1; i <= top_a; i++)\n    {\n        sum_a += a[que_a[i]];\n        if (sum_b > sum_a) sum_b += b[que_a[i]];\n        else sum_b = sum_a + b[que_a[i]];\n    }\n    return max(re, max(sum_a, sum_b));\n}\nvoid solve()\n{\n    top_a = top_b = 0;\n    for (int i = 1; i <= n; i++)\n        if (flag[i]) que_b[++top_b] = i;\n        else que_a[++top_a] = i;\n    sort(que_a + 1, que_a + top_a + 1, cmp_a);\n    sort(que_b + 1, que_b + top_b + 1, cmp_b);\n    int re = calc();\n    for (int cas = 1; cas <= 2000; cas++)\n    {\n        int a1, a2, b1, b2, tmp;\n        if (top_a)\n            swap(que_a[a1 = (rand() % top_a) + 1], que_a[a2 = (rand() % top_a) + 1]);\n        if (top_b)\n            swap(que_b[b1 = (rand() % top_b) + 1], que_b[b2 = (rand() % top_b) + 1]);\n        tmp = calc();\n        if (tmp < re) re = tmp;\n        else\n        {\n            if (top_a) swap(que_a[a1], que_a[a2]);\n            if (top_b) swap(que_b[b1], que_b[b2]);\n        }\n    }\n    if (re < ans) ans = re;\n}\nvoid dfs(int dep)\n{\n    if (dep > n) solve();\n    else if (t[dep] == 1) flag[dep] = 0, dfs(dep + 1);\n    else if (t[dep] == 2) flag[dep] = 1, dfs(dep + 1);\n    else\n    {\n        flag[dep] = 0; dfs(dep + 1);\n        flag[dep] = 1; dfs(dep + 1);\n    }\n}\nint main()\n{\n    srand(time(NULL) + 19260817);\n    n = read();\n    for (int i = 1; i <= n; i++)\n        t[i] = read(), a[i] = read(), b[i] = read();\n    dfs(1);\n    printf(\"%d\\n\", ans);\n    return 0;\n}", "step": ["Define the constants, input variables, and helper functions.", "Define a function to calculate the score of a scheduling arrangement.", "Use a randomized algorithm called simulated annealing to search for the best arrangement.", "Define a recursive function to generate all possible scheduling arrangements using depth-first search.", "Use the recursive function to generate and evaluate all possible scheduling arrangements.", "Output the best score found by the simulated annealing algorithm."], "nl_cn": "\n有 $n$ 个任务和两台机器 A 与 B。每个任务都需要既在机器 A 上执行，又在机器 B 上执行，\n\n第 $i$ 个任务需要在机器 A 上执行时间 $a_i$，且需要在机器 B 上执行时间 $b_i$。最终的目标是所有任务在 A 和 B 上都执行完，且希望执行完所有任务的总时间尽量少。当然问题没有这么简单，有些任务对于先在机器 A 上执行还是先在机器 B 上执行有一定的限制。据此可将所有任务分为三类：\n\n1. 任务必须先在机器 A 上执行完然后再在机器 B 上执行。\n2. 任务必须先在机器 B 上执行完然后再在机器 A 上执行。\n3. 任务没有限制，既可先在机器 A 上执行，也可先在机器 B 上执行。\n\n现在给定每个任务的类别和需要在机器 A 和机器 B 上分别执行的时间，问使所有任务都能按规定完成所需要的最少总时间是多少。", "test_cases": [{"input": "3\n3 5 7\n1 6 1 \n2 2 6\n", "output": "14"}, {"input": "3\n3 5 7\n1 6 1\n2 2 6\n", "output": "14"}, {"input": "4\n4 5 6\n1 2 3\n2 3 4\n1 4 2\n", "output": "15"}, {"input": "3\n1 1 1\n2 2 2\n2 2 2\n", "output": "6"}, {"input": "3\n1 1 1\n2 2 2\n1 2 3\n", "output": "6"}, {"input": "2\n1 1 1\n1 1 1\n", "output": "3"}, {"input": "4\n1 3 5\n2 4 6\n1 1 1\n2 2 2\n", "output": "14"}, {"input": "1\n5 5 5\n", "output": "10"}, {"input": "0\n", "output": "0"}], "test": "#undef NDEBUG\n#include<assert.h>\nint main(){\n    assert(solution(\"3\\n3 5 7\\n1 6 1 \\n2 2 6\\n\") == \"14\");\n    assert(solution(\"3\\n3 5 7\\n1 6 1\\n2 2 6\\n\") == \"14\");\n    assert(solution(\"4\\n4 5 6\\n1 2 3\\n2 3 4\\n1 4 2\\n\") == \"15\");\n    assert(solution(\"3\\n1 1 1\\n2 2 2\\n2 2 2\\n\") == \"6\");\n    assert(solution(\"3\\n1 1 1\\n2 2 2\\n1 2 3\\n\") == \"6\");\n    assert(solution(\"2\\n1 1 1\\n1 1 1\\n\") == \"3\");\n    assert(solution(\"4\\n1 3 5\\n2 4 6\\n1 1 1\\n2 2 2\\n\") == \"14\");\n    assert(solution(\"1\\n5 5 5\\n\") == \"10\");\n    assert(solution(\"0\\n\") == \"0\");\n    return 0; \n}", "prompt": "/*There are n tasks and two machines A and B. Each task needs to be executed on both machines A and B.\n\nThe i-th task needs to be executed for time a_i on machine A, and for time b_i on machine B. The ultimate goal is to complete all tasks on both A and B machines, and the total time taken to complete all tasks should be as short as possible. Of course, the problem is not that simple, as some tasks have certain restrictions on whether they should be executed on machine A or machine B first. Based on this, all tasks can be divided into three categories:\n\n1. The task must be completed on machine A first and then on machine B.\n2. The task must be completed on machine B first and then on machine A.\n3. There are no restrictions on the task, it can be executed on machine A or machine B first.\n\nNow, given the category of each task and the time required to be executed on machines A and B, the question is what is the minimum total time required to complete all tasks according to the rules.\n\ninput_format:\nThe first line of the input has only one positive integer $n$, which represents the number of tasks.\n\nThe next $n$line, each of which is three positive integers $t_i,a_i, and b_i$separated by Spaces, represents the category of the $i$task (the categories $1$, $2$, and $3$are defined above) and the time that the $i$task needs to be executed on machine A and machine B, respectively.\n\noutput_format:\nThe output contains only one positive integer, representing the minimum total time required for all tasks to complete.\n*/\n\n#include<sstream>\n#include<stdlib.h>\n#include<algorithm>\n#include<math.h>\n#include<stdio.h>\n#include<vector>\n#include<string>\n#include<climits>\n#include<cstring>\n#include<iostream>\nusing namespace std;\n\n             \nstring solution(string std_in){\n    istringstream iss(std_in);\n             ", "constraints": "#### 样例 1 解释\n\n一种最优任务调度方案为：\n\n机器 A 上执行的各任务依次安排如下：\n\n任务 $1\\ (0\\to 5)$，任务 $2\\ (5\\to 11)$, 任务 $3\\ (11\\to 13)$；\n\n机器 B 上执行的各任务依次安排如下：\n\n任务 $3\\ (0 \\to 6)$, 任务 $1\\ (6 \\to 13)$, 任务 $2\\ (13 \\to14)$，\n\n这样，所有任务都执行完所需要的总时间为 $14$。\n\n#### 数据规模与约定\n\n对于 $100\\%$ 的数据，保证 $1\\le n\\le 20$，$1\\le a_i\\le 10^3$，$1\\le t_i\\le 3$，并保证 $t_i=3$ 的 $i$ 不超过 $10$ 个。", "samples": [["3\n3 5 7\n1 6 1 \n2 2 6\n", "14"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}}
{"task_id": "P2524", "title": "Uim的情人节礼物·其之弐", "difficulty": "basic", "nl": "Preamble: See Luogu P2525 for details.\n\nUim successfully delivered gifts to N girls in order and maintained harmony among them.\n\nNow Uim wants to know the lexicographically smallest order of all possible orders for delivering gifts to N girls.", "code": "#include<bits/stdc++.h>\n#define IL inline\n#define RI register int\nconst int fac[]={1,1,2,6,24,120,720,5040,40320,362880};//阶乘 \nchar s[108];\nint n; \nIL int Contor(char s[],int n)\n{\n\tint ans=0;\n\tfor(RI i=0;i<n;i++)\n\t{\n\t\t//std::cout<<ans<<std::endl;\n\t\tint smaller=0;\n\t\tfor(RI j= i+1 ;j<n;j++)\n\t\t{\n\t\t\tif(s[i] > s[j])smaller++;\n\t\t}\n\t\tans += smaller*fac[n-i-1];\n\t}\n\treturn ans+1;\n}\nint main()\n{\n\tstd::cin>>n;\n\tstd::cin>>s;\n\tstd::cout<<Contor(s,n);\n}", "step": ["Define necessary variables and include required headers.", "Define a Contor function to compute lexicographic rank.", "Loop through the string and count smaller characters.", "Add smaller character count to rank.", "Return rank+1.", "Accept input strings and call Contor function."], "nl_cn": "前传：详见洛谷P2525\n\nUim成功地按照顺序将礼物送到了N个妹子的手里并维持她们的和谐。\n\nUim现在想知道，他最终选择的顺序是所有给N个妹子送礼顺序中、字典序第几小的。\n", "test_cases": [{"input": "3\n231", "output": "4"}, {"input": "4\nabcd", "output": "1"}, {"input": "2\nba", "output": "2"}, {"input": "6\nabcxyz", "output": "1"}, {"input": "2\nab", "output": "1"}, {"input": "3\n123", "output": "1"}, {"input": "1\n1", "output": "1"}, {"input": "2\n12", "output": "1"}, {"input": "2\n21", "output": "2"}, {"input": "3\n132", "output": "2"}, {"input": "3\n213", "output": "3"}, {"input": "3\n312", "output": "5"}, {"input": "3\n321", "output": "6"}, {"input": "4\n1234", "output": "1"}, {"input": "4\n1243", "output": "2"}, {"input": "4\n1324", "output": "3"}, {"input": "4\n1342", "output": "4"}, {"input": "4\n1423", "output": "5"}, {"input": "4\n1432", "output": "6"}, {"input": "4\n2134", "output": "7"}, {"input": "4\n2143", "output": "8"}, {"input": "4\n2314", "output": "9"}, {"input": "4\n2341", "output": "10"}, {"input": "4\n2413", "output": "11"}, {"input": "5\n54321\n", "output": "120"}, {"input": "6\n654321\n", "output": "720"}, {"input": "1\n2\n", "output": "1"}, {"input": "4\n4321\n", "output": "24"}, {"input": "5\n12345\n", "output": "1"}], "test": "#undef NDEBUG\n#include<assert.h>\nint main(){\n    assert(solution(\"3\\n231\") == \"4\");\n    assert(solution(\"4\\nabcd\") == \"1\");\n    assert(solution(\"2\\nba\") == \"2\");\n    assert(solution(\"6\\nabcxyz\") == \"1\");\n    assert(solution(\"2\\nab\") == \"1\");\n    assert(solution(\"3\\n123\") == \"1\");\n    assert(solution(\"1\\n1\") == \"1\");\n    assert(solution(\"2\\n12\") == \"1\");\n    assert(solution(\"2\\n21\") == \"2\");\n    assert(solution(\"3\\n132\") == \"2\");\n    assert(solution(\"3\\n213\") == \"3\");\n    assert(solution(\"3\\n312\") == \"5\");\n    assert(solution(\"3\\n321\") == \"6\");\n    assert(solution(\"4\\n1234\") == \"1\");\n    assert(solution(\"4\\n1243\") == \"2\");\n    assert(solution(\"4\\n1324\") == \"3\");\n    assert(solution(\"4\\n1342\") == \"4\");\n    assert(solution(\"4\\n1423\") == \"5\");\n    assert(solution(\"4\\n1432\") == \"6\");\n    assert(solution(\"4\\n2134\") == \"7\");\n    assert(solution(\"4\\n2143\") == \"8\");\n    assert(solution(\"4\\n2314\") == \"9\");\n    assert(solution(\"4\\n2341\") == \"10\");\n    assert(solution(\"4\\n2413\") == \"11\");\n    assert(solution(\"5\\n54321\\n\") == \"120\");\n    assert(solution(\"6\\n654321\\n\") == \"720\");\n    assert(solution(\"1\\n2\\n\") == \"1\");\n    assert(solution(\"4\\n4321\\n\") == \"24\");\n    assert(solution(\"5\\n12345\\n\") == \"1\");\n    return 0; \n}", "prompt": "/*Preamble: See Luogu P2525 for details.\n\nUim successfully delivered gifts to N girls in order and maintained harmony among them.\n\nNow Uim wants to know the lexicographically smallest order of all possible orders for delivering gifts to N girls.\n\ninput_format:\nThe first line contains an integer N, indicating the number of numbers.\n\nThe second line contains an integer X, indicating the given arrangement.\n\noutput_format:\nAn integer indicating the smallest lexicographic order.\n*/\n\n#include<sstream>\n#include<stdlib.h>\n#include<algorithm>\n#include<math.h>\n#include<stdio.h>\n#include<vector>\n#include<string>\n#include<climits>\n#include<cstring>\n#include<iostream>\nusing namespace std;\n\n             \nstring solution(string std_in){\n    istringstream iss(std_in);\n             ", "constraints": "$1\\le N \\le 9$。\n\n请注意输入的排列没有空格。\n", "samples": [["3\n231", "4"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000, 128000]}}
{"task_id": "P8241", "title": "[COCI2013-2014#3] RIJEČI", "difficulty": "basic", "nl": "One day, Mirko discovered a very large screen, which initially only had a letter $\\texttt{A}$. Mirko found a button next to the screen. When he pressed it once, the letter on the screen changed to $\\texttt{B}$. Afterwards, he pressed it several times, and the letters displayed on the screen were $\\texttt{BA}$, $\\texttt{BAB}$, $\\texttt{BABBA}$, etc. Then he realized that every time he pressed the button, the letter $\\texttt B$ on the screen became $\\texttt{BA}$, while the letter $\\texttt A$ became $\\texttt{B}$.\n\nNow, Mirko has pressed the button $k$ times and he wants to know how many letters $\\texttt A$ and letters $\\texttt B$ are on the screen.", "code": "#include <bits/stdc++.h>\nusing namespace std;\nint main()\n{\n    int k, a[50];\n    cin>>k;\n    a[0] = 0;\n    a[1] = 1;\n    a[2] = 1;\n    for (int i = 3;i <= k;i++)\n        a[i] = a[i - 1] + a[i - 2];\n    cout<<a[k - 1]<<\" \"<<a[k];\n}", "step": ["Declare integer variable k and an integer array a of size 50.", "Take input for k.", "Set initial values of a[0], a[1], and a[2] to 0, 1, and 1, respectively.", "Use a for loop to calculate the values of the remaining elements in the array using the formula a[i] = a[i-1] + a[i-2].", "Print the (k-1)-th and k-th element of the array."], "nl_cn": "一天，Mirko 发现了一个非常大的屏幕，这个屏幕上一开始只有一个字母 $\\texttt{A}$。Mirko 在这个屏幕旁边找到了一个按钮。当他按一次时，屏幕上的字母变成了 $\\texttt B$。随后他又按了若干次，屏幕上依次显示 $\\texttt{BA}$、$\\texttt{BAB}$、$\\texttt{BABBA}$、……这时他才发现，每当他按一次按钮，屏幕上的字母 $\\texttt B$ 变为 $\\texttt{BA}$，而字母 $\\texttt A$ 变为 $\\texttt{B}$。\n\n现在，Mirko 已经按了 $k$ 次按钮，他想知道屏幕上分别有多少个字母 $\\texttt A$ 和字母 $\\texttt B$。", "test_cases": [{"input": "1", "output": "0 1"}, {"input": "4", "output": "2 3"}, {"input": "10", "output": "34 55"}, {"input": "2\n", "output": "1 1"}, {"input": "5\n", "output": "3 5"}, {"input": "8\n", "output": "13 21"}, {"input": "15\n", "output": "377 610"}, {"input": "20\n", "output": "4181 6765"}, {"input": "3\n", "output": "1 2"}, {"input": "9\n", "output": "21 34"}, {"input": "25\n", "output": "46368 75025"}, {"input": "30\n", "output": "514229 832040"}, {"input": "35\n", "output": "5702887 9227465"}, {"input": "40\n", "output": "63245986 102334155"}, {"input": "45\n", "output": "701408733 1134903170"}, {"input": "6\n", "output": "5 8"}, {"input": "7\n", "output": "8 13"}, {"input": "11\n", "output": "55 89"}, {"input": "12\n", "output": "89 144"}, {"input": "13\n", "output": "144 233"}, {"input": "14\n", "output": "233 377"}, {"input": "16\n", "output": "610 987"}, {"input": "17\n", "output": "987 1597"}, {"input": "18\n", "output": "1597 2584"}, {"input": "19\n", "output": "2584 4181"}], "test": "#undef NDEBUG\n#include<assert.h>\nint main(){\n    assert(solution(\"1\") == \"0 1\");\n    assert(solution(\"4\") == \"2 3\");\n    assert(solution(\"10\") == \"34 55\");\n    assert(solution(\"2\\n\") == \"1 1\");\n    assert(solution(\"5\\n\") == \"3 5\");\n    assert(solution(\"8\\n\") == \"13 21\");\n    assert(solution(\"15\\n\") == \"377 610\");\n    assert(solution(\"20\\n\") == \"4181 6765\");\n    assert(solution(\"3\\n\") == \"1 2\");\n    assert(solution(\"9\\n\") == \"21 34\");\n    assert(solution(\"25\\n\") == \"46368 75025\");\n    assert(solution(\"30\\n\") == \"514229 832040\");\n    assert(solution(\"35\\n\") == \"5702887 9227465\");\n    assert(solution(\"40\\n\") == \"63245986 102334155\");\n    assert(solution(\"45\\n\") == \"701408733 1134903170\");\n    assert(solution(\"6\\n\") == \"5 8\");\n    assert(solution(\"7\\n\") == \"8 13\");\n    assert(solution(\"11\\n\") == \"55 89\");\n    assert(solution(\"12\\n\") == \"89 144\");\n    assert(solution(\"13\\n\") == \"144 233\");\n    assert(solution(\"14\\n\") == \"233 377\");\n    assert(solution(\"16\\n\") == \"610 987\");\n    assert(solution(\"17\\n\") == \"987 1597\");\n    assert(solution(\"18\\n\") == \"1597 2584\");\n    assert(solution(\"19\\n\") == \"2584 4181\");\n    return 0; \n}", "prompt": "/*One day, Mirko discovered a very large screen, which initially only had a letter $\\texttt{A}$. Mirko found a button next to the screen. When he pressed it once, the letter on the screen changed to $\\texttt{B}$. Afterwards, he pressed it several times, and the letters displayed on the screen were $\\texttt{BA}$, $\\texttt{BAB}$, $\\texttt{BABBA}$, etc. Then he realized that every time he pressed the button, the letter $\\texttt B$ on the screen became $\\texttt{BA}$, while the letter $\\texttt A$ became $\\texttt{B}$.\n\nNow, Mirko has pressed the button $k$ times and he wants to know how many letters $\\texttt A$ and letters $\\texttt B$ are on the screen.\n\ninput_format:\nEnter an integer $k$to represent the number of times Mirko has pressed the button.\n\noutput_format:\nOutput two integers, separated by Spaces, representing the number of letters $\\texttt A$and $\\texttt B$, respectively.\n*/\n\n#include<sstream>\n#include<stdlib.h>\n#include<algorithm>\n#include<math.h>\n#include<stdio.h>\n#include<vector>\n#include<string>\n#include<climits>\n#include<cstring>\n#include<iostream>\nusing namespace std;\n\n             \nstring solution(string std_in){\n    istringstream iss(std_in);\n             ", "constraints": "**【数据范围与限制】**\n\n对于 $20\\%$ 的数据，保证 $k\\leqslant 10$。  \n对于所有数据，$1\\leqslant k\\leqslant 45$。\n\n**【题目来源】**\n\n本题来源自 **_[COCI 2013-2014](https://hsin.hr/coci/archive/2013_2014/) [CONTEST 3](https://hsin.hr/coci/archive/2013_2014/contest3_tasks.pdf) T1 RIJEČI_**，按照原题数据配置，满分 $50$ 分。\n\n由 [Eason_AC](https://www.luogu.com.cn/user/112917) 翻译整理提供。", "samples": [["1", "0 1"], ["4", "2 3"], ["10", "34 55"]], "limits": {"time": [1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000], "memory": [32768, 32768, 32768, 32768, 32768, 32768, 32768, 32768, 32768, 32768]}}
{"task_id": "P7938", "title": "「Wdcfr-1」Beautiful Array", "difficulty": "basic", "nl": "In this problem, we call a sequence defined by '(' and ')' as \"parenthesis sequence\".\n\nThe definition of \"regular parenthesis sequence\" is as follows:\n\n1. `()` is a regular parenthesis sequence.\n2. If A is a regular parenthesis sequence, then `(A)` is also a regular parenthesis sequence.\n3. If both A and B are regular parenthesis sequences, then AB is also a regular parenthesis sequence.\n\nFor example, `()`, `(()))`, and `()()` are all regular parenthesis sequences, but `)(` and `()(` are not.\n\nIn particular, in this problem, an empty sequence is **not** a regular parenthesis sequence.\n\nNow, cute Ran gives you a parenthesis sequence s of length n. She wants you to construct 2*m* strictly increasing arrays, which we represent as $p_1, p_2, \\cdots, p_{2m}$ (you can make any of them empty). You need to ensure that all integers between 1 to n appear exactly once in these arrays.\n\nIf an array $p_i = \\{r_1, r_2, \\cdots, r_k\\}$ is *beautiful*, then $\\{s_{r_1}, s_{r_2}, \\cdots, s_{r_k}\\}$ is a regular parenthesis sequence.\n\nRan wants to know if it is possible to construct these arrays such that at least m of the 2*m* arrays are \"beautiful arrays\".", "code": "#include<bits/stdc++.h>\n#define int long long\nconst int MAXN = 1001;\nusing namespace std;\nint t, n, m, len, s1, s2, ans, st[MAXN];\nchar s[MAXN];\nsigned main()\n{\n\tios::sync_with_stdio(false);\n\tcin >> t;\n\twhile(t--)\n\t{\n\t\tint top = 0, ans = 0;\n\t\tcin >> n >> m;\n\t\tfor (int i = 1; i <= n; i++)\n\t\t{\n\t\t\tcin >> s[i];\n\t\t}\n\t\tfor (int i = 1; i <= n; i++)\n\t\t{\n\t\t\tif(s[i] == '(') \n\t\t\t{\n\t\t\t\tst[++top] = i;\n\t\t\t}\n\t\t\telse if(top)\n\t\t\t{\n\t\t\t\ttop--;\n\t\t\t\tans++;\n\t\t\t}\n\t\t}\n\t\tif(ans >= m)cout << 1 << endl;\n\t\telse cout << 0 << endl;\n\t}\n\treturn 0;\n}", "step": ["Initialize variables and arrays", "For each test case, take input values", "Loop through the string and check for parentheses", "If there is an opening parenthesis, push the index into the stack", "If there is closing parenthesis and stack is not empty, pop the opening parenthesis from the stack", "Check if the number of popped parentheses is greater than or equal to m and print the result"], "nl_cn": "In this problem, we define a sequence of `(` and `)` as a \"bracket sequence\".\n\nThe definition of *Regular Bracket Sequence* is as follows:\n\n1. `()` is a Regular Bracket Sequence.\n1. If `A` is a Regular Bracket Sequence, then `(A)` is also a Regular Bracket Sequence.\n1. If `A` and `B` are Regular Bracket Sequences, then `AB` is also a Regular Bracket Sequence.\n\nFor example: `()`, `(())`, and `()()` are all Regular Bracket Sequences, but `)(`, `()(` are not.\n\nIn particular, an empty sequence is **not** a Regular Bracket Sequence sequence in this problem.\n\nNow ~~cute~~ Ran gives you a bracket sequence $s$ of length $n$. She wants you to construct $2\\cdot m$ **strictly increasing** arrays. Let us denote them as\n $p_1,p_2,\\cdots,p_{2 m}$ (you can leave any of them empty). You need to ensure that all integers between $1\\sim n$ appear **exactly once** in these arrays. \n \nAn array $p_i=\\{r_1,r_2,\\cdots,r_k\\}$ is *Beautiful* if    $\\{s_{r_1},s_{r_2},\\cdots,s_{r_k}\\}$ is a Regular Bracket Sequence.\n\nRan wonders whether it is possible to construct these arrays so that at least $m$ of the $2\\cdot m$ arrays are \"beautiful arrays\". ", "test_cases": [{"input": "2\n2 1\n()\n2 99\n()", "output": "1\n0"}, {"input": "1\n8 6\n(((())))()(()())\n", "output": "0"}, {"input": "1\n7 3\n((())())\n", "output": "1"}, {"input": "1\n9 2\n()(()(()()))\n", "output": "1"}, {"input": "1\n4 2\n()()\n", "output": "1"}, {"input": "2\n5 3\n())((\n7 4\n(((()((\n", "output": "0\n0"}, {"input": "1\n6 1\n()))(())\n", "output": "1"}, {"input": "1\n10 3\n((((()))))\n", "output": "1"}, {"input": "1\n4 2\n)(()()\n", "output": "0"}, {"input": "1\n8 2\n((()())\n", "output": "1"}, {"input": "1\n10 3\n(((())))((()())())\n", "output": "1"}, {"input": "1\n4 2\n))((())()(\n", "output": "0"}, {"input": "1\n6 1\n))((((())((\n", "output": "0"}, {"input": "1\n3 2\n((\n", "output": "0"}, {"input": "1\n4 2\n))(\n", "output": "0"}, {"input": "3\n6 3\n(()())\n10 5\n()(()()())\n8 4\n((()())\n", "output": "1\n1\n0"}, {"input": "1\n8 4\n((()()()\n", "output": "0"}, {"input": "2\n5 3\n(())(\n5 2\n)()()\n", "output": "0\n1"}, {"input": "1\n6 3\n(())()\n", "output": "1"}, {"input": "1\n5 2\n()(()\n", "output": "1"}, {"input": "1\n7 4\n((()))(\n", "output": "0"}, {"input": "1\n6 3\n)))())\n", "output": "0"}, {"input": "1\n4 2\n(((()\n", "output": "0"}, {"input": "1\n6 3\n()()()\n", "output": "1"}, {"input": "1\n4 2\n())(\n", "output": "0"}, {"input": "1\n3 2\n(()\n", "output": "0"}, {"input": "1\n7 4\n()))())\n", "output": "0"}, {"input": "1\n6 3\n)()()(\n", "output": "0"}, {"input": "1\n5 2\n((()(\n", "output": "0"}, {"input": "1\n5 2\n()()()\n", "output": "1"}, {"input": "1\n8 4\n())))())\n", "output": "0"}], "test": "#undef NDEBUG\n#include<assert.h>\nint main(){\n    assert(solution(\"2\\n2 1\\n()\\n2 99\\n()\") == \"1\\n0\");\n    assert(solution(\"1\\n8 6\\n(((())))()(()())\\n\") == \"0\");\n    assert(solution(\"1\\n7 3\\n((())())\\n\") == \"1\");\n    assert(solution(\"1\\n9 2\\n()(()(()()))\\n\") == \"1\");\n    assert(solution(\"1\\n4 2\\n()()\\n\") == \"1\");\n    assert(solution(\"2\\n5 3\\n())((\\n7 4\\n(((()((\\n\") == \"0\\n0\");\n    assert(solution(\"1\\n6 1\\n()))(())\\n\") == \"1\");\n    assert(solution(\"1\\n10 3\\n((((()))))\\n\") == \"1\");\n    assert(solution(\"1\\n4 2\\n)(()()\\n\") == \"0\");\n    assert(solution(\"1\\n8 2\\n((()())\\n\") == \"1\");\n    assert(solution(\"1\\n10 3\\n(((())))((()())())\\n\") == \"1\");\n    assert(solution(\"1\\n4 2\\n))((())()(\\n\") == \"0\");\n    assert(solution(\"1\\n6 1\\n))((((())((\\n\") == \"0\");\n    assert(solution(\"1\\n3 2\\n((\\n\") == \"0\");\n    assert(solution(\"1\\n4 2\\n))(\\n\") == \"0\");\n    assert(solution(\"3\\n6 3\\n(()())\\n10 5\\n()(()()())\\n8 4\\n((()())\\n\") == \"1\\n1\\n0\");\n    assert(solution(\"1\\n8 4\\n((()()()\\n\") == \"0\");\n    assert(solution(\"2\\n5 3\\n(())(\\n5 2\\n)()()\\n\") == \"0\\n1\");\n    assert(solution(\"1\\n6 3\\n(())()\\n\") == \"1\");\n    assert(solution(\"1\\n5 2\\n()(()\\n\") == \"1\");\n    assert(solution(\"1\\n7 4\\n((()))(\\n\") == \"0\");\n    assert(solution(\"1\\n6 3\\n)))())\\n\") == \"0\");\n    assert(solution(\"1\\n4 2\\n(((()\\n\") == \"0\");\n    assert(solution(\"1\\n6 3\\n()()()\\n\") == \"1\");\n    assert(solution(\"1\\n4 2\\n())(\\n\") == \"0\");\n    assert(solution(\"1\\n3 2\\n(()\\n\") == \"0\");\n    assert(solution(\"1\\n7 4\\n()))())\\n\") == \"0\");\n    assert(solution(\"1\\n6 3\\n)()()(\\n\") == \"0\");\n    assert(solution(\"1\\n5 2\\n((()(\\n\") == \"0\");\n    assert(solution(\"1\\n5 2\\n()()()\\n\") == \"1\");\n    assert(solution(\"1\\n8 4\\n())))())\\n\") == \"0\");\n    return 0; \n}", "prompt": "/*In this problem, we call a sequence defined by '(' and ')' as \"parenthesis sequence\".\n\nThe definition of \"regular parenthesis sequence\" is as follows:\n\n1. `()` is a regular parenthesis sequence.\n2. If A is a regular parenthesis sequence, then `(A)` is also a regular parenthesis sequence.\n3. If both A and B are regular parenthesis sequences, then AB is also a regular parenthesis sequence.\n\nFor example, `()`, `(()))`, and `()()` are all regular parenthesis sequences, but `)(` and `()(` are not.\n\nIn particular, in this problem, an empty sequence is **not** a regular parenthesis sequence.\n\nNow, cute Ran gives you a parenthesis sequence s of length n. She wants you to construct 2*m* strictly increasing arrays, which we represent as $p_1, p_2, \\cdots, p_{2m}$ (you can make any of them empty). You need to ensure that all integers between 1 to n appear exactly once in these arrays.\n\nIf an array $p_i = \\{r_1, r_2, \\cdots, r_k\\}$ is *beautiful*, then $\\{s_{r_1}, s_{r_2}, \\cdots, s_{r_k}\\}$ is a regular parenthesis sequence.\n\nRan wants to know if it is possible to construct these arrays such that at least m of the 2*m* arrays are \"beautiful arrays\".\n\ninput_format:\nEach test contains multiple test cases.\n\nThe first line contains an integer $T$, the number of test cases.\n\nFor each test case, the first line contains two integers $n$ and $m$, and the second line contains a bracket sequence $s$.\n\noutput_format:\nFor each test case, print one line.\n\nIf it is possible to construct these arrays, print $1$. Otherwise print $0$.\n*/\n\n#include<sstream>\n#include<stdlib.h>\n#include<algorithm>\n#include<math.h>\n#include<stdio.h>\n#include<vector>\n#include<string>\n#include<climits>\n#include<cstring>\n#include<iostream>\nusing namespace std;\n\n             \nstring solution(string std_in){\n    istringstream iss(std_in);\n             ", "constraints": "### Explanation\n\nFor the first test case, we can construct $p_1=\\{1,2\\}$ and $ p_2=\\{\\}$. So $p_1$ is a \"beautiful array\".\n\nFor the second test case, it is obvious that we cannot use two numbers to construct $99$ beautiful arrays.\n\n### Constraints\n\n$1\\le T,n,m\\le 200$.", "samples": [["2\n2 1\n()\n2 99\n()", "1\n0"]], "limits": {"time": [100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100], "memory": [524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288, 524288]}}
{"task_id": "P7566", "title": "饱食", "difficulty": "basic", "nl": "The Bookworm has a backpack with $n$ rabbits, and the $i$-th rabbit is labeled with a string $S_i$ consisting of uppercase letters.\n\nThe Bookworm codes in C and writes a `random` function to randomly select three rabbits.\n\nHowever, the Bookworm has anorexia nervosa for now, and can only eat the selected rabbits if:\n\n- The first letter in the label is one of `M`, `C`, `O` or `I`.\n- The first letters of the labels are different.\n\nThe Bookworm wants to know how many ways there are to select three rabbits that satisfy these conditions so that it can eat them.", "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\ninline ll read(){\n\tll x=0,f=1;char ch=getchar();\n\twhile(!isdigit(ch)){if(ch=='-')f=-f;ch=getchar();}\n\twhile(isdigit(ch)){x=(x<<1)+(x<<3)+(ch^48);ch=getchar();}\n\treturn x*f;\n}\ninline void write(ll x){\n\tif(x<0)putchar('-'),x=-x;\n\tif(x>9)write(x/10);\n\tputchar(x%10+'0');\n}\ninline void writeln(ll x){write(x),putchar('\\n');}\nll n,cM,cC,cO,cI;\nint main(){\n\tn=read();\n\tfor(ll i=1;i<=n;i++){\n\t\tstring st;\n\t\tcin>>st;\n\t\tif(st[0]=='M')cM++;\n\t\telse if(st[0]=='C')cC++;\n\t\telse if(st[0]=='O')cO++;\n\t\telse if(st[0]=='I')cI++;\n\t}\n\tll ans=cM*cC*cO+cM*cC*cI+cM*cO*cI+cC*cO*cI;\n\twriteln(ans);\n\treturn 0;\n}", "step": ["Read in the number of strings n.", "Iterate n times, read in each string and count the number of strings starting with M, C, O, and I respectively.", "Calculate the product of the counts for all combinations of three distinct letters.", "Output the result."], "nl_cn": "书虫背包里有 $n$ 只兔兔，第 $i$ 只兔兔被书虫编号为一个由大写字母组成的字符串 $S_i$。\n\n书虫会 +C+，他用 +C+ 编写出了 `random` 函数，随机抽取出了三只兔兔。\n\n不过书虫暂时得了神经性厌食症，书虫能吃下这三只兔兔当且仅当：\n\n- 编号的首字母为 `M`，`C`，`O` 或 `I` 中的任意一个。\n- 编号的首字母不能相同。\n\n书虫想问有多少种选择方案使得他能吃下他选的的三只兔兔？", "test_cases": [{"input": "5\nMINE\nCRAFT\nOLYMPIAD\nIN\nINFORMATICS", "output": "7"}, {"input": "6\nCOMPETITION\nFOR\nPROGRAMMING\nOLYMPIAD\nINFORMATICS\nI\n", "output": "2"}, {"input": "2\nMR\nCO\n", "output": "0"}, {"input": "1\nMINECRAFTO\n", "output": "0"}, {"input": "0\n", "output": "0"}, {"input": "4\nA\nA\nA\nA\n", "output": "0"}, {"input": "2\nAA\nBB\n", "output": "0"}, {"input": "3\nA\nB\nC\n", "output": "0"}, {"input": "3\nMATH\nCHEM\nPHY", "output": "0"}, {"input": "4\nKING\nQUEEN\nCrown\nPrince", "output": "0"}, {"input": "3\nMAGIC\nCARPET\nONION", "output": "1"}, {"input": "2\nMINE\nINFORMATICS\n", "output": "0"}, {"input": "5\nCRAFT\nCRAFT\nCRAFT\nCRAFT\nCRAFT\n", "output": "0"}, {"input": "3\nMINE\nOLYMPIAD\nINFORMATICS\n", "output": "1"}, {"input": "2\nMINE\nMINE\n", "output": "0"}, {"input": "2\nMINE\nCRAFT\n", "output": "0"}, {"input": "3\nCRAFTCODE\nCRAFTCRAFT\nCRAFTOLYMPIAD\n", "output": "0"}, {"input": "4\nINFORMATICS\nINFORMATICS\nINFORMATICS\nINFORMATICS\n", "output": "0"}, {"input": "3\nMATH\nSCIENCE\nENGLISH\n", "output": "0"}, {"input": "4\nAPPLE\nBANANA\nCHERRY\nKIWI\n", "output": "0"}, {"input": "6\nDOG\nCAT\nHORSE\nRABBIT\nELEPHANT\nPONY\n", "output": "0"}, {"input": "9\nCAR\nBUS\nTRAIN\nPLANE\nBOAT\nBIKE\nWALK\nRUN\nSWIM\n", "output": "0"}, {"input": "2\nTEST\nCASE\n", "output": "0"}, {"input": "1\nGOLD\n", "output": "0"}, {"input": "8\nRED\nBLUE\nGREEN\nYELLOW\nORANGE\nPURPLE\nPINK\nBROWN\n", "output": "0"}, {"input": "4\nSPEED\nSTRENGTH\nAGILITY\nINTELLIGENCE\n", "output": "0"}, {"input": "3\nSUN\nMOON\nSTARS\n", "output": "0"}, {"input": "5\nAPPLE\nBANANA\nCHERRY\nKIWI\nMANGO\n", "output": "0"}, {"input": "6\nONE\nTWO\nTHREE\nFOUR\nFIVE\nSIX\n", "output": "0"}, {"input": "2\nUP\nDOWN\n", "output": "0"}, {"input": "7\nJUPITER\nMARS\nVENUS\nSATURN\nURANUS\nNEPTUNE\nPLUTO\n", "output": "0"}, {"input": "1\nHELLO\n", "output": "0"}, {"input": "4\nCAT\nDOG\nRABBIT\nBIRD\n", "output": "0"}, {"input": "3\nJANUARY\nFEBRUARY\nMARCH\n", "output": "0"}, {"input": "5\nMONDAY\nTUESDAY\nWEDNESDAY\nTHURSDAY\nFRIDAY\n", "output": "0"}, {"input": "9\nSCHOOL\nCOLLEGE\nUNIVERSITY\nINSTITUTE\nACADEMY\nCAMPUS\nCOURT\nHALL\nBUILDING\n", "output": "0"}], "test": "#undef NDEBUG\n#include<assert.h>\nint main(){\n    assert(solution(\"5\\nMINE\\nCRAFT\\nOLYMPIAD\\nIN\\nINFORMATICS\") == \"7\");\n    assert(solution(\"6\\nCOMPETITION\\nFOR\\nPROGRAMMING\\nOLYMPIAD\\nINFORMATICS\\nI\\n\") == \"2\");\n    assert(solution(\"2\\nMR\\nCO\\n\") == \"0\");\n    assert(solution(\"1\\nMINECRAFTO\\n\") == \"0\");\n    assert(solution(\"0\\n\") == \"0\");\n    assert(solution(\"4\\nA\\nA\\nA\\nA\\n\") == \"0\");\n    assert(solution(\"2\\nAA\\nBB\\n\") == \"0\");\n    assert(solution(\"3\\nA\\nB\\nC\\n\") == \"0\");\n    assert(solution(\"3\\nMATH\\nCHEM\\nPHY\") == \"0\");\n    assert(solution(\"4\\nKING\\nQUEEN\\nCrown\\nPrince\") == \"0\");\n    assert(solution(\"3\\nMAGIC\\nCARPET\\nONION\") == \"1\");\n    assert(solution(\"2\\nMINE\\nINFORMATICS\\n\") == \"0\");\n    assert(solution(\"5\\nCRAFT\\nCRAFT\\nCRAFT\\nCRAFT\\nCRAFT\\n\") == \"0\");\n    assert(solution(\"3\\nMINE\\nOLYMPIAD\\nINFORMATICS\\n\") == \"1\");\n    assert(solution(\"2\\nMINE\\nMINE\\n\") == \"0\");\n    assert(solution(\"2\\nMINE\\nCRAFT\\n\") == \"0\");\n    assert(solution(\"3\\nCRAFTCODE\\nCRAFTCRAFT\\nCRAFTOLYMPIAD\\n\") == \"0\");\n    assert(solution(\"4\\nINFORMATICS\\nINFORMATICS\\nINFORMATICS\\nINFORMATICS\\n\") == \"0\");\n    assert(solution(\"3\\nMATH\\nSCIENCE\\nENGLISH\\n\") == \"0\");\n    assert(solution(\"4\\nAPPLE\\nBANANA\\nCHERRY\\nKIWI\\n\") == \"0\");\n    assert(solution(\"6\\nDOG\\nCAT\\nHORSE\\nRABBIT\\nELEPHANT\\nPONY\\n\") == \"0\");\n    assert(solution(\"9\\nCAR\\nBUS\\nTRAIN\\nPLANE\\nBOAT\\nBIKE\\nWALK\\nRUN\\nSWIM\\n\") == \"0\");\n    assert(solution(\"2\\nTEST\\nCASE\\n\") == \"0\");\n    assert(solution(\"1\\nGOLD\\n\") == \"0\");\n    assert(solution(\"8\\nRED\\nBLUE\\nGREEN\\nYELLOW\\nORANGE\\nPURPLE\\nPINK\\nBROWN\\n\") == \"0\");\n    assert(solution(\"4\\nSPEED\\nSTRENGTH\\nAGILITY\\nINTELLIGENCE\\n\") == \"0\");\n    assert(solution(\"3\\nSUN\\nMOON\\nSTARS\\n\") == \"0\");\n    assert(solution(\"5\\nAPPLE\\nBANANA\\nCHERRY\\nKIWI\\nMANGO\\n\") == \"0\");\n    assert(solution(\"6\\nONE\\nTWO\\nTHREE\\nFOUR\\nFIVE\\nSIX\\n\") == \"0\");\n    assert(solution(\"2\\nUP\\nDOWN\\n\") == \"0\");\n    assert(solution(\"7\\nJUPITER\\nMARS\\nVENUS\\nSATURN\\nURANUS\\nNEPTUNE\\nPLUTO\\n\") == \"0\");\n    assert(solution(\"1\\nHELLO\\n\") == \"0\");\n    assert(solution(\"4\\nCAT\\nDOG\\nRABBIT\\nBIRD\\n\") == \"0\");\n    assert(solution(\"3\\nJANUARY\\nFEBRUARY\\nMARCH\\n\") == \"0\");\n    assert(solution(\"5\\nMONDAY\\nTUESDAY\\nWEDNESDAY\\nTHURSDAY\\nFRIDAY\\n\") == \"0\");\n    assert(solution(\"9\\nSCHOOL\\nCOLLEGE\\nUNIVERSITY\\nINSTITUTE\\nACADEMY\\nCAMPUS\\nCOURT\\nHALL\\nBUILDING\\n\") == \"0\");\n    return 0; \n}", "prompt": "/*The Bookworm has a backpack with $n$ rabbits, and the $i$-th rabbit is labeled with a string $S_i$ consisting of uppercase letters.\n\nThe Bookworm codes in C and writes a `random` function to randomly select three rabbits.\n\nHowever, the Bookworm has anorexia nervosa for now, and can only eat the selected rabbits if:\n\n- The first letter in the label is one of `M`, `C`, `O` or `I`.\n- The first letters of the labels are different.\n\nThe Bookworm wants to know how many ways there are to select three rabbits that satisfy these conditions so that it can eat them.\n\ninput_format:\nThe first row is an integer $n$represents the number of rabbits.\n\nNext $n$lines each line has a string $S_i$for a rabbit.\n\noutput_format:\nA row of integers represents the answer.\n*/\n\n#include<sstream>\n#include<stdlib.h>\n#include<algorithm>\n#include<math.h>\n#include<stdio.h>\n#include<vector>\n#include<string>\n#include<climits>\n#include<cstring>\n#include<iostream>\nusing namespace std;\n\n             \nstring solution(string std_in){\n    istringstream iss(std_in);\n             ", "constraints": "#### 样例 1 解释\n\n有如下 $7$ 种选择方式：\n\n- `MINE`，`CRAFT`，`OLYMPIAD`。\n- `MINE`，`CRAFT`，`IN`。\n- `MINE`，`CRAFT`，`INFORMATICS`。\n- `MINE`，`OLYMPIAD`，`IN`。\n- `MINE`，`OLYMPIAD`，`INFORMATICS`。\n- `CRAFT`，`OLYMPIAD`，`IN`。\n- `CRAFT`，`OLYMPIAD`，`INFORMATICS`。\n\n#### 数据规模与约定\n\n**本题采用捆绑测试。**\n\n- Subtask 1（10 pts）：$S_i$ 首字母均为 `M`。\n- Subtask 2（30 pts）：$n \\le 100$。\n- Subtask 3（60 pts）：无特殊限制。\n\n对于 $100\\%$ 的数据，$1\\le n\\le10^5$，$1 \\le |S_i| \\le 11$，$S_i$ 由大写字母组成。\n\n数据不保证 $S_i$ 互不相同。", "samples": [["5\nMINE\nCRAFT\nOLYMPIAD\nIN\nINFORMATICS", "7"]], "limits": {"time": [500, 500, 500], "memory": [131072, 131072, 131072]}}
